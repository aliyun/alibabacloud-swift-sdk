import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddGroupMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var accessLevel: Int32?

    public var aliyunPks: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.accessLevel != nil {
            map["accessLevel"] = self.accessLevel!
        }
        if self.aliyunPks != nil {
            map["aliyunPks"] = self.aliyunPks!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["accessLevel"] as? Int32 {
            self.accessLevel = value
        }
        if let value = dict["aliyunPks"] as? String {
            self.aliyunPks = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class AddGroupMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var name: String?

        public var sourceId: Int64?

        public var state: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["email"] as? String {
                self.email = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceId"] as? Int64 {
                self.sourceId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["username"] as? String {
                self.username = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [AddGroupMemberResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [AddGroupMemberResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = AddGroupMemberResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class AddGroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddGroupMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddPipelineRelationsRequest : Tea.TeaModel {
    public var relObjectIds: String?

    public var relObjectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relObjectIds != nil {
            map["relObjectIds"] = self.relObjectIds!
        }
        if self.relObjectType != nil {
            map["relObjectType"] = self.relObjectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["relObjectIds"] as? String {
            self.relObjectIds = value
        }
        if let value = dict["relObjectType"] as? String {
            self.relObjectType = value
        }
    }
}

public class AddPipelineRelationsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class AddPipelineRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPipelineRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddPipelineRelationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddRepositoryMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var accessLevel: Int32?

    public var aliyunPks: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.accessLevel != nil {
            map["accessLevel"] = self.accessLevel!
        }
        if self.aliyunPks != nil {
            map["aliyunPks"] = self.aliyunPks!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["accessLevel"] as? Int32 {
            self.accessLevel = value
        }
        if let value = dict["aliyunPks"] as? String {
            self.aliyunPks = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class AddRepositoryMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["email"] as? String {
                self.email = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [AddRepositoryMemberResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [AddRepositoryMemberResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = AddRepositoryMemberResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class AddRepositoryMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRepositoryMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddRepositoryMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddWebhookRequest : Tea.TeaModel {
    public var accessToken: String?

    public var description_: String?

    public var enableSslVerification: Bool?

    public var mergeRequestsEvents: Bool?

    public var noteEvents: Bool?

    public var pushEvents: Bool?

    public var secretToken: String?

    public var tagPushEvents: Bool?

    public var url: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.enableSslVerification != nil {
            map["enableSslVerification"] = self.enableSslVerification!
        }
        if self.mergeRequestsEvents != nil {
            map["mergeRequestsEvents"] = self.mergeRequestsEvents!
        }
        if self.noteEvents != nil {
            map["noteEvents"] = self.noteEvents!
        }
        if self.pushEvents != nil {
            map["pushEvents"] = self.pushEvents!
        }
        if self.secretToken != nil {
            map["secretToken"] = self.secretToken!
        }
        if self.tagPushEvents != nil {
            map["tagPushEvents"] = self.tagPushEvents!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["enableSslVerification"] as? Bool {
            self.enableSslVerification = value
        }
        if let value = dict["mergeRequestsEvents"] as? Bool {
            self.mergeRequestsEvents = value
        }
        if let value = dict["noteEvents"] as? Bool {
            self.noteEvents = value
        }
        if let value = dict["pushEvents"] as? Bool {
            self.pushEvents = value
        }
        if let value = dict["secretToken"] as? String {
            self.secretToken = value
        }
        if let value = dict["tagPushEvents"] as? Bool {
            self.tagPushEvents = value
        }
        if let value = dict["url"] as? String {
            self.url = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class AddWebhookResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var description_: String?

        public var enableSslVerification: Bool?

        public var id: Int64?

        public var lastTestResult: String?

        public var mergeRequestsEvents: Bool?

        public var noteEvents: Bool?

        public var pushEvents: Bool?

        public var repositoryId: Int64?

        public var secretToken: String?

        public var tagPushEvents: Bool?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.enableSslVerification != nil {
                map["enableSslVerification"] = self.enableSslVerification!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastTestResult != nil {
                map["lastTestResult"] = self.lastTestResult!
            }
            if self.mergeRequestsEvents != nil {
                map["mergeRequestsEvents"] = self.mergeRequestsEvents!
            }
            if self.noteEvents != nil {
                map["noteEvents"] = self.noteEvents!
            }
            if self.pushEvents != nil {
                map["pushEvents"] = self.pushEvents!
            }
            if self.repositoryId != nil {
                map["repositoryId"] = self.repositoryId!
            }
            if self.secretToken != nil {
                map["secretToken"] = self.secretToken!
            }
            if self.tagPushEvents != nil {
                map["tagPushEvents"] = self.tagPushEvents!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["enableSslVerification"] as? Bool {
                self.enableSslVerification = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["lastTestResult"] as? String {
                self.lastTestResult = value
            }
            if let value = dict["mergeRequestsEvents"] as? Bool {
                self.mergeRequestsEvents = value
            }
            if let value = dict["noteEvents"] as? Bool {
                self.noteEvents = value
            }
            if let value = dict["pushEvents"] as? Bool {
                self.pushEvents = value
            }
            if let value = dict["repositoryId"] as? Int64 {
                self.repositoryId = value
            }
            if let value = dict["secretToken"] as? String {
                self.secretToken = value
            }
            if let value = dict["tagPushEvents"] as? Bool {
                self.tagPushEvents = value
            }
            if let value = dict["url"] as? String {
                self.url = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: AddWebhookResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = AddWebhookResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class AddWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddWebhookResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelExecutionReleaseStageRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CancelExecutionReleaseStageResponseBody : Tea.TeaModel {
    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CancelExecutionReleaseStageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelExecutionReleaseStageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelExecutionReleaseStageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CloseMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CloseMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CloseMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CloseMergeRequestResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CloseMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CloseMergeRequestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAppMembersRequest : Tea.TeaModel {
    public class PlayerList : Tea.TeaModel {
        public var id: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var playerList: [CreateAppMembersRequest.PlayerList]?

    public var roleNames: [String]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.playerList != nil {
            var tmp : [Any] = []
            for k in self.playerList! {
                tmp.append(k.toMap())
            }
            map["playerList"] = tmp
        }
        if self.roleNames != nil {
            map["roleNames"] = self.roleNames!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["playerList"] as? [Any?] {
            var tmp : [CreateAppMembersRequest.PlayerList] = []
            for v in value {
                if v != nil {
                    var model = CreateAppMembersRequest.PlayerList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.playerList = tmp
        }
        if let value = dict["roleNames"] as? [String] {
            self.roleNames = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CreateAppMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class CreateBranchRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var ref: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.ref != nil {
            map["ref"] = self.ref!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["branchName"] as? String {
            self.branchName = value
        }
        if let value = dict["ref"] as? String {
            self.ref = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CreateBranchResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var committedDate: String?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["authorEmail"] as? String {
                    self.authorEmail = value
                }
                if let value = dict["authorName"] as? String {
                    self.authorName = value
                }
                if let value = dict["authoredDate"] as? String {
                    self.authoredDate = value
                }
                if let value = dict["committedDate"] as? String {
                    self.committedDate = value
                }
                if let value = dict["committerEmail"] as? String {
                    self.committerEmail = value
                }
                if let value = dict["committerName"] as? String {
                    self.committerName = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["parentIds"] as? [String] {
                    self.parentIds = value
                }
                if let value = dict["shortId"] as? String {
                    self.shortId = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public var commit: CreateBranchResponseBody.Result.Commit?

        public var name: String?

        public var protected: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.protected != nil {
                map["protected"] = self.protected!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["commit"] as? [String: Any?] {
                var model = CreateBranchResponseBody.Result.Commit()
                model.fromMap(value)
                self.commit = model
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["protected"] as? Bool {
                self.protected = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateBranchResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateBranchResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateBranchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBranchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateBranchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateChangeRequestRequest : Tea.TeaModel {
    public var appCodeRepoSn: String?

    public var autoDeleteBranchWhenEnd: Bool?

    public var branchName: String?

    public var createBranch: Bool?

    public var ownerAccountId: String?

    public var ownerId: String?

    public var title: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCodeRepoSn != nil {
            map["appCodeRepoSn"] = self.appCodeRepoSn!
        }
        if self.autoDeleteBranchWhenEnd != nil {
            map["autoDeleteBranchWhenEnd"] = self.autoDeleteBranchWhenEnd!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.createBranch != nil {
            map["createBranch"] = self.createBranch!
        }
        if self.ownerAccountId != nil {
            map["ownerAccountId"] = self.ownerAccountId!
        }
        if self.ownerId != nil {
            map["ownerId"] = self.ownerId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["appCodeRepoSn"] as? String {
            self.appCodeRepoSn = value
        }
        if let value = dict["autoDeleteBranchWhenEnd"] as? Bool {
            self.autoDeleteBranchWhenEnd = value
        }
        if let value = dict["branchName"] as? String {
            self.branchName = value
        }
        if let value = dict["createBranch"] as? Bool {
            self.createBranch = value
        }
        if let value = dict["ownerAccountId"] as? String {
            self.ownerAccountId = value
        }
        if let value = dict["ownerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["title"] as? String {
            self.title = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CreateChangeRequestResponseBody : Tea.TeaModel {
    public var appCodeRepoSn: String?

    public var appName: String?

    public var autoDeleteBranchWhenEnd: Bool?

    public var branch: String?

    public var creatorAccountId: String?

    public var creatorId: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var name: String?

    public var originBranch: String?

    public var originBranchRevisionSha: String?

    public var ownerAccountId: String?

    public var ownerId: String?

    public var sn: String?

    public var state: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCodeRepoSn != nil {
            map["appCodeRepoSn"] = self.appCodeRepoSn!
        }
        if self.appName != nil {
            map["appName"] = self.appName!
        }
        if self.autoDeleteBranchWhenEnd != nil {
            map["autoDeleteBranchWhenEnd"] = self.autoDeleteBranchWhenEnd!
        }
        if self.branch != nil {
            map["branch"] = self.branch!
        }
        if self.creatorAccountId != nil {
            map["creatorAccountId"] = self.creatorAccountId!
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["gmtModified"] = self.gmtModified!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.originBranch != nil {
            map["originBranch"] = self.originBranch!
        }
        if self.originBranchRevisionSha != nil {
            map["originBranchRevisionSha"] = self.originBranchRevisionSha!
        }
        if self.ownerAccountId != nil {
            map["ownerAccountId"] = self.ownerAccountId!
        }
        if self.ownerId != nil {
            map["ownerId"] = self.ownerId!
        }
        if self.sn != nil {
            map["sn"] = self.sn!
        }
        if self.state != nil {
            map["state"] = self.state!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["appCodeRepoSn"] as? String {
            self.appCodeRepoSn = value
        }
        if let value = dict["appName"] as? String {
            self.appName = value
        }
        if let value = dict["autoDeleteBranchWhenEnd"] as? Bool {
            self.autoDeleteBranchWhenEnd = value
        }
        if let value = dict["branch"] as? String {
            self.branch = value
        }
        if let value = dict["creatorAccountId"] as? String {
            self.creatorAccountId = value
        }
        if let value = dict["creatorId"] as? String {
            self.creatorId = value
        }
        if let value = dict["gmtCreate"] as? String {
            self.gmtCreate = value
        }
        if let value = dict["gmtModified"] as? String {
            self.gmtModified = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["originBranch"] as? String {
            self.originBranch = value
        }
        if let value = dict["originBranchRevisionSha"] as? String {
            self.originBranchRevisionSha = value
        }
        if let value = dict["ownerAccountId"] as? String {
            self.ownerAccountId = value
        }
        if let value = dict["ownerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["sn"] as? String {
            self.sn = value
        }
        if let value = dict["state"] as? String {
            self.state = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
    }
}

public class CreateChangeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateChangeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateChangeRequestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCheckRunRequest : Tea.TeaModel {
    public class Annotations : Tea.TeaModel {
        public var annotationLevel: String?

        public var endColumn: Int64?

        public var endLine: Int64?

        public var message: String?

        public var path: String?

        public var rawDetails: String?

        public var startColumn: Int64?

        public var startLine: Int64?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotationLevel != nil {
                map["annotationLevel"] = self.annotationLevel!
            }
            if self.endColumn != nil {
                map["endColumn"] = self.endColumn!
            }
            if self.endLine != nil {
                map["endLine"] = self.endLine!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.rawDetails != nil {
                map["rawDetails"] = self.rawDetails!
            }
            if self.startColumn != nil {
                map["startColumn"] = self.startColumn!
            }
            if self.startLine != nil {
                map["startLine"] = self.startLine!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["annotationLevel"] as? String {
                self.annotationLevel = value
            }
            if let value = dict["endColumn"] as? Int64 {
                self.endColumn = value
            }
            if let value = dict["endLine"] as? Int64 {
                self.endLine = value
            }
            if let value = dict["message"] as? String {
                self.message = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["rawDetails"] as? String {
                self.rawDetails = value
            }
            if let value = dict["startColumn"] as? Int64 {
                self.startColumn = value
            }
            if let value = dict["startLine"] as? Int64 {
                self.startLine = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
        }
    }
    public class Output : Tea.TeaModel {
        public class Images : Tea.TeaModel {
            public var alt: String?

            public var caption: String?

            public var imageUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alt != nil {
                    map["alt"] = self.alt!
                }
                if self.caption != nil {
                    map["caption"] = self.caption!
                }
                if self.imageUrl != nil {
                    map["imageUrl"] = self.imageUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["alt"] as? String {
                    self.alt = value
                }
                if let value = dict["caption"] as? String {
                    self.caption = value
                }
                if let value = dict["imageUrl"] as? String {
                    self.imageUrl = value
                }
            }
        }
        public var images: [CreateCheckRunRequest.Output.Images]?

        public var summary: String?

        public var text: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.images != nil {
                var tmp : [Any] = []
                for k in self.images! {
                    tmp.append(k.toMap())
                }
                map["images"] = tmp
            }
            if self.summary != nil {
                map["summary"] = self.summary!
            }
            if self.text != nil {
                map["text"] = self.text!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["images"] as? [Any?] {
                var tmp : [CreateCheckRunRequest.Output.Images] = []
                for v in value {
                    if v != nil {
                        var model = CreateCheckRunRequest.Output.Images()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.images = tmp
            }
            if let value = dict["summary"] as? String {
                self.summary = value
            }
            if let value = dict["text"] as? String {
                self.text = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
        }
    }
    public var accessToken: String?

    public var annotations: [CreateCheckRunRequest.Annotations]?

    public var completedAt: String?

    public var conclusion: String?

    public var detailsUrl: String?

    public var externalId: String?

    public var headSha: String?

    public var name: String?

    public var output: CreateCheckRunRequest.Output?

    public var startedAt: String?

    public var status: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.output?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.annotations != nil {
            var tmp : [Any] = []
            for k in self.annotations! {
                tmp.append(k.toMap())
            }
            map["annotations"] = tmp
        }
        if self.completedAt != nil {
            map["completedAt"] = self.completedAt!
        }
        if self.conclusion != nil {
            map["conclusion"] = self.conclusion!
        }
        if self.detailsUrl != nil {
            map["detailsUrl"] = self.detailsUrl!
        }
        if self.externalId != nil {
            map["externalId"] = self.externalId!
        }
        if self.headSha != nil {
            map["headSha"] = self.headSha!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.output != nil {
            map["output"] = self.output?.toMap()
        }
        if self.startedAt != nil {
            map["startedAt"] = self.startedAt!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["annotations"] as? [Any?] {
            var tmp : [CreateCheckRunRequest.Annotations] = []
            for v in value {
                if v != nil {
                    var model = CreateCheckRunRequest.Annotations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.annotations = tmp
        }
        if let value = dict["completedAt"] as? String {
            self.completedAt = value
        }
        if let value = dict["conclusion"] as? String {
            self.conclusion = value
        }
        if let value = dict["detailsUrl"] as? String {
            self.detailsUrl = value
        }
        if let value = dict["externalId"] as? String {
            self.externalId = value
        }
        if let value = dict["headSha"] as? String {
            self.headSha = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["output"] as? [String: Any?] {
            var model = CreateCheckRunRequest.Output()
            model.fromMap(value)
            self.output = model
        }
        if let value = dict["startedAt"] as? String {
            self.startedAt = value
        }
        if let value = dict["status"] as? String {
            self.status = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class CreateCheckRunResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var annotationLevel: String?

            public var endColumn: Int64?

            public var endLine: Int64?

            public var id: Int64?

            public var message: String?

            public var path: String?

            public var rawDetails: String?

            public var startColumn: Int64?

            public var startLine: Int64?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotationLevel != nil {
                    map["annotationLevel"] = self.annotationLevel!
                }
                if self.endColumn != nil {
                    map["endColumn"] = self.endColumn!
                }
                if self.endLine != nil {
                    map["endLine"] = self.endLine!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.rawDetails != nil {
                    map["rawDetails"] = self.rawDetails!
                }
                if self.startColumn != nil {
                    map["startColumn"] = self.startColumn!
                }
                if self.startLine != nil {
                    map["startLine"] = self.startLine!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["annotationLevel"] as? String {
                    self.annotationLevel = value
                }
                if let value = dict["endColumn"] as? Int64 {
                    self.endColumn = value
                }
                if let value = dict["endLine"] as? Int64 {
                    self.endLine = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["path"] as? String {
                    self.path = value
                }
                if let value = dict["rawDetails"] as? String {
                    self.rawDetails = value
                }
                if let value = dict["startColumn"] as? Int64 {
                    self.startColumn = value
                }
                if let value = dict["startLine"] as? Int64 {
                    self.startLine = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public class CheckSuite : Tea.TeaModel {
            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class Images : Tea.TeaModel {
                public var alt: String?

                public var caption: String?

                public var imageUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alt != nil {
                        map["alt"] = self.alt!
                    }
                    if self.caption != nil {
                        map["caption"] = self.caption!
                    }
                    if self.imageUrl != nil {
                        map["imageUrl"] = self.imageUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["alt"] as? String {
                        self.alt = value
                    }
                    if let value = dict["caption"] as? String {
                        self.caption = value
                    }
                    if let value = dict["imageUrl"] as? String {
                        self.imageUrl = value
                    }
                }
            }
            public var images: [CreateCheckRunResponseBody.Result.Output.Images]?

            public var summary: String?

            public var text: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.images != nil {
                    var tmp : [Any] = []
                    for k in self.images! {
                        tmp.append(k.toMap())
                    }
                    map["images"] = tmp
                }
                if self.summary != nil {
                    map["summary"] = self.summary!
                }
                if self.text != nil {
                    map["text"] = self.text!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["images"] as? [Any?] {
                    var tmp : [CreateCheckRunResponseBody.Result.Output.Images] = []
                    for v in value {
                        if v != nil {
                            var model = CreateCheckRunResponseBody.Result.Output.Images()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.images = tmp
                }
                if let value = dict["summary"] as? String {
                    self.summary = value
                }
                if let value = dict["text"] as? String {
                    self.text = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public class Writer : Tea.TeaModel {
            public var id: String?

            public var logoUrl: String?

            public var name: String?

            public var slug: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.logoUrl != nil {
                    map["logoUrl"] = self.logoUrl!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.slug != nil {
                    map["slug"] = self.slug!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["logoUrl"] as? String {
                    self.logoUrl = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["slug"] as? String {
                    self.slug = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public var annotations: [CreateCheckRunResponseBody.Result.Annotations]?

        public var checkSuite: CreateCheckRunResponseBody.Result.CheckSuite?

        public var completedAt: String?

        public var conclusion: String?

        public var createdAt: String?

        public var detailsUrl: String?

        public var externalId: String?

        public var headSha: String?

        public var id: Int64?

        public var name: String?

        public var output: CreateCheckRunResponseBody.Result.Output?

        public var startedAt: String?

        public var status: String?

        public var updatedAt: String?

        public var writer: CreateCheckRunResponseBody.Result.Writer?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkSuite?.validate()
            try self.output?.validate()
            try self.writer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["annotations"] = tmp
            }
            if self.checkSuite != nil {
                map["checkSuite"] = self.checkSuite?.toMap()
            }
            if self.completedAt != nil {
                map["completedAt"] = self.completedAt!
            }
            if self.conclusion != nil {
                map["conclusion"] = self.conclusion!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.detailsUrl != nil {
                map["detailsUrl"] = self.detailsUrl!
            }
            if self.externalId != nil {
                map["externalId"] = self.externalId!
            }
            if self.headSha != nil {
                map["headSha"] = self.headSha!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.output != nil {
                map["output"] = self.output?.toMap()
            }
            if self.startedAt != nil {
                map["startedAt"] = self.startedAt!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.writer != nil {
                map["writer"] = self.writer?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["annotations"] as? [Any?] {
                var tmp : [CreateCheckRunResponseBody.Result.Annotations] = []
                for v in value {
                    if v != nil {
                        var model = CreateCheckRunResponseBody.Result.Annotations()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.annotations = tmp
            }
            if let value = dict["checkSuite"] as? [String: Any?] {
                var model = CreateCheckRunResponseBody.Result.CheckSuite()
                model.fromMap(value)
                self.checkSuite = model
            }
            if let value = dict["completedAt"] as? String {
                self.completedAt = value
            }
            if let value = dict["conclusion"] as? String {
                self.conclusion = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["detailsUrl"] as? String {
                self.detailsUrl = value
            }
            if let value = dict["externalId"] as? String {
                self.externalId = value
            }
            if let value = dict["headSha"] as? String {
                self.headSha = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["output"] as? [String: Any?] {
                var model = CreateCheckRunResponseBody.Result.Output()
                model.fromMap(value)
                self.output = model
            }
            if let value = dict["startedAt"] as? String {
                self.startedAt = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["writer"] as? [String: Any?] {
                var model = CreateCheckRunResponseBody.Result.Writer()
                model.fromMap(value)
                self.writer = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateCheckRunResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateCheckRunResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateCheckRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCheckRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCheckRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCommentRequest : Tea.TeaModel {
    public var accessToken: String?

    public var commentType: String?

    public var content: String?

    public var draft: Bool?

    public var filePath: String?

    public var fromPachSetBizId: String?

    public var lineNumber: Int32?

    public var parentCommentBizId: String?

    public var patchSetBizId: String?

    public var resolved: Bool?

    public var toPatchSetBizId: String?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.commentType != nil {
            map["commentType"] = self.commentType!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.draft != nil {
            map["draft"] = self.draft!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.fromPachSetBizId != nil {
            map["fromPachSetBizId"] = self.fromPachSetBizId!
        }
        if self.lineNumber != nil {
            map["lineNumber"] = self.lineNumber!
        }
        if self.parentCommentBizId != nil {
            map["parentCommentBizId"] = self.parentCommentBizId!
        }
        if self.patchSetBizId != nil {
            map["patchSetBizId"] = self.patchSetBizId!
        }
        if self.resolved != nil {
            map["resolved"] = self.resolved!
        }
        if self.toPatchSetBizId != nil {
            map["toPatchSetBizId"] = self.toPatchSetBizId!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["commentType"] as? String {
            self.commentType = value
        }
        if let value = dict["content"] as? String {
            self.content = value
        }
        if let value = dict["draft"] as? Bool {
            self.draft = value
        }
        if let value = dict["filePath"] as? String {
            self.filePath = value
        }
        if let value = dict["fromPachSetBizId"] as? String {
            self.fromPachSetBizId = value
        }
        if let value = dict["lineNumber"] as? Int32 {
            self.lineNumber = value
        }
        if let value = dict["parentCommentBizId"] as? String {
            self.parentCommentBizId = value
        }
        if let value = dict["patchSetBizId"] as? String {
            self.patchSetBizId = value
        }
        if let value = dict["resolved"] as? Bool {
            self.resolved = value
        }
        if let value = dict["toPatchSetBizId"] as? String {
            self.toPatchSetBizId = value
        }
        if let value = dict["localId"] as? Int64 {
            self.localId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class CreateCommentResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliyunPk"] as? String {
                    self.aliyunPk = value
                }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public class RelatedPatchSet : Tea.TeaModel {
            public var commitId: String?

            public var createdAt: String?

            public var patchSetBizId: String?

            public var patchSetName: String?

            public var patchSetNo: String?

            public var relatedMergeItemType: String?

            public var shortId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commitId != nil {
                    map["commitId"] = self.commitId!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.patchSetBizId != nil {
                    map["patchSetBizId"] = self.patchSetBizId!
                }
                if self.patchSetName != nil {
                    map["patchSetName"] = self.patchSetName!
                }
                if self.patchSetNo != nil {
                    map["patchSetNo"] = self.patchSetNo!
                }
                if self.relatedMergeItemType != nil {
                    map["relatedMergeItemType"] = self.relatedMergeItemType!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["commitId"] as? String {
                    self.commitId = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["patchSetBizId"] as? String {
                    self.patchSetBizId = value
                }
                if let value = dict["patchSetName"] as? String {
                    self.patchSetName = value
                }
                if let value = dict["patchSetNo"] as? String {
                    self.patchSetNo = value
                }
                if let value = dict["relatedMergeItemType"] as? String {
                    self.relatedMergeItemType = value
                }
                if let value = dict["shortId"] as? String {
                    self.shortId = value
                }
            }
        }
        public var author: CreateCommentResponseBody.Result.Author?

        public var commentBizId: String?

        public var commentTime: String?

        public var commentType: String?

        public var content: String?

        public var deleted: Bool?

        public var filePath: String?

        public var lastEditTime: String?

        public var lineNumber: String?

        public var parentCommentBizId: String?

        public var relatedPatchSet: CreateCommentResponseBody.Result.RelatedPatchSet?

        public var resolved: Bool?

        public var rootCommentBizId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.relatedPatchSet?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.commentBizId != nil {
                map["commentBizId"] = self.commentBizId!
            }
            if self.commentTime != nil {
                map["commentTime"] = self.commentTime!
            }
            if self.commentType != nil {
                map["commentType"] = self.commentType!
            }
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.deleted != nil {
                map["deleted"] = self.deleted!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            if self.lastEditTime != nil {
                map["lastEditTime"] = self.lastEditTime!
            }
            if self.lineNumber != nil {
                map["lineNumber"] = self.lineNumber!
            }
            if self.parentCommentBizId != nil {
                map["parentCommentBizId"] = self.parentCommentBizId!
            }
            if self.relatedPatchSet != nil {
                map["relatedPatchSet"] = self.relatedPatchSet?.toMap()
            }
            if self.resolved != nil {
                map["resolved"] = self.resolved!
            }
            if self.rootCommentBizId != nil {
                map["rootCommentBizId"] = self.rootCommentBizId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["author"] as? [String: Any?] {
                var model = CreateCommentResponseBody.Result.Author()
                model.fromMap(value)
                self.author = model
            }
            if let value = dict["commentBizId"] as? String {
                self.commentBizId = value
            }
            if let value = dict["commentTime"] as? String {
                self.commentTime = value
            }
            if let value = dict["commentType"] as? String {
                self.commentType = value
            }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["deleted"] as? Bool {
                self.deleted = value
            }
            if let value = dict["filePath"] as? String {
                self.filePath = value
            }
            if let value = dict["lastEditTime"] as? String {
                self.lastEditTime = value
            }
            if let value = dict["lineNumber"] as? String {
                self.lineNumber = value
            }
            if let value = dict["parentCommentBizId"] as? String {
                self.parentCommentBizId = value
            }
            if let value = dict["relatedPatchSet"] as? [String: Any?] {
                var model = CreateCommentResponseBody.Result.RelatedPatchSet()
                model.fromMap(value)
                self.relatedPatchSet = model
            }
            if let value = dict["resolved"] as? Bool {
                self.resolved = value
            }
            if let value = dict["rootCommentBizId"] as? String {
                self.rootCommentBizId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateCommentResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateCommentResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateCommentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCommentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCommentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCommitStatusRequest : Tea.TeaModel {
    public var accessToken: String?

    public var context: String?

    public var description_: String?

    public var state: String?

    public var targetUrl: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public var sha: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.context != nil {
            map["context"] = self.context!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.state != nil {
            map["state"] = self.state!
        }
        if self.targetUrl != nil {
            map["targetUrl"] = self.targetUrl!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        if self.sha != nil {
            map["sha"] = self.sha!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["context"] as? String {
            self.context = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["state"] as? String {
            self.state = value
        }
        if let value = dict["targetUrl"] as? String {
            self.targetUrl = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
        if let value = dict["sha"] as? String {
            self.sha = value
        }
    }
}

public class CreateCommitStatusResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Creator : Tea.TeaModel {
            public var aliyunPk: Int64?

            public var avatarUrl: String?

            public var login: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.login != nil {
                    map["login"] = self.login!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliyunPk"] as? Int64 {
                    self.aliyunPk = value
                }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["login"] as? String {
                    self.login = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public var context: String?

        public var creator: CreateCommitStatusResponseBody.Result.Creator?

        public var description_: String?

        public var id: Int64?

        public var sha: String?

        public var state: String?

        public var targetUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.creator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.context != nil {
                map["context"] = self.context!
            }
            if self.creator != nil {
                map["creator"] = self.creator?.toMap()
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.sha != nil {
                map["sha"] = self.sha!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.targetUrl != nil {
                map["targetUrl"] = self.targetUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["context"] as? String {
                self.context = value
            }
            if let value = dict["creator"] as? [String: Any?] {
                var model = CreateCommitStatusResponseBody.Result.Creator()
                model.fromMap(value)
                self.creator = model
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["sha"] as? String {
                self.sha = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["targetUrl"] as? String {
                self.targetUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateCommitStatusResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateCommitStatusResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateCommitStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCommitStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCommitStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCommitWithMultipleFilesRequest : Tea.TeaModel {
    public class Actions : Tea.TeaModel {
        public var action: String?

        public var content: String?

        public var filePath: String?

        public var previousPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["action"] = self.action!
            }
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            if self.previousPath != nil {
                map["previousPath"] = self.previousPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["action"] as? String {
                self.action = value
            }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["filePath"] as? String {
                self.filePath = value
            }
            if let value = dict["previousPath"] as? String {
                self.previousPath = value
            }
        }
    }
    public var accessToken: String?

    public var actions: [CreateCommitWithMultipleFilesRequest.Actions]?

    public var branch: String?

    public var commitMessage: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.actions != nil {
            var tmp : [Any] = []
            for k in self.actions! {
                tmp.append(k.toMap())
            }
            map["actions"] = tmp
        }
        if self.branch != nil {
            map["branch"] = self.branch!
        }
        if self.commitMessage != nil {
            map["commitMessage"] = self.commitMessage!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["actions"] as? [Any?] {
            var tmp : [CreateCommitWithMultipleFilesRequest.Actions] = []
            for v in value {
                if v != nil {
                    var model = CreateCommitWithMultipleFilesRequest.Actions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.actions = tmp
        }
        if let value = dict["branch"] as? String {
            self.branch = value
        }
        if let value = dict["commitMessage"] as? String {
            self.commitMessage = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class CreateCommitWithMultipleFilesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliyunPk"] as? String {
                    self.aliyunPk = value
                }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
                if let value = dict["websiteUrl"] as? String {
                    self.websiteUrl = value
                }
            }
        }
        public class Committer : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliyunPk"] as? String {
                    self.aliyunPk = value
                }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
                if let value = dict["websiteUrl"] as? String {
                    self.websiteUrl = value
                }
            }
        }
        public var author: CreateCommitWithMultipleFilesResponseBody.Result.Author?

        public var authorEmail: String?

        public var authorName: String?

        public var authoredDate: String?

        public var committedDate: String?

        public var committer: CreateCommitWithMultipleFilesResponseBody.Result.Committer?

        public var committerEmail: String?

        public var committerName: String?

        public var createdAt: String?

        public var id: String?

        public var message: String?

        public var parentIds: [String]?

        public var shortId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.committer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.authorEmail != nil {
                map["authorEmail"] = self.authorEmail!
            }
            if self.authorName != nil {
                map["authorName"] = self.authorName!
            }
            if self.authoredDate != nil {
                map["authoredDate"] = self.authoredDate!
            }
            if self.committedDate != nil {
                map["committedDate"] = self.committedDate!
            }
            if self.committer != nil {
                map["committer"] = self.committer?.toMap()
            }
            if self.committerEmail != nil {
                map["committerEmail"] = self.committerEmail!
            }
            if self.committerName != nil {
                map["committerName"] = self.committerName!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.parentIds != nil {
                map["parentIds"] = self.parentIds!
            }
            if self.shortId != nil {
                map["shortId"] = self.shortId!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["author"] as? [String: Any?] {
                var model = CreateCommitWithMultipleFilesResponseBody.Result.Author()
                model.fromMap(value)
                self.author = model
            }
            if let value = dict["authorEmail"] as? String {
                self.authorEmail = value
            }
            if let value = dict["authorName"] as? String {
                self.authorName = value
            }
            if let value = dict["authoredDate"] as? String {
                self.authoredDate = value
            }
            if let value = dict["committedDate"] as? String {
                self.committedDate = value
            }
            if let value = dict["committer"] as? [String: Any?] {
                var model = CreateCommitWithMultipleFilesResponseBody.Result.Committer()
                model.fromMap(value)
                self.committer = model
            }
            if let value = dict["committerEmail"] as? String {
                self.committerEmail = value
            }
            if let value = dict["committerName"] as? String {
                self.committerName = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["message"] as? String {
                self.message = value
            }
            if let value = dict["parentIds"] as? [String] {
                self.parentIds = value
            }
            if let value = dict["shortId"] as? String {
                self.shortId = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var result: CreateCommitWithMultipleFilesResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateCommitWithMultipleFilesResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateCommitWithMultipleFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCommitWithMultipleFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCommitWithMultipleFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDeployKeyRequest : Tea.TeaModel {
    public var accessToken: String?

    public var key: String?

    public var title: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.key != nil {
            map["key"] = self.key!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["key"] as? String {
            self.key = value
        }
        if let value = dict["title"] as? String {
            self.title = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CreateDeployKeyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var fingerprint: String?

        public var id: Int64?

        public var key: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.fingerprint != nil {
                map["fingerprint"] = self.fingerprint!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["fingerprint"] as? String {
                self.fingerprint = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["key"] as? String {
                self.key = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateDeployKeyResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateDeployKeyResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateDeployKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDeployKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDeployKeyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateFileRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var commitMessage: String?

    public var content: String?

    public var encoding: String?

    public var filePath: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.commitMessage != nil {
            map["commitMessage"] = self.commitMessage!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.encoding != nil {
            map["encoding"] = self.encoding!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["branchName"] as? String {
            self.branchName = value
        }
        if let value = dict["commitMessage"] as? String {
            self.commitMessage = value
        }
        if let value = dict["content"] as? String {
            self.content = value
        }
        if let value = dict["encoding"] as? String {
            self.encoding = value
        }
        if let value = dict["filePath"] as? String {
            self.filePath = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CreateFileResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var branchName: String?

        public var filePath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["branchName"] = self.branchName!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["branchName"] as? String {
                self.branchName = value
            }
            if let value = dict["filePath"] as? String {
                self.filePath = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateFileResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateFileResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateFlowTagRequest : Tea.TeaModel {
    public var color: String?

    public var flowTagGroupId: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.color != nil {
            map["color"] = self.color!
        }
        if self.flowTagGroupId != nil {
            map["flowTagGroupId"] = self.flowTagGroupId!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["color"] as? String {
            self.color = value
        }
        if let value = dict["flowTagGroupId"] as? Int64 {
            self.flowTagGroupId = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
    }
}

public class CreateFlowTagResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var id: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["id"] as? Int64 {
            self.id = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateFlowTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateFlowTagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateFlowTagGroupRequest : Tea.TeaModel {
    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["name"] as? String {
            self.name = value
        }
    }
}

public class CreateFlowTagGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var id: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["id"] as? Int64 {
            self.id = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateFlowTagGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowTagGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateFlowTagGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateHostGroupRequest : Tea.TeaModel {
    public var aliyunRegion: String?

    public var ecsLabelKey: String?

    public var ecsLabelValue: String?

    public var ecsType: String?

    public var envId: String?

    public var machineInfos: String?

    public var name: String?

    public var serviceConnectionId: Int64?

    public var tagIds: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunRegion != nil {
            map["aliyunRegion"] = self.aliyunRegion!
        }
        if self.ecsLabelKey != nil {
            map["ecsLabelKey"] = self.ecsLabelKey!
        }
        if self.ecsLabelValue != nil {
            map["ecsLabelValue"] = self.ecsLabelValue!
        }
        if self.ecsType != nil {
            map["ecsType"] = self.ecsType!
        }
        if self.envId != nil {
            map["envId"] = self.envId!
        }
        if self.machineInfos != nil {
            map["machineInfos"] = self.machineInfos!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.serviceConnectionId != nil {
            map["serviceConnectionId"] = self.serviceConnectionId!
        }
        if self.tagIds != nil {
            map["tagIds"] = self.tagIds!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["aliyunRegion"] as? String {
            self.aliyunRegion = value
        }
        if let value = dict["ecsLabelKey"] as? String {
            self.ecsLabelKey = value
        }
        if let value = dict["ecsLabelValue"] as? String {
            self.ecsLabelValue = value
        }
        if let value = dict["ecsType"] as? String {
            self.ecsType = value
        }
        if let value = dict["envId"] as? String {
            self.envId = value
        }
        if let value = dict["machineInfos"] as? String {
            self.machineInfos = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["serviceConnectionId"] as? Int64 {
            self.serviceConnectionId = value
        }
        if let value = dict["tagIds"] as? String {
            self.tagIds = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
    }
}

public class CreateHostGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var hostGroupId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.hostGroupId != nil {
            map["hostGroupId"] = self.hostGroupId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["hostGroupId"] as? Int64 {
            self.hostGroupId = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateHostGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHostGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateHostGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var createFrom: String?

    public var description_: String?

    public var reviewerIds: [String]?

    public var sourceBranch: String?

    public var sourceProjectId: Int64?

    public var targetBranch: String?

    public var targetProjectId: Int64?

    public var title: String?

    public var workItemIds: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.createFrom != nil {
            map["createFrom"] = self.createFrom!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.reviewerIds != nil {
            map["reviewerIds"] = self.reviewerIds!
        }
        if self.sourceBranch != nil {
            map["sourceBranch"] = self.sourceBranch!
        }
        if self.sourceProjectId != nil {
            map["sourceProjectId"] = self.sourceProjectId!
        }
        if self.targetBranch != nil {
            map["targetBranch"] = self.targetBranch!
        }
        if self.targetProjectId != nil {
            map["targetProjectId"] = self.targetProjectId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.workItemIds != nil {
            map["workItemIds"] = self.workItemIds!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["createFrom"] as? String {
            self.createFrom = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["reviewerIds"] as? [String] {
            self.reviewerIds = value
        }
        if let value = dict["sourceBranch"] as? String {
            self.sourceBranch = value
        }
        if let value = dict["sourceProjectId"] as? Int64 {
            self.sourceProjectId = value
        }
        if let value = dict["targetBranch"] as? String {
            self.targetBranch = value
        }
        if let value = dict["targetProjectId"] as? Int64 {
            self.targetProjectId = value
        }
        if let value = dict["title"] as? String {
            self.title = value
        }
        if let value = dict["workItemIds"] as? String {
            self.workItemIds = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CreateMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public class Reviewers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var hasReviewed: Bool?

            public var id: Int64?

            public var name: String?

            public var reviewOpinionStatus: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.hasReviewed != nil {
                    map["hasReviewed"] = self.hasReviewed!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.reviewOpinionStatus != nil {
                    map["reviewOpinionStatus"] = self.reviewOpinionStatus!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["hasReviewed"] as? Bool {
                    self.hasReviewed = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["reviewOpinionStatus"] as? String {
                    self.reviewOpinionStatus = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public class Subscribers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public var ahead: Int32?

        public var allRequirementsPass: Bool?

        public var author: CreateMergeRequestResponseBody.Result.Author?

        public var behind: Int32?

        public var createFrom: String?

        public var createTime: String?

        public var description_: String?

        public var detailUrl: String?

        public var localId: Int64?

        public var mrBizId: String?

        public var mrType: String?

        public var projectId: Int64?

        public var reviewers: [CreateMergeRequestResponseBody.Result.Reviewers]?

        public var sourceBranch: String?

        public var sourceProjectId: Int64?

        public var status: String?

        public var subscribers: [CreateMergeRequestResponseBody.Result.Subscribers]?

        public var supportMergeFastForwardOnly: Bool?

        public var targetBranch: String?

        public var targetProjectId: Int64?

        public var title: String?

        public var updateTime: String?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ahead != nil {
                map["ahead"] = self.ahead!
            }
            if self.allRequirementsPass != nil {
                map["allRequirementsPass"] = self.allRequirementsPass!
            }
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.behind != nil {
                map["behind"] = self.behind!
            }
            if self.createFrom != nil {
                map["createFrom"] = self.createFrom!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.detailUrl != nil {
                map["detailUrl"] = self.detailUrl!
            }
            if self.localId != nil {
                map["localId"] = self.localId!
            }
            if self.mrBizId != nil {
                map["mrBizId"] = self.mrBizId!
            }
            if self.mrType != nil {
                map["mrType"] = self.mrType!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.reviewers != nil {
                var tmp : [Any] = []
                for k in self.reviewers! {
                    tmp.append(k.toMap())
                }
                map["reviewers"] = tmp
            }
            if self.sourceBranch != nil {
                map["sourceBranch"] = self.sourceBranch!
            }
            if self.sourceProjectId != nil {
                map["sourceProjectId"] = self.sourceProjectId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.subscribers != nil {
                var tmp : [Any] = []
                for k in self.subscribers! {
                    tmp.append(k.toMap())
                }
                map["subscribers"] = tmp
            }
            if self.supportMergeFastForwardOnly != nil {
                map["supportMergeFastForwardOnly"] = self.supportMergeFastForwardOnly!
            }
            if self.targetBranch != nil {
                map["targetBranch"] = self.targetBranch!
            }
            if self.targetProjectId != nil {
                map["targetProjectId"] = self.targetProjectId!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ahead"] as? Int32 {
                self.ahead = value
            }
            if let value = dict["allRequirementsPass"] as? Bool {
                self.allRequirementsPass = value
            }
            if let value = dict["author"] as? [String: Any?] {
                var model = CreateMergeRequestResponseBody.Result.Author()
                model.fromMap(value)
                self.author = model
            }
            if let value = dict["behind"] as? Int32 {
                self.behind = value
            }
            if let value = dict["createFrom"] as? String {
                self.createFrom = value
            }
            if let value = dict["createTime"] as? String {
                self.createTime = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["detailUrl"] as? String {
                self.detailUrl = value
            }
            if let value = dict["localId"] as? Int64 {
                self.localId = value
            }
            if let value = dict["mrBizId"] as? String {
                self.mrBizId = value
            }
            if let value = dict["mrType"] as? String {
                self.mrType = value
            }
            if let value = dict["projectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["reviewers"] as? [Any?] {
                var tmp : [CreateMergeRequestResponseBody.Result.Reviewers] = []
                for v in value {
                    if v != nil {
                        var model = CreateMergeRequestResponseBody.Result.Reviewers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.reviewers = tmp
            }
            if let value = dict["sourceBranch"] as? String {
                self.sourceBranch = value
            }
            if let value = dict["sourceProjectId"] as? Int64 {
                self.sourceProjectId = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["subscribers"] as? [Any?] {
                var tmp : [CreateMergeRequestResponseBody.Result.Subscribers] = []
                for v in value {
                    if v != nil {
                        var model = CreateMergeRequestResponseBody.Result.Subscribers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.subscribers = tmp
            }
            if let value = dict["supportMergeFastForwardOnly"] as? Bool {
                self.supportMergeFastForwardOnly = value
            }
            if let value = dict["targetBranch"] as? String {
                self.targetBranch = value
            }
            if let value = dict["targetProjectId"] as? Int64 {
                self.targetProjectId = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
            if let value = dict["updateTime"] as? String {
                self.updateTime = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateMergeRequestResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateMergeRequestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateOAuthTokenRequest : Tea.TeaModel {
    public var clientId: String?

    public var clientSecret: String?

    public var code: String?

    public var grantType: String?

    public var login: String?

    public var scope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientId != nil {
            map["clientId"] = self.clientId!
        }
        if self.clientSecret != nil {
            map["clientSecret"] = self.clientSecret!
        }
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.grantType != nil {
            map["grantType"] = self.grantType!
        }
        if self.login != nil {
            map["login"] = self.login!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientId"] as? String {
            self.clientId = value
        }
        if let value = dict["clientSecret"] as? String {
            self.clientSecret = value
        }
        if let value = dict["code"] as? String {
            self.code = value
        }
        if let value = dict["grantType"] as? String {
            self.grantType = value
        }
        if let value = dict["login"] as? String {
            self.login = value
        }
        if let value = dict["scope"] as? String {
            self.scope = value
        }
    }
}

public class CreateOAuthTokenResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessToken: String?

        public var id: String?

        public var scope: String?

        public var tokenType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessToken != nil {
                map["accessToken"] = self.accessToken!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.tokenType != nil {
                map["tokenType"] = self.tokenType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessToken"] as? String {
                self.accessToken = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["scope"] as? String {
                self.scope = value
            }
            if let value = dict["tokenType"] as? String {
                self.tokenType = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateOAuthTokenResponseBody.Result?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateOAuthTokenResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
    }
}

public class CreateOAuthTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOAuthTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateOAuthTokenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePipelineRequest : Tea.TeaModel {
    public var content: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["content"] as? String {
            self.content = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
    }
}

public class CreatePipelineResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelinId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelinId != nil {
            map["pipelinId"] = self.pipelinId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["pipelinId"] as? Int64 {
            self.pipelinId = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePipelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePipelineGroupRequest : Tea.TeaModel {
    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["name"] as? String {
            self.name = value
        }
    }
}

public class CreatePipelineGroupResponseBody : Tea.TeaModel {
    public class PipelineGroup : Tea.TeaModel {
        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelineGroup: CreatePipelineGroupResponseBody.PipelineGroup?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipelineGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelineGroup != nil {
            map["pipelineGroup"] = self.pipelineGroup?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["pipelineGroup"] as? [String: Any?] {
            var model = CreatePipelineGroupResponseBody.PipelineGroup()
            model.fromMap(value)
            self.pipelineGroup = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreatePipelineGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePipelineGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePipelineGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateProjectRequest : Tea.TeaModel {
    public var customCode: String?

    public var name: String?

    public var scope: String?

    public var templateIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customCode != nil {
            map["customCode"] = self.customCode!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.templateIdentifier != nil {
            map["templateIdentifier"] = self.templateIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["customCode"] as? String {
            self.customCode = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["scope"] as? String {
            self.scope = value
        }
        if let value = dict["templateIdentifier"] as? String {
            self.templateIdentifier = value
        }
    }
}

public class CreateProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var categoryIdentifier: String?

        public var creator: String?

        public var customCode: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var icon: String?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var name: String?

        public var organizationIdentifier: String?

        public var scope: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var typeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.customCode != nil {
                map["customCode"] = self.customCode!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.icon != nil {
                map["icon"] = self.icon!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationIdentifier != nil {
                map["organizationIdentifier"] = self.organizationIdentifier!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.typeIdentifier != nil {
                map["typeIdentifier"] = self.typeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["customCode"] as? String {
                self.customCode = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["icon"] as? String {
                self.icon = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["logicalStatus"] as? String {
                self.logicalStatus = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["organizationIdentifier"] as? String {
                self.organizationIdentifier = value
            }
            if let value = dict["scope"] as? String {
                self.scope = value
            }
            if let value = dict["statusIdentifier"] as? String {
                self.statusIdentifier = value
            }
            if let value = dict["statusStageIdentifier"] as? String {
                self.statusStageIdentifier = value
            }
            if let value = dict["typeIdentifier"] as? String {
                self.typeIdentifier = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var project: CreateProjectResponseBody.Project?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.project != nil {
            map["project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["project"] as? [String: Any?] {
            var model = CreateProjectResponseBody.Project()
            model.fromMap(value)
            self.project = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateProjectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateProjectLabelRequest : Tea.TeaModel {
    public var accessToken: String?

    public var color: String?

    public var description_: String?

    public var name: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.color != nil {
            map["color"] = self.color!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["color"] as? String {
            self.color = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class CreateProjectLabelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var color: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.color != nil {
                map["color"] = self.color!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["color"] as? String {
                self.color = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateProjectLabelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateProjectLabelResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateProjectLabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectLabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateProjectLabelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateProtectdBranchRequest : Tea.TeaModel {
    public class MergeRequestSetting : Tea.TeaModel {
        public var allowMergeRequestRoles: [Int32]?

        public var defaultAssignees: [String]?

        public var isAllowSelfApproval: Bool?

        public var isRequireDiscussionProcessed: Bool?

        public var isRequired: Bool?

        public var isResetApprovalWhenNewPush: Bool?

        public var minimumApproval: Int32?

        public var mrMode: String?

        public var whiteList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowMergeRequestRoles != nil {
                map["allowMergeRequestRoles"] = self.allowMergeRequestRoles!
            }
            if self.defaultAssignees != nil {
                map["defaultAssignees"] = self.defaultAssignees!
            }
            if self.isAllowSelfApproval != nil {
                map["isAllowSelfApproval"] = self.isAllowSelfApproval!
            }
            if self.isRequireDiscussionProcessed != nil {
                map["isRequireDiscussionProcessed"] = self.isRequireDiscussionProcessed!
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.isResetApprovalWhenNewPush != nil {
                map["isResetApprovalWhenNewPush"] = self.isResetApprovalWhenNewPush!
            }
            if self.minimumApproval != nil {
                map["minimumApproval"] = self.minimumApproval!
            }
            if self.mrMode != nil {
                map["mrMode"] = self.mrMode!
            }
            if self.whiteList != nil {
                map["whiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["allowMergeRequestRoles"] as? [Int32] {
                self.allowMergeRequestRoles = value
            }
            if let value = dict["defaultAssignees"] as? [String] {
                self.defaultAssignees = value
            }
            if let value = dict["isAllowSelfApproval"] as? Bool {
                self.isAllowSelfApproval = value
            }
            if let value = dict["isRequireDiscussionProcessed"] as? Bool {
                self.isRequireDiscussionProcessed = value
            }
            if let value = dict["isRequired"] as? Bool {
                self.isRequired = value
            }
            if let value = dict["isResetApprovalWhenNewPush"] as? Bool {
                self.isResetApprovalWhenNewPush = value
            }
            if let value = dict["minimumApproval"] as? Int32 {
                self.minimumApproval = value
            }
            if let value = dict["mrMode"] as? String {
                self.mrMode = value
            }
            if let value = dict["whiteList"] as? String {
                self.whiteList = value
            }
        }
    }
    public class TestSettingDTO : Tea.TeaModel {
        public class CheckConfig : Tea.TeaModel {
            public class CheckItems : Tea.TeaModel {
                public var isRequired: Bool?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isRequired != nil {
                        map["isRequired"] = self.isRequired!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["isRequired"] as? Bool {
                        self.isRequired = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                }
            }
            public var checkItems: [CreateProtectdBranchRequest.TestSettingDTO.CheckConfig.CheckItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkItems != nil {
                    var tmp : [Any] = []
                    for k in self.checkItems! {
                        tmp.append(k.toMap())
                    }
                    map["checkItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["checkItems"] as? [Any?] {
                    var tmp : [CreateProtectdBranchRequest.TestSettingDTO.CheckConfig.CheckItems] = []
                    for v in value {
                        if v != nil {
                            var model = CreateProtectdBranchRequest.TestSettingDTO.CheckConfig.CheckItems()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.checkItems = tmp
                }
            }
        }
        public class CheckTaskQualityConfig : Tea.TeaModel {
            public var bizNo: String?

            public var enabled: Bool?

            public var message: String?

            public var taskName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizNo != nil {
                    map["bizNo"] = self.bizNo!
                }
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.taskName != nil {
                    map["taskName"] = self.taskName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["bizNo"] as? String {
                    self.bizNo = value
                }
                if let value = dict["enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["taskName"] as? String {
                    self.taskName = value
                }
            }
        }
        public class CodeGuidelinesDetection : Tea.TeaModel {
            public var enabled: Bool?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
            }
        }
        public class SensitiveInfoDetection : Tea.TeaModel {
            public var enabled: Bool?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
            }
        }
        public var checkConfig: CreateProtectdBranchRequest.TestSettingDTO.CheckConfig?

        public var checkTaskQualityConfig: CreateProtectdBranchRequest.TestSettingDTO.CheckTaskQualityConfig?

        public var codeGuidelinesDetection: CreateProtectdBranchRequest.TestSettingDTO.CodeGuidelinesDetection?

        public var isRequired: Bool?

        public var sensitiveInfoDetection: CreateProtectdBranchRequest.TestSettingDTO.SensitiveInfoDetection?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkConfig?.validate()
            try self.checkTaskQualityConfig?.validate()
            try self.codeGuidelinesDetection?.validate()
            try self.sensitiveInfoDetection?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkConfig != nil {
                map["checkConfig"] = self.checkConfig?.toMap()
            }
            if self.checkTaskQualityConfig != nil {
                map["checkTaskQualityConfig"] = self.checkTaskQualityConfig?.toMap()
            }
            if self.codeGuidelinesDetection != nil {
                map["codeGuidelinesDetection"] = self.codeGuidelinesDetection?.toMap()
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.sensitiveInfoDetection != nil {
                map["sensitiveInfoDetection"] = self.sensitiveInfoDetection?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["checkConfig"] as? [String: Any?] {
                var model = CreateProtectdBranchRequest.TestSettingDTO.CheckConfig()
                model.fromMap(value)
                self.checkConfig = model
            }
            if let value = dict["checkTaskQualityConfig"] as? [String: Any?] {
                var model = CreateProtectdBranchRequest.TestSettingDTO.CheckTaskQualityConfig()
                model.fromMap(value)
                self.checkTaskQualityConfig = model
            }
            if let value = dict["codeGuidelinesDetection"] as? [String: Any?] {
                var model = CreateProtectdBranchRequest.TestSettingDTO.CodeGuidelinesDetection()
                model.fromMap(value)
                self.codeGuidelinesDetection = model
            }
            if let value = dict["isRequired"] as? Bool {
                self.isRequired = value
            }
            if let value = dict["sensitiveInfoDetection"] as? [String: Any?] {
                var model = CreateProtectdBranchRequest.TestSettingDTO.SensitiveInfoDetection()
                model.fromMap(value)
                self.sensitiveInfoDetection = model
            }
        }
    }
    public var accessToken: String?

    public var allowMergeRoles: [Int32]?

    public var allowMergeUserIds: [String]?

    public var allowPushRoles: [Int32]?

    public var allowPushUserIds: [String]?

    public var branch: String?

    public var id: Int64?

    public var mergeRequestSetting: CreateProtectdBranchRequest.MergeRequestSetting?

    public var testSettingDTO: CreateProtectdBranchRequest.TestSettingDTO?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mergeRequestSetting?.validate()
        try self.testSettingDTO?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.allowMergeRoles != nil {
            map["allowMergeRoles"] = self.allowMergeRoles!
        }
        if self.allowMergeUserIds != nil {
            map["allowMergeUserIds"] = self.allowMergeUserIds!
        }
        if self.allowPushRoles != nil {
            map["allowPushRoles"] = self.allowPushRoles!
        }
        if self.allowPushUserIds != nil {
            map["allowPushUserIds"] = self.allowPushUserIds!
        }
        if self.branch != nil {
            map["branch"] = self.branch!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.mergeRequestSetting != nil {
            map["mergeRequestSetting"] = self.mergeRequestSetting?.toMap()
        }
        if self.testSettingDTO != nil {
            map["testSettingDTO"] = self.testSettingDTO?.toMap()
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["allowMergeRoles"] as? [Int32] {
            self.allowMergeRoles = value
        }
        if let value = dict["allowMergeUserIds"] as? [String] {
            self.allowMergeUserIds = value
        }
        if let value = dict["allowPushRoles"] as? [Int32] {
            self.allowPushRoles = value
        }
        if let value = dict["allowPushUserIds"] as? [String] {
            self.allowPushUserIds = value
        }
        if let value = dict["branch"] as? String {
            self.branch = value
        }
        if let value = dict["id"] as? Int64 {
            self.id = value
        }
        if let value = dict["mergeRequestSetting"] as? [String: Any?] {
            var model = CreateProtectdBranchRequest.MergeRequestSetting()
            model.fromMap(value)
            self.mergeRequestSetting = model
        }
        if let value = dict["testSettingDTO"] as? [String: Any?] {
            var model = CreateProtectdBranchRequest.TestSettingDTO()
            model.fromMap(value)
            self.testSettingDTO = model
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CreateProtectdBranchResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class MergeRequestSetting : Tea.TeaModel {
            public var allowMergeRequestRoles: [Int32]?

            public var defaultAssignees: [String]?

            public var isAllowSelfApproval: Bool?

            public var isRequireDiscussionProcessed: Bool?

            public var isRequired: Bool?

            public var isResetApprovalWhenNewPush: Bool?

            public var minimumApproval: Int32?

            public var mrMode: String?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowMergeRequestRoles != nil {
                    map["allowMergeRequestRoles"] = self.allowMergeRequestRoles!
                }
                if self.defaultAssignees != nil {
                    map["defaultAssignees"] = self.defaultAssignees!
                }
                if self.isAllowSelfApproval != nil {
                    map["isAllowSelfApproval"] = self.isAllowSelfApproval!
                }
                if self.isRequireDiscussionProcessed != nil {
                    map["isRequireDiscussionProcessed"] = self.isRequireDiscussionProcessed!
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.isResetApprovalWhenNewPush != nil {
                    map["isResetApprovalWhenNewPush"] = self.isResetApprovalWhenNewPush!
                }
                if self.minimumApproval != nil {
                    map["minimumApproval"] = self.minimumApproval!
                }
                if self.mrMode != nil {
                    map["mrMode"] = self.mrMode!
                }
                if self.whiteList != nil {
                    map["whiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["allowMergeRequestRoles"] as? [Int32] {
                    self.allowMergeRequestRoles = value
                }
                if let value = dict["defaultAssignees"] as? [String] {
                    self.defaultAssignees = value
                }
                if let value = dict["isAllowSelfApproval"] as? Bool {
                    self.isAllowSelfApproval = value
                }
                if let value = dict["isRequireDiscussionProcessed"] as? Bool {
                    self.isRequireDiscussionProcessed = value
                }
                if let value = dict["isRequired"] as? Bool {
                    self.isRequired = value
                }
                if let value = dict["isResetApprovalWhenNewPush"] as? Bool {
                    self.isResetApprovalWhenNewPush = value
                }
                if let value = dict["minimumApproval"] as? Int32 {
                    self.minimumApproval = value
                }
                if let value = dict["mrMode"] as? String {
                    self.mrMode = value
                }
                if let value = dict["whiteList"] as? String {
                    self.whiteList = value
                }
            }
        }
        public class TestSettingDTO : Tea.TeaModel {
            public class CheckConfig : Tea.TeaModel {
                public class CheckItems : Tea.TeaModel {
                    public var isRequired: Bool?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isRequired != nil {
                            map["isRequired"] = self.isRequired!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["isRequired"] as? Bool {
                            self.isRequired = value
                        }
                        if let value = dict["name"] as? String {
                            self.name = value
                        }
                    }
                }
                public var checkItems: [CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkItems != nil {
                        var tmp : [Any] = []
                        for k in self.checkItems! {
                            tmp.append(k.toMap())
                        }
                        map["checkItems"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["checkItems"] as? [Any?] {
                        var tmp : [CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems] = []
                        for v in value {
                            if v != nil {
                                var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.checkItems = tmp
                    }
                }
            }
            public class CheckTaskQualityConfig : Tea.TeaModel {
                public var bizNo: String?

                public var enabled: Bool?

                public var message: String?

                public var taskName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizNo != nil {
                        map["bizNo"] = self.bizNo!
                    }
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    if self.taskName != nil {
                        map["taskName"] = self.taskName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["bizNo"] as? String {
                        self.bizNo = value
                    }
                    if let value = dict["enabled"] as? Bool {
                        self.enabled = value
                    }
                    if let value = dict["message"] as? String {
                        self.message = value
                    }
                    if let value = dict["taskName"] as? String {
                        self.taskName = value
                    }
                }
            }
            public class CodeGuidelinesDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["enabled"] as? Bool {
                        self.enabled = value
                    }
                    if let value = dict["message"] as? String {
                        self.message = value
                    }
                }
            }
            public class SensitiveInfoDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["enabled"] as? Bool {
                        self.enabled = value
                    }
                    if let value = dict["message"] as? String {
                        self.message = value
                    }
                }
            }
            public var checkConfig: CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckConfig?

            public var checkTaskQualityConfig: CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig?

            public var codeGuidelinesDetection: CreateProtectdBranchResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection?

            public var isRequired: Bool?

            public var sensitiveInfoDetection: CreateProtectdBranchResponseBody.Result.TestSettingDTO.SensitiveInfoDetection?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.checkConfig?.validate()
                try self.checkTaskQualityConfig?.validate()
                try self.codeGuidelinesDetection?.validate()
                try self.sensitiveInfoDetection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkConfig != nil {
                    map["checkConfig"] = self.checkConfig?.toMap()
                }
                if self.checkTaskQualityConfig != nil {
                    map["checkTaskQualityConfig"] = self.checkTaskQualityConfig?.toMap()
                }
                if self.codeGuidelinesDetection != nil {
                    map["codeGuidelinesDetection"] = self.codeGuidelinesDetection?.toMap()
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.sensitiveInfoDetection != nil {
                    map["sensitiveInfoDetection"] = self.sensitiveInfoDetection?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["checkConfig"] as? [String: Any?] {
                    var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckConfig()
                    model.fromMap(value)
                    self.checkConfig = model
                }
                if let value = dict["checkTaskQualityConfig"] as? [String: Any?] {
                    var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig()
                    model.fromMap(value)
                    self.checkTaskQualityConfig = model
                }
                if let value = dict["codeGuidelinesDetection"] as? [String: Any?] {
                    var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection()
                    model.fromMap(value)
                    self.codeGuidelinesDetection = model
                }
                if let value = dict["isRequired"] as? Bool {
                    self.isRequired = value
                }
                if let value = dict["sensitiveInfoDetection"] as? [String: Any?] {
                    var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO.SensitiveInfoDetection()
                    model.fromMap(value)
                    self.sensitiveInfoDetection = model
                }
            }
        }
        public var allowMergeRoles: [Int32]?

        public var allowMergeUserIds: [Int64]?

        public var allowPushRoles: [Int32]?

        public var allowPushUserIds: [Int64]?

        public var branch: String?

        public var id: Int64?

        public var mergeRequestSetting: CreateProtectdBranchResponseBody.Result.MergeRequestSetting?

        public var testSettingDTO: CreateProtectdBranchResponseBody.Result.TestSettingDTO?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mergeRequestSetting?.validate()
            try self.testSettingDTO?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowMergeRoles != nil {
                map["allowMergeRoles"] = self.allowMergeRoles!
            }
            if self.allowMergeUserIds != nil {
                map["allowMergeUserIds"] = self.allowMergeUserIds!
            }
            if self.allowPushRoles != nil {
                map["allowPushRoles"] = self.allowPushRoles!
            }
            if self.allowPushUserIds != nil {
                map["allowPushUserIds"] = self.allowPushUserIds!
            }
            if self.branch != nil {
                map["branch"] = self.branch!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.mergeRequestSetting != nil {
                map["mergeRequestSetting"] = self.mergeRequestSetting?.toMap()
            }
            if self.testSettingDTO != nil {
                map["testSettingDTO"] = self.testSettingDTO?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["allowMergeRoles"] as? [Int32] {
                self.allowMergeRoles = value
            }
            if let value = dict["allowMergeUserIds"] as? [Int64] {
                self.allowMergeUserIds = value
            }
            if let value = dict["allowPushRoles"] as? [Int32] {
                self.allowPushRoles = value
            }
            if let value = dict["allowPushUserIds"] as? [Int64] {
                self.allowPushUserIds = value
            }
            if let value = dict["branch"] as? String {
                self.branch = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["mergeRequestSetting"] as? [String: Any?] {
                var model = CreateProtectdBranchResponseBody.Result.MergeRequestSetting()
                model.fromMap(value)
                self.mergeRequestSetting = model
            }
            if let value = dict["testSettingDTO"] as? [String: Any?] {
                var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO()
                model.fromMap(value)
                self.testSettingDTO = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateProtectdBranchResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateProtectdBranchResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateProtectdBranchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProtectdBranchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateProtectdBranchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePushRuleRequest : Tea.TeaModel {
    public class RuleInfos : Tea.TeaModel {
        public var checkerName: String?

        public var checkerType: String?

        public var extraMessage: String?

        public var fileRuleRegexes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkerName != nil {
                map["checkerName"] = self.checkerName!
            }
            if self.checkerType != nil {
                map["checkerType"] = self.checkerType!
            }
            if self.extraMessage != nil {
                map["extraMessage"] = self.extraMessage!
            }
            if self.fileRuleRegexes != nil {
                map["fileRuleRegexes"] = self.fileRuleRegexes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["checkerName"] as? String {
                self.checkerName = value
            }
            if let value = dict["checkerType"] as? String {
                self.checkerType = value
            }
            if let value = dict["extraMessage"] as? String {
                self.extraMessage = value
            }
            if let value = dict["fileRuleRegexes"] as? [String] {
                self.fileRuleRegexes = value
            }
        }
    }
    public var accessToken: String?

    public var ruleInfos: [CreatePushRuleRequest.RuleInfos]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.ruleInfos != nil {
            var tmp : [Any] = []
            for k in self.ruleInfos! {
                tmp.append(k.toMap())
            }
            map["ruleInfos"] = tmp
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["ruleInfos"] as? [Any?] {
            var tmp : [CreatePushRuleRequest.RuleInfos] = []
            for v in value {
                if v != nil {
                    var model = CreatePushRuleRequest.RuleInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ruleInfos = tmp
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CreatePushRuleResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class RuleInfos : Tea.TeaModel {
            public var checkerName: String?

            public var checkerType: String?

            public var extraMessage: String?

            public var fileRuleRegexes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkerName != nil {
                    map["checkerName"] = self.checkerName!
                }
                if self.checkerType != nil {
                    map["checkerType"] = self.checkerType!
                }
                if self.extraMessage != nil {
                    map["extraMessage"] = self.extraMessage!
                }
                if self.fileRuleRegexes != nil {
                    map["fileRuleRegexes"] = self.fileRuleRegexes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["checkerName"] as? String {
                    self.checkerName = value
                }
                if let value = dict["checkerType"] as? String {
                    self.checkerType = value
                }
                if let value = dict["extraMessage"] as? String {
                    self.extraMessage = value
                }
                if let value = dict["fileRuleRegexes"] as? [String] {
                    self.fileRuleRegexes = value
                }
            }
        }
        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var ruleInfos: [CreatePushRuleResponseBody.Result.RuleInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleInfos != nil {
                var tmp : [Any] = []
                for k in self.ruleInfos! {
                    tmp.append(k.toMap())
                }
                map["ruleInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["gmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ruleInfos"] as? [Any?] {
                var tmp : [CreatePushRuleResponseBody.Result.RuleInfos] = []
                for v in value {
                    if v != nil {
                        var model = CreatePushRuleResponseBody.Result.RuleInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ruleInfos = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreatePushRuleResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreatePushRuleResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreatePushRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePushRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePushRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRepositoryRequest : Tea.TeaModel {
    public var accessToken: String?

    public var avatarUrl: String?

    public var description_: String?

    public var gitignoreType: String?

    public var importAccount: String?

    public var importDemoProject: Bool?

    public var importRepoType: String?

    public var importToken: String?

    public var importTokenEncrypted: String?

    public var importUrl: String?

    public var initStandardService: Bool?

    public var isCryptoEnabled: Bool?

    public var localImportUrl: String?

    public var name: String?

    public var namespaceId: Int64?

    public var path: String?

    public var readmeType: String?

    public var visibilityLevel: Int32?

    public var createParentPath: Bool?

    public var organizationId: String?

    public var sync: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.avatarUrl != nil {
            map["avatarUrl"] = self.avatarUrl!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.gitignoreType != nil {
            map["gitignoreType"] = self.gitignoreType!
        }
        if self.importAccount != nil {
            map["importAccount"] = self.importAccount!
        }
        if self.importDemoProject != nil {
            map["importDemoProject"] = self.importDemoProject!
        }
        if self.importRepoType != nil {
            map["importRepoType"] = self.importRepoType!
        }
        if self.importToken != nil {
            map["importToken"] = self.importToken!
        }
        if self.importTokenEncrypted != nil {
            map["importTokenEncrypted"] = self.importTokenEncrypted!
        }
        if self.importUrl != nil {
            map["importUrl"] = self.importUrl!
        }
        if self.initStandardService != nil {
            map["initStandardService"] = self.initStandardService!
        }
        if self.isCryptoEnabled != nil {
            map["isCryptoEnabled"] = self.isCryptoEnabled!
        }
        if self.localImportUrl != nil {
            map["localImportUrl"] = self.localImportUrl!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.namespaceId != nil {
            map["namespaceId"] = self.namespaceId!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.readmeType != nil {
            map["readmeType"] = self.readmeType!
        }
        if self.visibilityLevel != nil {
            map["visibilityLevel"] = self.visibilityLevel!
        }
        if self.createParentPath != nil {
            map["createParentPath"] = self.createParentPath!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.sync != nil {
            map["sync"] = self.sync!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["avatarUrl"] as? String {
            self.avatarUrl = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["gitignoreType"] as? String {
            self.gitignoreType = value
        }
        if let value = dict["importAccount"] as? String {
            self.importAccount = value
        }
        if let value = dict["importDemoProject"] as? Bool {
            self.importDemoProject = value
        }
        if let value = dict["importRepoType"] as? String {
            self.importRepoType = value
        }
        if let value = dict["importToken"] as? String {
            self.importToken = value
        }
        if let value = dict["importTokenEncrypted"] as? String {
            self.importTokenEncrypted = value
        }
        if let value = dict["importUrl"] as? String {
            self.importUrl = value
        }
        if let value = dict["initStandardService"] as? Bool {
            self.initStandardService = value
        }
        if let value = dict["isCryptoEnabled"] as? Bool {
            self.isCryptoEnabled = value
        }
        if let value = dict["localImportUrl"] as? String {
            self.localImportUrl = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["namespaceId"] as? Int64 {
            self.namespaceId = value
        }
        if let value = dict["path"] as? String {
            self.path = value
        }
        if let value = dict["readmeType"] as? String {
            self.readmeType = value
        }
        if let value = dict["visibilityLevel"] as? Int32 {
            self.visibilityLevel = value
        }
        if let value = dict["createParentPath"] as? Bool {
            self.createParentPath = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["sync"] as? Bool {
            self.sync = value
        }
    }
}

public class CreateRepositoryResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Namespace : Tea.TeaModel {
            public var avatar: String?

            public var createdAt: String?

            public var description_: String?

            public var id: Int64?

            public var name: String?

            public var ownerId: Int64?

            public var path: String?

            public var public_: Bool?

            public var updatedAt: String?

            public var visibilityLevel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.ownerId != nil {
                    map["ownerId"] = self.ownerId!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.public_ != nil {
                    map["public"] = self.public_!
                }
                if self.updatedAt != nil {
                    map["updatedAt"] = self.updatedAt!
                }
                if self.visibilityLevel != nil {
                    map["visibilityLevel"] = self.visibilityLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatar"] as? String {
                    self.avatar = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["description"] as? String {
                    self.description_ = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["ownerId"] as? Int64 {
                    self.ownerId = value
                }
                if let value = dict["path"] as? String {
                    self.path = value
                }
                if let value = dict["public"] as? Bool {
                    self.public_ = value
                }
                if let value = dict["updatedAt"] as? String {
                    self.updatedAt = value
                }
                if let value = dict["visibilityLevel"] as? String {
                    self.visibilityLevel = value
                }
            }
        }
        public var importFromSvn: Bool?

        public var archived: Bool?

        public var avatarUrl: String?

        public var createdAt: String?

        public var creatorId: Int64?

        public var defaultBranch: String?

        public var demoProject: Bool?

        public var description_: String?

        public var httpUrlToRepo: String?

        public var id: Int64?

        public var lastActivityAt: String?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespace: CreateRepositoryResponseBody.Result.Namespace?

        public var path: String?

        public var pathWithNamespace: String?

        public var sshUrlToRepo: String?

        public var visibilityLevel: String?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.namespace?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.importFromSvn != nil {
                map["Import_from_svn"] = self.importFromSvn!
            }
            if self.archived != nil {
                map["archived"] = self.archived!
            }
            if self.avatarUrl != nil {
                map["avatar_url"] = self.avatarUrl!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.defaultBranch != nil {
                map["defaultBranch"] = self.defaultBranch!
            }
            if self.demoProject != nil {
                map["demoProject"] = self.demoProject!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.httpUrlToRepo != nil {
                map["httpUrlToRepo"] = self.httpUrlToRepo!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespace != nil {
                map["namespace"] = self.namespace?.toMap()
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.sshUrlToRepo != nil {
                map["sshUrlToRepo"] = self.sshUrlToRepo!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Import_from_svn"] as? Bool {
                self.importFromSvn = value
            }
            if let value = dict["archived"] as? Bool {
                self.archived = value
            }
            if let value = dict["avatar_url"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["creatorId"] as? Int64 {
                self.creatorId = value
            }
            if let value = dict["defaultBranch"] as? String {
                self.defaultBranch = value
            }
            if let value = dict["demoProject"] as? Bool {
                self.demoProject = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["httpUrlToRepo"] as? String {
                self.httpUrlToRepo = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["lastActivityAt"] as? String {
                self.lastActivityAt = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["namespace"] as? [String: Any?] {
                var model = CreateRepositoryResponseBody.Result.Namespace()
                model.fromMap(value)
                self.namespace = model
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["pathWithNamespace"] as? String {
                self.pathWithNamespace = value
            }
            if let value = dict["sshUrlToRepo"] as? String {
                self.sshUrlToRepo = value
            }
            if let value = dict["visibilityLevel"] as? String {
                self.visibilityLevel = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateRepositoryResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateRepositoryResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRepositoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRepositoryGroupRequest : Tea.TeaModel {
    public var accessToken: String?

    public var avatarUrl: String?

    public var description_: String?

    public var name: String?

    public var parentId: Int64?

    public var path: String?

    public var visibilityLevel: Int32?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.avatarUrl != nil {
            map["avatarUrl"] = self.avatarUrl!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.parentId != nil {
            map["parentId"] = self.parentId!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.visibilityLevel != nil {
            map["visibilityLevel"] = self.visibilityLevel!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["avatarUrl"] as? String {
            self.avatarUrl = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["parentId"] as? Int64 {
            self.parentId = value
        }
        if let value = dict["path"] as? String {
            self.path = value
        }
        if let value = dict["visibilityLevel"] as? Int32 {
            self.visibilityLevel = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CreateRepositoryGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var avatarUrl: String?

        public var description_: String?

        public var id: Int64?

        public var name: String?

        public var nameWithNamespace: String?

        public var ownerId: Int64?

        public var parentId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var type: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["ownerId"] as? Int64 {
                self.ownerId = value
            }
            if let value = dict["parentId"] as? Int64 {
                self.parentId = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["pathWithNamespace"] as? String {
                self.pathWithNamespace = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["visibilityLevel"] as? Int32 {
                self.visibilityLevel = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateRepositoryGroupResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateRepositoryGroupResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateRepositoryGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRepositoryGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRepositoryGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateResourceMemberRequest : Tea.TeaModel {
    public var accountId: String?

    public var roleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        if self.roleName != nil {
            map["roleName"] = self.roleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accountId"] as? String {
            self.accountId = value
        }
        if let value = dict["roleName"] as? String {
            self.roleName = value
        }
    }
}

public class CreateResourceMemberResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateResourceMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateResourceMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateResourceMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateServiceAuthRequest : Tea.TeaModel {
    public var serviceAuthType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serviceAuthType != nil {
            map["serviceAuthType"] = self.serviceAuthType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["serviceAuthType"] as? String {
            self.serviceAuthType = value
        }
    }
}

public class CreateServiceAuthResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var id: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["id"] as? String {
            self.id = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateServiceAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateServiceAuthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateServiceConnectionRequest : Tea.TeaModel {
    public var authType: String?

    public var connectionName: String?

    public var connectionType: String?

    public var scope: String?

    public var serviceAuthId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authType != nil {
            map["authType"] = self.authType!
        }
        if self.connectionName != nil {
            map["connectionName"] = self.connectionName!
        }
        if self.connectionType != nil {
            map["connectionType"] = self.connectionType!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.serviceAuthId != nil {
            map["serviceAuthId"] = self.serviceAuthId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["authType"] as? String {
            self.authType = value
        }
        if let value = dict["connectionName"] as? String {
            self.connectionName = value
        }
        if let value = dict["connectionType"] as? String {
            self.connectionType = value
        }
        if let value = dict["scope"] as? String {
            self.scope = value
        }
        if let value = dict["serviceAuthId"] as? Int64 {
            self.serviceAuthId = value
        }
    }
}

public class CreateServiceConnectionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var id: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["id"] as? Int64 {
            self.id = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateServiceConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateServiceConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateServiceCredentialRequest : Tea.TeaModel {
    public var name: String?

    public var password: String?

    public var scope: String?

    public var type: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.username != nil {
            map["username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["password"] as? String {
            self.password = value
        }
        if let value = dict["scope"] as? String {
            self.scope = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
        if let value = dict["username"] as? String {
            self.username = value
        }
    }
}

public class CreateServiceCredentialResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var id: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["id"] as? Int64 {
            self.id = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateServiceCredentialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceCredentialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateServiceCredentialResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSprintRequest : Tea.TeaModel {
    public var endDate: String?

    public var name: String?

    public var spaceIdentifier: String?

    public var staffIds: [String]?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.staffIds != nil {
            map["staffIds"] = self.staffIds!
        }
        if self.startDate != nil {
            map["startDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endDate"] as? String {
            self.endDate = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["spaceIdentifier"] as? String {
            self.spaceIdentifier = value
        }
        if let value = dict["staffIds"] as? [String] {
            self.staffIds = value
        }
        if let value = dict["startDate"] as? String {
            self.startDate = value
        }
    }
}

public class CreateSprintResponseBody : Tea.TeaModel {
    public class Sprint : Tea.TeaModel {
        public var creator: String?

        public var description_: String?

        public var endDate: Int64?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var scope: String?

        public var spaceIdentifier: String?

        public var startDate: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endDate != nil {
                map["endDate"] = self.endDate!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.startDate != nil {
                map["startDate"] = self.startDate!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["endDate"] as? Int64 {
                self.endDate = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["scope"] as? String {
                self.scope = value
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["startDate"] as? Int64 {
                self.startDate = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var sprint: CreateSprintResponseBody.Sprint?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sprint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.sprint != nil {
            map["sprint"] = self.sprint?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["sprint"] as? [String: Any?] {
            var model = CreateSprintResponseBody.Sprint()
            model.fromMap(value)
            self.sprint = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateSprintResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSprintResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSprintResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSshKeyResponseBody : Tea.TeaModel {
    public class SshKey : Tea.TeaModel {
        public var id: Int64?

        public var publicKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.publicKey != nil {
                map["publicKey"] = self.publicKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["publicKey"] as? String {
                self.publicKey = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sshKey: CreateSshKeyResponseBody.SshKey?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sshKey?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.sshKey != nil {
            map["sshKey"] = self.sshKey?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["sshKey"] as? [String: Any?] {
            var model = CreateSshKeyResponseBody.SshKey()
            model.fromMap(value)
            self.sshKey = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateSshKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSshKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSshKeyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateTagRequest : Tea.TeaModel {
    public var accessToken: String?

    public var message: String?

    public var ref: String?

    public var tagName: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.ref != nil {
            map["ref"] = self.ref!
        }
        if self.tagName != nil {
            map["tagName"] = self.tagName!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["message"] as? String {
            self.message = value
        }
        if let value = dict["ref"] as? String {
            self.ref = value
        }
        if let value = dict["tagName"] as? String {
            self.tagName = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CreateTagResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var committedDate: String?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["authorEmail"] as? String {
                    self.authorEmail = value
                }
                if let value = dict["authorName"] as? String {
                    self.authorName = value
                }
                if let value = dict["authoredDate"] as? String {
                    self.authoredDate = value
                }
                if let value = dict["committedDate"] as? String {
                    self.committedDate = value
                }
                if let value = dict["committerEmail"] as? String {
                    self.committerEmail = value
                }
                if let value = dict["committerName"] as? String {
                    self.committerName = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["parentIds"] as? [String] {
                    self.parentIds = value
                }
                if let value = dict["shortId"] as? String {
                    self.shortId = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public var commit: CreateTagResponseBody.Result.Commit?

        public var id: String?

        public var message: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["commit"] as? [String: Any?] {
                var model = CreateTagResponseBody.Result.Commit()
                model.fromMap(value)
                self.commit = model
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["message"] as? String {
                self.message = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateTagResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateTagResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateTagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateTestCaseRequest : Tea.TeaModel {
    public class FieldValueList : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fieldIdentifier"] as? String {
                self.fieldIdentifier = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public class TestcaseStepContentInfo : Tea.TeaModel {
        public class StepResultList : Tea.TeaModel {
            public var expected: String?

            public var step: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expected != nil {
                    map["expected"] = self.expected!
                }
                if self.step != nil {
                    map["step"] = self.step!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["expected"] as? String {
                    self.expected = value
                }
                if let value = dict["step"] as? String {
                    self.step = value
                }
            }
        }
        public var precondition: String?

        public var stepResultList: [CreateTestCaseRequest.TestcaseStepContentInfo.StepResultList]?

        public var stepType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.precondition != nil {
                map["precondition"] = self.precondition!
            }
            if self.stepResultList != nil {
                var tmp : [Any] = []
                for k in self.stepResultList! {
                    tmp.append(k.toMap())
                }
                map["stepResultList"] = tmp
            }
            if self.stepType != nil {
                map["stepType"] = self.stepType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["precondition"] as? String {
                self.precondition = value
            }
            if let value = dict["stepResultList"] as? [Any?] {
                var tmp : [CreateTestCaseRequest.TestcaseStepContentInfo.StepResultList] = []
                for v in value {
                    if v != nil {
                        var model = CreateTestCaseRequest.TestcaseStepContentInfo.StepResultList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.stepResultList = tmp
            }
            if let value = dict["stepType"] as? String {
                self.stepType = value
            }
        }
    }
    public var assignedTo: String?

    public var directoryIdentifier: String?

    public var fieldValueList: [CreateTestCaseRequest.FieldValueList]?

    public var priority: String?

    public var spaceIdentifier: String?

    public var subject: String?

    public var tags: [String]?

    public var testcaseStepContentInfo: CreateTestCaseRequest.TestcaseStepContentInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.testcaseStepContentInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedTo != nil {
            map["assignedTo"] = self.assignedTo!
        }
        if self.directoryIdentifier != nil {
            map["directoryIdentifier"] = self.directoryIdentifier!
        }
        if self.fieldValueList != nil {
            var tmp : [Any] = []
            for k in self.fieldValueList! {
                tmp.append(k.toMap())
            }
            map["fieldValueList"] = tmp
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        if self.testcaseStepContentInfo != nil {
            map["testcaseStepContentInfo"] = self.testcaseStepContentInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["assignedTo"] as? String {
            self.assignedTo = value
        }
        if let value = dict["directoryIdentifier"] as? String {
            self.directoryIdentifier = value
        }
        if let value = dict["fieldValueList"] as? [Any?] {
            var tmp : [CreateTestCaseRequest.FieldValueList] = []
            for v in value {
                if v != nil {
                    var model = CreateTestCaseRequest.FieldValueList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.fieldValueList = tmp
        }
        if let value = dict["priority"] as? String {
            self.priority = value
        }
        if let value = dict["spaceIdentifier"] as? String {
            self.spaceIdentifier = value
        }
        if let value = dict["subject"] as? String {
            self.subject = value
        }
        if let value = dict["tags"] as? [String] {
            self.tags = value
        }
        if let value = dict["testcaseStepContentInfo"] as? [String: Any?] {
            var model = CreateTestCaseRequest.TestcaseStepContentInfo()
            model.fromMap(value)
            self.testcaseStepContentInfo = model
        }
    }
}

public class CreateTestCaseResponseBody : Tea.TeaModel {
    public class Testcase : Tea.TeaModel {
        public class AssignedTo : Tea.TeaModel {
            public var assignIdentifier: String?

            public var name: String?

            public var tbRoleId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assignIdentifier != nil {
                    map["assignIdentifier"] = self.assignIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.tbRoleId != nil {
                    map["tbRoleId"] = self.tbRoleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["assignIdentifier"] as? String {
                    self.assignIdentifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["tbRoleId"] as? String {
                    self.tbRoleId = value
                }
            }
        }
        public class Creator : Tea.TeaModel {
            public var createIdentifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createIdentifier != nil {
                    map["createIdentifier"] = self.createIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["createIdentifier"] as? String {
                    self.createIdentifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public class DetailInfo : Tea.TeaModel {
            public class ExpectedResult : Tea.TeaModel {
                public var expectContent: String?

                public var expectContentType: String?

                public var expectIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expectContent != nil {
                        map["expectContent"] = self.expectContent!
                    }
                    if self.expectContentType != nil {
                        map["expectContentType"] = self.expectContentType!
                    }
                    if self.expectIdentifier != nil {
                        map["expectIdentifier"] = self.expectIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["expectContent"] as? String {
                        self.expectContent = value
                    }
                    if let value = dict["expectContentType"] as? String {
                        self.expectContentType = value
                    }
                    if let value = dict["expectIdentifier"] as? String {
                        self.expectIdentifier = value
                    }
                }
            }
            public class Precondition : Tea.TeaModel {
                public var preContent: String?

                public var preContentType: String?

                public var preIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.preContent != nil {
                        map["preContent"] = self.preContent!
                    }
                    if self.preContentType != nil {
                        map["preContentType"] = self.preContentType!
                    }
                    if self.preIdentifier != nil {
                        map["preIdentifier"] = self.preIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["preContent"] as? String {
                        self.preContent = value
                    }
                    if let value = dict["preContentType"] as? String {
                        self.preContentType = value
                    }
                    if let value = dict["preIdentifier"] as? String {
                        self.preIdentifier = value
                    }
                }
            }
            public class StepContent : Tea.TeaModel {
                public var stepContent: String?

                public var stepContentType: String?

                public var stepIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.stepContent != nil {
                        map["stepContent"] = self.stepContent!
                    }
                    if self.stepContentType != nil {
                        map["stepContentType"] = self.stepContentType!
                    }
                    if self.stepIdentifier != nil {
                        map["stepIdentifier"] = self.stepIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["stepContent"] as? String {
                        self.stepContent = value
                    }
                    if let value = dict["stepContentType"] as? String {
                        self.stepContentType = value
                    }
                    if let value = dict["stepIdentifier"] as? String {
                        self.stepIdentifier = value
                    }
                }
            }
            public var expectedResult: CreateTestCaseResponseBody.Testcase.DetailInfo.ExpectedResult?

            public var precondition: CreateTestCaseResponseBody.Testcase.DetailInfo.Precondition?

            public var stepContent: CreateTestCaseResponseBody.Testcase.DetailInfo.StepContent?

            public var stepType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.expectedResult?.validate()
                try self.precondition?.validate()
                try self.stepContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expectedResult != nil {
                    map["expectedResult"] = self.expectedResult?.toMap()
                }
                if self.precondition != nil {
                    map["precondition"] = self.precondition?.toMap()
                }
                if self.stepContent != nil {
                    map["stepContent"] = self.stepContent?.toMap()
                }
                if self.stepType != nil {
                    map["stepType"] = self.stepType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["expectedResult"] as? [String: Any?] {
                    var model = CreateTestCaseResponseBody.Testcase.DetailInfo.ExpectedResult()
                    model.fromMap(value)
                    self.expectedResult = model
                }
                if let value = dict["precondition"] as? [String: Any?] {
                    var model = CreateTestCaseResponseBody.Testcase.DetailInfo.Precondition()
                    model.fromMap(value)
                    self.precondition = model
                }
                if let value = dict["stepContent"] as? [String: Any?] {
                    var model = CreateTestCaseResponseBody.Testcase.DetailInfo.StepContent()
                    model.fromMap(value)
                    self.stepContent = model
                }
                if let value = dict["stepType"] as? String {
                    self.stepType = value
                }
            }
        }
        public class Directory : Tea.TeaModel {
            public var childIdentifier: String?

            public var directoryIdentifier: String?

            public var name: String?

            public var pathName: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.childIdentifier != nil {
                    map["childIdentifier"] = self.childIdentifier!
                }
                if self.directoryIdentifier != nil {
                    map["directoryIdentifier"] = self.directoryIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.pathName != nil {
                    map["pathName"] = self.pathName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["childIdentifier"] as? String {
                    self.childIdentifier = value
                }
                if let value = dict["directoryIdentifier"] as? String {
                    self.directoryIdentifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["pathName"] as? [String] {
                    self.pathName = value
                }
            }
        }
        public class Modifier : Tea.TeaModel {
            public var modifyIdentifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.modifyIdentifier != nil {
                    map["modifyIdentifier"] = self.modifyIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["modifyIdentifier"] as? String {
                    self.modifyIdentifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public var assignedTo: CreateTestCaseResponseBody.Testcase.AssignedTo?

        public var categoryIdentifier: String?

        public var creator: CreateTestCaseResponseBody.Testcase.Creator?

        public var detailInfo: CreateTestCaseResponseBody.Testcase.DetailInfo?

        public var directory: CreateTestCaseResponseBody.Testcase.Directory?

        public var identifier: String?

        public var modifier: CreateTestCaseResponseBody.Testcase.Modifier?

        public var spaceIdentifier: String?

        public var spaceType: String?

        public var subject: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.assignedTo?.validate()
            try self.creator?.validate()
            try self.detailInfo?.validate()
            try self.directory?.validate()
            try self.modifier?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo?.toMap()
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator?.toMap()
            }
            if self.detailInfo != nil {
                map["detailInfo"] = self.detailInfo?.toMap()
            }
            if self.directory != nil {
                map["directory"] = self.directory?.toMap()
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier?.toMap()
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedTo"] as? [String: Any?] {
                var model = CreateTestCaseResponseBody.Testcase.AssignedTo()
                model.fromMap(value)
                self.assignedTo = model
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? [String: Any?] {
                var model = CreateTestCaseResponseBody.Testcase.Creator()
                model.fromMap(value)
                self.creator = model
            }
            if let value = dict["detailInfo"] as? [String: Any?] {
                var model = CreateTestCaseResponseBody.Testcase.DetailInfo()
                model.fromMap(value)
                self.detailInfo = model
            }
            if let value = dict["directory"] as? [String: Any?] {
                var model = CreateTestCaseResponseBody.Testcase.Directory()
                model.fromMap(value)
                self.directory = model
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["modifier"] as? [String: Any?] {
                var model = CreateTestCaseResponseBody.Testcase.Modifier()
                model.fromMap(value)
                self.modifier = model
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["spaceType"] as? String {
                self.spaceType = value
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var testcase: CreateTestCaseResponseBody.Testcase?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.testcase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.testcase != nil {
            map["testcase"] = self.testcase?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["testcase"] as? [String: Any?] {
            var model = CreateTestCaseResponseBody.Testcase()
            model.fromMap(value)
            self.testcase = model
        }
    }
}

public class CreateTestCaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTestCaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateTestCaseResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateUserKeyRequest : Tea.TeaModel {
    public var accessToken: String?

    public var expireTime: String?

    public var keyScope: String?

    public var publicKey: String?

    public var title: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.expireTime != nil {
            map["expireTime"] = self.expireTime!
        }
        if self.keyScope != nil {
            map["keyScope"] = self.keyScope!
        }
        if self.publicKey != nil {
            map["publicKey"] = self.publicKey!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["expireTime"] as? String {
            self.expireTime = value
        }
        if let value = dict["keyScope"] as? String {
            self.keyScope = value
        }
        if let value = dict["publicKey"] as? String {
            self.publicKey = value
        }
        if let value = dict["title"] as? String {
            self.title = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class CreateUserKeyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var expireTime: String?

        public var fingerPrint: String?

        public var id: Int64?

        public var keyScope: String?

        public var lastUsedTime: String?

        public var publicKey: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.expireTime != nil {
                map["expireTime"] = self.expireTime!
            }
            if self.fingerPrint != nil {
                map["fingerPrint"] = self.fingerPrint!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.keyScope != nil {
                map["keyScope"] = self.keyScope!
            }
            if self.lastUsedTime != nil {
                map["lastUsedTime"] = self.lastUsedTime!
            }
            if self.publicKey != nil {
                map["publicKey"] = self.publicKey!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["expireTime"] as? String {
                self.expireTime = value
            }
            if let value = dict["fingerPrint"] as? String {
                self.fingerPrint = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["keyScope"] as? String {
                self.keyScope = value
            }
            if let value = dict["lastUsedTime"] as? String {
                self.lastUsedTime = value
            }
            if let value = dict["publicKey"] as? String {
                self.publicKey = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateUserKeyResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = CreateUserKeyResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateUserKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUserKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateUserKeyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVariableGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var variables: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.variables != nil {
            map["variables"] = self.variables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["variables"] as? String {
            self.variables = value
        }
    }
}

public class CreateVariableGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var variableGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.variableGroupId != nil {
            map["variableGroupId"] = self.variableGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["variableGroupId"] as? Int64 {
            self.variableGroupId = value
        }
    }
}

public class CreateVariableGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVariableGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVariableGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateWorkitemRequest : Tea.TeaModel {
    public class FieldValueList : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var value: String?

        public var workitemIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            if self.workitemIdentifier != nil {
                map["workitemIdentifier"] = self.workitemIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fieldIdentifier"] as? String {
                self.fieldIdentifier = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
            if let value = dict["workitemIdentifier"] as? String {
                self.workitemIdentifier = value
            }
        }
    }
    public var assignedTo: String?

    public var category: String?

    public var description_: String?

    public var descriptionFormat: String?

    public var fieldValueList: [CreateWorkitemRequest.FieldValueList]?

    public var parent: String?

    public var participant: [String]?

    public var space: String?

    public var spaceIdentifier: String?

    public var spaceType: String?

    public var sprint: [String]?

    public var subject: String?

    public var tracker: [String]?

    public var verifier: [String]?

    public var workitemType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedTo != nil {
            map["assignedTo"] = self.assignedTo!
        }
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.descriptionFormat != nil {
            map["descriptionFormat"] = self.descriptionFormat!
        }
        if self.fieldValueList != nil {
            var tmp : [Any] = []
            for k in self.fieldValueList! {
                tmp.append(k.toMap())
            }
            map["fieldValueList"] = tmp
        }
        if self.parent != nil {
            map["parent"] = self.parent!
        }
        if self.participant != nil {
            map["participant"] = self.participant!
        }
        if self.space != nil {
            map["space"] = self.space!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        if self.sprint != nil {
            map["sprint"] = self.sprint!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.tracker != nil {
            map["tracker"] = self.tracker!
        }
        if self.verifier != nil {
            map["verifier"] = self.verifier!
        }
        if self.workitemType != nil {
            map["workitemType"] = self.workitemType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["assignedTo"] as? String {
            self.assignedTo = value
        }
        if let value = dict["category"] as? String {
            self.category = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["descriptionFormat"] as? String {
            self.descriptionFormat = value
        }
        if let value = dict["fieldValueList"] as? [Any?] {
            var tmp : [CreateWorkitemRequest.FieldValueList] = []
            for v in value {
                if v != nil {
                    var model = CreateWorkitemRequest.FieldValueList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.fieldValueList = tmp
        }
        if let value = dict["parent"] as? String {
            self.parent = value
        }
        if let value = dict["participant"] as? [String] {
            self.participant = value
        }
        if let value = dict["space"] as? String {
            self.space = value
        }
        if let value = dict["spaceIdentifier"] as? String {
            self.spaceIdentifier = value
        }
        if let value = dict["spaceType"] as? String {
            self.spaceType = value
        }
        if let value = dict["sprint"] as? [String] {
            self.sprint = value
        }
        if let value = dict["subject"] as? String {
            self.subject = value
        }
        if let value = dict["tracker"] as? [String] {
            self.tracker = value
        }
        if let value = dict["verifier"] as? [String] {
            self.verifier = value
        }
        if let value = dict["workitemType"] as? String {
            self.workitemType = value
        }
    }
}

public class CreateWorkitemResponseBody : Tea.TeaModel {
    public class Workitem : Tea.TeaModel {
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var document: String?

        public var documentFormat: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var parentIdentifier: String?

        public var serialNumber: String?

        public var spaceIdentifier: String?

        public var spaceName: String?

        public var spaceType: String?

        public var sprintIdentifier: String?

        public var status: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subject: String?

        public var updateStatusAt: Int64?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.document != nil {
                map["document"] = self.document!
            }
            if self.documentFormat != nil {
                map["documentFormat"] = self.documentFormat!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceName != nil {
                map["spaceName"] = self.spaceName!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.sprintIdentifier != nil {
                map["sprintIdentifier"] = self.sprintIdentifier!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.updateStatusAt != nil {
                map["updateStatusAt"] = self.updateStatusAt!
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedTo"] as? String {
                self.assignedTo = value
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["document"] as? String {
                self.document = value
            }
            if let value = dict["documentFormat"] as? String {
                self.documentFormat = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["logicalStatus"] as? String {
                self.logicalStatus = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["parentIdentifier"] as? String {
                self.parentIdentifier = value
            }
            if let value = dict["serialNumber"] as? String {
                self.serialNumber = value
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["spaceName"] as? String {
                self.spaceName = value
            }
            if let value = dict["spaceType"] as? String {
                self.spaceType = value
            }
            if let value = dict["sprintIdentifier"] as? String {
                self.sprintIdentifier = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["statusIdentifier"] as? String {
                self.statusIdentifier = value
            }
            if let value = dict["statusStageIdentifier"] as? String {
                self.statusStageIdentifier = value
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
            if let value = dict["updateStatusAt"] as? Int64 {
                self.updateStatusAt = value
            }
            if let value = dict["workitemTypeIdentifier"] as? String {
                self.workitemTypeIdentifier = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var workitem: CreateWorkitemResponseBody.Workitem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitem != nil {
            map["workitem"] = self.workitem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["workitem"] as? [String: Any?] {
            var model = CreateWorkitemResponseBody.Workitem()
            model.fromMap(value)
            self.workitem = model
        }
    }
}

public class CreateWorkitemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkitemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateWorkitemResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateWorkitemCommentRequest : Tea.TeaModel {
    public var content: String?

    public var formatType: String?

    public var parentId: String?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.formatType != nil {
            map["formatType"] = self.formatType!
        }
        if self.parentId != nil {
            map["parentId"] = self.parentId!
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["content"] as? String {
            self.content = value
        }
        if let value = dict["formatType"] as? String {
            self.formatType = value
        }
        if let value = dict["parentId"] as? String {
            self.parentId = value
        }
        if let value = dict["workitemIdentifier"] as? String {
            self.workitemIdentifier = value
        }
    }
}

public class CreateWorkitemCommentResponseBody : Tea.TeaModel {
    public class Comment : Tea.TeaModel {
        public class User : Tea.TeaModel {
            public var account: String?

            public var avatar: String?

            public var displayName: String?

            public var identifier: String?

            public var nickName: String?

            public var realName: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["account"] = self.account!
                }
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.nickName != nil {
                    map["nickName"] = self.nickName!
                }
                if self.realName != nil {
                    map["realName"] = self.realName!
                }
                if self.targetType != nil {
                    map["targetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["account"] as? String {
                    self.account = value
                }
                if let value = dict["avatar"] as? String {
                    self.avatar = value
                }
                if let value = dict["displayName"] as? String {
                    self.displayName = value
                }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["nickName"] as? String {
                    self.nickName = value
                }
                if let value = dict["realName"] as? String {
                    self.realName = value
                }
                if let value = dict["targetType"] as? String {
                    self.targetType = value
                }
            }
        }
        public var id: Int64?

        public var content: String?

        public var createTime: Int64?

        public var formatType: String?

        public var isTop: Bool?

        public var modifiedTime: Int64?

        public var parentId: Int64?

        public var targetIdentifier: String?

        public var targetType: String?

        public var topTime: Int64?

        public var user: CreateWorkitemCommentResponseBody.Comment.User?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.user?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.formatType != nil {
                map["formatType"] = self.formatType!
            }
            if self.isTop != nil {
                map["isTop"] = self.isTop!
            }
            if self.modifiedTime != nil {
                map["modifiedTime"] = self.modifiedTime!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.targetIdentifier != nil {
                map["targetIdentifier"] = self.targetIdentifier!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.topTime != nil {
                map["topTime"] = self.topTime!
            }
            if self.user != nil {
                map["user"] = self.user?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["formatType"] as? String {
                self.formatType = value
            }
            if let value = dict["isTop"] as? Bool {
                self.isTop = value
            }
            if let value = dict["modifiedTime"] as? Int64 {
                self.modifiedTime = value
            }
            if let value = dict["parentId"] as? Int64 {
                self.parentId = value
            }
            if let value = dict["targetIdentifier"] as? String {
                self.targetIdentifier = value
            }
            if let value = dict["targetType"] as? String {
                self.targetType = value
            }
            if let value = dict["topTime"] as? Int64 {
                self.topTime = value
            }
            if let value = dict["user"] as? [String: Any?] {
                var model = CreateWorkitemCommentResponseBody.Comment.User()
                model.fromMap(value)
                self.user = model
            }
        }
    }
    public var comment: CreateWorkitemCommentResponseBody.Comment?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.comment?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Comment"] as? [String: Any?] {
            var model = CreateWorkitemCommentResponseBody.Comment()
            model.fromMap(value)
            self.comment = model
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
    }
}

public class CreateWorkitemCommentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkitemCommentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateWorkitemCommentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateWorkitemEstimateRequest : Tea.TeaModel {
    public var description_: String?

    public var recordUserIdentifier: String?

    public var spentTime: String?

    public var type: String?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.recordUserIdentifier != nil {
            map["recordUserIdentifier"] = self.recordUserIdentifier!
        }
        if self.spentTime != nil {
            map["spentTime"] = self.spentTime!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["recordUserIdentifier"] as? String {
            self.recordUserIdentifier = value
        }
        if let value = dict["spentTime"] as? String {
            self.spentTime = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
        if let value = dict["workitemIdentifier"] as? String {
            self.workitemIdentifier = value
        }
    }
}

public class CreateWorkitemEstimateResponseBody : Tea.TeaModel {
    public class WorkitemTimeEstimate : Tea.TeaModel {
        public class RecordUser : Tea.TeaModel {
            public var account: String?

            public var avatar: String?

            public var dingTalkId: String?

            public var displayName: String?

            public var displayNickName: String?

            public var displayRealName: String?

            public var email: String?

            public var gender: String?

            public var identifier: String?

            public var isDisabled: Bool?

            public var mobile: String?

            public var nameEn: String?

            public var nickName: String?

            public var nickNamePinyin: String?

            public var realName: String?

            public var realNamePinyin: String?

            public var stamp: String?

            public var tbRoleId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["account"] = self.account!
                }
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.dingTalkId != nil {
                    map["dingTalkId"] = self.dingTalkId!
                }
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.displayNickName != nil {
                    map["displayNickName"] = self.displayNickName!
                }
                if self.displayRealName != nil {
                    map["displayRealName"] = self.displayRealName!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.gender != nil {
                    map["gender"] = self.gender!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.isDisabled != nil {
                    map["isDisabled"] = self.isDisabled!
                }
                if self.mobile != nil {
                    map["mobile"] = self.mobile!
                }
                if self.nameEn != nil {
                    map["nameEn"] = self.nameEn!
                }
                if self.nickName != nil {
                    map["nickName"] = self.nickName!
                }
                if self.nickNamePinyin != nil {
                    map["nickNamePinyin"] = self.nickNamePinyin!
                }
                if self.realName != nil {
                    map["realName"] = self.realName!
                }
                if self.realNamePinyin != nil {
                    map["realNamePinyin"] = self.realNamePinyin!
                }
                if self.stamp != nil {
                    map["stamp"] = self.stamp!
                }
                if self.tbRoleId != nil {
                    map["tbRoleId"] = self.tbRoleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["account"] as? String {
                    self.account = value
                }
                if let value = dict["avatar"] as? String {
                    self.avatar = value
                }
                if let value = dict["dingTalkId"] as? String {
                    self.dingTalkId = value
                }
                if let value = dict["displayName"] as? String {
                    self.displayName = value
                }
                if let value = dict["displayNickName"] as? String {
                    self.displayNickName = value
                }
                if let value = dict["displayRealName"] as? String {
                    self.displayRealName = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["gender"] as? String {
                    self.gender = value
                }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["isDisabled"] as? Bool {
                    self.isDisabled = value
                }
                if let value = dict["mobile"] as? String {
                    self.mobile = value
                }
                if let value = dict["nameEn"] as? String {
                    self.nameEn = value
                }
                if let value = dict["nickName"] as? String {
                    self.nickName = value
                }
                if let value = dict["nickNamePinyin"] as? String {
                    self.nickNamePinyin = value
                }
                if let value = dict["realName"] as? String {
                    self.realName = value
                }
                if let value = dict["realNamePinyin"] as? String {
                    self.realNamePinyin = value
                }
                if let value = dict["stamp"] as? String {
                    self.stamp = value
                }
                if let value = dict["tbRoleId"] as? String {
                    self.tbRoleId = value
                }
            }
        }
        public var description_: String?

        public var identifier: String?

        public var recordUser: CreateWorkitemEstimateResponseBody.WorkitemTimeEstimate.RecordUser?

        public var spentTime: Int64?

        public var type: String?

        public var workitemIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordUser?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.recordUser != nil {
                map["recordUser"] = self.recordUser?.toMap()
            }
            if self.spentTime != nil {
                map["spentTime"] = self.spentTime!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.workitemIdentifier != nil {
                map["workitemIdentifier"] = self.workitemIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["recordUser"] as? [String: Any?] {
                var model = CreateWorkitemEstimateResponseBody.WorkitemTimeEstimate.RecordUser()
                model.fromMap(value)
                self.recordUser = model
            }
            if let value = dict["spentTime"] as? Int64 {
                self.spentTime = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["workitemIdentifier"] as? String {
                self.workitemIdentifier = value
            }
        }
    }
    public var workitemTimeEstimate: CreateWorkitemEstimateResponseBody.WorkitemTimeEstimate?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitemTimeEstimate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.workitemTimeEstimate != nil {
            map["WorkitemTimeEstimate"] = self.workitemTimeEstimate?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["WorkitemTimeEstimate"] as? [String: Any?] {
            var model = CreateWorkitemEstimateResponseBody.WorkitemTimeEstimate()
            model.fromMap(value)
            self.workitemTimeEstimate = model
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateWorkitemEstimateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkitemEstimateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateWorkitemEstimateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateWorkitemRecordRequest : Tea.TeaModel {
    public var actualTime: String?

    public var description_: String?

    public var gmtEnd: String?

    public var gmtStart: String?

    public var recordUserIdentifier: String?

    public var type: String?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actualTime != nil {
            map["actualTime"] = self.actualTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.gmtEnd != nil {
            map["gmtEnd"] = self.gmtEnd!
        }
        if self.gmtStart != nil {
            map["gmtStart"] = self.gmtStart!
        }
        if self.recordUserIdentifier != nil {
            map["recordUserIdentifier"] = self.recordUserIdentifier!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["actualTime"] as? String {
            self.actualTime = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["gmtEnd"] as? String {
            self.gmtEnd = value
        }
        if let value = dict["gmtStart"] as? String {
            self.gmtStart = value
        }
        if let value = dict["recordUserIdentifier"] as? String {
            self.recordUserIdentifier = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
        if let value = dict["workitemIdentifier"] as? String {
            self.workitemIdentifier = value
        }
    }
}

public class CreateWorkitemRecordResponseBody : Tea.TeaModel {
    public class WorkitemTime : Tea.TeaModel {
        public class RecordUser : Tea.TeaModel {
            public var account: String?

            public var avatar: String?

            public var dingTalkId: String?

            public var displayName: String?

            public var displayNickName: String?

            public var displayRealName: String?

            public var email: String?

            public var gender: String?

            public var identifier: String?

            public var isDisabled: Bool?

            public var mobile: String?

            public var nameEn: String?

            public var nickName: String?

            public var nickNamePinyin: String?

            public var realName: String?

            public var realNamePinyin: String?

            public var stamp: String?

            public var tbRoleId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["account"] = self.account!
                }
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.dingTalkId != nil {
                    map["dingTalkId"] = self.dingTalkId!
                }
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.displayNickName != nil {
                    map["displayNickName"] = self.displayNickName!
                }
                if self.displayRealName != nil {
                    map["displayRealName"] = self.displayRealName!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.gender != nil {
                    map["gender"] = self.gender!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.isDisabled != nil {
                    map["isDisabled"] = self.isDisabled!
                }
                if self.mobile != nil {
                    map["mobile"] = self.mobile!
                }
                if self.nameEn != nil {
                    map["nameEn"] = self.nameEn!
                }
                if self.nickName != nil {
                    map["nickName"] = self.nickName!
                }
                if self.nickNamePinyin != nil {
                    map["nickNamePinyin"] = self.nickNamePinyin!
                }
                if self.realName != nil {
                    map["realName"] = self.realName!
                }
                if self.realNamePinyin != nil {
                    map["realNamePinyin"] = self.realNamePinyin!
                }
                if self.stamp != nil {
                    map["stamp"] = self.stamp!
                }
                if self.tbRoleId != nil {
                    map["tbRoleId"] = self.tbRoleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["account"] as? String {
                    self.account = value
                }
                if let value = dict["avatar"] as? String {
                    self.avatar = value
                }
                if let value = dict["dingTalkId"] as? String {
                    self.dingTalkId = value
                }
                if let value = dict["displayName"] as? String {
                    self.displayName = value
                }
                if let value = dict["displayNickName"] as? String {
                    self.displayNickName = value
                }
                if let value = dict["displayRealName"] as? String {
                    self.displayRealName = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["gender"] as? String {
                    self.gender = value
                }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["isDisabled"] as? Bool {
                    self.isDisabled = value
                }
                if let value = dict["mobile"] as? String {
                    self.mobile = value
                }
                if let value = dict["nameEn"] as? String {
                    self.nameEn = value
                }
                if let value = dict["nickName"] as? String {
                    self.nickName = value
                }
                if let value = dict["nickNamePinyin"] as? String {
                    self.nickNamePinyin = value
                }
                if let value = dict["realName"] as? String {
                    self.realName = value
                }
                if let value = dict["realNamePinyin"] as? String {
                    self.realNamePinyin = value
                }
                if let value = dict["stamp"] as? String {
                    self.stamp = value
                }
                if let value = dict["tbRoleId"] as? String {
                    self.tbRoleId = value
                }
            }
        }
        public var actualTime: Int64?

        public var description_: String?

        public var gmtEnd: Int64?

        public var gmtStart: Int64?

        public var identifier: String?

        public var recordUser: CreateWorkitemRecordResponseBody.WorkitemTime.RecordUser?

        public var type: String?

        public var workitemIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordUser?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualTime != nil {
                map["actualTime"] = self.actualTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtEnd != nil {
                map["gmtEnd"] = self.gmtEnd!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.recordUser != nil {
                map["recordUser"] = self.recordUser?.toMap()
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.workitemIdentifier != nil {
                map["workitemIdentifier"] = self.workitemIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["actualTime"] as? Int64 {
                self.actualTime = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtEnd"] as? Int64 {
                self.gmtEnd = value
            }
            if let value = dict["gmtStart"] as? Int64 {
                self.gmtStart = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["recordUser"] as? [String: Any?] {
                var model = CreateWorkitemRecordResponseBody.WorkitemTime.RecordUser()
                model.fromMap(value)
                self.recordUser = model
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["workitemIdentifier"] as? String {
                self.workitemIdentifier = value
            }
        }
    }
    public var workitemTime: CreateWorkitemRecordResponseBody.WorkitemTime?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitemTime?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.workitemTime != nil {
            map["WorkitemTime"] = self.workitemTime?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["WorkitemTime"] as? [String: Any?] {
            var model = CreateWorkitemRecordResponseBody.WorkitemTime()
            model.fromMap(value)
            self.workitemTime = model
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateWorkitemRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkitemRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateWorkitemRecordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateWorkitemV2Request : Tea.TeaModel {
    public class FieldValueList : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fieldIdentifier"] as? String {
                self.fieldIdentifier = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public var assignedTo: String?

    public var category: String?

    public var description_: String?

    public var fieldValueList: [CreateWorkitemV2Request.FieldValueList]?

    public var parentIdentifier: String?

    public var participants: [String]?

    public var spaceIdentifier: String?

    public var sprintIdentifier: String?

    public var subject: String?

    public var tags: [String]?

    public var trackers: [String]?

    public var verifier: String?

    public var versions: [String]?

    public var workitemTypeIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedTo != nil {
            map["assignedTo"] = self.assignedTo!
        }
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.fieldValueList != nil {
            var tmp : [Any] = []
            for k in self.fieldValueList! {
                tmp.append(k.toMap())
            }
            map["fieldValueList"] = tmp
        }
        if self.parentIdentifier != nil {
            map["parentIdentifier"] = self.parentIdentifier!
        }
        if self.participants != nil {
            map["participants"] = self.participants!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.sprintIdentifier != nil {
            map["sprintIdentifier"] = self.sprintIdentifier!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        if self.trackers != nil {
            map["trackers"] = self.trackers!
        }
        if self.verifier != nil {
            map["verifier"] = self.verifier!
        }
        if self.versions != nil {
            map["versions"] = self.versions!
        }
        if self.workitemTypeIdentifier != nil {
            map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["assignedTo"] as? String {
            self.assignedTo = value
        }
        if let value = dict["category"] as? String {
            self.category = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["fieldValueList"] as? [Any?] {
            var tmp : [CreateWorkitemV2Request.FieldValueList] = []
            for v in value {
                if v != nil {
                    var model = CreateWorkitemV2Request.FieldValueList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.fieldValueList = tmp
        }
        if let value = dict["parentIdentifier"] as? String {
            self.parentIdentifier = value
        }
        if let value = dict["participants"] as? [String] {
            self.participants = value
        }
        if let value = dict["spaceIdentifier"] as? String {
            self.spaceIdentifier = value
        }
        if let value = dict["sprintIdentifier"] as? String {
            self.sprintIdentifier = value
        }
        if let value = dict["subject"] as? String {
            self.subject = value
        }
        if let value = dict["tags"] as? [String] {
            self.tags = value
        }
        if let value = dict["trackers"] as? [String] {
            self.trackers = value
        }
        if let value = dict["verifier"] as? String {
            self.verifier = value
        }
        if let value = dict["versions"] as? [String] {
            self.versions = value
        }
        if let value = dict["workitemTypeIdentifier"] as? String {
            self.workitemTypeIdentifier = value
        }
    }
}

public class CreateWorkitemV2ResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: String?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
        if let value = dict["workitemIdentifier"] as? String {
            self.workitemIdentifier = value
        }
    }
}

public class CreateWorkitemV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkitemV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateWorkitemV2ResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAppMemberRequest : Tea.TeaModel {
    public var organizationId: String?

    public var subjectId: String?

    public var subjectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.subjectId != nil {
            map["subjectId"] = self.subjectId!
        }
        if self.subjectType != nil {
            map["subjectType"] = self.subjectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["subjectId"] as? String {
            self.subjectId = value
        }
        if let value = dict["subjectType"] as? String {
            self.subjectType = value
        }
    }
}

public class DeleteAppMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class DeleteBranchRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["branchName"] as? String {
            self.branchName = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class DeleteBranchResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var branchName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["branchName"] = self.branchName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["branchName"] as? String {
                self.branchName = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteBranchResponseBody.Result?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeleteBranchResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
    }
}

public class DeleteBranchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBranchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteBranchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteFileRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var commitMessage: String?

    public var filePath: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.commitMessage != nil {
            map["commitMessage"] = self.commitMessage!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["branchName"] as? String {
            self.branchName = value
        }
        if let value = dict["commitMessage"] as? String {
            self.commitMessage = value
        }
        if let value = dict["filePath"] as? String {
            self.filePath = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class DeleteFileResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var branchName: String?

        public var filePath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["branchName"] = self.branchName!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["branchName"] as? String {
                self.branchName = value
            }
            if let value = dict["filePath"] as? String {
                self.filePath = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteFileResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeleteFileResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteFlowTagResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteFlowTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteFlowTagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteFlowTagGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteFlowTagGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowTagGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteFlowTagGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteGroupMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var aliyunPk: String?

    public var memberType: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.aliyunPk != nil {
            map["aliyunPk"] = self.aliyunPk!
        }
        if self.memberType != nil {
            map["memberType"] = self.memberType!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["aliyunPk"] as? String {
            self.aliyunPk = value
        }
        if let value = dict["memberType"] as? String {
            self.memberType = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class DeleteGroupMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var id: Int64?

        public var memberType: String?

        public var name: String?

        public var sourceId: Int64?

        public var state: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.memberType != nil {
                map["memberType"] = self.memberType!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["memberType"] as? String {
                self.memberType = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceId"] as? Int64 {
                self.sourceId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["username"] as? String {
                self.username = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteGroupMemberResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeleteGroupMemberResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteGroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteGroupMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteHostGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteHostGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHostGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteHostGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePipelineResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeletePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePipelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePipelineGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeletePipelineGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePipelineGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePipelineRelationsRequest : Tea.TeaModel {
    public var relObjectId: String?

    public var relObjectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relObjectId != nil {
            map["relObjectId"] = self.relObjectId!
        }
        if self.relObjectType != nil {
            map["relObjectType"] = self.relObjectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["relObjectId"] as? String {
            self.relObjectId = value
        }
        if let value = dict["relObjectType"] as? String {
            self.relObjectType = value
        }
    }
}

public class DeletePipelineRelationsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeletePipelineRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePipelineRelationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteProjectRequest : Tea.TeaModel {
    public var identifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["identifier"] as? String {
            self.identifier = value
        }
    }
}

public class DeleteProjectResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? Bool {
            self.result = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteProjectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteProjectLabelRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class DeleteProjectLabelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteProjectLabelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeleteProjectLabelResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteProjectLabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectLabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteProjectLabelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteProtectedBranchRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class DeleteProtectedBranchResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteProtectedBranchResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeleteProtectedBranchResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteProtectedBranchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProtectedBranchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteProtectedBranchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePushRuleRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class DeletePushRuleResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeletePushRuleResponseBody.Result?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeletePushRuleResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
    }
}

public class DeletePushRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePushRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePushRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRepositoryRequest : Tea.TeaModel {
    public var accessToken: String?

    public var reason: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.reason != nil {
            map["reason"] = self.reason!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["reason"] as? String {
            self.reason = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class DeleteRepositoryResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteRepositoryResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeleteRepositoryResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRepositoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRepositoryGroupRequest : Tea.TeaModel {
    public var accessToken: String?

    public var reason: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.reason != nil {
            map["reason"] = self.reason!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["reason"] as? String {
            self.reason = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class DeleteRepositoryGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteRepositoryGroupResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeleteRepositoryGroupResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteRepositoryGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRepositoryGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRepositoryGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRepositoryMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var memberType: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.memberType != nil {
            map["memberType"] = self.memberType!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["memberType"] as? String {
            self.memberType = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class DeleteRepositoryMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var createAt: String?

        public var id: Int64?

        public var sourceId: Int64?

        public var sourceType: String?

        public var updateAt: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.createAt != nil {
                map["createAt"] = self.createAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.updateAt != nil {
                map["updateAt"] = self.updateAt!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["createAt"] as? String {
                self.createAt = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["sourceId"] as? Int64 {
                self.sourceId = value
            }
            if let value = dict["sourceType"] as? String {
                self.sourceType = value
            }
            if let value = dict["updateAt"] as? String {
                self.updateAt = value
            }
            if let value = dict["userId"] as? Int64 {
                self.userId = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteRepositoryMemberResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeleteRepositoryMemberResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteRepositoryMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRepositoryMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRepositoryMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRepositoryWebhookRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class DeleteRepositoryWebhookResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var buildEvents: Bool?

        public var createdAt: String?

        public var description_: String?

        public var enableSslVerification: Bool?

        public var id: Int64?

        public var issuesEvents: Bool?

        public var lastTestResult: String?

        public var mergeRequestsEvents: Bool?

        public var noteEvents: Bool?

        public var projectId: Int64?

        public var pushEvents: Bool?

        public var secretToken: String?

        public var tagPushEvents: Bool?

        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.buildEvents != nil {
                map["buildEvents"] = self.buildEvents!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.enableSslVerification != nil {
                map["enableSslVerification"] = self.enableSslVerification!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.issuesEvents != nil {
                map["issuesEvents"] = self.issuesEvents!
            }
            if self.lastTestResult != nil {
                map["lastTestResult"] = self.lastTestResult!
            }
            if self.mergeRequestsEvents != nil {
                map["mergeRequestsEvents"] = self.mergeRequestsEvents!
            }
            if self.noteEvents != nil {
                map["noteEvents"] = self.noteEvents!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.pushEvents != nil {
                map["pushEvents"] = self.pushEvents!
            }
            if self.secretToken != nil {
                map["secretToken"] = self.secretToken!
            }
            if self.tagPushEvents != nil {
                map["tagPushEvents"] = self.tagPushEvents!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["buildEvents"] as? Bool {
                self.buildEvents = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["enableSslVerification"] as? Bool {
                self.enableSslVerification = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["issuesEvents"] as? Bool {
                self.issuesEvents = value
            }
            if let value = dict["lastTestResult"] as? String {
                self.lastTestResult = value
            }
            if let value = dict["mergeRequestsEvents"] as? Bool {
                self.mergeRequestsEvents = value
            }
            if let value = dict["noteEvents"] as? Bool {
                self.noteEvents = value
            }
            if let value = dict["projectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["pushEvents"] as? Bool {
                self.pushEvents = value
            }
            if let value = dict["secretToken"] as? String {
                self.secretToken = value
            }
            if let value = dict["tagPushEvents"] as? Bool {
                self.tagPushEvents = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["url"] as? String {
                self.url = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteRepositoryWebhookResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeleteRepositoryWebhookResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteRepositoryWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRepositoryWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRepositoryWebhookResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteResourceMemberResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteResourceMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteResourceMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteResourceMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteTagRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var tagName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.tagName != nil {
            map["tagName"] = self.tagName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["tagName"] as? String {
            self.tagName = value
        }
    }
}

public class DeleteTagResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var tagName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagName != nil {
                map["tagName"] = self.tagName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["tagName"] as? String {
                self.tagName = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteTagResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeleteTagResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteTagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteUserKeyRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class DeleteUserKeyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var context: String?

        public var createdAt: String?

        public var expireTime: String?

        public var fingerPrint: String?

        public var id: Int64?

        public var keyScope: String?

        public var lastUsedTime: String?

        public var publicKey: String?

        public var shaContext: String?

        public var title: String?

        public var updatedAt: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.context != nil {
                map["context"] = self.context!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.expireTime != nil {
                map["expireTime"] = self.expireTime!
            }
            if self.fingerPrint != nil {
                map["fingerPrint"] = self.fingerPrint!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.keyScope != nil {
                map["keyScope"] = self.keyScope!
            }
            if self.lastUsedTime != nil {
                map["lastUsedTime"] = self.lastUsedTime!
            }
            if self.publicKey != nil {
                map["publicKey"] = self.publicKey!
            }
            if self.shaContext != nil {
                map["shaContext"] = self.shaContext!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["context"] as? String {
                self.context = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["expireTime"] as? String {
                self.expireTime = value
            }
            if let value = dict["fingerPrint"] as? String {
                self.fingerPrint = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["keyScope"] as? String {
                self.keyScope = value
            }
            if let value = dict["lastUsedTime"] as? String {
                self.lastUsedTime = value
            }
            if let value = dict["publicKey"] as? String {
                self.publicKey = value
            }
            if let value = dict["shaContext"] as? String {
                self.shaContext = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteUserKeyResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = DeleteUserKeyResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteUserKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteUserKeyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVariableGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteVariableGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVariableGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVariableGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteWorkitemRequest : Tea.TeaModel {
    public var identifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["identifier"] as? String {
            self.identifier = value
        }
    }
}

public class DeleteWorkitemResponseBody : Tea.TeaModel {
    public var deleteFlag: Bool?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFlag != nil {
            map["deleteFlag"] = self.deleteFlag!
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["deleteFlag"] as? Bool {
            self.deleteFlag = value
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteWorkitemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkitemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteWorkitemResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteWorkitemAllCommentRequest : Tea.TeaModel {
    public var identifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["identifier"] as? String {
            self.identifier = value
        }
    }
}

public class DeleteWorkitemAllCommentResponseBody : Tea.TeaModel {
    public var deleteFlag: Bool?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFlag != nil {
            map["deleteFlag"] = self.deleteFlag!
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["deleteFlag"] as? Bool {
            self.deleteFlag = value
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
    }
}

public class DeleteWorkitemAllCommentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkitemAllCommentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteWorkitemAllCommentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteWorkitemCommentRequest : Tea.TeaModel {
    public var commentId: Int64?

    public var identifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commentId != nil {
            map["commentId"] = self.commentId!
        }
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["commentId"] as? Int64 {
            self.commentId = value
        }
        if let value = dict["identifier"] as? String {
            self.identifier = value
        }
    }
}

public class DeleteWorkitemCommentResponseBody : Tea.TeaModel {
    public var deleteFlag: Bool?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFlag != nil {
            map["deleteFlag"] = self.deleteFlag!
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["deleteFlag"] as? Bool {
            self.deleteFlag = value
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
    }
}

public class DeleteWorkitemCommentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkitemCommentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteWorkitemCommentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableDeployKeyRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class EnableDeployKeyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: EnableDeployKeyResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = EnableDeployKeyResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class EnableDeployKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableDeployKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableDeployKeyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExecuteChangeRequestReleaseStageRequest : Tea.TeaModel {
    public var params: [String: Any]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.params != nil {
            map["params"] = self.params!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["params"] as? [String: Any] {
            self.params = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ExecuteChangeRequestReleaseStageResponseBody : Tea.TeaModel {
    public var object: Int64?

    public var pipelineId: Int64?

    public var pipelineRunId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.object != nil {
            map["object"] = self.object!
        }
        if self.pipelineId != nil {
            map["pipelineId"] = self.pipelineId!
        }
        if self.pipelineRunId != nil {
            map["pipelineRunId"] = self.pipelineRunId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["object"] as? Int64 {
            self.object = value
        }
        if let value = dict["pipelineId"] as? Int64 {
            self.pipelineId = value
        }
        if let value = dict["pipelineRunId"] as? Int64 {
            self.pipelineRunId = value
        }
    }
}

public class ExecuteChangeRequestReleaseStageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteChangeRequestReleaseStageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExecuteChangeRequestReleaseStageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportInsightCustomValueRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportInsightCustomValueResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var doubleValue: Double?

        public var fieldId: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var longValue: Int64?

        public var organizationId: String?

        public var targetId: String?

        public var targetType: String?

        public var type: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.doubleValue != nil {
                map["doubleValue"] = self.doubleValue!
            }
            if self.fieldId != nil {
                map["fieldId"] = self.fieldId!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.longValue != nil {
                map["longValue"] = self.longValue!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.targetId != nil {
                map["targetId"] = self.targetId!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["doubleValue"] as? Double {
                self.doubleValue = value
            }
            if let value = dict["fieldId"] as? String {
                self.fieldId = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["isDeleted"] as? String {
                self.isDeleted = value
            }
            if let value = dict["longValue"] as? Int64 {
                self.longValue = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["targetId"] as? String {
                self.targetId = value
            }
            if let value = dict["targetType"] as? String {
                self.targetType = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightCustomValueResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportInsightCustomValueResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportInsightCustomValueResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportInsightCustomValueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightCustomValueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportInsightCustomValueResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportInsightExpectedWorkTimeRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportInsightExpectedWorkTimeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var organizationId: String?

        public var projectId: String?

        public var recorderId: String?

        public var source: String?

        public var type: String?

        public var value: Double?

        public var workitemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.recorderId != nil {
                map["recorderId"] = self.recorderId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            if self.workitemId != nil {
                map["workitemId"] = self.workitemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["isDeleted"] as? String {
                self.isDeleted = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["projectId"] as? String {
                self.projectId = value
            }
            if let value = dict["recorderId"] as? String {
                self.recorderId = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["value"] as? Double {
                self.value = value
            }
            if let value = dict["workitemId"] as? String {
                self.workitemId = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightExpectedWorkTimeResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportInsightExpectedWorkTimeResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportInsightExpectedWorkTimeResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportInsightExpectedWorkTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightExpectedWorkTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportInsightExpectedWorkTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportInsightFieldRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportInsightFieldResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fieldId: String?

        public var fieldName: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var isSystem: String?

        public var optionValue: String?

        public var organizationId: String?

        public var position: Int32?

        public var scope: String?

        public var source: String?

        public var targetId: String?

        public var targetType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldId != nil {
                map["fieldId"] = self.fieldId!
            }
            if self.fieldName != nil {
                map["fieldName"] = self.fieldName!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.isSystem != nil {
                map["isSystem"] = self.isSystem!
            }
            if self.optionValue != nil {
                map["optionValue"] = self.optionValue!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.position != nil {
                map["position"] = self.position!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.targetId != nil {
                map["targetId"] = self.targetId!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fieldId"] as? String {
                self.fieldId = value
            }
            if let value = dict["fieldName"] as? String {
                self.fieldName = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["isDeleted"] as? String {
                self.isDeleted = value
            }
            if let value = dict["isSystem"] as? String {
                self.isSystem = value
            }
            if let value = dict["optionValue"] as? String {
                self.optionValue = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["position"] as? Int32 {
                self.position = value
            }
            if let value = dict["scope"] as? String {
                self.scope = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["targetId"] as? String {
                self.targetId = value
            }
            if let value = dict["targetType"] as? String {
                self.targetType = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightFieldResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportInsightFieldResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportInsightFieldResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportInsightFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportInsightFieldResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportInsightSpaceRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportInsightSpaceResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var category: String?

        public var customCode: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var name: String?

        public var organizationId: String?

        public var source: String?

        public var stage: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["category"] = self.category!
            }
            if self.customCode != nil {
                map["customCode"] = self.customCode!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.stage != nil {
                map["stage"] = self.stage!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["category"] as? String {
                self.category = value
            }
            if let value = dict["customCode"] as? String {
                self.customCode = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["isDeleted"] as? String {
                self.isDeleted = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["stage"] as? String {
                self.stage = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightSpaceResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportInsightSpaceResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportInsightSpaceResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportInsightSpaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightSpaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportInsightSpaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportInsightSpaceRefRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportInsightSpaceRefResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var creatorId: String?

        public var fromId: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var modifierId: String?

        public var organizationId: String?

        public var toId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.fromId != nil {
                map["fromId"] = self.fromId!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.modifierId != nil {
                map["modifierId"] = self.modifierId!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.toId != nil {
                map["toId"] = self.toId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["creatorId"] as? String {
                self.creatorId = value
            }
            if let value = dict["fromId"] as? String {
                self.fromId = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["isDeleted"] as? String {
                self.isDeleted = value
            }
            if let value = dict["modifierId"] as? String {
                self.modifierId = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["toId"] as? String {
                self.toId = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightSpaceRefResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportInsightSpaceRefResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportInsightSpaceRefResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportInsightSpaceRefResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightSpaceRefResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportInsightSpaceRefResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportInsightSprintRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportInsightSprintResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var actualEnd: Int64?

        public var actualStart: Int64?

        public var gmtCreate: Int64?

        public var gmtEnd: Int64?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var name: String?

        public var organizationId: String?

        public var projectId: String?

        public var source: String?

        public var status: Int32?

        public var workTimeCapacity: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualEnd != nil {
                map["actualEnd"] = self.actualEnd!
            }
            if self.actualStart != nil {
                map["actualStart"] = self.actualStart!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtEnd != nil {
                map["gmtEnd"] = self.gmtEnd!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.workTimeCapacity != nil {
                map["workTimeCapacity"] = self.workTimeCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["actualEnd"] as? Int64 {
                self.actualEnd = value
            }
            if let value = dict["actualStart"] as? Int64 {
                self.actualStart = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtEnd"] as? Int64 {
                self.gmtEnd = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["gmtStart"] as? Int64 {
                self.gmtStart = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["isDeleted"] as? String {
                self.isDeleted = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["projectId"] as? String {
                self.projectId = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["status"] as? Int32 {
                self.status = value
            }
            if let value = dict["workTimeCapacity"] as? Double {
                self.workTimeCapacity = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightSprintResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportInsightSprintResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportInsightSprintResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportInsightSprintResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightSprintResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportInsightSprintResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportInsightTagRefRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportInsightTagRefResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var name: String?

        public var organizationId: String?

        public var tagId: String?

        public var targetId: String?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.tagId != nil {
                map["tagId"] = self.tagId!
            }
            if self.targetId != nil {
                map["targetId"] = self.targetId!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["isDeleted"] as? String {
                self.isDeleted = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["tagId"] as? String {
                self.tagId = value
            }
            if let value = dict["targetId"] as? String {
                self.targetId = value
            }
            if let value = dict["targetType"] as? String {
                self.targetType = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightTagRefResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportInsightTagRefResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportInsightTagRefResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportInsightTagRefResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightTagRefResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportInsightTagRefResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportInsightWorkTimeRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportInsightWorkTimeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var actualValue: Double?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtEnd: Int64?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var organizationId: String?

        public var projectId: String?

        public var recorderId: String?

        public var source: String?

        public var type: String?

        public var uuid: String?

        public var value: Int64?

        public var workitemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualValue != nil {
                map["actualValue"] = self.actualValue!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtEnd != nil {
                map["gmtEnd"] = self.gmtEnd!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.recorderId != nil {
                map["recorderId"] = self.recorderId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.uuid != nil {
                map["uuid"] = self.uuid!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            if self.workitemId != nil {
                map["workitemId"] = self.workitemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["actualValue"] as? Double {
                self.actualValue = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtEnd"] as? Int64 {
                self.gmtEnd = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["gmtStart"] as? Int64 {
                self.gmtStart = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["isDeleted"] as? String {
                self.isDeleted = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["projectId"] as? String {
                self.projectId = value
            }
            if let value = dict["recorderId"] as? String {
                self.recorderId = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["uuid"] as? String {
                self.uuid = value
            }
            if let value = dict["value"] as? Int64 {
                self.value = value
            }
            if let value = dict["workitemId"] as? String {
                self.workitemId = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightWorkTimeResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportInsightWorkTimeResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportInsightWorkTimeResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportInsightWorkTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightWorkTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportInsightWorkTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportInsightWorkitemStatusRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportInsightWorkitemStatusResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var assignedToId: String?

        public var creatorId: String?

        public var expectedWorkTime: Int64?

        public var gmtClosed: Int64?

        public var gmtCreate: Int64?

        public var gmtDue: Int64?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var gmtTodo: Int64?

        public var id: Int64?

        public var isArchived: String?

        public var isDeleted: String?

        public var isDone: String?

        public var organizationId: String?

        public var parentId: String?

        public var participantIds: String?

        public var phase: Int32?

        public var priority: Int32?

        public var productId: String?

        public var projectId: String?

        public var serialNumber: Int32?

        public var source: String?

        public var sprintId: String?

        public var stage: Int32?

        public var status: String?

        public var statusId: String?

        public var storyPoint: Double?

        public var subType: String?

        public var subject: String?

        public var type: Int32?

        public var versionId: String?

        public var versions: String?

        public var workTime: Int64?

        public var workitemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedToId != nil {
                map["assignedToId"] = self.assignedToId!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.expectedWorkTime != nil {
                map["expectedWorkTime"] = self.expectedWorkTime!
            }
            if self.gmtClosed != nil {
                map["gmtClosed"] = self.gmtClosed!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtDue != nil {
                map["gmtDue"] = self.gmtDue!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.gmtTodo != nil {
                map["gmtTodo"] = self.gmtTodo!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isArchived != nil {
                map["isArchived"] = self.isArchived!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.isDone != nil {
                map["isDone"] = self.isDone!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.participantIds != nil {
                map["participantIds"] = self.participantIds!
            }
            if self.phase != nil {
                map["phase"] = self.phase!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.productId != nil {
                map["productId"] = self.productId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.sprintId != nil {
                map["sprintId"] = self.sprintId!
            }
            if self.stage != nil {
                map["stage"] = self.stage!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusId != nil {
                map["statusId"] = self.statusId!
            }
            if self.storyPoint != nil {
                map["storyPoint"] = self.storyPoint!
            }
            if self.subType != nil {
                map["subType"] = self.subType!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.versionId != nil {
                map["versionId"] = self.versionId!
            }
            if self.versions != nil {
                map["versions"] = self.versions!
            }
            if self.workTime != nil {
                map["workTime"] = self.workTime!
            }
            if self.workitemId != nil {
                map["workitemId"] = self.workitemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedToId"] as? String {
                self.assignedToId = value
            }
            if let value = dict["creatorId"] as? String {
                self.creatorId = value
            }
            if let value = dict["expectedWorkTime"] as? Int64 {
                self.expectedWorkTime = value
            }
            if let value = dict["gmtClosed"] as? Int64 {
                self.gmtClosed = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtDue"] as? Int64 {
                self.gmtDue = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["gmtStart"] as? Int64 {
                self.gmtStart = value
            }
            if let value = dict["gmtTodo"] as? Int64 {
                self.gmtTodo = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["isArchived"] as? String {
                self.isArchived = value
            }
            if let value = dict["isDeleted"] as? String {
                self.isDeleted = value
            }
            if let value = dict["isDone"] as? String {
                self.isDone = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["parentId"] as? String {
                self.parentId = value
            }
            if let value = dict["participantIds"] as? String {
                self.participantIds = value
            }
            if let value = dict["phase"] as? Int32 {
                self.phase = value
            }
            if let value = dict["priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["productId"] as? String {
                self.productId = value
            }
            if let value = dict["projectId"] as? String {
                self.projectId = value
            }
            if let value = dict["serialNumber"] as? Int32 {
                self.serialNumber = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["sprintId"] as? String {
                self.sprintId = value
            }
            if let value = dict["stage"] as? Int32 {
                self.stage = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["statusId"] as? String {
                self.statusId = value
            }
            if let value = dict["storyPoint"] as? Double {
                self.storyPoint = value
            }
            if let value = dict["subType"] as? String {
                self.subType = value
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
            if let value = dict["type"] as? Int32 {
                self.type = value
            }
            if let value = dict["versionId"] as? String {
                self.versionId = value
            }
            if let value = dict["versions"] as? String {
                self.versions = value
            }
            if let value = dict["workTime"] as? Int64 {
                self.workTime = value
            }
            if let value = dict["workitemId"] as? String {
                self.workitemId = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightWorkitemStatusResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportInsightWorkitemStatusResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportInsightWorkitemStatusResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportInsightWorkitemStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightWorkitemStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportInsightWorkitemStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var assignedToId: String?

        public var creatorId: String?

        public var expectedWorkTime: Int64?

        public var extraId: Int64?

        public var extraIsDeleted: String?

        public var foundPhase: Int32?

        public var gmtClosed: Int64?

        public var gmtCreate: Int64?

        public var gmtDue: Int64?

        public var gmtFixed: String?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var gmtTodo: Int64?

        public var id: Int64?

        public var isArchived: String?

        public var isDeleted: String?

        public var isDone: String?

        public var isStupid: String?

        public var organizationId: String?

        public var parentId: String?

        public var participantIds: String?

        public var phase: Int32?

        public var priority: Int32?

        public var productId: String?

        public var projectId: String?

        public var reopenNum: Int32?

        public var serialNumber: Int32?

        public var seriousLevel: Int32?

        public var solution: String?

        public var source: String?

        public var sprintId: String?

        public var stage: Int32?

        public var status: String?

        public var statusId: String?

        public var storyPoint: Double?

        public var subType: String?

        public var subject: String?

        public var type: Int32?

        public var verifierId: String?

        public var versionId: String?

        public var versions: String?

        public var workTime: Int64?

        public var workitemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedToId != nil {
                map["assignedToId"] = self.assignedToId!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.expectedWorkTime != nil {
                map["expectedWorkTime"] = self.expectedWorkTime!
            }
            if self.extraId != nil {
                map["extraId"] = self.extraId!
            }
            if self.extraIsDeleted != nil {
                map["extraIsDeleted"] = self.extraIsDeleted!
            }
            if self.foundPhase != nil {
                map["foundPhase"] = self.foundPhase!
            }
            if self.gmtClosed != nil {
                map["gmtClosed"] = self.gmtClosed!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtDue != nil {
                map["gmtDue"] = self.gmtDue!
            }
            if self.gmtFixed != nil {
                map["gmtFixed"] = self.gmtFixed!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.gmtTodo != nil {
                map["gmtTodo"] = self.gmtTodo!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isArchived != nil {
                map["isArchived"] = self.isArchived!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.isDone != nil {
                map["isDone"] = self.isDone!
            }
            if self.isStupid != nil {
                map["isStupid"] = self.isStupid!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.participantIds != nil {
                map["participantIds"] = self.participantIds!
            }
            if self.phase != nil {
                map["phase"] = self.phase!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.productId != nil {
                map["productId"] = self.productId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.reopenNum != nil {
                map["reopenNum"] = self.reopenNum!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.seriousLevel != nil {
                map["seriousLevel"] = self.seriousLevel!
            }
            if self.solution != nil {
                map["solution"] = self.solution!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.sprintId != nil {
                map["sprintId"] = self.sprintId!
            }
            if self.stage != nil {
                map["stage"] = self.stage!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusId != nil {
                map["statusId"] = self.statusId!
            }
            if self.storyPoint != nil {
                map["storyPoint"] = self.storyPoint!
            }
            if self.subType != nil {
                map["subType"] = self.subType!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.verifierId != nil {
                map["verifierId"] = self.verifierId!
            }
            if self.versionId != nil {
                map["versionId"] = self.versionId!
            }
            if self.versions != nil {
                map["versions"] = self.versions!
            }
            if self.workTime != nil {
                map["workTime"] = self.workTime!
            }
            if self.workitemId != nil {
                map["workitemId"] = self.workitemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedToId"] as? String {
                self.assignedToId = value
            }
            if let value = dict["creatorId"] as? String {
                self.creatorId = value
            }
            if let value = dict["expectedWorkTime"] as? Int64 {
                self.expectedWorkTime = value
            }
            if let value = dict["extraId"] as? Int64 {
                self.extraId = value
            }
            if let value = dict["extraIsDeleted"] as? String {
                self.extraIsDeleted = value
            }
            if let value = dict["foundPhase"] as? Int32 {
                self.foundPhase = value
            }
            if let value = dict["gmtClosed"] as? Int64 {
                self.gmtClosed = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtDue"] as? Int64 {
                self.gmtDue = value
            }
            if let value = dict["gmtFixed"] as? String {
                self.gmtFixed = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["gmtStart"] as? Int64 {
                self.gmtStart = value
            }
            if let value = dict["gmtTodo"] as? Int64 {
                self.gmtTodo = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["isArchived"] as? String {
                self.isArchived = value
            }
            if let value = dict["isDeleted"] as? String {
                self.isDeleted = value
            }
            if let value = dict["isDone"] as? String {
                self.isDone = value
            }
            if let value = dict["isStupid"] as? String {
                self.isStupid = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["parentId"] as? String {
                self.parentId = value
            }
            if let value = dict["participantIds"] as? String {
                self.participantIds = value
            }
            if let value = dict["phase"] as? Int32 {
                self.phase = value
            }
            if let value = dict["priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["productId"] as? String {
                self.productId = value
            }
            if let value = dict["projectId"] as? String {
                self.projectId = value
            }
            if let value = dict["reopenNum"] as? Int32 {
                self.reopenNum = value
            }
            if let value = dict["serialNumber"] as? Int32 {
                self.serialNumber = value
            }
            if let value = dict["seriousLevel"] as? Int32 {
                self.seriousLevel = value
            }
            if let value = dict["solution"] as? String {
                self.solution = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["sprintId"] as? String {
                self.sprintId = value
            }
            if let value = dict["stage"] as? Int32 {
                self.stage = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["statusId"] as? String {
                self.statusId = value
            }
            if let value = dict["storyPoint"] as? Double {
                self.storyPoint = value
            }
            if let value = dict["subType"] as? String {
                self.subType = value
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
            if let value = dict["type"] as? Int32 {
                self.type = value
            }
            if let value = dict["verifierId"] as? String {
                self.verifierId = value
            }
            if let value = dict["versionId"] as? String {
                self.versionId = value
            }
            if let value = dict["versions"] as? String {
                self.versions = value
            }
            if let value = dict["workTime"] as? Int64 {
                self.workTime = value
            }
            if let value = dict["workitemId"] as? String {
                self.workitemId = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportInsightWorkitemVersionRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportInsightWorkitemVersionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var gmtPublish: Int64?

        public var gmtStart: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var lockStatus: Int32?

        public var name: String?

        public var organizationId: String?

        public var source: String?

        public var status: Int32?

        public var targetId: String?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtPublish != nil {
                map["gmtPublish"] = self.gmtPublish!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.lockStatus != nil {
                map["lockStatus"] = self.lockStatus!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.targetId != nil {
                map["targetId"] = self.targetId!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["gmtPublish"] as? Int64 {
                self.gmtPublish = value
            }
            if let value = dict["gmtStart"] as? Int64 {
                self.gmtStart = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["isDeleted"] as? String {
                self.isDeleted = value
            }
            if let value = dict["lockStatus"] as? Int32 {
                self.lockStatus = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["status"] as? Int32 {
                self.status = value
            }
            if let value = dict["targetId"] as? String {
                self.targetId = value
            }
            if let value = dict["targetType"] as? String {
                self.targetType = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightWorkitemVersionResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportInsightWorkitemVersionResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportInsightWorkitemVersionResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportInsightWorkitemVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightWorkitemVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportInsightWorkitemVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExportWorkitemActivityRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? String {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? String {
            self.startTime = value
        }
    }
}

public class ExportWorkitemActivityResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var gmtEvent: Int64?

        public var id: Int64?

        public var identifier: String?

        public var newValue: String?

        public var oldValue: String?

        public var organizationId: String?

        public var projectId: String?

        public var source: String?

        public var type: String?

        public var workitemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtEvent != nil {
                map["gmtEvent"] = self.gmtEvent!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.newValue != nil {
                map["newValue"] = self.newValue!
            }
            if self.oldValue != nil {
                map["oldValue"] = self.oldValue!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.workitemId != nil {
                map["workitemId"] = self.workitemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["gmtEvent"] as? Int64 {
                self.gmtEvent = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["newValue"] as? String {
                self.newValue = value
            }
            if let value = dict["oldValue"] as? String {
                self.oldValue = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["projectId"] as? String {
                self.projectId = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["workitemId"] as? String {
                self.workitemId = value
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportWorkitemActivityResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ExportWorkitemActivityResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ExportWorkitemActivityResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ExportWorkitemActivityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportWorkitemActivityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExportWorkitemActivityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetApplicationRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class GetApplicationResponseBody : Tea.TeaModel {
    public var appTemplateDisplayName: String?

    public var appTemplateName: String?

    public var creatorAccountId: String?

    public var description_: String?

    public var gmtCreate: String?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appTemplateDisplayName != nil {
            map["appTemplateDisplayName"] = self.appTemplateDisplayName!
        }
        if self.appTemplateName != nil {
            map["appTemplateName"] = self.appTemplateName!
        }
        if self.creatorAccountId != nil {
            map["creatorAccountId"] = self.creatorAccountId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["appTemplateDisplayName"] as? String {
            self.appTemplateDisplayName = value
        }
        if let value = dict["appTemplateName"] as? String {
            self.appTemplateName = value
        }
        if let value = dict["creatorAccountId"] as? String {
            self.creatorAccountId = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["gmtCreate"] as? String {
            self.gmtCreate = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetBranchInfoRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["branchName"] as? String {
            self.branchName = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class GetBranchInfoResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public class Author : Tea.TeaModel {
                public var avatarUrl: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var state: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avatarUrl != nil {
                        map["avatarUrl"] = self.avatarUrl!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["avatarUrl"] as? String {
                        self.avatarUrl = value
                    }
                    if let value = dict["email"] as? String {
                        self.email = value
                    }
                    if let value = dict["id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["state"] as? String {
                        self.state = value
                    }
                    if let value = dict["username"] as? String {
                        self.username = value
                    }
                }
            }
            public class Committer : Tea.TeaModel {
                public var avatarUrl: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var state: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avatarUrl != nil {
                        map["avatarUrl"] = self.avatarUrl!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["avatarUrl"] as? String {
                        self.avatarUrl = value
                    }
                    if let value = dict["email"] as? String {
                        self.email = value
                    }
                    if let value = dict["id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["state"] as? String {
                        self.state = value
                    }
                    if let value = dict["username"] as? String {
                        self.username = value
                    }
                }
            }
            public class Signature : Tea.TeaModel {
                public var gpgKeyId: String?

                public var verificationStatus: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gpgKeyId != nil {
                        map["gpgKeyId"] = self.gpgKeyId!
                    }
                    if self.verificationStatus != nil {
                        map["verificationStatus"] = self.verificationStatus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["gpgKeyId"] as? String {
                        self.gpgKeyId = value
                    }
                    if let value = dict["verificationStatus"] as? String {
                        self.verificationStatus = value
                    }
                }
            }
            public var author: GetBranchInfoResponseBody.Result.Commit.Author?

            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var commentsCount: Int64?

            public var committedDate: String?

            public var committer: GetBranchInfoResponseBody.Result.Commit.Committer?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var signature: GetBranchInfoResponseBody.Result.Commit.Signature?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.author?.validate()
                try self.committer?.validate()
                try self.signature?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.author != nil {
                    map["author"] = self.author?.toMap()
                }
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.commentsCount != nil {
                    map["commentsCount"] = self.commentsCount!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committer != nil {
                    map["committer"] = self.committer?.toMap()
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.signature != nil {
                    map["signature"] = self.signature?.toMap()
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["author"] as? [String: Any?] {
                    var model = GetBranchInfoResponseBody.Result.Commit.Author()
                    model.fromMap(value)
                    self.author = model
                }
                if let value = dict["authorEmail"] as? String {
                    self.authorEmail = value
                }
                if let value = dict["authorName"] as? String {
                    self.authorName = value
                }
                if let value = dict["authoredDate"] as? String {
                    self.authoredDate = value
                }
                if let value = dict["commentsCount"] as? Int64 {
                    self.commentsCount = value
                }
                if let value = dict["committedDate"] as? String {
                    self.committedDate = value
                }
                if let value = dict["committer"] as? [String: Any?] {
                    var model = GetBranchInfoResponseBody.Result.Commit.Committer()
                    model.fromMap(value)
                    self.committer = model
                }
                if let value = dict["committerEmail"] as? String {
                    self.committerEmail = value
                }
                if let value = dict["committerName"] as? String {
                    self.committerName = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["parentIds"] as? [String] {
                    self.parentIds = value
                }
                if let value = dict["shortId"] as? String {
                    self.shortId = value
                }
                if let value = dict["signature"] as? [String: Any?] {
                    var model = GetBranchInfoResponseBody.Result.Commit.Signature()
                    model.fromMap(value)
                    self.signature = model
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public var commit: GetBranchInfoResponseBody.Result.Commit?

        public var name: String?

        public var protected: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.protected != nil {
                map["protected"] = self.protected!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["commit"] as? [String: Any?] {
                var model = GetBranchInfoResponseBody.Result.Commit()
                model.fromMap(value)
                self.commit = model
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["protected"] as? String {
                self.protected = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetBranchInfoResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetBranchInfoResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetBranchInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBranchInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetBranchInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetCheckRunRequest : Tea.TeaModel {
    public var accessToken: String?

    public var checkRunId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.checkRunId != nil {
            map["checkRunId"] = self.checkRunId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["checkRunId"] as? Int64 {
            self.checkRunId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class GetCheckRunResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var annotationLevel: String?

            public var endColumn: Int64?

            public var endLine: Int64?

            public var id: Int64?

            public var message: String?

            public var path: String?

            public var rawDetails: String?

            public var startColumn: Int64?

            public var startLine: Int64?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotationLevel != nil {
                    map["annotationLevel"] = self.annotationLevel!
                }
                if self.endColumn != nil {
                    map["endColumn"] = self.endColumn!
                }
                if self.endLine != nil {
                    map["endLine"] = self.endLine!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.rawDetails != nil {
                    map["rawDetails"] = self.rawDetails!
                }
                if self.startColumn != nil {
                    map["startColumn"] = self.startColumn!
                }
                if self.startLine != nil {
                    map["startLine"] = self.startLine!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["annotationLevel"] as? String {
                    self.annotationLevel = value
                }
                if let value = dict["endColumn"] as? Int64 {
                    self.endColumn = value
                }
                if let value = dict["endLine"] as? Int64 {
                    self.endLine = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["path"] as? String {
                    self.path = value
                }
                if let value = dict["rawDetails"] as? String {
                    self.rawDetails = value
                }
                if let value = dict["startColumn"] as? Int64 {
                    self.startColumn = value
                }
                if let value = dict["startLine"] as? Int64 {
                    self.startLine = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public class CheckSuite : Tea.TeaModel {
            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class Images : Tea.TeaModel {
                public var alt: String?

                public var caption: String?

                public var imageUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alt != nil {
                        map["alt"] = self.alt!
                    }
                    if self.caption != nil {
                        map["caption"] = self.caption!
                    }
                    if self.imageUrl != nil {
                        map["imageUrl"] = self.imageUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["alt"] as? String {
                        self.alt = value
                    }
                    if let value = dict["caption"] as? String {
                        self.caption = value
                    }
                    if let value = dict["imageUrl"] as? String {
                        self.imageUrl = value
                    }
                }
            }
            public var images: [GetCheckRunResponseBody.Result.Output.Images]?

            public var summary: String?

            public var text: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.images != nil {
                    var tmp : [Any] = []
                    for k in self.images! {
                        tmp.append(k.toMap())
                    }
                    map["images"] = tmp
                }
                if self.summary != nil {
                    map["summary"] = self.summary!
                }
                if self.text != nil {
                    map["text"] = self.text!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["images"] as? [Any?] {
                    var tmp : [GetCheckRunResponseBody.Result.Output.Images] = []
                    for v in value {
                        if v != nil {
                            var model = GetCheckRunResponseBody.Result.Output.Images()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.images = tmp
                }
                if let value = dict["summary"] as? String {
                    self.summary = value
                }
                if let value = dict["text"] as? String {
                    self.text = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public class Writer : Tea.TeaModel {
            public var id: String?

            public var logoUrl: String?

            public var name: String?

            public var slug: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.logoUrl != nil {
                    map["logoUrl"] = self.logoUrl!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.slug != nil {
                    map["slug"] = self.slug!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["logoUrl"] as? String {
                    self.logoUrl = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["slug"] as? String {
                    self.slug = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public var annotations: [GetCheckRunResponseBody.Result.Annotations]?

        public var checkSuite: GetCheckRunResponseBody.Result.CheckSuite?

        public var completedAt: String?

        public var conclusion: String?

        public var createdAt: String?

        public var detailsUrl: String?

        public var externalId: String?

        public var headSha: String?

        public var id: Int64?

        public var name: String?

        public var output: GetCheckRunResponseBody.Result.Output?

        public var startedAt: String?

        public var status: String?

        public var updatedAt: String?

        public var writer: GetCheckRunResponseBody.Result.Writer?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkSuite?.validate()
            try self.output?.validate()
            try self.writer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["annotations"] = tmp
            }
            if self.checkSuite != nil {
                map["checkSuite"] = self.checkSuite?.toMap()
            }
            if self.completedAt != nil {
                map["completedAt"] = self.completedAt!
            }
            if self.conclusion != nil {
                map["conclusion"] = self.conclusion!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.detailsUrl != nil {
                map["detailsUrl"] = self.detailsUrl!
            }
            if self.externalId != nil {
                map["externalId"] = self.externalId!
            }
            if self.headSha != nil {
                map["headSha"] = self.headSha!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.output != nil {
                map["output"] = self.output?.toMap()
            }
            if self.startedAt != nil {
                map["startedAt"] = self.startedAt!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.writer != nil {
                map["writer"] = self.writer?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["annotations"] as? [Any?] {
                var tmp : [GetCheckRunResponseBody.Result.Annotations] = []
                for v in value {
                    if v != nil {
                        var model = GetCheckRunResponseBody.Result.Annotations()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.annotations = tmp
            }
            if let value = dict["checkSuite"] as? [String: Any?] {
                var model = GetCheckRunResponseBody.Result.CheckSuite()
                model.fromMap(value)
                self.checkSuite = model
            }
            if let value = dict["completedAt"] as? String {
                self.completedAt = value
            }
            if let value = dict["conclusion"] as? String {
                self.conclusion = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["detailsUrl"] as? String {
                self.detailsUrl = value
            }
            if let value = dict["externalId"] as? String {
                self.externalId = value
            }
            if let value = dict["headSha"] as? String {
                self.headSha = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["output"] as? [String: Any?] {
                var model = GetCheckRunResponseBody.Result.Output()
                model.fromMap(value)
                self.output = model
            }
            if let value = dict["startedAt"] as? String {
                self.startedAt = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["writer"] as? [String: Any?] {
                var model = GetCheckRunResponseBody.Result.Writer()
                model.fromMap(value)
                self.writer = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetCheckRunResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetCheckRunResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetCheckRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCheckRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetCheckRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetCodeupOrganizationRequest : Tea.TeaModel {
    public var accessToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
    }
}

public class GetCodeupOrganizationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var id: Int64?

        public var namespaceId: Int64?

        public var organizationId: String?

        public var path: String?

        public var updatedAt: String?

        public var userRole: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.namespaceId != nil {
                map["namespaceId"] = self.namespaceId!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.userRole != nil {
                map["userRole"] = self.userRole!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["namespaceId"] as? Int64 {
                self.namespaceId = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["userRole"] as? String {
                self.userRole = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetCodeupOrganizationResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetCodeupOrganizationResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetCodeupOrganizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCodeupOrganizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetCodeupOrganizationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetCompareDetailRequest : Tea.TeaModel {
    public var from: String?

    public var maxDiffByte: Int32?

    public var maxDiffFile: Int32?

    public var mergeBase: Bool?

    public var organizationId: String?

    public var to: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["from"] = self.from!
        }
        if self.maxDiffByte != nil {
            map["maxDiffByte"] = self.maxDiffByte!
        }
        if self.maxDiffFile != nil {
            map["maxDiffFile"] = self.maxDiffFile!
        }
        if self.mergeBase != nil {
            map["mergeBase"] = self.mergeBase!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.to != nil {
            map["to"] = self.to!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["from"] as? String {
            self.from = value
        }
        if let value = dict["maxDiffByte"] as? Int32 {
            self.maxDiffByte = value
        }
        if let value = dict["maxDiffFile"] as? Int32 {
            self.maxDiffFile = value
        }
        if let value = dict["mergeBase"] as? Bool {
            self.mergeBase = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["to"] as? String {
            self.to = value
        }
    }
}

public class GetCompareDetailResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commits : Tea.TeaModel {
            public class Author : Tea.TeaModel {
                public var avatarUrl: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var state: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avatarUrl != nil {
                        map["avatarUrl"] = self.avatarUrl!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["avatarUrl"] as? String {
                        self.avatarUrl = value
                    }
                    if let value = dict["email"] as? String {
                        self.email = value
                    }
                    if let value = dict["id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["state"] as? String {
                        self.state = value
                    }
                    if let value = dict["username"] as? String {
                        self.username = value
                    }
                }
            }
            public class Committer : Tea.TeaModel {
                public var avatarUrl: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var state: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avatarUrl != nil {
                        map["avatarUrl"] = self.avatarUrl!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["avatarUrl"] as? String {
                        self.avatarUrl = value
                    }
                    if let value = dict["email"] as? String {
                        self.email = value
                    }
                    if let value = dict["id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["state"] as? String {
                        self.state = value
                    }
                    if let value = dict["username"] as? String {
                        self.username = value
                    }
                }
            }
            public var author: GetCompareDetailResponseBody.Result.Commits.Author?

            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var commentsCount: Int64?

            public var committedDate: String?

            public var committer: GetCompareDetailResponseBody.Result.Commits.Committer?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.author?.validate()
                try self.committer?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.author != nil {
                    map["author"] = self.author?.toMap()
                }
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.commentsCount != nil {
                    map["commentsCount"] = self.commentsCount!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committer != nil {
                    map["committer"] = self.committer?.toMap()
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["author"] as? [String: Any?] {
                    var model = GetCompareDetailResponseBody.Result.Commits.Author()
                    model.fromMap(value)
                    self.author = model
                }
                if let value = dict["authorEmail"] as? String {
                    self.authorEmail = value
                }
                if let value = dict["authorName"] as? String {
                    self.authorName = value
                }
                if let value = dict["authoredDate"] as? String {
                    self.authoredDate = value
                }
                if let value = dict["commentsCount"] as? Int64 {
                    self.commentsCount = value
                }
                if let value = dict["committedDate"] as? String {
                    self.committedDate = value
                }
                if let value = dict["committer"] as? [String: Any?] {
                    var model = GetCompareDetailResponseBody.Result.Commits.Committer()
                    model.fromMap(value)
                    self.committer = model
                }
                if let value = dict["committerEmail"] as? String {
                    self.committerEmail = value
                }
                if let value = dict["committerName"] as? String {
                    self.committerName = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["parentIds"] as? [String] {
                    self.parentIds = value
                }
                if let value = dict["shortId"] as? String {
                    self.shortId = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public class Diffs : Tea.TeaModel {
            public var aMode: String?

            public var bMode: String?

            public var deletedFile: Bool?

            public var diff: String?

            public var isBinary: Bool?

            public var isNewLfs: Bool?

            public var isOldLfs: Bool?

            public var newFile: Bool?

            public var newId: String?

            public var newPath: String?

            public var oldId: String?

            public var oldPath: String?

            public var renamedFile: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aMode != nil {
                    map["aMode"] = self.aMode!
                }
                if self.bMode != nil {
                    map["bMode"] = self.bMode!
                }
                if self.deletedFile != nil {
                    map["deletedFile"] = self.deletedFile!
                }
                if self.diff != nil {
                    map["diff"] = self.diff!
                }
                if self.isBinary != nil {
                    map["isBinary"] = self.isBinary!
                }
                if self.isNewLfs != nil {
                    map["isNewLfs"] = self.isNewLfs!
                }
                if self.isOldLfs != nil {
                    map["isOldLfs"] = self.isOldLfs!
                }
                if self.newFile != nil {
                    map["newFile"] = self.newFile!
                }
                if self.newId != nil {
                    map["newId"] = self.newId!
                }
                if self.newPath != nil {
                    map["newPath"] = self.newPath!
                }
                if self.oldId != nil {
                    map["oldId"] = self.oldId!
                }
                if self.oldPath != nil {
                    map["oldPath"] = self.oldPath!
                }
                if self.renamedFile != nil {
                    map["renamedFile"] = self.renamedFile!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aMode"] as? String {
                    self.aMode = value
                }
                if let value = dict["bMode"] as? String {
                    self.bMode = value
                }
                if let value = dict["deletedFile"] as? Bool {
                    self.deletedFile = value
                }
                if let value = dict["diff"] as? String {
                    self.diff = value
                }
                if let value = dict["isBinary"] as? Bool {
                    self.isBinary = value
                }
                if let value = dict["isNewLfs"] as? Bool {
                    self.isNewLfs = value
                }
                if let value = dict["isOldLfs"] as? Bool {
                    self.isOldLfs = value
                }
                if let value = dict["newFile"] as? Bool {
                    self.newFile = value
                }
                if let value = dict["newId"] as? String {
                    self.newId = value
                }
                if let value = dict["newPath"] as? String {
                    self.newPath = value
                }
                if let value = dict["oldId"] as? String {
                    self.oldId = value
                }
                if let value = dict["oldPath"] as? String {
                    self.oldPath = value
                }
                if let value = dict["renamedFile"] as? Bool {
                    self.renamedFile = value
                }
            }
        }
        public var commits: [GetCompareDetailResponseBody.Result.Commits]?

        public var diffs: [GetCompareDetailResponseBody.Result.Diffs]?

        public var messages: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commits != nil {
                var tmp : [Any] = []
                for k in self.commits! {
                    tmp.append(k.toMap())
                }
                map["commits"] = tmp
            }
            if self.diffs != nil {
                var tmp : [Any] = []
                for k in self.diffs! {
                    tmp.append(k.toMap())
                }
                map["diffs"] = tmp
            }
            if self.messages != nil {
                map["messages"] = self.messages!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["commits"] as? [Any?] {
                var tmp : [GetCompareDetailResponseBody.Result.Commits] = []
                for v in value {
                    if v != nil {
                        var model = GetCompareDetailResponseBody.Result.Commits()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.commits = tmp
            }
            if let value = dict["diffs"] as? [Any?] {
                var tmp : [GetCompareDetailResponseBody.Result.Diffs] = []
                for v in value {
                    if v != nil {
                        var model = GetCompareDetailResponseBody.Result.Diffs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.diffs = tmp
            }
            if let value = dict["messages"] as? [String] {
                self.messages = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetCompareDetailResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetCompareDetailResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetCompareDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCompareDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetCompareDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetCustomFieldOptionRequest : Tea.TeaModel {
    public var spaceIdentifier: String?

    public var spaceType: String?

    public var workitemTypeIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        if self.workitemTypeIdentifier != nil {
            map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["spaceIdentifier"] as? String {
            self.spaceIdentifier = value
        }
        if let value = dict["spaceType"] as? String {
            self.spaceType = value
        }
        if let value = dict["workitemTypeIdentifier"] as? String {
            self.workitemTypeIdentifier = value
        }
    }
}

public class GetCustomFieldOptionResponseBody : Tea.TeaModel {
    public class Fileds : Tea.TeaModel {
        public var displayValue: String?

        public var fieldIdentifier: String?

        public var identifier: String?

        public var level: Int64?

        public var position: Int64?

        public var value: String?

        public var valueEn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayValue != nil {
                map["displayValue"] = self.displayValue!
            }
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.level != nil {
                map["level"] = self.level!
            }
            if self.position != nil {
                map["position"] = self.position!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            if self.valueEn != nil {
                map["valueEn"] = self.valueEn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["displayValue"] as? String {
                self.displayValue = value
            }
            if let value = dict["fieldIdentifier"] as? String {
                self.fieldIdentifier = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["level"] as? Int64 {
                self.level = value
            }
            if let value = dict["position"] as? Int64 {
                self.position = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
            if let value = dict["valueEn"] as? String {
                self.valueEn = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var fileds: [GetCustomFieldOptionResponseBody.Fileds]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.fileds != nil {
            var tmp : [Any] = []
            for k in self.fileds! {
                tmp.append(k.toMap())
            }
            map["fileds"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["fileds"] as? [Any?] {
            var tmp : [GetCustomFieldOptionResponseBody.Fileds] = []
            for v in value {
                if v != nil {
                    var model = GetCustomFieldOptionResponseBody.Fileds()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.fileds = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetCustomFieldOptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomFieldOptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetCustomFieldOptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFileBlobsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var filePath: String?

    public var from: Int64?

    public var organizationId: String?

    public var ref: String?

    public var to: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.from != nil {
            map["from"] = self.from!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.ref != nil {
            map["ref"] = self.ref!
        }
        if self.to != nil {
            map["to"] = self.to!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["filePath"] as? String {
            self.filePath = value
        }
        if let value = dict["from"] as? Int64 {
            self.from = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["ref"] as? String {
            self.ref = value
        }
        if let value = dict["to"] as? Int64 {
            self.to = value
        }
    }
}

public class GetFileBlobsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var size: Int64?

        public var totalLines: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.size != nil {
                map["size"] = self.size!
            }
            if self.totalLines != nil {
                map["totalLines"] = self.totalLines!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["size"] as? Int64 {
                self.size = value
            }
            if let value = dict["totalLines"] as? Int32 {
                self.totalLines = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetFileBlobsResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetFileBlobsResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetFileBlobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileBlobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFileBlobsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFileLastCommitRequest : Tea.TeaModel {
    public var accessToken: String?

    public var filePath: String?

    public var organizationId: String?

    public var sha: String?

    public var showSignature: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.sha != nil {
            map["sha"] = self.sha!
        }
        if self.showSignature != nil {
            map["showSignature"] = self.showSignature!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["filePath"] as? String {
            self.filePath = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["sha"] as? String {
            self.sha = value
        }
        if let value = dict["showSignature"] as? Bool {
            self.showSignature = value
        }
    }
}

public class GetFileLastCommitResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Signature : Tea.TeaModel {
            public var gpgKeyId: String?

            public var verificationStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gpgKeyId != nil {
                    map["gpgKeyId"] = self.gpgKeyId!
                }
                if self.verificationStatus != nil {
                    map["verificationStatus"] = self.verificationStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["gpgKeyId"] as? String {
                    self.gpgKeyId = value
                }
                if let value = dict["verificationStatus"] as? String {
                    self.verificationStatus = value
                }
            }
        }
        public var authorDate: String?

        public var authorEmail: String?

        public var authorName: String?

        public var committedDate: String?

        public var committerEmail: String?

        public var committerName: String?

        public var createdAt: String?

        public var id: String?

        public var message: String?

        public var parentIds: [String]?

        public var shortId: String?

        public var signature: GetFileLastCommitResponseBody.Result.Signature?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.signature?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorDate != nil {
                map["authorDate"] = self.authorDate!
            }
            if self.authorEmail != nil {
                map["authorEmail"] = self.authorEmail!
            }
            if self.authorName != nil {
                map["authorName"] = self.authorName!
            }
            if self.committedDate != nil {
                map["committedDate"] = self.committedDate!
            }
            if self.committerEmail != nil {
                map["committerEmail"] = self.committerEmail!
            }
            if self.committerName != nil {
                map["committerName"] = self.committerName!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.parentIds != nil {
                map["parentIds"] = self.parentIds!
            }
            if self.shortId != nil {
                map["shortId"] = self.shortId!
            }
            if self.signature != nil {
                map["signature"] = self.signature?.toMap()
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["authorDate"] as? String {
                self.authorDate = value
            }
            if let value = dict["authorEmail"] as? String {
                self.authorEmail = value
            }
            if let value = dict["authorName"] as? String {
                self.authorName = value
            }
            if let value = dict["committedDate"] as? String {
                self.committedDate = value
            }
            if let value = dict["committerEmail"] as? String {
                self.committerEmail = value
            }
            if let value = dict["committerName"] as? String {
                self.committerName = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["message"] as? String {
                self.message = value
            }
            if let value = dict["parentIds"] as? [String] {
                self.parentIds = value
            }
            if let value = dict["shortId"] as? String {
                self.shortId = value
            }
            if let value = dict["signature"] as? [String: Any?] {
                var model = GetFileLastCommitResponseBody.Result.Signature()
                model.fromMap(value)
                self.signature = model
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetFileLastCommitResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetFileLastCommitResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetFileLastCommitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileLastCommitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFileLastCommitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetFlowTagGroupResponseBody : Tea.TeaModel {
    public class FlowTagGroup : Tea.TeaModel {
        public class FlowTagList : Tea.TeaModel {
            public var color: String?

            public var creatorAccountId: String?

            public var id: Int64?

            public var modiferAccountId: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.color != nil {
                    map["color"] = self.color!
                }
                if self.creatorAccountId != nil {
                    map["creatorAccountId"] = self.creatorAccountId!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.modiferAccountId != nil {
                    map["modiferAccountId"] = self.modiferAccountId!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["color"] as? String {
                    self.color = value
                }
                if let value = dict["creatorAccountId"] as? String {
                    self.creatorAccountId = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["modiferAccountId"] as? String {
                    self.modiferAccountId = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public var creatorAccountId: String?

        public var flowTagList: [GetFlowTagGroupResponseBody.FlowTagGroup.FlowTagList]?

        public var id: Int64?

        public var modiferAccountId: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.flowTagList != nil {
                var tmp : [Any] = []
                for k in self.flowTagList! {
                    tmp.append(k.toMap())
                }
                map["flowTagList"] = tmp
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modiferAccountId != nil {
                map["modiferAccountId"] = self.modiferAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["creatorAccountId"] as? String {
                self.creatorAccountId = value
            }
            if let value = dict["flowTagList"] as? [Any?] {
                var tmp : [GetFlowTagGroupResponseBody.FlowTagGroup.FlowTagList] = []
                for v in value {
                    if v != nil {
                        var model = GetFlowTagGroupResponseBody.FlowTagGroup.FlowTagList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.flowTagList = tmp
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["modiferAccountId"] as? String {
                self.modiferAccountId = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var flowTagGroup: GetFlowTagGroupResponseBody.FlowTagGroup?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.flowTagGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.flowTagGroup != nil {
            map["flowTagGroup"] = self.flowTagGroup?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["flowTagGroup"] as? [String: Any?] {
            var model = GetFlowTagGroupResponseBody.FlowTagGroup()
            model.fromMap(value)
            self.flowTagGroup = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetFlowTagGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFlowTagGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetFlowTagGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetGroupByPathRequest : Tea.TeaModel {
    public var identity: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identity != nil {
            map["identity"] = self.identity!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["identity"] as? String {
            self.identity = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class GetGroupByPathResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var avatarUrl: String?

        public var description_: String?

        public var id: Int64?

        public var name: String?

        public var nameWithNamespace: String?

        public var ownerId: String?

        public var parentId: String?

        public var path: String?

        public var pathWithNamespace: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["ownerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["parentId"] as? String {
                self.parentId = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["pathWithNamespace"] as? String {
                self.pathWithNamespace = value
            }
            if let value = dict["visibilityLevel"] as? Int32 {
                self.visibilityLevel = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetGroupByPathResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetGroupByPathResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetGroupByPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGroupByPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetGroupByPathResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetGroupDetailRequest : Tea.TeaModel {
    public var accessToken: String?

    public var groupId: Int64?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.groupId != nil {
            map["groupId"] = self.groupId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["groupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class GetGroupDetailResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var avatarUrl: String?

        public var description_: String?

        public var id: Int64?

        public var name: String?

        public var nameWithNamespace: String?

        public var ownerId: Int64?

        public var parentId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var type: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["ownerId"] as? Int64 {
                self.ownerId = value
            }
            if let value = dict["parentId"] as? Int64 {
                self.parentId = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["pathWithNamespace"] as? String {
                self.pathWithNamespace = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["visibilityLevel"] as? Int32 {
                self.visibilityLevel = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetGroupDetailResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetGroupDetailResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetGroupDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGroupDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetGroupDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetHostGroupResponseBody : Tea.TeaModel {
    public class HostGroup : Tea.TeaModel {
        public class HostInfos : Tea.TeaModel {
            public var aliyunRegionId: String?

            public var createTime: Int64?

            public var creatorAccountId: String?

            public var instanceName: String?

            public var ip: String?

            public var machineSn: String?

            public var modifierAccountId: String?

            public var objectType: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunRegionId != nil {
                    map["aliyunRegionId"] = self.aliyunRegionId!
                }
                if self.createTime != nil {
                    map["createTime"] = self.createTime!
                }
                if self.creatorAccountId != nil {
                    map["creatorAccountId"] = self.creatorAccountId!
                }
                if self.instanceName != nil {
                    map["instanceName"] = self.instanceName!
                }
                if self.ip != nil {
                    map["ip"] = self.ip!
                }
                if self.machineSn != nil {
                    map["machineSn"] = self.machineSn!
                }
                if self.modifierAccountId != nil {
                    map["modifierAccountId"] = self.modifierAccountId!
                }
                if self.objectType != nil {
                    map["objectType"] = self.objectType!
                }
                if self.updateTime != nil {
                    map["updateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliyunRegionId"] as? String {
                    self.aliyunRegionId = value
                }
                if let value = dict["createTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["creatorAccountId"] as? String {
                    self.creatorAccountId = value
                }
                if let value = dict["instanceName"] as? String {
                    self.instanceName = value
                }
                if let value = dict["ip"] as? String {
                    self.ip = value
                }
                if let value = dict["machineSn"] as? String {
                    self.machineSn = value
                }
                if let value = dict["modifierAccountId"] as? String {
                    self.modifierAccountId = value
                }
                if let value = dict["objectType"] as? String {
                    self.objectType = value
                }
                if let value = dict["updateTime"] as? Int64 {
                    self.updateTime = value
                }
            }
        }
        public var aliyunRegion: String?

        public var createTime: Int64?

        public var creatorAccountId: String?

        public var description_: String?

        public var ecsLabelKey: String?

        public var ecsLabelValue: String?

        public var ecsType: String?

        public var hostInfos: [GetHostGroupResponseBody.HostGroup.HostInfos]?

        public var hostNum: Int64?

        public var id: Int64?

        public var modifierAccountId: String?

        public var name: String?

        public var serviceConnectionId: Int64?

        public var type: String?

        public var upateTIme: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunRegion != nil {
                map["aliyunRegion"] = self.aliyunRegion!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.ecsLabelKey != nil {
                map["ecsLabelKey"] = self.ecsLabelKey!
            }
            if self.ecsLabelValue != nil {
                map["ecsLabelValue"] = self.ecsLabelValue!
            }
            if self.ecsType != nil {
                map["ecsType"] = self.ecsType!
            }
            if self.hostInfos != nil {
                var tmp : [Any] = []
                for k in self.hostInfos! {
                    tmp.append(k.toMap())
                }
                map["hostInfos"] = tmp
            }
            if self.hostNum != nil {
                map["hostNum"] = self.hostNum!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.serviceConnectionId != nil {
                map["serviceConnectionId"] = self.serviceConnectionId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.upateTIme != nil {
                map["upateTIme"] = self.upateTIme!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["aliyunRegion"] as? String {
                self.aliyunRegion = value
            }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["creatorAccountId"] as? String {
                self.creatorAccountId = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["ecsLabelKey"] as? String {
                self.ecsLabelKey = value
            }
            if let value = dict["ecsLabelValue"] as? String {
                self.ecsLabelValue = value
            }
            if let value = dict["ecsType"] as? String {
                self.ecsType = value
            }
            if let value = dict["hostInfos"] as? [Any?] {
                var tmp : [GetHostGroupResponseBody.HostGroup.HostInfos] = []
                for v in value {
                    if v != nil {
                        var model = GetHostGroupResponseBody.HostGroup.HostInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.hostInfos = tmp
            }
            if let value = dict["hostNum"] as? Int64 {
                self.hostNum = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["modifierAccountId"] as? String {
                self.modifierAccountId = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["serviceConnectionId"] as? Int64 {
                self.serviceConnectionId = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["upateTIme"] as? Int64 {
                self.upateTIme = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var hostGroup: GetHostGroupResponseBody.HostGroup?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hostGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.hostGroup != nil {
            map["hostGroup"] = self.hostGroup?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["hostGroup"] as? [String: Any?] {
            var model = GetHostGroupResponseBody.HostGroup()
            model.fromMap(value)
            self.hostGroup = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetHostGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHostGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetHostGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class GetMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public class Reviewers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var hasCommented: Bool?

            public var hasReviewed: Bool?

            public var id: Int64?

            public var name: String?

            public var reviewOpinionStatus: String?

            public var reviewTime: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.hasCommented != nil {
                    map["hasCommented"] = self.hasCommented!
                }
                if self.hasReviewed != nil {
                    map["hasReviewed"] = self.hasReviewed!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.reviewOpinionStatus != nil {
                    map["reviewOpinionStatus"] = self.reviewOpinionStatus!
                }
                if self.reviewTime != nil {
                    map["reviewTime"] = self.reviewTime!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["hasCommented"] as? Bool {
                    self.hasCommented = value
                }
                if let value = dict["hasReviewed"] as? Bool {
                    self.hasReviewed = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["reviewOpinionStatus"] as? String {
                    self.reviewOpinionStatus = value
                }
                if let value = dict["reviewTime"] as? String {
                    self.reviewTime = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public class Subscribers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public class TodoList : Tea.TeaModel {
            public class RequirementCheckItems : Tea.TeaModel {
                public var itemType: String?

                public var pass: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.itemType != nil {
                        map["itemType"] = self.itemType!
                    }
                    if self.pass != nil {
                        map["pass"] = self.pass!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["itemType"] as? String {
                        self.itemType = value
                    }
                    if let value = dict["pass"] as? Bool {
                        self.pass = value
                    }
                }
            }
            public var requirementCheckItems: [GetMergeRequestResponseBody.Result.TodoList.RequirementCheckItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requirementCheckItems != nil {
                    var tmp : [Any] = []
                    for k in self.requirementCheckItems! {
                        tmp.append(k.toMap())
                    }
                    map["requirementCheckItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["requirementCheckItems"] as? [Any?] {
                    var tmp : [GetMergeRequestResponseBody.Result.TodoList.RequirementCheckItems] = []
                    for v in value {
                        if v != nil {
                            var model = GetMergeRequestResponseBody.Result.TodoList.RequirementCheckItems()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.requirementCheckItems = tmp
                }
            }
        }
        public var ahead: Int32?

        public var allRequirementsPass: Bool?

        public var author: GetMergeRequestResponseBody.Result.Author?

        public var behind: Int32?

        public var createFrom: String?

        public var createTime: String?

        public var description_: String?

        public var detailUrl: String?

        public var localId: Int64?

        public var mergedRevision: String?

        public var mrBizId: String?

        public var mrType: String?

        public var projectId: Int64?

        public var reviewers: [GetMergeRequestResponseBody.Result.Reviewers]?

        public var sourceBranch: String?

        public var sourceProjectId: Int64?

        public var status: String?

        public var subscribers: [GetMergeRequestResponseBody.Result.Subscribers]?

        public var supportMergeFastForwardOnly: Bool?

        public var targetBranch: String?

        public var targetProjectId: Int64?

        public var targetProjectNameWithNamespace: String?

        public var targetProjectPathWithNamespace: String?

        public var title: String?

        public var todoList: GetMergeRequestResponseBody.Result.TodoList?

        public var updateTime: String?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.todoList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ahead != nil {
                map["ahead"] = self.ahead!
            }
            if self.allRequirementsPass != nil {
                map["allRequirementsPass"] = self.allRequirementsPass!
            }
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.behind != nil {
                map["behind"] = self.behind!
            }
            if self.createFrom != nil {
                map["createFrom"] = self.createFrom!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.detailUrl != nil {
                map["detailUrl"] = self.detailUrl!
            }
            if self.localId != nil {
                map["localId"] = self.localId!
            }
            if self.mergedRevision != nil {
                map["mergedRevision"] = self.mergedRevision!
            }
            if self.mrBizId != nil {
                map["mrBizId"] = self.mrBizId!
            }
            if self.mrType != nil {
                map["mrType"] = self.mrType!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.reviewers != nil {
                var tmp : [Any] = []
                for k in self.reviewers! {
                    tmp.append(k.toMap())
                }
                map["reviewers"] = tmp
            }
            if self.sourceBranch != nil {
                map["sourceBranch"] = self.sourceBranch!
            }
            if self.sourceProjectId != nil {
                map["sourceProjectId"] = self.sourceProjectId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.subscribers != nil {
                var tmp : [Any] = []
                for k in self.subscribers! {
                    tmp.append(k.toMap())
                }
                map["subscribers"] = tmp
            }
            if self.supportMergeFastForwardOnly != nil {
                map["supportMergeFastForwardOnly"] = self.supportMergeFastForwardOnly!
            }
            if self.targetBranch != nil {
                map["targetBranch"] = self.targetBranch!
            }
            if self.targetProjectId != nil {
                map["targetProjectId"] = self.targetProjectId!
            }
            if self.targetProjectNameWithNamespace != nil {
                map["targetProjectNameWithNamespace"] = self.targetProjectNameWithNamespace!
            }
            if self.targetProjectPathWithNamespace != nil {
                map["targetProjectPathWithNamespace"] = self.targetProjectPathWithNamespace!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.todoList != nil {
                map["todoList"] = self.todoList?.toMap()
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ahead"] as? Int32 {
                self.ahead = value
            }
            if let value = dict["allRequirementsPass"] as? Bool {
                self.allRequirementsPass = value
            }
            if let value = dict["author"] as? [String: Any?] {
                var model = GetMergeRequestResponseBody.Result.Author()
                model.fromMap(value)
                self.author = model
            }
            if let value = dict["behind"] as? Int32 {
                self.behind = value
            }
            if let value = dict["createFrom"] as? String {
                self.createFrom = value
            }
            if let value = dict["createTime"] as? String {
                self.createTime = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["detailUrl"] as? String {
                self.detailUrl = value
            }
            if let value = dict["localId"] as? Int64 {
                self.localId = value
            }
            if let value = dict["mergedRevision"] as? String {
                self.mergedRevision = value
            }
            if let value = dict["mrBizId"] as? String {
                self.mrBizId = value
            }
            if let value = dict["mrType"] as? String {
                self.mrType = value
            }
            if let value = dict["projectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["reviewers"] as? [Any?] {
                var tmp : [GetMergeRequestResponseBody.Result.Reviewers] = []
                for v in value {
                    if v != nil {
                        var model = GetMergeRequestResponseBody.Result.Reviewers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.reviewers = tmp
            }
            if let value = dict["sourceBranch"] as? String {
                self.sourceBranch = value
            }
            if let value = dict["sourceProjectId"] as? Int64 {
                self.sourceProjectId = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["subscribers"] as? [Any?] {
                var tmp : [GetMergeRequestResponseBody.Result.Subscribers] = []
                for v in value {
                    if v != nil {
                        var model = GetMergeRequestResponseBody.Result.Subscribers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.subscribers = tmp
            }
            if let value = dict["supportMergeFastForwardOnly"] as? Bool {
                self.supportMergeFastForwardOnly = value
            }
            if let value = dict["targetBranch"] as? String {
                self.targetBranch = value
            }
            if let value = dict["targetProjectId"] as? Int64 {
                self.targetProjectId = value
            }
            if let value = dict["targetProjectNameWithNamespace"] as? String {
                self.targetProjectNameWithNamespace = value
            }
            if let value = dict["targetProjectPathWithNamespace"] as? String {
                self.targetProjectPathWithNamespace = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
            if let value = dict["todoList"] as? [String: Any?] {
                var model = GetMergeRequestResponseBody.Result.TodoList()
                model.fromMap(value)
                self.todoList = model
            }
            if let value = dict["updateTime"] as? String {
                self.updateTime = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetMergeRequestResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMergeRequestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMergeRequestChangeTreeRequest : Tea.TeaModel {
    public var accessToken: String?

    public var fromPatchSetBizId: String?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public var toPatchSetBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.fromPatchSetBizId != nil {
            map["fromPatchSetBizId"] = self.fromPatchSetBizId!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        if self.toPatchSetBizId != nil {
            map["toPatchSetBizId"] = self.toPatchSetBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["fromPatchSetBizId"] as? String {
            self.fromPatchSetBizId = value
        }
        if let value = dict["localId"] as? Int64 {
            self.localId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
        if let value = dict["toPatchSetBizId"] as? String {
            self.toPatchSetBizId = value
        }
    }
}

public class GetMergeRequestChangeTreeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ChangedFilesInfos : Tea.TeaModel {
            public var addLines: Int64?

            public var binaryFile: Bool?

            public var delLines: Int64?

            public var deletedFile: Bool?

            public var newFile: Bool?

            public var newPath: String?

            public var oldPath: String?

            public var renamedFile: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addLines != nil {
                    map["addLines"] = self.addLines!
                }
                if self.binaryFile != nil {
                    map["binaryFile"] = self.binaryFile!
                }
                if self.delLines != nil {
                    map["delLines"] = self.delLines!
                }
                if self.deletedFile != nil {
                    map["deletedFile"] = self.deletedFile!
                }
                if self.newFile != nil {
                    map["newFile"] = self.newFile!
                }
                if self.newPath != nil {
                    map["newPath"] = self.newPath!
                }
                if self.oldPath != nil {
                    map["oldPath"] = self.oldPath!
                }
                if self.renamedFile != nil {
                    map["renamedFile"] = self.renamedFile!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["addLines"] as? Int64 {
                    self.addLines = value
                }
                if let value = dict["binaryFile"] as? Bool {
                    self.binaryFile = value
                }
                if let value = dict["delLines"] as? Int64 {
                    self.delLines = value
                }
                if let value = dict["deletedFile"] as? Bool {
                    self.deletedFile = value
                }
                if let value = dict["newFile"] as? Bool {
                    self.newFile = value
                }
                if let value = dict["newPath"] as? String {
                    self.newPath = value
                }
                if let value = dict["oldPath"] as? String {
                    self.oldPath = value
                }
                if let value = dict["renamedFile"] as? Bool {
                    self.renamedFile = value
                }
            }
        }
        public var changedFilesCount: Int64?

        public var changedFilesInfos: [GetMergeRequestChangeTreeResponseBody.Result.ChangedFilesInfos]?

        public var totalAddLines: Int64?

        public var totalDelLines: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changedFilesCount != nil {
                map["changedFilesCount"] = self.changedFilesCount!
            }
            if self.changedFilesInfos != nil {
                var tmp : [Any] = []
                for k in self.changedFilesInfos! {
                    tmp.append(k.toMap())
                }
                map["changedFilesInfos"] = tmp
            }
            if self.totalAddLines != nil {
                map["totalAddLines"] = self.totalAddLines!
            }
            if self.totalDelLines != nil {
                map["totalDelLines"] = self.totalDelLines!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["changedFilesCount"] as? Int64 {
                self.changedFilesCount = value
            }
            if let value = dict["changedFilesInfos"] as? [Any?] {
                var tmp : [GetMergeRequestChangeTreeResponseBody.Result.ChangedFilesInfos] = []
                for v in value {
                    if v != nil {
                        var model = GetMergeRequestChangeTreeResponseBody.Result.ChangedFilesInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.changedFilesInfos = tmp
            }
            if let value = dict["totalAddLines"] as? Int64 {
                self.totalAddLines = value
            }
            if let value = dict["totalDelLines"] as? Int64 {
                self.totalDelLines = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetMergeRequestChangeTreeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetMergeRequestChangeTreeResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetMergeRequestChangeTreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMergeRequestChangeTreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMergeRequestChangeTreeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetOrganizationMemberResponseBody : Tea.TeaModel {
    public class Member : Tea.TeaModel {
        public class Identities : Tea.TeaModel {
            public var externUid: String?

            public var provider: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.externUid != nil {
                    map["externUid"] = self.externUid!
                }
                if self.provider != nil {
                    map["provider"] = self.provider!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["externUid"] as? String {
                    self.externUid = value
                }
                if let value = dict["provider"] as? String {
                    self.provider = value
                }
            }
        }
        public var accountId: String?

        public var birthday: Int64?

        public var deptLists: [String]?

        public var email: String?

        public var hiredDate: Int64?

        public var identities: GetOrganizationMemberResponseBody.Member.Identities?

        public var jobNumber: String?

        public var joinTime: Int64?

        public var lastVisitTime: Int64?

        public var mobile: String?

        public var organizationMemberName: String?

        public var organizationRoleId: String?

        public var organizationRoleName: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.identities?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            if self.birthday != nil {
                map["birthday"] = self.birthday!
            }
            if self.deptLists != nil {
                map["deptLists"] = self.deptLists!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.hiredDate != nil {
                map["hiredDate"] = self.hiredDate!
            }
            if self.identities != nil {
                map["identities"] = self.identities?.toMap()
            }
            if self.jobNumber != nil {
                map["jobNumber"] = self.jobNumber!
            }
            if self.joinTime != nil {
                map["joinTime"] = self.joinTime!
            }
            if self.lastVisitTime != nil {
                map["lastVisitTime"] = self.lastVisitTime!
            }
            if self.mobile != nil {
                map["mobile"] = self.mobile!
            }
            if self.organizationMemberName != nil {
                map["organizationMemberName"] = self.organizationMemberName!
            }
            if self.organizationRoleId != nil {
                map["organizationRoleId"] = self.organizationRoleId!
            }
            if self.organizationRoleName != nil {
                map["organizationRoleName"] = self.organizationRoleName!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accountId"] as? String {
                self.accountId = value
            }
            if let value = dict["birthday"] as? Int64 {
                self.birthday = value
            }
            if let value = dict["deptLists"] as? [String] {
                self.deptLists = value
            }
            if let value = dict["email"] as? String {
                self.email = value
            }
            if let value = dict["hiredDate"] as? Int64 {
                self.hiredDate = value
            }
            if let value = dict["identities"] as? [String: Any?] {
                var model = GetOrganizationMemberResponseBody.Member.Identities()
                model.fromMap(value)
                self.identities = model
            }
            if let value = dict["jobNumber"] as? String {
                self.jobNumber = value
            }
            if let value = dict["joinTime"] as? Int64 {
                self.joinTime = value
            }
            if let value = dict["lastVisitTime"] as? Int64 {
                self.lastVisitTime = value
            }
            if let value = dict["mobile"] as? String {
                self.mobile = value
            }
            if let value = dict["organizationMemberName"] as? String {
                self.organizationMemberName = value
            }
            if let value = dict["organizationRoleId"] as? String {
                self.organizationRoleId = value
            }
            if let value = dict["organizationRoleName"] as? String {
                self.organizationRoleName = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var member: GetOrganizationMemberResponseBody.Member?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.member?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.member != nil {
            map["member"] = self.member?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["member"] as? [String: Any?] {
            var model = GetOrganizationMemberResponseBody.Member()
            model.fromMap(value)
            self.member = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetOrganizationMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOrganizationMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetOrganizationMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public class PipelineConfig : Tea.TeaModel {
            public class Sources : Tea.TeaModel {
                public class Data : Tea.TeaModel {
                    public var branch: String?

                    public var cloneDepth: Int64?

                    public var credentialId: Int64?

                    public var credentialLabel: String?

                    public var credentialType: String?

                    public var events: [String]?

                    public var isBranchMode: Bool?

                    public var isCloneDepth: Bool?

                    public var isSubmodule: Bool?

                    public var isTrigger: Bool?

                    public var label: String?

                    public var namespace: String?

                    public var repo: String?

                    public var serviceConnectionId: Int64?

                    public var triggerFilter: String?

                    public var webhook: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.branch != nil {
                            map["branch"] = self.branch!
                        }
                        if self.cloneDepth != nil {
                            map["cloneDepth"] = self.cloneDepth!
                        }
                        if self.credentialId != nil {
                            map["credentialId"] = self.credentialId!
                        }
                        if self.credentialLabel != nil {
                            map["credentialLabel"] = self.credentialLabel!
                        }
                        if self.credentialType != nil {
                            map["credentialType"] = self.credentialType!
                        }
                        if self.events != nil {
                            map["events"] = self.events!
                        }
                        if self.isBranchMode != nil {
                            map["isBranchMode"] = self.isBranchMode!
                        }
                        if self.isCloneDepth != nil {
                            map["isCloneDepth"] = self.isCloneDepth!
                        }
                        if self.isSubmodule != nil {
                            map["isSubmodule"] = self.isSubmodule!
                        }
                        if self.isTrigger != nil {
                            map["isTrigger"] = self.isTrigger!
                        }
                        if self.label != nil {
                            map["label"] = self.label!
                        }
                        if self.namespace != nil {
                            map["namespace"] = self.namespace!
                        }
                        if self.repo != nil {
                            map["repo"] = self.repo!
                        }
                        if self.serviceConnectionId != nil {
                            map["serviceConnectionId"] = self.serviceConnectionId!
                        }
                        if self.triggerFilter != nil {
                            map["triggerFilter"] = self.triggerFilter!
                        }
                        if self.webhook != nil {
                            map["webhook"] = self.webhook!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["branch"] as? String {
                            self.branch = value
                        }
                        if let value = dict["cloneDepth"] as? Int64 {
                            self.cloneDepth = value
                        }
                        if let value = dict["credentialId"] as? Int64 {
                            self.credentialId = value
                        }
                        if let value = dict["credentialLabel"] as? String {
                            self.credentialLabel = value
                        }
                        if let value = dict["credentialType"] as? String {
                            self.credentialType = value
                        }
                        if let value = dict["events"] as? [String] {
                            self.events = value
                        }
                        if let value = dict["isBranchMode"] as? Bool {
                            self.isBranchMode = value
                        }
                        if let value = dict["isCloneDepth"] as? Bool {
                            self.isCloneDepth = value
                        }
                        if let value = dict["isSubmodule"] as? Bool {
                            self.isSubmodule = value
                        }
                        if let value = dict["isTrigger"] as? Bool {
                            self.isTrigger = value
                        }
                        if let value = dict["label"] as? String {
                            self.label = value
                        }
                        if let value = dict["namespace"] as? String {
                            self.namespace = value
                        }
                        if let value = dict["repo"] as? String {
                            self.repo = value
                        }
                        if let value = dict["serviceConnectionId"] as? Int64 {
                            self.serviceConnectionId = value
                        }
                        if let value = dict["triggerFilter"] as? String {
                            self.triggerFilter = value
                        }
                        if let value = dict["webhook"] as? String {
                            self.webhook = value
                        }
                    }
                }
                public var data: GetPipelineResponseBody.Pipeline.PipelineConfig.Sources.Data?

                public var sign: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.data?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.data != nil {
                        map["data"] = self.data?.toMap()
                    }
                    if self.sign != nil {
                        map["sign"] = self.sign!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["data"] as? [String: Any?] {
                        var model = GetPipelineResponseBody.Pipeline.PipelineConfig.Sources.Data()
                        model.fromMap(value)
                        self.data = model
                    }
                    if let value = dict["sign"] as? String {
                        self.sign = value
                    }
                    if let value = dict["type"] as? String {
                        self.type = value
                    }
                }
            }
            public var flow: String?

            public var settings: String?

            public var sources: [GetPipelineResponseBody.Pipeline.PipelineConfig.Sources]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.flow != nil {
                    map["flow"] = self.flow!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                if self.sources != nil {
                    var tmp : [Any] = []
                    for k in self.sources! {
                        tmp.append(k.toMap())
                    }
                    map["sources"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["flow"] as? String {
                    self.flow = value
                }
                if let value = dict["settings"] as? String {
                    self.settings = value
                }
                if let value = dict["sources"] as? [Any?] {
                    var tmp : [GetPipelineResponseBody.Pipeline.PipelineConfig.Sources] = []
                    for v in value {
                        if v != nil {
                            var model = GetPipelineResponseBody.Pipeline.PipelineConfig.Sources()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.sources = tmp
                }
            }
        }
        public class TagList : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public var createTime: Int64?

        public var creatorAccountId: String?

        public var envId: Int32?

        public var envName: String?

        public var groupId: Int64?

        public var modifierAccountId: String?

        public var name: String?

        public var pipelineConfig: GetPipelineResponseBody.Pipeline.PipelineConfig?

        public var tagList: [GetPipelineResponseBody.Pipeline.TagList]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pipelineConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.envId != nil {
                map["envId"] = self.envId!
            }
            if self.envName != nil {
                map["envName"] = self.envName!
            }
            if self.groupId != nil {
                map["groupId"] = self.groupId!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.pipelineConfig != nil {
                map["pipelineConfig"] = self.pipelineConfig?.toMap()
            }
            if self.tagList != nil {
                var tmp : [Any] = []
                for k in self.tagList! {
                    tmp.append(k.toMap())
                }
                map["tagList"] = tmp
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["creatorAccountId"] as? String {
                self.creatorAccountId = value
            }
            if let value = dict["envId"] as? Int32 {
                self.envId = value
            }
            if let value = dict["envName"] as? String {
                self.envName = value
            }
            if let value = dict["groupId"] as? Int64 {
                self.groupId = value
            }
            if let value = dict["modifierAccountId"] as? String {
                self.modifierAccountId = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["pipelineConfig"] as? [String: Any?] {
                var model = GetPipelineResponseBody.Pipeline.PipelineConfig()
                model.fromMap(value)
                self.pipelineConfig = model
            }
            if let value = dict["tagList"] as? [Any?] {
                var tmp : [GetPipelineResponseBody.Pipeline.TagList] = []
                for v in value {
                    if v != nil {
                        var model = GetPipelineResponseBody.Pipeline.TagList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagList = tmp
            }
            if let value = dict["updateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var pipeline: GetPipelineResponseBody.Pipeline?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipeline != nil {
            map["pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["pipeline"] as? [String: Any?] {
            var model = GetPipelineResponseBody.Pipeline()
            model.fromMap(value)
            self.pipeline = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPipelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPipelineArtifactUrlRequest : Tea.TeaModel {
    public var fileName: String?

    public var filePath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["fileName"] = self.fileName!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["fileName"] as? String {
            self.fileName = value
        }
        if let value = dict["filePath"] as? String {
            self.filePath = value
        }
    }
}

public class GetPipelineArtifactUrlResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var fileUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.fileUrl != nil {
            map["fileUrl"] = self.fileUrl!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["fileUrl"] as? String {
            self.fileUrl = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetPipelineArtifactUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineArtifactUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPipelineArtifactUrlResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPipelineEmasArtifactUrlRequest : Tea.TeaModel {
    public var serviceConnectionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serviceConnectionId != nil {
            map["serviceConnectionId"] = self.serviceConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["serviceConnectionId"] as? Int64 {
            self.serviceConnectionId = value
        }
    }
}

public class GetPipelineEmasArtifactUrlResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var fileUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.fileUrl != nil {
            map["fileUrl"] = self.fileUrl!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["fileUrl"] as? String {
            self.fileUrl = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetPipelineEmasArtifactUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineEmasArtifactUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPipelineEmasArtifactUrlResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPipelineGroupResponseBody : Tea.TeaModel {
    public class PipelineGroup : Tea.TeaModel {
        public var createTime: Int64?

        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelineGroup: GetPipelineGroupResponseBody.PipelineGroup?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipelineGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelineGroup != nil {
            map["pipelineGroup"] = self.pipelineGroup?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["pipelineGroup"] as? [String: Any?] {
            var model = GetPipelineGroupResponseBody.PipelineGroup()
            model.fromMap(value)
            self.pipelineGroup = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetPipelineGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPipelineGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPipelineRunResponseBody : Tea.TeaModel {
    public class PipelineRun : Tea.TeaModel {
        public class Sources : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var branch: String?

                public var commint: String?

                public var repo: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.branch != nil {
                        map["branch"] = self.branch!
                    }
                    if self.commint != nil {
                        map["commint"] = self.commint!
                    }
                    if self.repo != nil {
                        map["repo"] = self.repo!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["branch"] as? String {
                        self.branch = value
                    }
                    if let value = dict["commint"] as? String {
                        self.commint = value
                    }
                    if let value = dict["repo"] as? String {
                        self.repo = value
                    }
                }
            }
            public var data: GetPipelineRunResponseBody.PipelineRun.Sources.Data?

            public var sign: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.data?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data?.toMap()
                }
                if self.sign != nil {
                    map["sign"] = self.sign!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["data"] as? [String: Any?] {
                    var model = GetPipelineRunResponseBody.PipelineRun.Sources.Data()
                    model.fromMap(value)
                    self.data = model
                }
                if let value = dict["sign"] as? String {
                    self.sign = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public class Stages : Tea.TeaModel {
            public class StageInfo : Tea.TeaModel {
                public class Jobs : Tea.TeaModel {
                    public class Actions : Tea.TeaModel {
                        public var disable: Bool?

                        public var params: [String: Any]?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.disable != nil {
                                map["disable"] = self.disable!
                            }
                            if self.params != nil {
                                map["params"] = self.params!
                            }
                            if self.type != nil {
                                map["type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["disable"] as? Bool {
                                self.disable = value
                            }
                            if let value = dict["params"] as? [String: Any] {
                                self.params = value
                            }
                            if let value = dict["type"] as? String {
                                self.type = value
                            }
                        }
                    }
                    public var actions: [GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs.Actions]?

                    public var endTime: Int64?

                    public var id: Int64?

                    public var name: String?

                    public var params: String?

                    public var startTime: Int64?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.actions != nil {
                            var tmp : [Any] = []
                            for k in self.actions! {
                                tmp.append(k.toMap())
                            }
                            map["actions"] = tmp
                        }
                        if self.endTime != nil {
                            map["endTime"] = self.endTime!
                        }
                        if self.id != nil {
                            map["id"] = self.id!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.params != nil {
                            map["params"] = self.params!
                        }
                        if self.startTime != nil {
                            map["startTime"] = self.startTime!
                        }
                        if self.status != nil {
                            map["status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["actions"] as? [Any?] {
                            var tmp : [GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs.Actions] = []
                            for v in value {
                                if v != nil {
                                    var model = GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs.Actions()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.actions = tmp
                        }
                        if let value = dict["endTime"] as? Int64 {
                            self.endTime = value
                        }
                        if let value = dict["id"] as? Int64 {
                            self.id = value
                        }
                        if let value = dict["name"] as? String {
                            self.name = value
                        }
                        if let value = dict["params"] as? String {
                            self.params = value
                        }
                        if let value = dict["startTime"] as? Int64 {
                            self.startTime = value
                        }
                        if let value = dict["status"] as? String {
                            self.status = value
                        }
                    }
                }
                public var endTime: Int64?

                public var jobs: [GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs]?

                public var name: String?

                public var startTime: Int64?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["endTime"] = self.endTime!
                    }
                    if self.jobs != nil {
                        var tmp : [Any] = []
                        for k in self.jobs! {
                            tmp.append(k.toMap())
                        }
                        map["jobs"] = tmp
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.startTime != nil {
                        map["startTime"] = self.startTime!
                    }
                    if self.status != nil {
                        map["status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["endTime"] as? Int64 {
                        self.endTime = value
                    }
                    if let value = dict["jobs"] as? [Any?] {
                        var tmp : [GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs] = []
                        for v in value {
                            if v != nil {
                                var model = GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.jobs = tmp
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["startTime"] as? Int64 {
                        self.startTime = value
                    }
                    if let value = dict["status"] as? String {
                        self.status = value
                    }
                }
            }
            public var name: String?

            public var stageInfo: GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.stageInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.stageInfo != nil {
                    map["stageInfo"] = self.stageInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["stageInfo"] as? [String: Any?] {
                    var model = GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo()
                    model.fromMap(value)
                    self.stageInfo = model
                }
            }
        }
        public var createTime: Int64?

        public var creatorAccountId: String?

        public var modifierAccountId: String?

        public var pipelineId: Int64?

        public var pipelineRunId: Int64?

        public var sources: [GetPipelineRunResponseBody.PipelineRun.Sources]?

        public var stageGroup: [[String]]?

        public var stages: [GetPipelineRunResponseBody.PipelineRun.Stages]?

        public var status: String?

        public var triggerMode: Int32?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineRunId != nil {
                map["pipelineRunId"] = self.pipelineRunId!
            }
            if self.sources != nil {
                var tmp : [Any] = []
                for k in self.sources! {
                    tmp.append(k.toMap())
                }
                map["sources"] = tmp
            }
            if self.stageGroup != nil {
                map["stageGroup"] = self.stageGroup!
            }
            if self.stages != nil {
                var tmp : [Any] = []
                for k in self.stages! {
                    tmp.append(k.toMap())
                }
                map["stages"] = tmp
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.triggerMode != nil {
                map["triggerMode"] = self.triggerMode!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["creatorAccountId"] as? String {
                self.creatorAccountId = value
            }
            if let value = dict["modifierAccountId"] as? String {
                self.modifierAccountId = value
            }
            if let value = dict["pipelineId"] as? Int64 {
                self.pipelineId = value
            }
            if let value = dict["pipelineRunId"] as? Int64 {
                self.pipelineRunId = value
            }
            if let value = dict["sources"] as? [Any?] {
                var tmp : [GetPipelineRunResponseBody.PipelineRun.Sources] = []
                for v in value {
                    if v != nil {
                        var model = GetPipelineRunResponseBody.PipelineRun.Sources()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sources = tmp
            }
            if let value = dict["stageGroup"] as? [[String]] {
                self.stageGroup = value
            }
            if let value = dict["stages"] as? [Any?] {
                var tmp : [GetPipelineRunResponseBody.PipelineRun.Stages] = []
                for v in value {
                    if v != nil {
                        var model = GetPipelineRunResponseBody.PipelineRun.Stages()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.stages = tmp
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["triggerMode"] as? Int32 {
                self.triggerMode = value
            }
            if let value = dict["updateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelineRun: GetPipelineRunResponseBody.PipelineRun?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipelineRun?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelineRun != nil {
            map["pipelineRun"] = self.pipelineRun?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["pipelineRun"] as? [String: Any?] {
            var model = GetPipelineRunResponseBody.PipelineRun()
            model.fromMap(value)
            self.pipelineRun = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetPipelineRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPipelineRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPipelineScanReportUrlRequest : Tea.TeaModel {
    public var reportPath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportPath != nil {
            map["reportPath"] = self.reportPath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["reportPath"] as? String {
            self.reportPath = value
        }
    }
}

public class GetPipelineScanReportUrlResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var reportUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.reportUrl != nil {
            map["reportUrl"] = self.reportUrl!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["reportUrl"] as? String {
            self.reportUrl = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetPipelineScanReportUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineScanReportUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPipelineScanReportUrlResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetProjectInfoResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var category: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var customCode: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var icon: String?

        public var iconBig: String?

        public var iconGroup: String?

        public var iconSmall: String?

        public var id: String?

        public var identifier: String?

        public var identifierPath: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var name: String?

        public var organizationIdentifier: String?

        public var parentIdentifier: String?

        public var scope: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subType: String?

        public var typeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["category"] = self.category!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.customCode != nil {
                map["customCode"] = self.customCode!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.icon != nil {
                map["icon"] = self.icon!
            }
            if self.iconBig != nil {
                map["iconBig"] = self.iconBig!
            }
            if self.iconGroup != nil {
                map["iconGroup"] = self.iconGroup!
            }
            if self.iconSmall != nil {
                map["iconSmall"] = self.iconSmall!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.identifierPath != nil {
                map["identifierPath"] = self.identifierPath!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationIdentifier != nil {
                map["organizationIdentifier"] = self.organizationIdentifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subType != nil {
                map["subType"] = self.subType!
            }
            if self.typeIdentifier != nil {
                map["typeIdentifier"] = self.typeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["category"] as? String {
                self.category = value
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["customCode"] as? String {
                self.customCode = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["icon"] as? String {
                self.icon = value
            }
            if let value = dict["iconBig"] as? String {
                self.iconBig = value
            }
            if let value = dict["iconGroup"] as? String {
                self.iconGroup = value
            }
            if let value = dict["iconSmall"] as? String {
                self.iconSmall = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["identifierPath"] as? String {
                self.identifierPath = value
            }
            if let value = dict["logicalStatus"] as? String {
                self.logicalStatus = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["organizationIdentifier"] as? String {
                self.organizationIdentifier = value
            }
            if let value = dict["parentIdentifier"] as? String {
                self.parentIdentifier = value
            }
            if let value = dict["scope"] as? String {
                self.scope = value
            }
            if let value = dict["statusIdentifier"] as? String {
                self.statusIdentifier = value
            }
            if let value = dict["statusStageIdentifier"] as? String {
                self.statusStageIdentifier = value
            }
            if let value = dict["subType"] as? String {
                self.subType = value
            }
            if let value = dict["typeIdentifier"] as? String {
                self.typeIdentifier = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var project: GetProjectInfoResponseBody.Project?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.project != nil {
            map["project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["project"] as? [String: Any?] {
            var model = GetProjectInfoResponseBody.Project()
            model.fromMap(value)
            self.project = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetProjectInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetProjectInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetProjectMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class GetProjectMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["email"] as? String {
                self.email = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetProjectMemberResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetProjectMemberResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetProjectMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetReleaseStagePipelineRunRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class GetReleaseStagePipelineRunResponseBody : Tea.TeaModel {
    public class PipelineRun : Tea.TeaModel {
        public class Sources : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var branch: String?

                public var commit: String?

                public var repo: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.branch != nil {
                        map["branch"] = self.branch!
                    }
                    if self.commit != nil {
                        map["commit"] = self.commit!
                    }
                    if self.repo != nil {
                        map["repo"] = self.repo!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["branch"] as? String {
                        self.branch = value
                    }
                    if let value = dict["commit"] as? String {
                        self.commit = value
                    }
                    if let value = dict["repo"] as? String {
                        self.repo = value
                    }
                }
            }
            public var data: GetReleaseStagePipelineRunResponseBody.PipelineRun.Sources.Data?

            public var sign: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.data?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data?.toMap()
                }
                if self.sign != nil {
                    map["sign"] = self.sign!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["data"] as? [String: Any?] {
                    var model = GetReleaseStagePipelineRunResponseBody.PipelineRun.Sources.Data()
                    model.fromMap(value)
                    self.data = model
                }
                if let value = dict["sign"] as? String {
                    self.sign = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public class Stages : Tea.TeaModel {
            public class StageInfo : Tea.TeaModel {
                public class Jobs : Tea.TeaModel {
                    public class Actions : Tea.TeaModel {
                        public var disable: Bool?

                        public var params: Any?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.disable != nil {
                                map["disable"] = self.disable!
                            }
                            if self.params != nil {
                                map["params"] = self.params!
                            }
                            if self.type != nil {
                                map["type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["disable"] as? Bool {
                                self.disable = value
                            }
                            if let value = dict["params"] as? Any {
                                self.params = value
                            }
                            if let value = dict["type"] as? String {
                                self.type = value
                            }
                        }
                    }
                    public var actions: [GetReleaseStagePipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs.Actions]?

                    public var endTime: Int64?

                    public var id: Int64?

                    public var name: String?

                    public var params: String?

                    public var startTime: Int64?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.actions != nil {
                            var tmp : [Any] = []
                            for k in self.actions! {
                                tmp.append(k.toMap())
                            }
                            map["actions"] = tmp
                        }
                        if self.endTime != nil {
                            map["endTime"] = self.endTime!
                        }
                        if self.id != nil {
                            map["id"] = self.id!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.params != nil {
                            map["params"] = self.params!
                        }
                        if self.startTime != nil {
                            map["startTime"] = self.startTime!
                        }
                        if self.status != nil {
                            map["status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["actions"] as? [Any?] {
                            var tmp : [GetReleaseStagePipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs.Actions] = []
                            for v in value {
                                if v != nil {
                                    var model = GetReleaseStagePipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs.Actions()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.actions = tmp
                        }
                        if let value = dict["endTime"] as? Int64 {
                            self.endTime = value
                        }
                        if let value = dict["id"] as? Int64 {
                            self.id = value
                        }
                        if let value = dict["name"] as? String {
                            self.name = value
                        }
                        if let value = dict["params"] as? String {
                            self.params = value
                        }
                        if let value = dict["startTime"] as? Int64 {
                            self.startTime = value
                        }
                        if let value = dict["status"] as? String {
                            self.status = value
                        }
                    }
                }
                public var endTime: Int64?

                public var jobs: [GetReleaseStagePipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs]?

                public var name: String?

                public var startTime: Int64?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["endTime"] = self.endTime!
                    }
                    if self.jobs != nil {
                        var tmp : [Any] = []
                        for k in self.jobs! {
                            tmp.append(k.toMap())
                        }
                        map["jobs"] = tmp
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.startTime != nil {
                        map["startTime"] = self.startTime!
                    }
                    if self.status != nil {
                        map["status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["endTime"] as? Int64 {
                        self.endTime = value
                    }
                    if let value = dict["jobs"] as? [Any?] {
                        var tmp : [GetReleaseStagePipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs] = []
                        for v in value {
                            if v != nil {
                                var model = GetReleaseStagePipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.jobs = tmp
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["startTime"] as? Int64 {
                        self.startTime = value
                    }
                    if let value = dict["status"] as? String {
                        self.status = value
                    }
                }
            }
            public var name: String?

            public var stageInfo: GetReleaseStagePipelineRunResponseBody.PipelineRun.Stages.StageInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.stageInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.stageInfo != nil {
                    map["stageInfo"] = self.stageInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["stageInfo"] as? [String: Any?] {
                    var model = GetReleaseStagePipelineRunResponseBody.PipelineRun.Stages.StageInfo()
                    model.fromMap(value)
                    self.stageInfo = model
                }
            }
        }
        public var createTime: Int64?

        public var creatorAccountId: String?

        public var modifierAccountId: String?

        public var pipelineId: Int64?

        public var pipelineRunId: Int64?

        public var sources: [GetReleaseStagePipelineRunResponseBody.PipelineRun.Sources]?

        public var stageGroup: [[String]]?

        public var stages: [GetReleaseStagePipelineRunResponseBody.PipelineRun.Stages]?

        public var status: String?

        public var triggerMode: Int32?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineRunId != nil {
                map["pipelineRunId"] = self.pipelineRunId!
            }
            if self.sources != nil {
                var tmp : [Any] = []
                for k in self.sources! {
                    tmp.append(k.toMap())
                }
                map["sources"] = tmp
            }
            if self.stageGroup != nil {
                map["stageGroup"] = self.stageGroup!
            }
            if self.stages != nil {
                var tmp : [Any] = []
                for k in self.stages! {
                    tmp.append(k.toMap())
                }
                map["stages"] = tmp
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.triggerMode != nil {
                map["triggerMode"] = self.triggerMode!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["creatorAccountId"] as? String {
                self.creatorAccountId = value
            }
            if let value = dict["modifierAccountId"] as? String {
                self.modifierAccountId = value
            }
            if let value = dict["pipelineId"] as? Int64 {
                self.pipelineId = value
            }
            if let value = dict["pipelineRunId"] as? Int64 {
                self.pipelineRunId = value
            }
            if let value = dict["sources"] as? [Any?] {
                var tmp : [GetReleaseStagePipelineRunResponseBody.PipelineRun.Sources] = []
                for v in value {
                    if v != nil {
                        var model = GetReleaseStagePipelineRunResponseBody.PipelineRun.Sources()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sources = tmp
            }
            if let value = dict["stageGroup"] as? [[String]] {
                self.stageGroup = value
            }
            if let value = dict["stages"] as? [Any?] {
                var tmp : [GetReleaseStagePipelineRunResponseBody.PipelineRun.Stages] = []
                for v in value {
                    if v != nil {
                        var model = GetReleaseStagePipelineRunResponseBody.PipelineRun.Stages()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.stages = tmp
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["triggerMode"] as? Int32 {
                self.triggerMode = value
            }
            if let value = dict["updateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var pipelineRun: GetReleaseStagePipelineRunResponseBody.PipelineRun?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipelineRun?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineRun != nil {
            map["pipelineRun"] = self.pipelineRun?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["pipelineRun"] as? [String: Any?] {
            var model = GetReleaseStagePipelineRunResponseBody.PipelineRun()
            model.fromMap(value)
            self.pipelineRun = model
        }
    }
}

public class GetReleaseStagePipelineRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetReleaseStagePipelineRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetReleaseStagePipelineRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRepositoryRequest : Tea.TeaModel {
    public var accessToken: String?

    public var identity: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.identity != nil {
            map["identity"] = self.identity!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["identity"] as? String {
            self.identity = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class GetRepositoryResponseBody : Tea.TeaModel {
    public class Repository : Tea.TeaModel {
        public class Namespace : Tea.TeaModel {
            public var avatar: String?

            public var createdAt: String?

            public var description_: String?

            public var id: Int64?

            public var name: String?

            public var ownerId: Int64?

            public var path: String?

            public var updatedAt: String?

            public var visibilityLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.ownerId != nil {
                    map["ownerId"] = self.ownerId!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.updatedAt != nil {
                    map["updatedAt"] = self.updatedAt!
                }
                if self.visibilityLevel != nil {
                    map["visibilityLevel"] = self.visibilityLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatar"] as? String {
                    self.avatar = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["description"] as? String {
                    self.description_ = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["ownerId"] as? Int64 {
                    self.ownerId = value
                }
                if let value = dict["path"] as? String {
                    self.path = value
                }
                if let value = dict["updatedAt"] as? String {
                    self.updatedAt = value
                }
                if let value = dict["visibilityLevel"] as? Int32 {
                    self.visibilityLevel = value
                }
            }
        }
        public var archive: Bool?

        public var avatarUrl: String?

        public var createdAt: String?

        public var creatorId: Int64?

        public var defaultBranch: String?

        public var demoProjectStatus: Bool?

        public var description_: String?

        public var httpUrlToRepository: String?

        public var id: Int64?

        public var lastActivityAt: String?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespace: GetRepositoryResponseBody.Repository.Namespace?

        public var path: String?

        public var pathWithNamespace: String?

        public var sshUrlToRepository: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.namespace?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archive != nil {
                map["archive"] = self.archive!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.defaultBranch != nil {
                map["defaultBranch"] = self.defaultBranch!
            }
            if self.demoProjectStatus != nil {
                map["demoProjectStatus"] = self.demoProjectStatus!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.httpUrlToRepository != nil {
                map["httpUrlToRepository"] = self.httpUrlToRepository!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespace != nil {
                map["namespace"] = self.namespace?.toMap()
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.sshUrlToRepository != nil {
                map["sshUrlToRepository"] = self.sshUrlToRepository!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["archive"] as? Bool {
                self.archive = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["creatorId"] as? Int64 {
                self.creatorId = value
            }
            if let value = dict["defaultBranch"] as? String {
                self.defaultBranch = value
            }
            if let value = dict["demoProjectStatus"] as? Bool {
                self.demoProjectStatus = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["httpUrlToRepository"] as? String {
                self.httpUrlToRepository = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["lastActivityAt"] as? String {
                self.lastActivityAt = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["namespace"] as? [String: Any?] {
                var model = GetRepositoryResponseBody.Repository.Namespace()
                model.fromMap(value)
                self.namespace = model
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["pathWithNamespace"] as? String {
                self.pathWithNamespace = value
            }
            if let value = dict["sshUrlToRepository"] as? String {
                self.sshUrlToRepository = value
            }
            if let value = dict["visibilityLevel"] as? Int32 {
                self.visibilityLevel = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var repository: GetRepositoryResponseBody.Repository?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.repository?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.repository != nil {
            map["repository"] = self.repository?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["repository"] as? [String: Any?] {
            var model = GetRepositoryResponseBody.Repository()
            model.fromMap(value)
            self.repository = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRepositoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRepositoryCommitRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var showSignature: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.showSignature != nil {
            map["showSignature"] = self.showSignature!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["showSignature"] as? Bool {
            self.showSignature = value
        }
    }
}

public class GetRepositoryCommitResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
                if let value = dict["websiteUrl"] as? String {
                    self.websiteUrl = value
                }
            }
        }
        public class Committer : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
                if let value = dict["websiteUrl"] as? String {
                    self.websiteUrl = value
                }
            }
        }
        public class Signature : Tea.TeaModel {
            public var gpgKeyId: String?

            public var verificationStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gpgKeyId != nil {
                    map["gpgKeyId"] = self.gpgKeyId!
                }
                if self.verificationStatus != nil {
                    map["verificationStatus"] = self.verificationStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["gpgKeyId"] as? String {
                    self.gpgKeyId = value
                }
                if let value = dict["verificationStatus"] as? String {
                    self.verificationStatus = value
                }
            }
        }
        public var author: GetRepositoryCommitResponseBody.Result.Author?

        public var authorEmail: String?

        public var authorName: String?

        public var authoredDate: String?

        public var commentsCount: Int64?

        public var committedDate: String?

        public var committer: GetRepositoryCommitResponseBody.Result.Committer?

        public var committerEmail: String?

        public var committerName: String?

        public var createdAt: String?

        public var id: String?

        public var message: String?

        public var parentIds: [String]?

        public var shortId: String?

        public var signature: GetRepositoryCommitResponseBody.Result.Signature?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.committer?.validate()
            try self.signature?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.authorEmail != nil {
                map["authorEmail"] = self.authorEmail!
            }
            if self.authorName != nil {
                map["authorName"] = self.authorName!
            }
            if self.authoredDate != nil {
                map["authoredDate"] = self.authoredDate!
            }
            if self.commentsCount != nil {
                map["commentsCount"] = self.commentsCount!
            }
            if self.committedDate != nil {
                map["committedDate"] = self.committedDate!
            }
            if self.committer != nil {
                map["committer"] = self.committer?.toMap()
            }
            if self.committerEmail != nil {
                map["committerEmail"] = self.committerEmail!
            }
            if self.committerName != nil {
                map["committerName"] = self.committerName!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.parentIds != nil {
                map["parentIds"] = self.parentIds!
            }
            if self.shortId != nil {
                map["shortId"] = self.shortId!
            }
            if self.signature != nil {
                map["signature"] = self.signature?.toMap()
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["author"] as? [String: Any?] {
                var model = GetRepositoryCommitResponseBody.Result.Author()
                model.fromMap(value)
                self.author = model
            }
            if let value = dict["authorEmail"] as? String {
                self.authorEmail = value
            }
            if let value = dict["authorName"] as? String {
                self.authorName = value
            }
            if let value = dict["authoredDate"] as? String {
                self.authoredDate = value
            }
            if let value = dict["commentsCount"] as? Int64 {
                self.commentsCount = value
            }
            if let value = dict["committedDate"] as? String {
                self.committedDate = value
            }
            if let value = dict["committer"] as? [String: Any?] {
                var model = GetRepositoryCommitResponseBody.Result.Committer()
                model.fromMap(value)
                self.committer = model
            }
            if let value = dict["committerEmail"] as? String {
                self.committerEmail = value
            }
            if let value = dict["committerName"] as? String {
                self.committerName = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["message"] as? String {
                self.message = value
            }
            if let value = dict["parentIds"] as? [String] {
                self.parentIds = value
            }
            if let value = dict["shortId"] as? String {
                self.shortId = value
            }
            if let value = dict["signature"] as? [String: Any?] {
                var model = GetRepositoryCommitResponseBody.Result.Signature()
                model.fromMap(value)
                self.signature = model
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetRepositoryCommitResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetRepositoryCommitResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetRepositoryCommitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRepositoryCommitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRepositoryCommitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRepositoryTagRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var tagName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.tagName != nil {
            map["tagName"] = self.tagName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["tagName"] as? String {
            self.tagName = value
        }
    }
}

public class GetRepositoryTagResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public class Signature : Tea.TeaModel {
                public var gpgKeyId: String?

                public var verificationStatus: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gpgKeyId != nil {
                        map["gpgKeyId"] = self.gpgKeyId!
                    }
                    if self.verificationStatus != nil {
                        map["verificationStatus"] = self.verificationStatus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["gpgKeyId"] as? String {
                        self.gpgKeyId = value
                    }
                    if let value = dict["verificationStatus"] as? String {
                        self.verificationStatus = value
                    }
                }
            }
            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var committedDate: String?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var signature: GetRepositoryTagResponseBody.Result.Commit.Signature?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.signature?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.signature != nil {
                    map["signature"] = self.signature?.toMap()
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["authorEmail"] as? String {
                    self.authorEmail = value
                }
                if let value = dict["authorName"] as? String {
                    self.authorName = value
                }
                if let value = dict["authoredDate"] as? String {
                    self.authoredDate = value
                }
                if let value = dict["committedDate"] as? String {
                    self.committedDate = value
                }
                if let value = dict["committerEmail"] as? String {
                    self.committerEmail = value
                }
                if let value = dict["committerName"] as? String {
                    self.committerName = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["parentIds"] as? [String] {
                    self.parentIds = value
                }
                if let value = dict["shortId"] as? String {
                    self.shortId = value
                }
                if let value = dict["signature"] as? [String: Any?] {
                    var model = GetRepositoryTagResponseBody.Result.Commit.Signature()
                    model.fromMap(value)
                    self.signature = model
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public var commit: GetRepositoryTagResponseBody.Result.Commit?

        public var id: String?

        public var message: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["commit"] as? [String: Any?] {
                var model = GetRepositoryTagResponseBody.Result.Commit()
                model.fromMap(value)
                self.commit = model
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["message"] as? String {
                self.message = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetRepositoryTagResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetRepositoryTagResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetRepositoryTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRepositoryTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRepositoryTagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSearchCodePreviewRequest : Tea.TeaModel {
    public var docId: String?

    public var isDsl: Bool?

    public var keyword: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.docId != nil {
            map["docId"] = self.docId!
        }
        if self.isDsl != nil {
            map["isDsl"] = self.isDsl!
        }
        if self.keyword != nil {
            map["keyword"] = self.keyword!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["docId"] as? String {
            self.docId = value
        }
        if let value = dict["isDsl"] as? Bool {
            self.isDsl = value
        }
        if let value = dict["keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class GetSearchCodePreviewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class HighlightTextMap : Tea.TeaModel {
            public var clob: String?

            public var fileName: String?

            public var organizationId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clob != nil {
                    map["clob"] = self.clob!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["clob"] as? String {
                    self.clob = value
                }
                if let value = dict["fileName"] as? String {
                    self.fileName = value
                }
                if let value = dict["organizationId"] as? String {
                    self.organizationId = value
                }
            }
        }
        public class Source : Tea.TeaModel {
            public var branch: String?

            public var checkinDate: String?

            public var fileName: String?

            public var filePath: String?

            public var language: String?

            public var organizationId: String?

            public var repoPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.branch != nil {
                    map["branch"] = self.branch!
                }
                if self.checkinDate != nil {
                    map["checkinDate"] = self.checkinDate!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                if self.filePath != nil {
                    map["filePath"] = self.filePath!
                }
                if self.language != nil {
                    map["language"] = self.language!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.repoPath != nil {
                    map["repoPath"] = self.repoPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["branch"] as? String {
                    self.branch = value
                }
                if let value = dict["checkinDate"] as? String {
                    self.checkinDate = value
                }
                if let value = dict["fileName"] as? String {
                    self.fileName = value
                }
                if let value = dict["filePath"] as? String {
                    self.filePath = value
                }
                if let value = dict["language"] as? String {
                    self.language = value
                }
                if let value = dict["organizationId"] as? String {
                    self.organizationId = value
                }
                if let value = dict["repoPath"] as? String {
                    self.repoPath = value
                }
            }
        }
        public var docId: String?

        public var highlightTextMap: GetSearchCodePreviewResponseBody.Result.HighlightTextMap?

        public var source: GetSearchCodePreviewResponseBody.Result.Source?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.highlightTextMap?.validate()
            try self.source?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.docId != nil {
                map["docId"] = self.docId!
            }
            if self.highlightTextMap != nil {
                map["highlightTextMap"] = self.highlightTextMap?.toMap()
            }
            if self.source != nil {
                map["source"] = self.source?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["docId"] as? String {
                self.docId = value
            }
            if let value = dict["highlightTextMap"] as? [String: Any?] {
                var model = GetSearchCodePreviewResponseBody.Result.HighlightTextMap()
                model.fromMap(value)
                self.highlightTextMap = model
            }
            if let value = dict["source"] as? [String: Any?] {
                var model = GetSearchCodePreviewResponseBody.Result.Source()
                model.fromMap(value)
                self.source = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetSearchCodePreviewResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetSearchCodePreviewResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetSearchCodePreviewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSearchCodePreviewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSearchCodePreviewResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSprintInfoResponseBody : Tea.TeaModel {
    public class Sprint : Tea.TeaModel {
        public var creator: String?

        public var description_: String?

        public var endDate: Int64?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var owners: [String]?

        public var scope: String?

        public var spaceIdentifier: String?

        public var startDate: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endDate != nil {
                map["endDate"] = self.endDate!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.owners != nil {
                map["owners"] = self.owners!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.startDate != nil {
                map["startDate"] = self.startDate!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["endDate"] as? Int64 {
                self.endDate = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["owners"] as? [String] {
                self.owners = value
            }
            if let value = dict["scope"] as? String {
                self.scope = value
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["startDate"] as? Int64 {
                self.startDate = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sprint: GetSprintInfoResponseBody.Sprint?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sprint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.sprint != nil {
            map["sprint"] = self.sprint?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["sprint"] as? [String: Any?] {
            var model = GetSprintInfoResponseBody.Sprint()
            model.fromMap(value)
            self.sprint = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetSprintInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSprintInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSprintInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTestResultListRequest : Tea.TeaModel {
    public var conditions: String?

    public var directoryIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditions != nil {
            map["conditions"] = self.conditions!
        }
        if self.directoryIdentifier != nil {
            map["directoryIdentifier"] = self.directoryIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["conditions"] as? String {
            self.conditions = value
        }
        if let value = dict["directoryIdentifier"] as? String {
            self.directoryIdentifier = value
        }
    }
}

public class GetTestResultListResponseBody : Tea.TeaModel {
    public class TestResult : Tea.TeaModel {
        public class AssignedTo : Tea.TeaModel {
            public var assignedToIdenttifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assignedToIdenttifier != nil {
                    map["assignedToIdenttifier"] = self.assignedToIdenttifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["assignedToIdenttifier"] as? String {
                    self.assignedToIdenttifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public class CustomFields : Tea.TeaModel {
            public var fieldClassName: String?

            public var fieldFormat: String?

            public var fieldIdentifier: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldClassName != nil {
                    map["fieldClassName"] = self.fieldClassName!
                }
                if self.fieldFormat != nil {
                    map["fieldFormat"] = self.fieldFormat!
                }
                if self.fieldIdentifier != nil {
                    map["fieldIdentifier"] = self.fieldIdentifier!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fieldClassName"] as? String {
                    self.fieldClassName = value
                }
                if let value = dict["fieldFormat"] as? String {
                    self.fieldFormat = value
                }
                if let value = dict["fieldIdentifier"] as? String {
                    self.fieldIdentifier = value
                }
                if let value = dict["value"] as? String {
                    self.value = value
                }
            }
        }
        public class TestResultExecutor : Tea.TeaModel {
            public var executorIdentifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.executorIdentifier != nil {
                    map["executorIdentifier"] = self.executorIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["executorIdentifier"] as? String {
                    self.executorIdentifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public var assignedTo: GetTestResultListResponseBody.TestResult.AssignedTo?

        public var bugCount: Int64?

        public var categoryIdentifier: String?

        public var customFields: [GetTestResultListResponseBody.TestResult.CustomFields]?

        public var gmtCreate: Int64?

        public var spaceIdentifier: String?

        public var subject: String?

        public var testResultExecutor: GetTestResultListResponseBody.TestResult.TestResultExecutor?

        public var testResultGmtCreate: Int64?

        public var testResultIdentifier: String?

        public var testResultStatus: String?

        public var testcaseIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.assignedTo?.validate()
            try self.testResultExecutor?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo?.toMap()
            }
            if self.bugCount != nil {
                map["bugCount"] = self.bugCount!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.customFields != nil {
                var tmp : [Any] = []
                for k in self.customFields! {
                    tmp.append(k.toMap())
                }
                map["customFields"] = tmp
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.testResultExecutor != nil {
                map["testResultExecutor"] = self.testResultExecutor?.toMap()
            }
            if self.testResultGmtCreate != nil {
                map["testResultGmtCreate"] = self.testResultGmtCreate!
            }
            if self.testResultIdentifier != nil {
                map["testResultIdentifier"] = self.testResultIdentifier!
            }
            if self.testResultStatus != nil {
                map["testResultStatus"] = self.testResultStatus!
            }
            if self.testcaseIdentifier != nil {
                map["testcaseIdentifier"] = self.testcaseIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedTo"] as? [String: Any?] {
                var model = GetTestResultListResponseBody.TestResult.AssignedTo()
                model.fromMap(value)
                self.assignedTo = model
            }
            if let value = dict["bugCount"] as? Int64 {
                self.bugCount = value
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["customFields"] as? [Any?] {
                var tmp : [GetTestResultListResponseBody.TestResult.CustomFields] = []
                for v in value {
                    if v != nil {
                        var model = GetTestResultListResponseBody.TestResult.CustomFields()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.customFields = tmp
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
            if let value = dict["testResultExecutor"] as? [String: Any?] {
                var model = GetTestResultListResponseBody.TestResult.TestResultExecutor()
                model.fromMap(value)
                self.testResultExecutor = model
            }
            if let value = dict["testResultGmtCreate"] as? Int64 {
                self.testResultGmtCreate = value
            }
            if let value = dict["testResultIdentifier"] as? String {
                self.testResultIdentifier = value
            }
            if let value = dict["testResultStatus"] as? String {
                self.testResultStatus = value
            }
            if let value = dict["testcaseIdentifier"] as? String {
                self.testcaseIdentifier = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var testResult: [GetTestResultListResponseBody.TestResult]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.testResult != nil {
            var tmp : [Any] = []
            for k in self.testResult! {
                tmp.append(k.toMap())
            }
            map["testResult"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["testResult"] as? [Any?] {
            var tmp : [GetTestResultListResponseBody.TestResult] = []
            for v in value {
                if v != nil {
                    var model = GetTestResultListResponseBody.TestResult()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.testResult = tmp
        }
    }
}

public class GetTestResultListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTestResultListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTestResultListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTestcaseListRequest : Tea.TeaModel {
    public var conditions: String?

    public var directoryIdentifier: String?

    public var maxResult: String?

    public var nextToken: String?

    public var spaceIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditions != nil {
            map["conditions"] = self.conditions!
        }
        if self.directoryIdentifier != nil {
            map["directoryIdentifier"] = self.directoryIdentifier!
        }
        if self.maxResult != nil {
            map["maxResult"] = self.maxResult!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["conditions"] as? String {
            self.conditions = value
        }
        if let value = dict["directoryIdentifier"] as? String {
            self.directoryIdentifier = value
        }
        if let value = dict["maxResult"] as? String {
            self.maxResult = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["spaceIdentifier"] as? String {
            self.spaceIdentifier = value
        }
    }
}

public class GetTestcaseListResponseBody : Tea.TeaModel {
    public class Testcase : Tea.TeaModel {
        public class AssignedTo : Tea.TeaModel {
            public var assignedToIdenttifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assignedToIdenttifier != nil {
                    map["assignedToIdenttifier"] = self.assignedToIdenttifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["assignedToIdenttifier"] as? String {
                    self.assignedToIdenttifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public class CustomFields : Tea.TeaModel {
            public var fieldClassName: String?

            public var fieldFormat: String?

            public var fieldIdentifier: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldClassName != nil {
                    map["fieldClassName"] = self.fieldClassName!
                }
                if self.fieldFormat != nil {
                    map["fieldFormat"] = self.fieldFormat!
                }
                if self.fieldIdentifier != nil {
                    map["fieldIdentifier"] = self.fieldIdentifier!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fieldClassName"] as? String {
                    self.fieldClassName = value
                }
                if let value = dict["fieldFormat"] as? String {
                    self.fieldFormat = value
                }
                if let value = dict["fieldIdentifier"] as? String {
                    self.fieldIdentifier = value
                }
                if let value = dict["value"] as? String {
                    self.value = value
                }
            }
        }
        public class Space : Tea.TeaModel {
            public var spaceIdentifier: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.spaceIdentifier != nil {
                    map["spaceIdentifier"] = self.spaceIdentifier!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["spaceIdentifier"] as? String {
                    self.spaceIdentifier = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var name: String?

            public var tagIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.tagIdentifier != nil {
                    map["tagIdentifier"] = self.tagIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["tagIdentifier"] as? String {
                    self.tagIdentifier = value
                }
            }
        }
        public var assignedTo: GetTestcaseListResponseBody.Testcase.AssignedTo?

        public var categoryIdentifier: String?

        public var customFields: [GetTestcaseListResponseBody.Testcase.CustomFields]?

        public var gmtCreate: Int64?

        public var identifier: String?

        public var space: GetTestcaseListResponseBody.Testcase.Space?

        public var subject: String?

        public var tags: [GetTestcaseListResponseBody.Testcase.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.assignedTo?.validate()
            try self.space?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo?.toMap()
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.customFields != nil {
                var tmp : [Any] = []
                for k in self.customFields! {
                    tmp.append(k.toMap())
                }
                map["customFields"] = tmp
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.space != nil {
                map["space"] = self.space?.toMap()
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedTo"] as? [String: Any?] {
                var model = GetTestcaseListResponseBody.Testcase.AssignedTo()
                model.fromMap(value)
                self.assignedTo = model
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["customFields"] as? [Any?] {
                var tmp : [GetTestcaseListResponseBody.Testcase.CustomFields] = []
                for v in value {
                    if v != nil {
                        var model = GetTestcaseListResponseBody.Testcase.CustomFields()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.customFields = tmp
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["space"] as? [String: Any?] {
                var model = GetTestcaseListResponseBody.Testcase.Space()
                model.fromMap(value)
                self.space = model
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
            if let value = dict["tags"] as? [Any?] {
                var tmp : [GetTestcaseListResponseBody.Testcase.Tags] = []
                for v in value {
                    if v != nil {
                        var model = GetTestcaseListResponseBody.Testcase.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var testcase: [GetTestcaseListResponseBody.Testcase]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.testcase != nil {
            var tmp : [Any] = []
            for k in self.testcase! {
                tmp.append(k.toMap())
            }
            map["testcase"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["testcase"] as? [Any?] {
            var tmp : [GetTestcaseListResponseBody.Testcase] = []
            for v in value {
                if v != nil {
                    var model = GetTestcaseListResponseBody.Testcase()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.testcase = tmp
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class GetTestcaseListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTestcaseListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTestcaseListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetUserInfoRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class GetUserInfoResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var name: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["email"] as? String {
                self.email = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["username"] as? String {
                self.username = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetUserInfoResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = GetUserInfoResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetUserInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetUserInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetVMDeployOrderResponseBody : Tea.TeaModel {
    public class DeployOrder : Tea.TeaModel {
        public class Actions : Tea.TeaModel {
            public var disable: Bool?

            public var params: Any?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disable != nil {
                    map["disable"] = self.disable!
                }
                if self.params != nil {
                    map["params"] = self.params!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["disable"] as? Bool {
                    self.disable = value
                }
                if let value = dict["params"] as? Any {
                    self.params = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public class DeployMachineInfo : Tea.TeaModel {
            public class DeployMachines : Tea.TeaModel {
                public class Actions : Tea.TeaModel {
                    public var disable: Bool?

                    public var params: Any?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.disable != nil {
                            map["disable"] = self.disable!
                        }
                        if self.params != nil {
                            map["params"] = self.params!
                        }
                        if self.type != nil {
                            map["type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["disable"] as? Bool {
                            self.disable = value
                        }
                        if let value = dict["params"] as? Any {
                            self.params = value
                        }
                        if let value = dict["type"] as? String {
                            self.type = value
                        }
                    }
                }
                public var actions: [GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines.Actions]?

                public var batchNum: Int32?

                public var clientStatus: String?

                public var createTime: Int64?

                public var ip: String?

                public var machineSn: String?

                public var status: String?

                public var updateTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.actions != nil {
                        var tmp : [Any] = []
                        for k in self.actions! {
                            tmp.append(k.toMap())
                        }
                        map["actions"] = tmp
                    }
                    if self.batchNum != nil {
                        map["batchNum"] = self.batchNum!
                    }
                    if self.clientStatus != nil {
                        map["clientStatus"] = self.clientStatus!
                    }
                    if self.createTime != nil {
                        map["createTime"] = self.createTime!
                    }
                    if self.ip != nil {
                        map["ip"] = self.ip!
                    }
                    if self.machineSn != nil {
                        map["machineSn"] = self.machineSn!
                    }
                    if self.status != nil {
                        map["status"] = self.status!
                    }
                    if self.updateTime != nil {
                        map["updateTime"] = self.updateTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["actions"] as? [Any?] {
                        var tmp : [GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines.Actions] = []
                        for v in value {
                            if v != nil {
                                var model = GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines.Actions()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.actions = tmp
                    }
                    if let value = dict["batchNum"] as? Int32 {
                        self.batchNum = value
                    }
                    if let value = dict["clientStatus"] as? String {
                        self.clientStatus = value
                    }
                    if let value = dict["createTime"] as? Int64 {
                        self.createTime = value
                    }
                    if let value = dict["ip"] as? String {
                        self.ip = value
                    }
                    if let value = dict["machineSn"] as? String {
                        self.machineSn = value
                    }
                    if let value = dict["status"] as? String {
                        self.status = value
                    }
                    if let value = dict["updateTime"] as? Int64 {
                        self.updateTime = value
                    }
                }
            }
            public var batchNum: Int32?

            public var deployMachines: [GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines]?

            public var hostGroupId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchNum != nil {
                    map["batchNum"] = self.batchNum!
                }
                if self.deployMachines != nil {
                    var tmp : [Any] = []
                    for k in self.deployMachines! {
                        tmp.append(k.toMap())
                    }
                    map["deployMachines"] = tmp
                }
                if self.hostGroupId != nil {
                    map["hostGroupId"] = self.hostGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["batchNum"] as? Int32 {
                    self.batchNum = value
                }
                if let value = dict["deployMachines"] as? [Any?] {
                    var tmp : [GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines] = []
                    for v in value {
                        if v != nil {
                            var model = GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.deployMachines = tmp
                }
                if let value = dict["hostGroupId"] as? Int64 {
                    self.hostGroupId = value
                }
            }
        }
        public var actions: [GetVMDeployOrderResponseBody.DeployOrder.Actions]?

        public var createTime: Int64?

        public var creator: String?

        public var currentBatch: Int32?

        public var deployMachineInfo: GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo?

        public var deployOrderId: String?

        public var exceptionCode: String?

        public var status: String?

        public var totalBatch: Int32?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.deployMachineInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actions != nil {
                var tmp : [Any] = []
                for k in self.actions! {
                    tmp.append(k.toMap())
                }
                map["actions"] = tmp
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.currentBatch != nil {
                map["currentBatch"] = self.currentBatch!
            }
            if self.deployMachineInfo != nil {
                map["deployMachineInfo"] = self.deployMachineInfo?.toMap()
            }
            if self.deployOrderId != nil {
                map["deployOrderId"] = self.deployOrderId!
            }
            if self.exceptionCode != nil {
                map["exceptionCode"] = self.exceptionCode!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.totalBatch != nil {
                map["totalBatch"] = self.totalBatch!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["actions"] as? [Any?] {
                var tmp : [GetVMDeployOrderResponseBody.DeployOrder.Actions] = []
                for v in value {
                    if v != nil {
                        var model = GetVMDeployOrderResponseBody.DeployOrder.Actions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.actions = tmp
            }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["currentBatch"] as? Int32 {
                self.currentBatch = value
            }
            if let value = dict["deployMachineInfo"] as? [String: Any?] {
                var model = GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo()
                model.fromMap(value)
                self.deployMachineInfo = model
            }
            if let value = dict["deployOrderId"] as? String {
                self.deployOrderId = value
            }
            if let value = dict["exceptionCode"] as? String {
                self.exceptionCode = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["totalBatch"] as? Int32 {
                self.totalBatch = value
            }
            if let value = dict["updateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var deployOrder: GetVMDeployOrderResponseBody.DeployOrder?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployOrder?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployOrder != nil {
            map["deployOrder"] = self.deployOrder?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["deployOrder"] as? [String: Any?] {
            var model = GetVMDeployOrderResponseBody.DeployOrder()
            model.fromMap(value)
            self.deployOrder = model
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetVMDeployOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVMDeployOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetVMDeployOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetVariableGroupResponseBody : Tea.TeaModel {
    public class VariableGroup : Tea.TeaModel {
        public class RelatedPipelines : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public class Variables : Tea.TeaModel {
            public var isEncrypted: Bool?

            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isEncrypted != nil {
                    map["isEncrypted"] = self.isEncrypted!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["isEncrypted"] as? Bool {
                    self.isEncrypted = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["value"] as? String {
                    self.value = value
                }
            }
        }
        public var ccreatorAccountId: String?

        public var createTime: Int64?

        public var description_: String?

        public var id: Int64?

        public var modifierAccountId: String?

        public var name: String?

        public var relatedPipelines: [GetVariableGroupResponseBody.VariableGroup.RelatedPipelines]?

        public var updateTime: Int64?

        public var variables: [GetVariableGroupResponseBody.VariableGroup.Variables]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ccreatorAccountId != nil {
                map["ccreatorAccountId"] = self.ccreatorAccountId!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.relatedPipelines != nil {
                var tmp : [Any] = []
                for k in self.relatedPipelines! {
                    tmp.append(k.toMap())
                }
                map["relatedPipelines"] = tmp
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.variables != nil {
                var tmp : [Any] = []
                for k in self.variables! {
                    tmp.append(k.toMap())
                }
                map["variables"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ccreatorAccountId"] as? String {
                self.ccreatorAccountId = value
            }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["modifierAccountId"] as? String {
                self.modifierAccountId = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["relatedPipelines"] as? [Any?] {
                var tmp : [GetVariableGroupResponseBody.VariableGroup.RelatedPipelines] = []
                for v in value {
                    if v != nil {
                        var model = GetVariableGroupResponseBody.VariableGroup.RelatedPipelines()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.relatedPipelines = tmp
            }
            if let value = dict["updateTime"] as? Int64 {
                self.updateTime = value
            }
            if let value = dict["variables"] as? [Any?] {
                var tmp : [GetVariableGroupResponseBody.VariableGroup.Variables] = []
                for v in value {
                    if v != nil {
                        var model = GetVariableGroupResponseBody.VariableGroup.Variables()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.variables = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var variableGroup: GetVariableGroupResponseBody.VariableGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.variableGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.variableGroup != nil {
            map["variableGroup"] = self.variableGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["variableGroup"] as? [String: Any?] {
            var model = GetVariableGroupResponseBody.VariableGroup()
            model.fromMap(value)
            self.variableGroup = model
        }
    }
}

public class GetVariableGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVariableGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetVariableGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWorkItemActivityResponseBody : Tea.TeaModel {
    public class Activities : Tea.TeaModel {
        public class NewValue : Tea.TeaModel {
            public var displayValue: String?

            public var plainValue: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayValue != nil {
                    map["displayValue"] = self.displayValue!
                }
                if self.plainValue != nil {
                    map["plainValue"] = self.plainValue!
                }
                if self.resourceType != nil {
                    map["resourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["displayValue"] as? String {
                    self.displayValue = value
                }
                if let value = dict["plainValue"] as? String {
                    self.plainValue = value
                }
                if let value = dict["resourceType"] as? String {
                    self.resourceType = value
                }
            }
        }
        public class OldValue : Tea.TeaModel {
            public var displayValue: String?

            public var plainValue: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayValue != nil {
                    map["displayValue"] = self.displayValue!
                }
                if self.plainValue != nil {
                    map["plainValue"] = self.plainValue!
                }
                if self.resourceType != nil {
                    map["resourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["displayValue"] as? String {
                    self.displayValue = value
                }
                if let value = dict["plainValue"] as? String {
                    self.plainValue = value
                }
                if let value = dict["resourceType"] as? String {
                    self.resourceType = value
                }
            }
        }
        public class Property : Tea.TeaModel {
            public var displayName: String?

            public var propertyIdentifier: String?

            public var propertyName: String?

            public var propertyType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.propertyIdentifier != nil {
                    map["propertyIdentifier"] = self.propertyIdentifier!
                }
                if self.propertyName != nil {
                    map["propertyName"] = self.propertyName!
                }
                if self.propertyType != nil {
                    map["propertyType"] = self.propertyType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["displayName"] as? String {
                    self.displayName = value
                }
                if let value = dict["propertyIdentifier"] as? String {
                    self.propertyIdentifier = value
                }
                if let value = dict["propertyName"] as? String {
                    self.propertyName = value
                }
                if let value = dict["propertyType"] as? String {
                    self.propertyType = value
                }
            }
        }
        public var actionType: String?

        public var eventId: Int64?

        public var eventTime: Int64?

        public var eventType: String?

        public var newValue: [GetWorkItemActivityResponseBody.Activities.NewValue]?

        public var oldValue: [GetWorkItemActivityResponseBody.Activities.OldValue]?

        public var operator_: String?

        public var parentEventId: Int64?

        public var property: GetWorkItemActivityResponseBody.Activities.Property?

        public var resourceIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.property?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionType != nil {
                map["actionType"] = self.actionType!
            }
            if self.eventId != nil {
                map["eventId"] = self.eventId!
            }
            if self.eventTime != nil {
                map["eventTime"] = self.eventTime!
            }
            if self.eventType != nil {
                map["eventType"] = self.eventType!
            }
            if self.newValue != nil {
                var tmp : [Any] = []
                for k in self.newValue! {
                    tmp.append(k.toMap())
                }
                map["newValue"] = tmp
            }
            if self.oldValue != nil {
                var tmp : [Any] = []
                for k in self.oldValue! {
                    tmp.append(k.toMap())
                }
                map["oldValue"] = tmp
            }
            if self.operator_ != nil {
                map["operator"] = self.operator_!
            }
            if self.parentEventId != nil {
                map["parentEventId"] = self.parentEventId!
            }
            if self.property != nil {
                map["property"] = self.property?.toMap()
            }
            if self.resourceIdentifier != nil {
                map["resourceIdentifier"] = self.resourceIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["actionType"] as? String {
                self.actionType = value
            }
            if let value = dict["eventId"] as? Int64 {
                self.eventId = value
            }
            if let value = dict["eventTime"] as? Int64 {
                self.eventTime = value
            }
            if let value = dict["eventType"] as? String {
                self.eventType = value
            }
            if let value = dict["newValue"] as? [Any?] {
                var tmp : [GetWorkItemActivityResponseBody.Activities.NewValue] = []
                for v in value {
                    if v != nil {
                        var model = GetWorkItemActivityResponseBody.Activities.NewValue()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.newValue = tmp
            }
            if let value = dict["oldValue"] as? [Any?] {
                var tmp : [GetWorkItemActivityResponseBody.Activities.OldValue] = []
                for v in value {
                    if v != nil {
                        var model = GetWorkItemActivityResponseBody.Activities.OldValue()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.oldValue = tmp
            }
            if let value = dict["operator"] as? String {
                self.operator_ = value
            }
            if let value = dict["parentEventId"] as? Int64 {
                self.parentEventId = value
            }
            if let value = dict["property"] as? [String: Any?] {
                var model = GetWorkItemActivityResponseBody.Activities.Property()
                model.fromMap(value)
                self.property = model
            }
            if let value = dict["resourceIdentifier"] as? String {
                self.resourceIdentifier = value
            }
        }
    }
    public var activities: [GetWorkItemActivityResponseBody.Activities]?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activities != nil {
            var tmp : [Any] = []
            for k in self.activities! {
                tmp.append(k.toMap())
            }
            map["activities"] = tmp
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["activities"] as? [Any?] {
            var tmp : [GetWorkItemActivityResponseBody.Activities] = []
            for v in value {
                if v != nil {
                    var model = GetWorkItemActivityResponseBody.Activities()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.activities = tmp
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetWorkItemActivityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkItemActivityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWorkItemActivityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWorkItemInfoResponseBody : Tea.TeaModel {
    public class Workitem : Tea.TeaModel {
        public class CustomFields : Tea.TeaModel {
            public class ValueList : Tea.TeaModel {
                public var displayValue: String?

                public var identifier: String?

                public var level: Int64?

                public var value: String?

                public var valueEn: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.displayValue != nil {
                        map["displayValue"] = self.displayValue!
                    }
                    if self.identifier != nil {
                        map["identifier"] = self.identifier!
                    }
                    if self.level != nil {
                        map["level"] = self.level!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    if self.valueEn != nil {
                        map["valueEn"] = self.valueEn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["displayValue"] as? String {
                        self.displayValue = value
                    }
                    if let value = dict["identifier"] as? String {
                        self.identifier = value
                    }
                    if let value = dict["level"] as? Int64 {
                        self.level = value
                    }
                    if let value = dict["value"] as? String {
                        self.value = value
                    }
                    if let value = dict["valueEn"] as? String {
                        self.valueEn = value
                    }
                }
            }
            public var fieldClassName: String?

            public var fieldFormat: String?

            public var fieldIdentifier: String?

            public var level: Int64?

            public var objectValue: String?

            public var position: Int64?

            public var value: String?

            public var valueList: [GetWorkItemInfoResponseBody.Workitem.CustomFields.ValueList]?

            public var workitemIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldClassName != nil {
                    map["fieldClassName"] = self.fieldClassName!
                }
                if self.fieldFormat != nil {
                    map["fieldFormat"] = self.fieldFormat!
                }
                if self.fieldIdentifier != nil {
                    map["fieldIdentifier"] = self.fieldIdentifier!
                }
                if self.level != nil {
                    map["level"] = self.level!
                }
                if self.objectValue != nil {
                    map["objectValue"] = self.objectValue!
                }
                if self.position != nil {
                    map["position"] = self.position!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                if self.valueList != nil {
                    var tmp : [Any] = []
                    for k in self.valueList! {
                        tmp.append(k.toMap())
                    }
                    map["valueList"] = tmp
                }
                if self.workitemIdentifier != nil {
                    map["workitemIdentifier"] = self.workitemIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fieldClassName"] as? String {
                    self.fieldClassName = value
                }
                if let value = dict["fieldFormat"] as? String {
                    self.fieldFormat = value
                }
                if let value = dict["fieldIdentifier"] as? String {
                    self.fieldIdentifier = value
                }
                if let value = dict["level"] as? Int64 {
                    self.level = value
                }
                if let value = dict["objectValue"] as? String {
                    self.objectValue = value
                }
                if let value = dict["position"] as? Int64 {
                    self.position = value
                }
                if let value = dict["value"] as? String {
                    self.value = value
                }
                if let value = dict["valueList"] as? [Any?] {
                    var tmp : [GetWorkItemInfoResponseBody.Workitem.CustomFields.ValueList] = []
                    for v in value {
                        if v != nil {
                            var model = GetWorkItemInfoResponseBody.Workitem.CustomFields.ValueList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.valueList = tmp
                }
                if let value = dict["workitemIdentifier"] as? String {
                    self.workitemIdentifier = value
                }
            }
        }
        public class TagDetails : Tea.TeaModel {
            public var color: String?

            public var identifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.color != nil {
                    map["color"] = self.color!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["color"] as? String {
                    self.color = value
                }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public class Versions : Tea.TeaModel {
            public var identifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var customFields: [GetWorkItemInfoResponseBody.Workitem.CustomFields]?

        public var document: String?

        public var documentFormat: String?

        public var finishTime: Int64?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var parentIdentifier: String?

        public var participant: [String]?

        public var serialNumber: String?

        public var spaceIdentifier: String?

        public var spaceName: String?

        public var spaceType: String?

        public var sprint: [String]?

        public var status: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subject: String?

        public var tag: [String]?

        public var tagDetails: [GetWorkItemInfoResponseBody.Workitem.TagDetails]?

        public var tracker: [String]?

        public var updateStatusAt: Int64?

        public var verifier: [String]?

        public var versions: [GetWorkItemInfoResponseBody.Workitem.Versions]?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.customFields != nil {
                var tmp : [Any] = []
                for k in self.customFields! {
                    tmp.append(k.toMap())
                }
                map["customFields"] = tmp
            }
            if self.document != nil {
                map["document"] = self.document!
            }
            if self.documentFormat != nil {
                map["documentFormat"] = self.documentFormat!
            }
            if self.finishTime != nil {
                map["finishTime"] = self.finishTime!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.participant != nil {
                map["participant"] = self.participant!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceName != nil {
                map["spaceName"] = self.spaceName!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.sprint != nil {
                map["sprint"] = self.sprint!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.tag != nil {
                map["tag"] = self.tag!
            }
            if self.tagDetails != nil {
                var tmp : [Any] = []
                for k in self.tagDetails! {
                    tmp.append(k.toMap())
                }
                map["tagDetails"] = tmp
            }
            if self.tracker != nil {
                map["tracker"] = self.tracker!
            }
            if self.updateStatusAt != nil {
                map["updateStatusAt"] = self.updateStatusAt!
            }
            if self.verifier != nil {
                map["verifier"] = self.verifier!
            }
            if self.versions != nil {
                var tmp : [Any] = []
                for k in self.versions! {
                    tmp.append(k.toMap())
                }
                map["versions"] = tmp
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedTo"] as? String {
                self.assignedTo = value
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["customFields"] as? [Any?] {
                var tmp : [GetWorkItemInfoResponseBody.Workitem.CustomFields] = []
                for v in value {
                    if v != nil {
                        var model = GetWorkItemInfoResponseBody.Workitem.CustomFields()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.customFields = tmp
            }
            if let value = dict["document"] as? String {
                self.document = value
            }
            if let value = dict["documentFormat"] as? String {
                self.documentFormat = value
            }
            if let value = dict["finishTime"] as? Int64 {
                self.finishTime = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["logicalStatus"] as? String {
                self.logicalStatus = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["parentIdentifier"] as? String {
                self.parentIdentifier = value
            }
            if let value = dict["participant"] as? [String] {
                self.participant = value
            }
            if let value = dict["serialNumber"] as? String {
                self.serialNumber = value
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["spaceName"] as? String {
                self.spaceName = value
            }
            if let value = dict["spaceType"] as? String {
                self.spaceType = value
            }
            if let value = dict["sprint"] as? [String] {
                self.sprint = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["statusIdentifier"] as? String {
                self.statusIdentifier = value
            }
            if let value = dict["statusStageIdentifier"] as? String {
                self.statusStageIdentifier = value
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
            if let value = dict["tag"] as? [String] {
                self.tag = value
            }
            if let value = dict["tagDetails"] as? [Any?] {
                var tmp : [GetWorkItemInfoResponseBody.Workitem.TagDetails] = []
                for v in value {
                    if v != nil {
                        var model = GetWorkItemInfoResponseBody.Workitem.TagDetails()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagDetails = tmp
            }
            if let value = dict["tracker"] as? [String] {
                self.tracker = value
            }
            if let value = dict["updateStatusAt"] as? Int64 {
                self.updateStatusAt = value
            }
            if let value = dict["verifier"] as? [String] {
                self.verifier = value
            }
            if let value = dict["versions"] as? [Any?] {
                var tmp : [GetWorkItemInfoResponseBody.Workitem.Versions] = []
                for v in value {
                    if v != nil {
                        var model = GetWorkItemInfoResponseBody.Workitem.Versions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.versions = tmp
            }
            if let value = dict["workitemTypeIdentifier"] as? String {
                self.workitemTypeIdentifier = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workitem: GetWorkItemInfoResponseBody.Workitem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitem != nil {
            map["workitem"] = self.workitem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["workitem"] as? [String: Any?] {
            var model = GetWorkItemInfoResponseBody.Workitem()
            model.fromMap(value)
            self.workitem = model
        }
    }
}

public class GetWorkItemInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkItemInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWorkItemInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWorkItemWorkFlowInfoRequest : Tea.TeaModel {
    public var configurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configurationId != nil {
            map["configurationId"] = self.configurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["configurationId"] as? String {
            self.configurationId = value
        }
    }
}

public class GetWorkItemWorkFlowInfoResponseBody : Tea.TeaModel {
    public class Workflow : Tea.TeaModel {
        public class Statuses : Tea.TeaModel {
            public var creator: String?

            public var description_: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var identifier: String?

            public var modifier: String?

            public var name: String?

            public var resourceType: String?

            public var source: String?

            public var workflowStageIdentifier: String?

            public var workflowStageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creator != nil {
                    map["creator"] = self.creator!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["gmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["gmtModified"] = self.gmtModified!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.modifier != nil {
                    map["modifier"] = self.modifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.resourceType != nil {
                    map["resourceType"] = self.resourceType!
                }
                if self.source != nil {
                    map["source"] = self.source!
                }
                if self.workflowStageIdentifier != nil {
                    map["workflowStageIdentifier"] = self.workflowStageIdentifier!
                }
                if self.workflowStageName != nil {
                    map["workflowStageName"] = self.workflowStageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["creator"] as? String {
                    self.creator = value
                }
                if let value = dict["description"] as? String {
                    self.description_ = value
                }
                if let value = dict["gmtCreate"] as? Int64 {
                    self.gmtCreate = value
                }
                if let value = dict["gmtModified"] as? Int64 {
                    self.gmtModified = value
                }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["modifier"] as? String {
                    self.modifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["resourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["source"] as? String {
                    self.source = value
                }
                if let value = dict["workflowStageIdentifier"] as? String {
                    self.workflowStageIdentifier = value
                }
                if let value = dict["workflowStageName"] as? String {
                    self.workflowStageName = value
                }
            }
        }
        public class WorkflowActions : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public var nextWorkflowStatusIdentifier: String?

            public var workflowIdentifier: String?

            public var workflowStatusIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.nextWorkflowStatusIdentifier != nil {
                    map["nextWorkflowStatusIdentifier"] = self.nextWorkflowStatusIdentifier!
                }
                if self.workflowIdentifier != nil {
                    map["workflowIdentifier"] = self.workflowIdentifier!
                }
                if self.workflowStatusIdentifier != nil {
                    map["workflowStatusIdentifier"] = self.workflowStatusIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["nextWorkflowStatusIdentifier"] as? String {
                    self.nextWorkflowStatusIdentifier = value
                }
                if let value = dict["workflowIdentifier"] as? String {
                    self.workflowIdentifier = value
                }
                if let value = dict["workflowStatusIdentifier"] as? String {
                    self.workflowStatusIdentifier = value
                }
            }
        }
        public var creator: String?

        public var defaultStatusIdentifier: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var ownerSpaceIdentifier: String?

        public var ownerSpaceType: String?

        public var resourceType: String?

        public var source: String?

        public var statusOrder: String?

        public var statuses: [GetWorkItemWorkFlowInfoResponseBody.Workflow.Statuses]?

        public var workflowActions: [GetWorkItemWorkFlowInfoResponseBody.Workflow.WorkflowActions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.defaultStatusIdentifier != nil {
                map["defaultStatusIdentifier"] = self.defaultStatusIdentifier!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerSpaceIdentifier != nil {
                map["ownerSpaceIdentifier"] = self.ownerSpaceIdentifier!
            }
            if self.ownerSpaceType != nil {
                map["ownerSpaceType"] = self.ownerSpaceType!
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.statusOrder != nil {
                map["statusOrder"] = self.statusOrder!
            }
            if self.statuses != nil {
                var tmp : [Any] = []
                for k in self.statuses! {
                    tmp.append(k.toMap())
                }
                map["statuses"] = tmp
            }
            if self.workflowActions != nil {
                var tmp : [Any] = []
                for k in self.workflowActions! {
                    tmp.append(k.toMap())
                }
                map["workflowActions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["defaultStatusIdentifier"] as? String {
                self.defaultStatusIdentifier = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["ownerSpaceIdentifier"] as? String {
                self.ownerSpaceIdentifier = value
            }
            if let value = dict["ownerSpaceType"] as? String {
                self.ownerSpaceType = value
            }
            if let value = dict["resourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["statusOrder"] as? String {
                self.statusOrder = value
            }
            if let value = dict["statuses"] as? [Any?] {
                var tmp : [GetWorkItemWorkFlowInfoResponseBody.Workflow.Statuses] = []
                for v in value {
                    if v != nil {
                        var model = GetWorkItemWorkFlowInfoResponseBody.Workflow.Statuses()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.statuses = tmp
            }
            if let value = dict["workflowActions"] as? [Any?] {
                var tmp : [GetWorkItemWorkFlowInfoResponseBody.Workflow.WorkflowActions] = []
                for v in value {
                    if v != nil {
                        var model = GetWorkItemWorkFlowInfoResponseBody.Workflow.WorkflowActions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.workflowActions = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workflow: GetWorkItemWorkFlowInfoResponseBody.Workflow?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workflow != nil {
            map["workflow"] = self.workflow?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["workflow"] as? [String: Any?] {
            var model = GetWorkItemWorkFlowInfoResponseBody.Workflow()
            model.fromMap(value)
            self.workflow = model
        }
    }
}

public class GetWorkItemWorkFlowInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkItemWorkFlowInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWorkItemWorkFlowInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWorkitemAttachmentCreatemetaRequest : Tea.TeaModel {
    public var fileName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["fileName"] = self.fileName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["fileName"] as? String {
            self.fileName = value
        }
    }
}

public class GetWorkitemAttachmentCreatemetaResponseBody : Tea.TeaModel {
    public class UploadInfo : Tea.TeaModel {
        public var accessid: String?

        public var dir: String?

        public var host: String?

        public var policy: String?

        public var signature: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessid != nil {
                map["accessid"] = self.accessid!
            }
            if self.dir != nil {
                map["dir"] = self.dir!
            }
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.policy != nil {
                map["policy"] = self.policy!
            }
            if self.signature != nil {
                map["signature"] = self.signature!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessid"] as? String {
                self.accessid = value
            }
            if let value = dict["dir"] as? String {
                self.dir = value
            }
            if let value = dict["host"] as? String {
                self.host = value
            }
            if let value = dict["policy"] as? String {
                self.policy = value
            }
            if let value = dict["signature"] as? String {
                self.signature = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: String?

    public var uploadInfo: GetWorkitemAttachmentCreatemetaResponseBody.UploadInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.uploadInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.uploadInfo != nil {
            map["uploadInfo"] = self.uploadInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
        if let value = dict["uploadInfo"] as? [String: Any?] {
            var model = GetWorkitemAttachmentCreatemetaResponseBody.UploadInfo()
            model.fromMap(value)
            self.uploadInfo = model
        }
    }
}

public class GetWorkitemAttachmentCreatemetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkitemAttachmentCreatemetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWorkitemAttachmentCreatemetaResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWorkitemCommentListResponseBody : Tea.TeaModel {
    public class CommentList : Tea.TeaModel {
        public class User : Tea.TeaModel {
            public var account: String?

            public var avatar: String?

            public var identifier: String?

            public var nickName: String?

            public var realName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["account"] = self.account!
                }
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.nickName != nil {
                    map["nickName"] = self.nickName!
                }
                if self.realName != nil {
                    map["realName"] = self.realName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["account"] as? String {
                    self.account = value
                }
                if let value = dict["avatar"] as? String {
                    self.avatar = value
                }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["nickName"] as? String {
                    self.nickName = value
                }
                if let value = dict["realName"] as? String {
                    self.realName = value
                }
            }
        }
        public var content: String?

        public var createTime: Int64?

        public var formatType: String?

        public var id: Int64?

        public var isTop: Bool?

        public var modifiedTime: Int64?

        public var parentId: Int64?

        public var targetIdentifier: String?

        public var targetType: String?

        public var topTime: Int64?

        public var user: GetWorkitemCommentListResponseBody.CommentList.User?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.user?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.formatType != nil {
                map["formatType"] = self.formatType!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isTop != nil {
                map["isTop"] = self.isTop!
            }
            if self.modifiedTime != nil {
                map["modifiedTime"] = self.modifiedTime!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.targetIdentifier != nil {
                map["targetIdentifier"] = self.targetIdentifier!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.topTime != nil {
                map["topTime"] = self.topTime!
            }
            if self.user != nil {
                map["user"] = self.user?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["formatType"] as? String {
                self.formatType = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["isTop"] as? Bool {
                self.isTop = value
            }
            if let value = dict["modifiedTime"] as? Int64 {
                self.modifiedTime = value
            }
            if let value = dict["parentId"] as? Int64 {
                self.parentId = value
            }
            if let value = dict["targetIdentifier"] as? String {
                self.targetIdentifier = value
            }
            if let value = dict["targetType"] as? String {
                self.targetType = value
            }
            if let value = dict["topTime"] as? Int64 {
                self.topTime = value
            }
            if let value = dict["user"] as? [String: Any?] {
                var model = GetWorkitemCommentListResponseBody.CommentList.User()
                model.fromMap(value)
                self.user = model
            }
        }
    }
    public var commentList: [GetWorkitemCommentListResponseBody.CommentList]?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commentList != nil {
            var tmp : [Any] = []
            for k in self.commentList! {
                tmp.append(k.toMap())
            }
            map["commentList"] = tmp
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["commentList"] as? [Any?] {
            var tmp : [GetWorkitemCommentListResponseBody.CommentList] = []
            for v in value {
                if v != nil {
                    var model = GetWorkitemCommentListResponseBody.CommentList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.commentList = tmp
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
    }
}

public class GetWorkitemCommentListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkitemCommentListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWorkitemCommentListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWorkitemFileResponseBody : Tea.TeaModel {
    public class WorkitemFile : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public var size: Int32?

        public var suffix: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.size != nil {
                map["size"] = self.size!
            }
            if self.suffix != nil {
                map["suffix"] = self.suffix!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["size"] as? Int32 {
                self.size = value
            }
            if let value = dict["suffix"] as? String {
                self.suffix = value
            }
            if let value = dict["url"] as? String {
                self.url = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public var workitemFile: GetWorkitemFileResponseBody.WorkitemFile?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitemFile?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitemFile != nil {
            map["workitemFile"] = self.workitemFile?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
        if let value = dict["workitemFile"] as? [String: Any?] {
            var model = GetWorkitemFileResponseBody.WorkitemFile()
            model.fromMap(value)
            self.workitemFile = model
        }
    }
}

public class GetWorkitemFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkitemFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWorkitemFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWorkitemRelationsRequest : Tea.TeaModel {
    public var relationType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relationType != nil {
            map["relationType"] = self.relationType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["relationType"] as? String {
            self.relationType = value
        }
    }
}

public class GetWorkitemRelationsResponseBody : Tea.TeaModel {
    public class RelationList : Tea.TeaModel {
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var identifier: String?

        public var spaceIdentifier: String?

        public var subject: String?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedTo"] as? String {
                self.assignedTo = value
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["gmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
            if let value = dict["workitemTypeIdentifier"] as? String {
                self.workitemTypeIdentifier = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var relationList: [GetWorkitemRelationsResponseBody.RelationList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.relationList != nil {
            var tmp : [Any] = []
            for k in self.relationList! {
                tmp.append(k.toMap())
            }
            map["relationList"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["relationList"] as? [Any?] {
            var tmp : [GetWorkitemRelationsResponseBody.RelationList] = []
            for v in value {
                if v != nil {
                    var model = GetWorkitemRelationsResponseBody.RelationList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.relationList = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GetWorkitemRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkitemRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWorkitemRelationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWorkitemTimeTypeListResponseBody : Tea.TeaModel {
    public class TimeType : Tea.TeaModel {
        public var description_: String?

        public var displayName: String?

        public var identifier: String?

        public var name: String?

        public var position: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.position != nil {
                map["position"] = self.position!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["displayName"] as? String {
                self.displayName = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["position"] as? Int64 {
                self.position = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public var timeType: [GetWorkitemTimeTypeListResponseBody.TimeType]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.timeType != nil {
            var tmp : [Any] = []
            for k in self.timeType! {
                tmp.append(k.toMap())
            }
            map["timeType"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
        if let value = dict["timeType"] as? [Any?] {
            var tmp : [GetWorkitemTimeTypeListResponseBody.TimeType] = []
            for v in value {
                if v != nil {
                    var model = GetWorkitemTimeTypeListResponseBody.TimeType()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.timeType = tmp
        }
    }
}

public class GetWorkitemTimeTypeListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkitemTimeTypeListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWorkitemTimeTypeListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class JoinPipelineGroupRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var pipelineIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["groupId"] = self.groupId!
        }
        if self.pipelineIds != nil {
            map["pipelineIds"] = self.pipelineIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["groupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["pipelineIds"] as? String {
            self.pipelineIds = value
        }
    }
}

public class JoinPipelineGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class JoinPipelineGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinPipelineGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = JoinPipelineGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class LinkMergeRequestLabelRequest : Tea.TeaModel {
    public var accessToken: String?

    public var labelIds: [String]?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.labelIds != nil {
            map["labelIds"] = self.labelIds!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["labelIds"] as? [String] {
            self.labelIds = value
        }
        if let value = dict["localId"] as? Int64 {
            self.localId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class LinkMergeRequestLabelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: LinkMergeRequestLabelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = LinkMergeRequestLabelResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class LinkMergeRequestLabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LinkMergeRequestLabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = LinkMergeRequestLabelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAllReleaseWorkflowsRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ListAllReleaseWorkflowsResponse : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public class ReleaseStages : Tea.TeaModel {
            public class VariableGroups : Tea.TeaModel {
                public var name: String?

                public var displayName: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.displayName != nil {
                        map["displayName"] = self.displayName!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["displayName"] as? String {
                        self.displayName = value
                    }
                    if let value = dict["type"] as? String {
                        self.type = value
                    }
                }
            }
            public var appName: String?

            public var name: String?

            public var sn: String?

            public var releaseWorkflowSn: String?

            public var order: String?

            public var variableGroups: [ListAllReleaseWorkflowsResponse.Body.ReleaseStages.VariableGroups]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["appName"] = self.appName!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sn != nil {
                    map["sn"] = self.sn!
                }
                if self.releaseWorkflowSn != nil {
                    map["releaseWorkflowSn"] = self.releaseWorkflowSn!
                }
                if self.order != nil {
                    map["order"] = self.order!
                }
                if self.variableGroups != nil {
                    var tmp : [Any] = []
                    for k in self.variableGroups! {
                        tmp.append(k.toMap())
                    }
                    map["variableGroups"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["appName"] as? String {
                    self.appName = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["sn"] as? String {
                    self.sn = value
                }
                if let value = dict["releaseWorkflowSn"] as? String {
                    self.releaseWorkflowSn = value
                }
                if let value = dict["order"] as? String {
                    self.order = value
                }
                if let value = dict["variableGroups"] as? [Any?] {
                    var tmp : [ListAllReleaseWorkflowsResponse.Body.ReleaseStages.VariableGroups] = []
                    for v in value {
                        if v != nil {
                            var model = ListAllReleaseWorkflowsResponse.Body.ReleaseStages.VariableGroups()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.variableGroups = tmp
                }
            }
        }
        public var appName: String?

        public var sn: String?

        public var name: String?

        public var order: String?

        public var releaseStages: [ListAllReleaseWorkflowsResponse.Body.ReleaseStages]?

        public var note: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["appName"] = self.appName!
            }
            if self.sn != nil {
                map["sn"] = self.sn!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.order != nil {
                map["order"] = self.order!
            }
            if self.releaseStages != nil {
                var tmp : [Any] = []
                for k in self.releaseStages! {
                    tmp.append(k.toMap())
                }
                map["releaseStages"] = tmp
            }
            if self.note != nil {
                map["note"] = self.note!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["appName"] as? String {
                self.appName = value
            }
            if let value = dict["sn"] as? String {
                self.sn = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["order"] as? String {
                self.order = value
            }
            if let value = dict["releaseStages"] as? [Any?] {
                var tmp : [ListAllReleaseWorkflowsResponse.Body.ReleaseStages] = []
                for v in value {
                    if v != nil {
                        var model = ListAllReleaseWorkflowsResponse.Body.ReleaseStages()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.releaseStages = tmp
            }
            if let value = dict["note"] as? String {
                self.note = value
            }
        }
    }
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: [ListAllReleaseWorkflowsResponse.Body]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [Any?] {
            var tmp : [ListAllReleaseWorkflowsResponse.Body] = []
            for v in value {
                if v != nil {
                    var model = ListAllReleaseWorkflowsResponse.Body()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.body = tmp
        }
    }
}

public class ListAppReleaseStageExecutionIntegratedMetadataRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ListAppReleaseStageExecutionIntegratedMetadataResponse : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public class ChangeRequests : Tea.TeaModel {
            public var sn: String?

            public var name: String?

            public var branchName: String?

            public var commitId: String?

            public var ownerAccountId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sn != nil {
                    map["sn"] = self.sn!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.branchName != nil {
                    map["branchName"] = self.branchName!
                }
                if self.commitId != nil {
                    map["commitId"] = self.commitId!
                }
                if self.ownerAccountId != nil {
                    map["ownerAccountId"] = self.ownerAccountId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["sn"] as? String {
                    self.sn = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["branchName"] as? String {
                    self.branchName = value
                }
                if let value = dict["commitId"] as? String {
                    self.commitId = value
                }
                if let value = dict["ownerAccountId"] as? String {
                    self.ownerAccountId = value
                }
            }
        }
        public var releaseBranch: String?

        public var releaseRevision: String?

        public var repoUrl: String?

        public var repoType: String?

        public var changeRequests: [ListAppReleaseStageExecutionIntegratedMetadataResponse.Body.ChangeRequests]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.releaseBranch != nil {
                map["releaseBranch"] = self.releaseBranch!
            }
            if self.releaseRevision != nil {
                map["releaseRevision"] = self.releaseRevision!
            }
            if self.repoUrl != nil {
                map["repoUrl"] = self.repoUrl!
            }
            if self.repoType != nil {
                map["repoType"] = self.repoType!
            }
            if self.changeRequests != nil {
                var tmp : [Any] = []
                for k in self.changeRequests! {
                    tmp.append(k.toMap())
                }
                map["changeRequests"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["releaseBranch"] as? String {
                self.releaseBranch = value
            }
            if let value = dict["releaseRevision"] as? String {
                self.releaseRevision = value
            }
            if let value = dict["repoUrl"] as? String {
                self.repoUrl = value
            }
            if let value = dict["repoType"] as? String {
                self.repoType = value
            }
            if let value = dict["changeRequests"] as? [Any?] {
                var tmp : [ListAppReleaseStageExecutionIntegratedMetadataResponse.Body.ChangeRequests] = []
                for v in value {
                    if v != nil {
                        var model = ListAppReleaseStageExecutionIntegratedMetadataResponse.Body.ChangeRequests()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.changeRequests = tmp
            }
        }
    }
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: [ListAppReleaseStageExecutionIntegratedMetadataResponse.Body]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [Any?] {
            var tmp : [ListAppReleaseStageExecutionIntegratedMetadataResponse.Body] = []
            for v in value {
                if v != nil {
                    var model = ListAppReleaseStageExecutionIntegratedMetadataResponse.Body()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.body = tmp
        }
    }
}

public class ListAppReleaseStageExecutionsRequest : Tea.TeaModel {
    public var nextToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int32?

    public var pagination: String?

    public var perPage: Int32?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pagination != nil {
            map["pagination"] = self.pagination!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["orderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["pagination"] as? String {
            self.pagination = value
        }
        if let value = dict["perPage"] as? Int32 {
            self.perPage = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
    }
}

public class ListAppReleaseStageExecutionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var endTime: String?

        public var number: String?

        public var startTime: String?

        public var state: String?

        public var triggerMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.number != nil {
                map["number"] = self.number!
            }
            if self.startTime != nil {
                map["startTime"] = self.startTime!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.triggerMode != nil {
                map["triggerMode"] = self.triggerMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["endTime"] as? String {
                self.endTime = value
            }
            if let value = dict["number"] as? String {
                self.number = value
            }
            if let value = dict["startTime"] as? String {
                self.startTime = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["triggerMode"] as? String {
                self.triggerMode = value
            }
        }
    }
    public var current: Int64?

    public var data: [ListAppReleaseStageExecutionsResponseBody.Data]?

    public var nextToken: String?

    public var pages: Int64?

    public var perPage: Int64?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["current"] = self.current!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pages != nil {
            map["pages"] = self.pages!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["current"] as? Int64 {
            self.current = value
        }
        if let value = dict["data"] as? [Any?] {
            var tmp : [ListAppReleaseStageExecutionsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListAppReleaseStageExecutionsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["pages"] as? Int64 {
            self.pages = value
        }
        if let value = dict["perPage"] as? Int64 {
            self.perPage = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListAppReleaseStageExecutionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppReleaseStageExecutionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAppReleaseStageExecutionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApplicationMembersRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ListApplicationMembersResponseBody : Tea.TeaModel {
    public class Records : Tea.TeaModel {
        public class RoleList : Tea.TeaModel {
            public var displayName: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["displayName"] as? String {
                    self.displayName = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public var avatar: String?

        public var description_: String?

        public var displayName: String?

        public var id: String?

        public var roleList: [ListApplicationMembersResponseBody.Records.RoleList]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatar != nil {
                map["avatar"] = self.avatar!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.roleList != nil {
                var tmp : [Any] = []
                for k in self.roleList! {
                    tmp.append(k.toMap())
                }
                map["roleList"] = tmp
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["avatar"] as? String {
                self.avatar = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["displayName"] as? String {
                self.displayName = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["roleList"] as? [Any?] {
                var tmp : [ListApplicationMembersResponseBody.Records.RoleList] = []
                for v in value {
                    if v != nil {
                        var model = ListApplicationMembersResponseBody.Records.RoleList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.roleList = tmp
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var current: Int64?

    public var pageSize: Int64?

    public var pages: Int64?

    public var records: [ListApplicationMembersResponseBody.Records]?

    public var requestId: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["current"] = self.current!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.pages != nil {
            map["pages"] = self.pages!
        }
        if self.records != nil {
            var tmp : [Any] = []
            for k in self.records! {
                tmp.append(k.toMap())
            }
            map["records"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["current"] as? Int64 {
            self.current = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["pages"] as? Int64 {
            self.pages = value
        }
        if let value = dict["records"] as? [Any?] {
            var tmp : [ListApplicationMembersResponseBody.Records] = []
            for v in value {
                if v != nil {
                    var model = ListApplicationMembersResponseBody.Records()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.records = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListApplicationMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApplicationMembersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApplicationsRequest : Tea.TeaModel {
    public var nextToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var pagination: String?

    public var perPage: Int32?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.pagination != nil {
            map["pagination"] = self.pagination!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["orderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["pagination"] as? String {
            self.pagination = value
        }
        if let value = dict["perPage"] as? Int32 {
            self.perPage = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
    }
}

public class ListApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var creatorAccountId: String?

        public var description_: String?

        public var gmtCreate: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["creatorAccountId"] as? String {
                self.creatorAccountId = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var data: [ListApplicationsResponseBody.Data]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["data"] as? [Any?] {
            var tmp : [ListApplicationsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListApplicationsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApplicationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListChangeRequestWorkflowExecutionsRequest : Tea.TeaModel {
    public var orderBy: String?

    public var organizationId: String?

    public var page: Int64?

    public var perPage: Int64?

    public var releaseStageSn: String?

    public var releaseWorkflowSn: String?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.releaseStageSn != nil {
            map["releaseStageSn"] = self.releaseStageSn!
        }
        if self.releaseWorkflowSn != nil {
            map["releaseWorkflowSn"] = self.releaseWorkflowSn!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["orderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["perPage"] as? Int64 {
            self.perPage = value
        }
        if let value = dict["releaseStageSn"] as? String {
            self.releaseStageSn = value
        }
        if let value = dict["releaseWorkflowSn"] as? String {
            self.releaseWorkflowSn = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
    }
}

public class ListChangeRequestWorkflowExecutionsResponseBody : Tea.TeaModel {
    public var current: Int64?

    public var pageSize: Int64?

    public var pages: Int64?

    public var records: [Any]?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["current"] = self.current!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.pages != nil {
            map["pages"] = self.pages!
        }
        if self.records != nil {
            map["records"] = self.records!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["current"] as? Int64 {
            self.current = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["pages"] as? Int64 {
            self.pages = value
        }
        if let value = dict["records"] as? [Any] {
            self.records = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListChangeRequestWorkflowExecutionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListChangeRequestWorkflowExecutionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListChangeRequestWorkflowExecutionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListChangeRequestsRequest : Tea.TeaModel {
    public var appNameList: [String]?

    public var displayNameKeyword: String?

    public var nextToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var ownerIdList: [String]?

    public var page: Int32?

    public var pagination: String?

    public var perPage: Int32?

    public var sort: String?

    public var stateList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appNameList != nil {
            map["appNameList"] = self.appNameList!
        }
        if self.displayNameKeyword != nil {
            map["displayNameKeyword"] = self.displayNameKeyword!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.ownerIdList != nil {
            map["ownerIdList"] = self.ownerIdList!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pagination != nil {
            map["pagination"] = self.pagination!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.stateList != nil {
            map["stateList"] = self.stateList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["appNameList"] as? [String] {
            self.appNameList = value
        }
        if let value = dict["displayNameKeyword"] as? String {
            self.displayNameKeyword = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["orderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["ownerIdList"] as? [String] {
            self.ownerIdList = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["pagination"] as? String {
            self.pagination = value
        }
        if let value = dict["perPage"] as? Int32 {
            self.perPage = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
        if let value = dict["stateList"] as? [String] {
            self.stateList = value
        }
    }
}

public class ListChangeRequestsShrinkRequest : Tea.TeaModel {
    public var appNameListShrink: String?

    public var displayNameKeyword: String?

    public var nextToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var ownerIdListShrink: String?

    public var page: Int32?

    public var pagination: String?

    public var perPage: Int32?

    public var sort: String?

    public var stateListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appNameListShrink != nil {
            map["appNameList"] = self.appNameListShrink!
        }
        if self.displayNameKeyword != nil {
            map["displayNameKeyword"] = self.displayNameKeyword!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.ownerIdListShrink != nil {
            map["ownerIdList"] = self.ownerIdListShrink!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pagination != nil {
            map["pagination"] = self.pagination!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.stateListShrink != nil {
            map["stateList"] = self.stateListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["appNameList"] as? String {
            self.appNameListShrink = value
        }
        if let value = dict["displayNameKeyword"] as? String {
            self.displayNameKeyword = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["orderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["ownerIdList"] as? String {
            self.ownerIdListShrink = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["pagination"] as? String {
            self.pagination = value
        }
        if let value = dict["perPage"] as? Int32 {
            self.perPage = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
        if let value = dict["stateList"] as? String {
            self.stateListShrink = value
        }
    }
}

public class ListChangeRequestsResponseBody : Tea.TeaModel {
    public var current: Int64?

    public var data: [Any]?

    public var nextToken: String?

    public var pages: Int64?

    public var perPage: Int64?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["current"] = self.current!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pages != nil {
            map["pages"] = self.pages!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["current"] as? Int64 {
            self.current = value
        }
        if let value = dict["data"] as? [Any] {
            self.data = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["pages"] as? Int64 {
            self.pages = value
        }
        if let value = dict["perPage"] as? Int64 {
            self.perPage = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListChangeRequestsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListChangeRequestsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListChangeRequestsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCheckRunsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var ref: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.ref != nil {
            map["ref"] = self.ref!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ref"] as? String {
            self.ref = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class ListCheckRunsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var annotationLevel: String?

            public var endColumn: Int64?

            public var endLine: Int64?

            public var id: Int64?

            public var message: String?

            public var path: String?

            public var rawDetails: String?

            public var startColumn: Int64?

            public var startLine: Int64?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotationLevel != nil {
                    map["annotationLevel"] = self.annotationLevel!
                }
                if self.endColumn != nil {
                    map["endColumn"] = self.endColumn!
                }
                if self.endLine != nil {
                    map["endLine"] = self.endLine!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.rawDetails != nil {
                    map["rawDetails"] = self.rawDetails!
                }
                if self.startColumn != nil {
                    map["startColumn"] = self.startColumn!
                }
                if self.startLine != nil {
                    map["startLine"] = self.startLine!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["annotationLevel"] as? String {
                    self.annotationLevel = value
                }
                if let value = dict["endColumn"] as? Int64 {
                    self.endColumn = value
                }
                if let value = dict["endLine"] as? Int64 {
                    self.endLine = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["path"] as? String {
                    self.path = value
                }
                if let value = dict["rawDetails"] as? String {
                    self.rawDetails = value
                }
                if let value = dict["startColumn"] as? Int64 {
                    self.startColumn = value
                }
                if let value = dict["startLine"] as? Int64 {
                    self.startLine = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public class CheckSuite : Tea.TeaModel {
            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class Images : Tea.TeaModel {
                public var alt: String?

                public var caption: String?

                public var imageUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alt != nil {
                        map["alt"] = self.alt!
                    }
                    if self.caption != nil {
                        map["caption"] = self.caption!
                    }
                    if self.imageUrl != nil {
                        map["imageUrl"] = self.imageUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["alt"] as? String {
                        self.alt = value
                    }
                    if let value = dict["caption"] as? String {
                        self.caption = value
                    }
                    if let value = dict["imageUrl"] as? String {
                        self.imageUrl = value
                    }
                }
            }
            public var images: [ListCheckRunsResponseBody.Result.Output.Images]?

            public var summary: String?

            public var text: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.images != nil {
                    var tmp : [Any] = []
                    for k in self.images! {
                        tmp.append(k.toMap())
                    }
                    map["images"] = tmp
                }
                if self.summary != nil {
                    map["summary"] = self.summary!
                }
                if self.text != nil {
                    map["text"] = self.text!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["images"] as? [Any?] {
                    var tmp : [ListCheckRunsResponseBody.Result.Output.Images] = []
                    for v in value {
                        if v != nil {
                            var model = ListCheckRunsResponseBody.Result.Output.Images()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.images = tmp
                }
                if let value = dict["summary"] as? String {
                    self.summary = value
                }
                if let value = dict["text"] as? String {
                    self.text = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public class Writer : Tea.TeaModel {
            public var id: String?

            public var logoUrl: String?

            public var name: String?

            public var slug: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.logoUrl != nil {
                    map["logoUrl"] = self.logoUrl!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.slug != nil {
                    map["slug"] = self.slug!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["logoUrl"] as? String {
                    self.logoUrl = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["slug"] as? String {
                    self.slug = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public var annotations: [ListCheckRunsResponseBody.Result.Annotations]?

        public var checkSuite: ListCheckRunsResponseBody.Result.CheckSuite?

        public var completedAt: String?

        public var conclusion: String?

        public var createdAt: String?

        public var detailsUrl: String?

        public var externalId: String?

        public var headSha: String?

        public var id: Int64?

        public var name: String?

        public var output: ListCheckRunsResponseBody.Result.Output?

        public var startedAt: String?

        public var status: String?

        public var updatedAt: String?

        public var writer: ListCheckRunsResponseBody.Result.Writer?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkSuite?.validate()
            try self.output?.validate()
            try self.writer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["annotations"] = tmp
            }
            if self.checkSuite != nil {
                map["checkSuite"] = self.checkSuite?.toMap()
            }
            if self.completedAt != nil {
                map["completedAt"] = self.completedAt!
            }
            if self.conclusion != nil {
                map["conclusion"] = self.conclusion!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.detailsUrl != nil {
                map["detailsUrl"] = self.detailsUrl!
            }
            if self.externalId != nil {
                map["externalId"] = self.externalId!
            }
            if self.headSha != nil {
                map["headSha"] = self.headSha!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.output != nil {
                map["output"] = self.output?.toMap()
            }
            if self.startedAt != nil {
                map["startedAt"] = self.startedAt!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.writer != nil {
                map["writer"] = self.writer?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["annotations"] as? [Any?] {
                var tmp : [ListCheckRunsResponseBody.Result.Annotations] = []
                for v in value {
                    if v != nil {
                        var model = ListCheckRunsResponseBody.Result.Annotations()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.annotations = tmp
            }
            if let value = dict["checkSuite"] as? [String: Any?] {
                var model = ListCheckRunsResponseBody.Result.CheckSuite()
                model.fromMap(value)
                self.checkSuite = model
            }
            if let value = dict["completedAt"] as? String {
                self.completedAt = value
            }
            if let value = dict["conclusion"] as? String {
                self.conclusion = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["detailsUrl"] as? String {
                self.detailsUrl = value
            }
            if let value = dict["externalId"] as? String {
                self.externalId = value
            }
            if let value = dict["headSha"] as? String {
                self.headSha = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["output"] as? [String: Any?] {
                var model = ListCheckRunsResponseBody.Result.Output()
                model.fromMap(value)
                self.output = model
            }
            if let value = dict["startedAt"] as? String {
                self.startedAt = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["writer"] as? [String: Any?] {
                var model = ListCheckRunsResponseBody.Result.Writer()
                model.fromMap(value)
                self.writer = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListCheckRunsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListCheckRunsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListCheckRunsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListCheckRunsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCheckRunsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCheckRunsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCommitStatusesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var repositoryIdentity: String?

    public var sha: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        if self.sha != nil {
            map["sha"] = self.sha!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
        if let value = dict["sha"] as? String {
            self.sha = value
        }
    }
}

public class ListCommitStatusesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Creator : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var login: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.login != nil {
                    map["login"] = self.login!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliyunPk"] as? String {
                    self.aliyunPk = value
                }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["login"] as? String {
                    self.login = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public var context: String?

        public var creator: ListCommitStatusesResponseBody.Result.Creator?

        public var description_: String?

        public var id: Int64?

        public var sha: String?

        public var state: String?

        public var targetUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.creator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.context != nil {
                map["context"] = self.context!
            }
            if self.creator != nil {
                map["creator"] = self.creator?.toMap()
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.sha != nil {
                map["sha"] = self.sha!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.targetUrl != nil {
                map["targetUrl"] = self.targetUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["context"] as? String {
                self.context = value
            }
            if let value = dict["creator"] as? [String: Any?] {
                var model = ListCommitStatusesResponseBody.Result.Creator()
                model.fromMap(value)
                self.creator = model
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["sha"] as? String {
                self.sha = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["targetUrl"] as? String {
                self.targetUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListCommitStatusesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListCommitStatusesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListCommitStatusesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListCommitStatusesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCommitStatusesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCommitStatusesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListFlowTagGroupsResponseBody : Tea.TeaModel {
    public class FlowTagGroups : Tea.TeaModel {
        public var creatorAccountId: String?

        public var id: Int64?

        public var modiferAccountId: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modiferAccountId != nil {
                map["modiferAccountId"] = self.modiferAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["creatorAccountId"] as? String {
                self.creatorAccountId = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["modiferAccountId"] as? String {
                self.modiferAccountId = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var flowTagGroups: [ListFlowTagGroupsResponseBody.FlowTagGroups]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.flowTagGroups != nil {
            var tmp : [Any] = []
            for k in self.flowTagGroups! {
                tmp.append(k.toMap())
            }
            map["flowTagGroups"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["flowTagGroups"] as? [Any?] {
            var tmp : [ListFlowTagGroupsResponseBody.FlowTagGroups] = []
            for v in value {
                if v != nil {
                    var model = ListFlowTagGroupsResponseBody.FlowTagGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.flowTagGroups = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListFlowTagGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowTagGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListFlowTagGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListGroupMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ListGroupMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var memberType: String?

        public var name: String?

        public var sourceId: Int64?

        public var state: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.memberType != nil {
                map["memberType"] = self.memberType!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["email"] as? String {
                self.email = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["memberType"] as? String {
                self.memberType = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceId"] as? Int64 {
                self.sourceId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["username"] as? String {
                self.username = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListGroupMemberResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListGroupMemberResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListGroupMemberResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListGroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListGroupMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListGroupRepositoriesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var search: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["search"] as? String {
            self.search = value
        }
    }
}

public class ListGroupRepositoriesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var archived: Bool?

        public var commitCount: Int64?

        public var createdAt: String?

        public var creatorId: Int64?

        public var description_: String?

        public var httpUrl: String?

        public var id: Int64?

        public var importUrl: String?

        public var isStared: Bool?

        public var issuesEnabled: Bool?

        public var lastActivityAt: String?

        public var mergeRequestsEnabled: Bool?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespaceId: Bool?

        public var path: String?

        public var pathWithNamespace: String?

        public var privateFlag: Bool?

        public var snippetsEnabled: Bool?

        public var sshUrl: String?

        public var starCount: Int32?

        public var updatedAt: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public var wikiEnabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archived != nil {
                map["archived"] = self.archived!
            }
            if self.commitCount != nil {
                map["commitCount"] = self.commitCount!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.httpUrl != nil {
                map["httpUrl"] = self.httpUrl!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.importUrl != nil {
                map["importUrl"] = self.importUrl!
            }
            if self.isStared != nil {
                map["isStared"] = self.isStared!
            }
            if self.issuesEnabled != nil {
                map["issuesEnabled"] = self.issuesEnabled!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.mergeRequestsEnabled != nil {
                map["mergeRequestsEnabled"] = self.mergeRequestsEnabled!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespaceId != nil {
                map["namespaceId"] = self.namespaceId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.privateFlag != nil {
                map["privateFlag"] = self.privateFlag!
            }
            if self.snippetsEnabled != nil {
                map["snippetsEnabled"] = self.snippetsEnabled!
            }
            if self.sshUrl != nil {
                map["sshUrl"] = self.sshUrl!
            }
            if self.starCount != nil {
                map["starCount"] = self.starCount!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            if self.wikiEnabled != nil {
                map["wikiEnabled"] = self.wikiEnabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["archived"] as? Bool {
                self.archived = value
            }
            if let value = dict["commitCount"] as? Int64 {
                self.commitCount = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["creatorId"] as? Int64 {
                self.creatorId = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["httpUrl"] as? String {
                self.httpUrl = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["importUrl"] as? String {
                self.importUrl = value
            }
            if let value = dict["isStared"] as? Bool {
                self.isStared = value
            }
            if let value = dict["issuesEnabled"] as? Bool {
                self.issuesEnabled = value
            }
            if let value = dict["lastActivityAt"] as? String {
                self.lastActivityAt = value
            }
            if let value = dict["mergeRequestsEnabled"] as? Bool {
                self.mergeRequestsEnabled = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["namespaceId"] as? Bool {
                self.namespaceId = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["pathWithNamespace"] as? String {
                self.pathWithNamespace = value
            }
            if let value = dict["privateFlag"] as? Bool {
                self.privateFlag = value
            }
            if let value = dict["snippetsEnabled"] as? Bool {
                self.snippetsEnabled = value
            }
            if let value = dict["sshUrl"] as? String {
                self.sshUrl = value
            }
            if let value = dict["starCount"] as? Int32 {
                self.starCount = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["visibilityLevel"] as? Int32 {
                self.visibilityLevel = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
            if let value = dict["wikiEnabled"] as? Bool {
                self.wikiEnabled = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListGroupRepositoriesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListGroupRepositoriesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListGroupRepositoriesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListGroupRepositoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGroupRepositoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListGroupRepositoriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListHostGroupsRequest : Tea.TeaModel {
    public var createEndTime: Int64?

    public var createStartTime: Int64?

    public var creatorAccountIds: String?

    public var ids: String?

    public var maxResults: Int64?

    public var name: String?

    public var nextToken: String?

    public var pageOrder: String?

    public var pageSort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createEndTime != nil {
            map["createEndTime"] = self.createEndTime!
        }
        if self.createStartTime != nil {
            map["createStartTime"] = self.createStartTime!
        }
        if self.creatorAccountIds != nil {
            map["creatorAccountIds"] = self.creatorAccountIds!
        }
        if self.ids != nil {
            map["ids"] = self.ids!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pageOrder != nil {
            map["pageOrder"] = self.pageOrder!
        }
        if self.pageSort != nil {
            map["pageSort"] = self.pageSort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["createEndTime"] as? Int64 {
            self.createEndTime = value
        }
        if let value = dict["createStartTime"] as? Int64 {
            self.createStartTime = value
        }
        if let value = dict["creatorAccountIds"] as? String {
            self.creatorAccountIds = value
        }
        if let value = dict["ids"] as? String {
            self.ids = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["pageOrder"] as? String {
            self.pageOrder = value
        }
        if let value = dict["pageSort"] as? String {
            self.pageSort = value
        }
    }
}

public class ListHostGroupsResponseBody : Tea.TeaModel {
    public class HostGroups : Tea.TeaModel {
        public var aliyunRegion: String?

        public var createTime: Int64?

        public var creatorAccountId: String?

        public var description_: String?

        public var ecsLabelKey: String?

        public var ecsLabelValue: String?

        public var ecsType: String?

        public var hostNum: Int64?

        public var id: Int64?

        public var modifierAccountId: String?

        public var name: String?

        public var serviceConnectionId: Int64?

        public var type: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunRegion != nil {
                map["aliyunRegion"] = self.aliyunRegion!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.ecsLabelKey != nil {
                map["ecsLabelKey"] = self.ecsLabelKey!
            }
            if self.ecsLabelValue != nil {
                map["ecsLabelValue"] = self.ecsLabelValue!
            }
            if self.ecsType != nil {
                map["ecsType"] = self.ecsType!
            }
            if self.hostNum != nil {
                map["hostNum"] = self.hostNum!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.serviceConnectionId != nil {
                map["serviceConnectionId"] = self.serviceConnectionId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["aliyunRegion"] as? String {
                self.aliyunRegion = value
            }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["creatorAccountId"] as? String {
                self.creatorAccountId = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["ecsLabelKey"] as? String {
                self.ecsLabelKey = value
            }
            if let value = dict["ecsLabelValue"] as? String {
                self.ecsLabelValue = value
            }
            if let value = dict["ecsType"] as? String {
                self.ecsType = value
            }
            if let value = dict["hostNum"] as? Int64 {
                self.hostNum = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["modifierAccountId"] as? String {
                self.modifierAccountId = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["serviceConnectionId"] as? Int64 {
                self.serviceConnectionId = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["updateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var hostGroups: [ListHostGroupsResponseBody.HostGroups]?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.hostGroups != nil {
            var tmp : [Any] = []
            for k in self.hostGroups! {
                tmp.append(k.toMap())
            }
            map["hostGroups"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["hostGroups"] as? [Any?] {
            var tmp : [ListHostGroupsResponseBody.HostGroups] = []
            for v in value {
                if v != nil {
                    var model = ListHostGroupsResponseBody.HostGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.hostGroups = tmp
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListHostGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHostGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListHostGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListJoinedOrganizationsResponseBody : Tea.TeaModel {
    public class Organizations : Tea.TeaModel {
        public var id: String?

        public var isOrgAdmin: Bool?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isOrgAdmin != nil {
                map["isOrgAdmin"] = self.isOrgAdmin!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["isOrgAdmin"] as? Bool {
                self.isOrgAdmin = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var organizations: [ListJoinedOrganizationsResponseBody.Organizations]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.organizations != nil {
            var tmp : [Any] = []
            for k in self.organizations! {
                tmp.append(k.toMap())
            }
            map["organizations"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["organizations"] as? [Any?] {
            var tmp : [ListJoinedOrganizationsResponseBody.Organizations] = []
            for v in value {
                if v != nil {
                    var model = ListJoinedOrganizationsResponseBody.Organizations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.organizations = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListJoinedOrganizationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListJoinedOrganizationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListJoinedOrganizationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMergeRequestCommentsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var commentType: String?

    public var filePath: String?

    public var patchSetBizIds: [String]?

    public var resolved: Bool?

    public var state: String?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.commentType != nil {
            map["commentType"] = self.commentType!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.patchSetBizIds != nil {
            map["patchSetBizIds"] = self.patchSetBizIds!
        }
        if self.resolved != nil {
            map["resolved"] = self.resolved!
        }
        if self.state != nil {
            map["state"] = self.state!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["commentType"] as? String {
            self.commentType = value
        }
        if let value = dict["filePath"] as? String {
            self.filePath = value
        }
        if let value = dict["patchSetBizIds"] as? [String] {
            self.patchSetBizIds = value
        }
        if let value = dict["resolved"] as? Bool {
            self.resolved = value
        }
        if let value = dict["state"] as? String {
            self.state = value
        }
        if let value = dict["localId"] as? Int64 {
            self.localId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class ListMergeRequestCommentsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliyunPk"] as? String {
                    self.aliyunPk = value
                }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public class ChildComments : Tea.TeaModel {
            public class Author : Tea.TeaModel {
                public var aliyunPk: String?

                public var avatarUrl: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var state: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aliyunPk != nil {
                        map["aliyunPk"] = self.aliyunPk!
                    }
                    if self.avatarUrl != nil {
                        map["avatarUrl"] = self.avatarUrl!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["aliyunPk"] as? String {
                        self.aliyunPk = value
                    }
                    if let value = dict["avatarUrl"] as? String {
                        self.avatarUrl = value
                    }
                    if let value = dict["email"] as? String {
                        self.email = value
                    }
                    if let value = dict["id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["state"] as? String {
                        self.state = value
                    }
                    if let value = dict["username"] as? String {
                        self.username = value
                    }
                }
            }
            public class FinalChildComments : Tea.TeaModel {
                public class Author : Tea.TeaModel {
                    public var aliyunPk: String?

                    public var avatarUrl: String?

                    public var email: String?

                    public var id: Int64?

                    public var name: String?

                    public var state: String?

                    public var username: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.aliyunPk != nil {
                            map["aliyunPk"] = self.aliyunPk!
                        }
                        if self.avatarUrl != nil {
                            map["avatarUrl"] = self.avatarUrl!
                        }
                        if self.email != nil {
                            map["email"] = self.email!
                        }
                        if self.id != nil {
                            map["id"] = self.id!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.state != nil {
                            map["state"] = self.state!
                        }
                        if self.username != nil {
                            map["username"] = self.username!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["aliyunPk"] as? String {
                            self.aliyunPk = value
                        }
                        if let value = dict["avatarUrl"] as? String {
                            self.avatarUrl = value
                        }
                        if let value = dict["email"] as? String {
                            self.email = value
                        }
                        if let value = dict["id"] as? Int64 {
                            self.id = value
                        }
                        if let value = dict["name"] as? String {
                            self.name = value
                        }
                        if let value = dict["state"] as? String {
                            self.state = value
                        }
                        if let value = dict["username"] as? String {
                            self.username = value
                        }
                    }
                }
                public class RelatedPatchSet : Tea.TeaModel {
                    public var commitId: String?

                    public var createdAt: String?

                    public var patchSetBizId: String?

                    public var patchSetName: String?

                    public var patchSetNo: String?

                    public var relatedMergeItemType: String?

                    public var shortId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.commitId != nil {
                            map["commitId"] = self.commitId!
                        }
                        if self.createdAt != nil {
                            map["createdAt"] = self.createdAt!
                        }
                        if self.patchSetBizId != nil {
                            map["patchSetBizId"] = self.patchSetBizId!
                        }
                        if self.patchSetName != nil {
                            map["patchSetName"] = self.patchSetName!
                        }
                        if self.patchSetNo != nil {
                            map["patchSetNo"] = self.patchSetNo!
                        }
                        if self.relatedMergeItemType != nil {
                            map["relatedMergeItemType"] = self.relatedMergeItemType!
                        }
                        if self.shortId != nil {
                            map["shortId"] = self.shortId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["commitId"] as? String {
                            self.commitId = value
                        }
                        if let value = dict["createdAt"] as? String {
                            self.createdAt = value
                        }
                        if let value = dict["patchSetBizId"] as? String {
                            self.patchSetBizId = value
                        }
                        if let value = dict["patchSetName"] as? String {
                            self.patchSetName = value
                        }
                        if let value = dict["patchSetNo"] as? String {
                            self.patchSetNo = value
                        }
                        if let value = dict["relatedMergeItemType"] as? String {
                            self.relatedMergeItemType = value
                        }
                        if let value = dict["shortId"] as? String {
                            self.shortId = value
                        }
                    }
                }
                public var author: ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments.Author?

                public var commentBizId: String?

                public var commentTime: String?

                public var commentType: String?

                public var content: String?

                public var deleted: Bool?

                public var filePath: String?

                public var lastEditTime: String?

                public var lineNumber: String?

                public var parentCommentBizId: String?

                public var relatedPatchSet: ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments.RelatedPatchSet?

                public var resolved: Bool?

                public var rootCommentBizId: String?

                public var state: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.author?.validate()
                    try self.relatedPatchSet?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.author != nil {
                        map["author"] = self.author?.toMap()
                    }
                    if self.commentBizId != nil {
                        map["commentBizId"] = self.commentBizId!
                    }
                    if self.commentTime != nil {
                        map["commentTime"] = self.commentTime!
                    }
                    if self.commentType != nil {
                        map["commentType"] = self.commentType!
                    }
                    if self.content != nil {
                        map["content"] = self.content!
                    }
                    if self.deleted != nil {
                        map["deleted"] = self.deleted!
                    }
                    if self.filePath != nil {
                        map["filePath"] = self.filePath!
                    }
                    if self.lastEditTime != nil {
                        map["lastEditTime"] = self.lastEditTime!
                    }
                    if self.lineNumber != nil {
                        map["lineNumber"] = self.lineNumber!
                    }
                    if self.parentCommentBizId != nil {
                        map["parentCommentBizId"] = self.parentCommentBizId!
                    }
                    if self.relatedPatchSet != nil {
                        map["relatedPatchSet"] = self.relatedPatchSet?.toMap()
                    }
                    if self.resolved != nil {
                        map["resolved"] = self.resolved!
                    }
                    if self.rootCommentBizId != nil {
                        map["rootCommentBizId"] = self.rootCommentBizId!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["author"] as? [String: Any?] {
                        var model = ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments.Author()
                        model.fromMap(value)
                        self.author = model
                    }
                    if let value = dict["commentBizId"] as? String {
                        self.commentBizId = value
                    }
                    if let value = dict["commentTime"] as? String {
                        self.commentTime = value
                    }
                    if let value = dict["commentType"] as? String {
                        self.commentType = value
                    }
                    if let value = dict["content"] as? String {
                        self.content = value
                    }
                    if let value = dict["deleted"] as? Bool {
                        self.deleted = value
                    }
                    if let value = dict["filePath"] as? String {
                        self.filePath = value
                    }
                    if let value = dict["lastEditTime"] as? String {
                        self.lastEditTime = value
                    }
                    if let value = dict["lineNumber"] as? String {
                        self.lineNumber = value
                    }
                    if let value = dict["parentCommentBizId"] as? String {
                        self.parentCommentBizId = value
                    }
                    if let value = dict["relatedPatchSet"] as? [String: Any?] {
                        var model = ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments.RelatedPatchSet()
                        model.fromMap(value)
                        self.relatedPatchSet = model
                    }
                    if let value = dict["resolved"] as? Bool {
                        self.resolved = value
                    }
                    if let value = dict["rootCommentBizId"] as? String {
                        self.rootCommentBizId = value
                    }
                    if let value = dict["state"] as? String {
                        self.state = value
                    }
                }
            }
            public class RelatedPatchSet : Tea.TeaModel {
                public var commitId: String?

                public var createdAt: String?

                public var patchSetBizId: String?

                public var patchSetName: String?

                public var patchSetNo: String?

                public var relatedMergeItemType: String?

                public var shortId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commitId != nil {
                        map["commitId"] = self.commitId!
                    }
                    if self.createdAt != nil {
                        map["createdAt"] = self.createdAt!
                    }
                    if self.patchSetBizId != nil {
                        map["patchSetBizId"] = self.patchSetBizId!
                    }
                    if self.patchSetName != nil {
                        map["patchSetName"] = self.patchSetName!
                    }
                    if self.patchSetNo != nil {
                        map["patchSetNo"] = self.patchSetNo!
                    }
                    if self.relatedMergeItemType != nil {
                        map["relatedMergeItemType"] = self.relatedMergeItemType!
                    }
                    if self.shortId != nil {
                        map["shortId"] = self.shortId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["commitId"] as? String {
                        self.commitId = value
                    }
                    if let value = dict["createdAt"] as? String {
                        self.createdAt = value
                    }
                    if let value = dict["patchSetBizId"] as? String {
                        self.patchSetBizId = value
                    }
                    if let value = dict["patchSetName"] as? String {
                        self.patchSetName = value
                    }
                    if let value = dict["patchSetNo"] as? String {
                        self.patchSetNo = value
                    }
                    if let value = dict["relatedMergeItemType"] as? String {
                        self.relatedMergeItemType = value
                    }
                    if let value = dict["shortId"] as? String {
                        self.shortId = value
                    }
                }
            }
            public var author: ListMergeRequestCommentsResponseBody.Result.ChildComments.Author?

            public var commentBizId: String?

            public var commentTime: String?

            public var commentType: String?

            public var content: String?

            public var deleted: Bool?

            public var filePath: String?

            public var finalChildComments: [ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments]?

            public var lastEditTime: String?

            public var lineNumber: String?

            public var parentCommentBizId: String?

            public var relatedPatchSet: ListMergeRequestCommentsResponseBody.Result.ChildComments.RelatedPatchSet?

            public var resolved: Bool?

            public var rootCommentBizId: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.author?.validate()
                try self.relatedPatchSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.author != nil {
                    map["author"] = self.author?.toMap()
                }
                if self.commentBizId != nil {
                    map["commentBizId"] = self.commentBizId!
                }
                if self.commentTime != nil {
                    map["commentTime"] = self.commentTime!
                }
                if self.commentType != nil {
                    map["commentType"] = self.commentType!
                }
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.deleted != nil {
                    map["deleted"] = self.deleted!
                }
                if self.filePath != nil {
                    map["filePath"] = self.filePath!
                }
                if self.finalChildComments != nil {
                    var tmp : [Any] = []
                    for k in self.finalChildComments! {
                        tmp.append(k.toMap())
                    }
                    map["finalChildComments"] = tmp
                }
                if self.lastEditTime != nil {
                    map["lastEditTime"] = self.lastEditTime!
                }
                if self.lineNumber != nil {
                    map["lineNumber"] = self.lineNumber!
                }
                if self.parentCommentBizId != nil {
                    map["parentCommentBizId"] = self.parentCommentBizId!
                }
                if self.relatedPatchSet != nil {
                    map["relatedPatchSet"] = self.relatedPatchSet?.toMap()
                }
                if self.resolved != nil {
                    map["resolved"] = self.resolved!
                }
                if self.rootCommentBizId != nil {
                    map["rootCommentBizId"] = self.rootCommentBizId!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["author"] as? [String: Any?] {
                    var model = ListMergeRequestCommentsResponseBody.Result.ChildComments.Author()
                    model.fromMap(value)
                    self.author = model
                }
                if let value = dict["commentBizId"] as? String {
                    self.commentBizId = value
                }
                if let value = dict["commentTime"] as? String {
                    self.commentTime = value
                }
                if let value = dict["commentType"] as? String {
                    self.commentType = value
                }
                if let value = dict["content"] as? String {
                    self.content = value
                }
                if let value = dict["deleted"] as? Bool {
                    self.deleted = value
                }
                if let value = dict["filePath"] as? String {
                    self.filePath = value
                }
                if let value = dict["finalChildComments"] as? [Any?] {
                    var tmp : [ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments] = []
                    for v in value {
                        if v != nil {
                            var model = ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.finalChildComments = tmp
                }
                if let value = dict["lastEditTime"] as? String {
                    self.lastEditTime = value
                }
                if let value = dict["lineNumber"] as? String {
                    self.lineNumber = value
                }
                if let value = dict["parentCommentBizId"] as? String {
                    self.parentCommentBizId = value
                }
                if let value = dict["relatedPatchSet"] as? [String: Any?] {
                    var model = ListMergeRequestCommentsResponseBody.Result.ChildComments.RelatedPatchSet()
                    model.fromMap(value)
                    self.relatedPatchSet = model
                }
                if let value = dict["resolved"] as? Bool {
                    self.resolved = value
                }
                if let value = dict["rootCommentBizId"] as? String {
                    self.rootCommentBizId = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
            }
        }
        public class RelatedPatchSet : Tea.TeaModel {
            public var commitId: String?

            public var createdAt: String?

            public var patchSetBizId: String?

            public var patchSetName: String?

            public var patchSetNo: String?

            public var relatedMergeItemType: String?

            public var shortId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commitId != nil {
                    map["commitId"] = self.commitId!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.patchSetBizId != nil {
                    map["patchSetBizId"] = self.patchSetBizId!
                }
                if self.patchSetName != nil {
                    map["patchSetName"] = self.patchSetName!
                }
                if self.patchSetNo != nil {
                    map["patchSetNo"] = self.patchSetNo!
                }
                if self.relatedMergeItemType != nil {
                    map["relatedMergeItemType"] = self.relatedMergeItemType!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["commitId"] as? String {
                    self.commitId = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["patchSetBizId"] as? String {
                    self.patchSetBizId = value
                }
                if let value = dict["patchSetName"] as? String {
                    self.patchSetName = value
                }
                if let value = dict["patchSetNo"] as? String {
                    self.patchSetNo = value
                }
                if let value = dict["relatedMergeItemType"] as? String {
                    self.relatedMergeItemType = value
                }
                if let value = dict["shortId"] as? String {
                    self.shortId = value
                }
            }
        }
        public var author: ListMergeRequestCommentsResponseBody.Result.Author?

        public var childComments: [ListMergeRequestCommentsResponseBody.Result.ChildComments]?

        public var commentBizId: String?

        public var commentTime: String?

        public var commentType: String?

        public var content: String?

        public var deleted: Bool?

        public var filePath: String?

        public var lastEditTime: String?

        public var lineNumber: String?

        public var parentCommentBizId: String?

        public var relatedPatchSet: ListMergeRequestCommentsResponseBody.Result.RelatedPatchSet?

        public var resolved: Bool?

        public var rootCommentBizId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.relatedPatchSet?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.childComments != nil {
                var tmp : [Any] = []
                for k in self.childComments! {
                    tmp.append(k.toMap())
                }
                map["childComments"] = tmp
            }
            if self.commentBizId != nil {
                map["commentBizId"] = self.commentBizId!
            }
            if self.commentTime != nil {
                map["commentTime"] = self.commentTime!
            }
            if self.commentType != nil {
                map["commentType"] = self.commentType!
            }
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.deleted != nil {
                map["deleted"] = self.deleted!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            if self.lastEditTime != nil {
                map["lastEditTime"] = self.lastEditTime!
            }
            if self.lineNumber != nil {
                map["lineNumber"] = self.lineNumber!
            }
            if self.parentCommentBizId != nil {
                map["parentCommentBizId"] = self.parentCommentBizId!
            }
            if self.relatedPatchSet != nil {
                map["relatedPatchSet"] = self.relatedPatchSet?.toMap()
            }
            if self.resolved != nil {
                map["resolved"] = self.resolved!
            }
            if self.rootCommentBizId != nil {
                map["rootCommentBizId"] = self.rootCommentBizId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["author"] as? [String: Any?] {
                var model = ListMergeRequestCommentsResponseBody.Result.Author()
                model.fromMap(value)
                self.author = model
            }
            if let value = dict["childComments"] as? [Any?] {
                var tmp : [ListMergeRequestCommentsResponseBody.Result.ChildComments] = []
                for v in value {
                    if v != nil {
                        var model = ListMergeRequestCommentsResponseBody.Result.ChildComments()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.childComments = tmp
            }
            if let value = dict["commentBizId"] as? String {
                self.commentBizId = value
            }
            if let value = dict["commentTime"] as? String {
                self.commentTime = value
            }
            if let value = dict["commentType"] as? String {
                self.commentType = value
            }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["deleted"] as? Bool {
                self.deleted = value
            }
            if let value = dict["filePath"] as? String {
                self.filePath = value
            }
            if let value = dict["lastEditTime"] as? String {
                self.lastEditTime = value
            }
            if let value = dict["lineNumber"] as? String {
                self.lineNumber = value
            }
            if let value = dict["parentCommentBizId"] as? String {
                self.parentCommentBizId = value
            }
            if let value = dict["relatedPatchSet"] as? [String: Any?] {
                var model = ListMergeRequestCommentsResponseBody.Result.RelatedPatchSet()
                model.fromMap(value)
                self.relatedPatchSet = model
            }
            if let value = dict["resolved"] as? Bool {
                self.resolved = value
            }
            if let value = dict["rootCommentBizId"] as? String {
                self.rootCommentBizId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListMergeRequestCommentsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListMergeRequestCommentsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListMergeRequestCommentsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListMergeRequestCommentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMergeRequestCommentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMergeRequestCommentsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMergeRequestFilesReadsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var fromPatchSetBizId: String?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public var toPatchSetBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.fromPatchSetBizId != nil {
            map["fromPatchSetBizId"] = self.fromPatchSetBizId!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        if self.toPatchSetBizId != nil {
            map["toPatchSetBizId"] = self.toPatchSetBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["fromPatchSetBizId"] as? String {
            self.fromPatchSetBizId = value
        }
        if let value = dict["localId"] as? Int64 {
            self.localId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
        if let value = dict["toPatchSetBizId"] as? String {
            self.toPatchSetBizId = value
        }
    }
}

public class ListMergeRequestFilesReadsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ReadUsers : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var email: String?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliyunPk"] as? String {
                    self.aliyunPk = value
                }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public var deletedFile: String?

        public var newFile: Bool?

        public var newFilePath: String?

        public var oldFilePath: String?

        public var readUsers: [ListMergeRequestFilesReadsResponseBody.Result.ReadUsers]?

        public var renamedFile: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deletedFile != nil {
                map["deletedFile"] = self.deletedFile!
            }
            if self.newFile != nil {
                map["newFile"] = self.newFile!
            }
            if self.newFilePath != nil {
                map["newFilePath"] = self.newFilePath!
            }
            if self.oldFilePath != nil {
                map["oldFilePath"] = self.oldFilePath!
            }
            if self.readUsers != nil {
                var tmp : [Any] = []
                for k in self.readUsers! {
                    tmp.append(k.toMap())
                }
                map["readUsers"] = tmp
            }
            if self.renamedFile != nil {
                map["renamedFile"] = self.renamedFile!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["deletedFile"] as? String {
                self.deletedFile = value
            }
            if let value = dict["newFile"] as? Bool {
                self.newFile = value
            }
            if let value = dict["newFilePath"] as? String {
                self.newFilePath = value
            }
            if let value = dict["oldFilePath"] as? String {
                self.oldFilePath = value
            }
            if let value = dict["readUsers"] as? [Any?] {
                var tmp : [ListMergeRequestFilesReadsResponseBody.Result.ReadUsers] = []
                for v in value {
                    if v != nil {
                        var model = ListMergeRequestFilesReadsResponseBody.Result.ReadUsers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.readUsers = tmp
            }
            if let value = dict["renamedFile"] as? String {
                self.renamedFile = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListMergeRequestFilesReadsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListMergeRequestFilesReadsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListMergeRequestFilesReadsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListMergeRequestFilesReadsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMergeRequestFilesReadsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMergeRequestFilesReadsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMergeRequestLabelsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["localId"] as? Int64 {
            self.localId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class ListMergeRequestLabelsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var color: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.color != nil {
                map["color"] = self.color!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["color"] as? String {
                self.color = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListMergeRequestLabelsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListMergeRequestLabelsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListMergeRequestLabelsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListMergeRequestLabelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMergeRequestLabelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMergeRequestLabelsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMergeRequestPatchSetsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["localId"] as? Int64 {
            self.localId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class ListMergeRequestPatchSetsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var commitId: String?

        public var createdAt: String?

        public var patchSetBizId: String?

        public var patchSetName: String?

        public var patchSetNo: Int64?

        public var relatedMergeItemType: String?

        public var shortCommitId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commitId != nil {
                map["commitId"] = self.commitId!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.patchSetBizId != nil {
                map["patchSetBizId"] = self.patchSetBizId!
            }
            if self.patchSetName != nil {
                map["patchSetName"] = self.patchSetName!
            }
            if self.patchSetNo != nil {
                map["patchSetNo"] = self.patchSetNo!
            }
            if self.relatedMergeItemType != nil {
                map["relatedMergeItemType"] = self.relatedMergeItemType!
            }
            if self.shortCommitId != nil {
                map["shortCommitId"] = self.shortCommitId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["commitId"] as? String {
                self.commitId = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["patchSetBizId"] as? String {
                self.patchSetBizId = value
            }
            if let value = dict["patchSetName"] as? String {
                self.patchSetName = value
            }
            if let value = dict["patchSetNo"] as? Int64 {
                self.patchSetNo = value
            }
            if let value = dict["relatedMergeItemType"] as? String {
                self.relatedMergeItemType = value
            }
            if let value = dict["shortCommitId"] as? String {
                self.shortCommitId = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListMergeRequestPatchSetsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListMergeRequestPatchSetsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListMergeRequestPatchSetsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListMergeRequestPatchSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMergeRequestPatchSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMergeRequestPatchSetsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMergeRequestsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var authorIds: String?

    public var createdAfter: String?

    public var createdBefore: String?

    public var filter: String?

    public var groupIds: String?

    public var labelIds: String?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var projectIds: String?

    public var reviewerIds: String?

    public var search: String?

    public var sort: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.authorIds != nil {
            map["authorIds"] = self.authorIds!
        }
        if self.createdAfter != nil {
            map["createdAfter"] = self.createdAfter!
        }
        if self.createdBefore != nil {
            map["createdBefore"] = self.createdBefore!
        }
        if self.filter != nil {
            map["filter"] = self.filter!
        }
        if self.groupIds != nil {
            map["groupIds"] = self.groupIds!
        }
        if self.labelIds != nil {
            map["labelIds"] = self.labelIds!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.projectIds != nil {
            map["projectIds"] = self.projectIds!
        }
        if self.reviewerIds != nil {
            map["reviewerIds"] = self.reviewerIds!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.state != nil {
            map["state"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["authorIds"] as? String {
            self.authorIds = value
        }
        if let value = dict["createdAfter"] as? String {
            self.createdAfter = value
        }
        if let value = dict["createdBefore"] as? String {
            self.createdBefore = value
        }
        if let value = dict["filter"] as? String {
            self.filter = value
        }
        if let value = dict["groupIds"] as? String {
            self.groupIds = value
        }
        if let value = dict["labelIds"] as? String {
            self.labelIds = value
        }
        if let value = dict["orderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["projectIds"] as? String {
            self.projectIds = value
        }
        if let value = dict["reviewerIds"] as? String {
            self.reviewerIds = value
        }
        if let value = dict["search"] as? String {
            self.search = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
        if let value = dict["state"] as? String {
            self.state = value
        }
    }
}

public class ListMergeRequestsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var color: String?

            public var description_: String?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.color != nil {
                    map["color"] = self.color!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["color"] as? String {
                    self.color = value
                }
                if let value = dict["description"] as? String {
                    self.description_ = value
                }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public class Reviewers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var hasCommented: Bool?

            public var hasReviewed: Bool?

            public var id: Int64?

            public var name: String?

            public var reviewOpinionStatus: String?

            public var reviewTime: String?

            public var state: String?

            public var status: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.hasCommented != nil {
                    map["hasCommented"] = self.hasCommented!
                }
                if self.hasReviewed != nil {
                    map["hasReviewed"] = self.hasReviewed!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.reviewOpinionStatus != nil {
                    map["reviewOpinionStatus"] = self.reviewOpinionStatus!
                }
                if self.reviewTime != nil {
                    map["reviewTime"] = self.reviewTime!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.status != nil {
                    map["status"] = self.status!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["hasCommented"] as? Bool {
                    self.hasCommented = value
                }
                if let value = dict["hasReviewed"] as? Bool {
                    self.hasReviewed = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["reviewOpinionStatus"] as? String {
                    self.reviewOpinionStatus = value
                }
                if let value = dict["reviewTime"] as? String {
                    self.reviewTime = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["status"] as? String {
                    self.status = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public class Subscribers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public var author: ListMergeRequestsResponseBody.Result.Author?

        public var createdAt: String?

        public var creationMethod: String?

        public var description_: String?

        public var detailUrl: String?

        public var id: Int64?

        public var iid: Int64?

        public var labels: [ListMergeRequestsResponseBody.Result.Labels]?

        public var localId: Int64?

        public var mergedRevision: String?

        public var mrBizId: String?

        public var nameWithNamespace: String?

        public var newMergeRequestIdentifier: Bool?

        public var newVersionState: String?

        public var projectId: Int64?

        public var reviewers: [ListMergeRequestsResponseBody.Result.Reviewers]?

        public var sourceBranch: String?

        public var sourceProjectId: Int64?

        public var sourceType: String?

        public var sshUrl: String?

        public var state: String?

        public var subscribers: [ListMergeRequestsResponseBody.Result.Subscribers]?

        public var supportMergeFFOnly: Bool?

        public var targetBranch: String?

        public var targetProjectId: Int64?

        public var targetType: String?

        public var title: String?

        public var updatedAt: String?

        public var webUrl: String?

        public var workInProgress: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creationMethod != nil {
                map["creationMethod"] = self.creationMethod!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.detailUrl != nil {
                map["detailUrl"] = self.detailUrl!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.iid != nil {
                map["iid"] = self.iid!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["labels"] = tmp
            }
            if self.localId != nil {
                map["localId"] = self.localId!
            }
            if self.mergedRevision != nil {
                map["mergedRevision"] = self.mergedRevision!
            }
            if self.mrBizId != nil {
                map["mrBizId"] = self.mrBizId!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.newMergeRequestIdentifier != nil {
                map["newMergeRequestIdentifier"] = self.newMergeRequestIdentifier!
            }
            if self.newVersionState != nil {
                map["newVersionState"] = self.newVersionState!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.reviewers != nil {
                var tmp : [Any] = []
                for k in self.reviewers! {
                    tmp.append(k.toMap())
                }
                map["reviewers"] = tmp
            }
            if self.sourceBranch != nil {
                map["sourceBranch"] = self.sourceBranch!
            }
            if self.sourceProjectId != nil {
                map["sourceProjectId"] = self.sourceProjectId!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.sshUrl != nil {
                map["sshUrl"] = self.sshUrl!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.subscribers != nil {
                var tmp : [Any] = []
                for k in self.subscribers! {
                    tmp.append(k.toMap())
                }
                map["subscribers"] = tmp
            }
            if self.supportMergeFFOnly != nil {
                map["supportMergeFFOnly"] = self.supportMergeFFOnly!
            }
            if self.targetBranch != nil {
                map["targetBranch"] = self.targetBranch!
            }
            if self.targetProjectId != nil {
                map["targetProjectId"] = self.targetProjectId!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            if self.workInProgress != nil {
                map["workInProgress"] = self.workInProgress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["author"] as? [String: Any?] {
                var model = ListMergeRequestsResponseBody.Result.Author()
                model.fromMap(value)
                self.author = model
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["creationMethod"] as? String {
                self.creationMethod = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["detailUrl"] as? String {
                self.detailUrl = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["iid"] as? Int64 {
                self.iid = value
            }
            if let value = dict["labels"] as? [Any?] {
                var tmp : [ListMergeRequestsResponseBody.Result.Labels] = []
                for v in value {
                    if v != nil {
                        var model = ListMergeRequestsResponseBody.Result.Labels()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.labels = tmp
            }
            if let value = dict["localId"] as? Int64 {
                self.localId = value
            }
            if let value = dict["mergedRevision"] as? String {
                self.mergedRevision = value
            }
            if let value = dict["mrBizId"] as? String {
                self.mrBizId = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["newMergeRequestIdentifier"] as? Bool {
                self.newMergeRequestIdentifier = value
            }
            if let value = dict["newVersionState"] as? String {
                self.newVersionState = value
            }
            if let value = dict["projectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["reviewers"] as? [Any?] {
                var tmp : [ListMergeRequestsResponseBody.Result.Reviewers] = []
                for v in value {
                    if v != nil {
                        var model = ListMergeRequestsResponseBody.Result.Reviewers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.reviewers = tmp
            }
            if let value = dict["sourceBranch"] as? String {
                self.sourceBranch = value
            }
            if let value = dict["sourceProjectId"] as? Int64 {
                self.sourceProjectId = value
            }
            if let value = dict["sourceType"] as? String {
                self.sourceType = value
            }
            if let value = dict["sshUrl"] as? String {
                self.sshUrl = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["subscribers"] as? [Any?] {
                var tmp : [ListMergeRequestsResponseBody.Result.Subscribers] = []
                for v in value {
                    if v != nil {
                        var model = ListMergeRequestsResponseBody.Result.Subscribers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.subscribers = tmp
            }
            if let value = dict["supportMergeFFOnly"] as? Bool {
                self.supportMergeFFOnly = value
            }
            if let value = dict["targetBranch"] as? String {
                self.targetBranch = value
            }
            if let value = dict["targetProjectId"] as? Int64 {
                self.targetProjectId = value
            }
            if let value = dict["targetType"] as? String {
                self.targetType = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
            if let value = dict["workInProgress"] as? Bool {
                self.workInProgress = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListMergeRequestsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListMergeRequestsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListMergeRequestsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListMergeRequestsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMergeRequestsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMergeRequestsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListOrganizationMembersRequest : Tea.TeaModel {
    public var containsExternInfo: Bool?

    public var externUid: String?

    public var joinTimeFrom: Int64?

    public var joinTimeTo: Int64?

    public var maxResults: Int64?

    public var nextToken: String?

    public var organizationMemberName: String?

    public var provider: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containsExternInfo != nil {
            map["containsExternInfo"] = self.containsExternInfo!
        }
        if self.externUid != nil {
            map["externUid"] = self.externUid!
        }
        if self.joinTimeFrom != nil {
            map["joinTimeFrom"] = self.joinTimeFrom!
        }
        if self.joinTimeTo != nil {
            map["joinTimeTo"] = self.joinTimeTo!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.organizationMemberName != nil {
            map["organizationMemberName"] = self.organizationMemberName!
        }
        if self.provider != nil {
            map["provider"] = self.provider!
        }
        if self.state != nil {
            map["state"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["containsExternInfo"] as? Bool {
            self.containsExternInfo = value
        }
        if let value = dict["externUid"] as? String {
            self.externUid = value
        }
        if let value = dict["joinTimeFrom"] as? Int64 {
            self.joinTimeFrom = value
        }
        if let value = dict["joinTimeTo"] as? Int64 {
            self.joinTimeTo = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["organizationMemberName"] as? String {
            self.organizationMemberName = value
        }
        if let value = dict["provider"] as? String {
            self.provider = value
        }
        if let value = dict["state"] as? String {
            self.state = value
        }
    }
}

public class ListOrganizationMembersResponseBody : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public class Identities : Tea.TeaModel {
            public var externUid: String?

            public var provider: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.externUid != nil {
                    map["externUid"] = self.externUid!
                }
                if self.provider != nil {
                    map["provider"] = self.provider!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["externUid"] as? String {
                    self.externUid = value
                }
                if let value = dict["provider"] as? String {
                    self.provider = value
                }
            }
        }
        public var accountId: String?

        public var birthday: Int64?

        public var deptLists: [String]?

        public var email: String?

        public var hiredDate: Int64?

        public var identities: ListOrganizationMembersResponseBody.Members.Identities?

        public var jobNumber: String?

        public var joinTime: Int64?

        public var lastVisitTime: Int64?

        public var mobile: String?

        public var organizationMemberName: String?

        public var organizationRoleId: String?

        public var organizationRoleName: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.identities?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            if self.birthday != nil {
                map["birthday"] = self.birthday!
            }
            if self.deptLists != nil {
                map["deptLists"] = self.deptLists!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.hiredDate != nil {
                map["hiredDate"] = self.hiredDate!
            }
            if self.identities != nil {
                map["identities"] = self.identities?.toMap()
            }
            if self.jobNumber != nil {
                map["jobNumber"] = self.jobNumber!
            }
            if self.joinTime != nil {
                map["joinTime"] = self.joinTime!
            }
            if self.lastVisitTime != nil {
                map["lastVisitTime"] = self.lastVisitTime!
            }
            if self.mobile != nil {
                map["mobile"] = self.mobile!
            }
            if self.organizationMemberName != nil {
                map["organizationMemberName"] = self.organizationMemberName!
            }
            if self.organizationRoleId != nil {
                map["organizationRoleId"] = self.organizationRoleId!
            }
            if self.organizationRoleName != nil {
                map["organizationRoleName"] = self.organizationRoleName!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accountId"] as? String {
                self.accountId = value
            }
            if let value = dict["birthday"] as? Int64 {
                self.birthday = value
            }
            if let value = dict["deptLists"] as? [String] {
                self.deptLists = value
            }
            if let value = dict["email"] as? String {
                self.email = value
            }
            if let value = dict["hiredDate"] as? Int64 {
                self.hiredDate = value
            }
            if let value = dict["identities"] as? [String: Any?] {
                var model = ListOrganizationMembersResponseBody.Members.Identities()
                model.fromMap(value)
                self.identities = model
            }
            if let value = dict["jobNumber"] as? String {
                self.jobNumber = value
            }
            if let value = dict["joinTime"] as? Int64 {
                self.joinTime = value
            }
            if let value = dict["lastVisitTime"] as? Int64 {
                self.lastVisitTime = value
            }
            if let value = dict["mobile"] as? String {
                self.mobile = value
            }
            if let value = dict["organizationMemberName"] as? String {
                self.organizationMemberName = value
            }
            if let value = dict["organizationRoleId"] as? String {
                self.organizationRoleId = value
            }
            if let value = dict["organizationRoleName"] as? String {
                self.organizationRoleName = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var members: [ListOrganizationMembersResponseBody.Members]?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["members"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["members"] as? [Any?] {
            var tmp : [ListOrganizationMembersResponseBody.Members] = []
            for v in value {
                if v != nil {
                    var model = ListOrganizationMembersResponseBody.Members()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.members = tmp
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListOrganizationMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOrganizationMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListOrganizationMembersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListOrganizationsRequest : Tea.TeaModel {
    public var accessLevel: Int32?

    public var accessToken: String?

    public var minAccessLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessLevel != nil {
            map["accessLevel"] = self.accessLevel!
        }
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.minAccessLevel != nil {
            map["minAccessLevel"] = self.minAccessLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessLevel"] as? Int32 {
            self.accessLevel = value
        }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["minAccessLevel"] as? Int32 {
            self.minAccessLevel = value
        }
    }
}

public class ListOrganizationsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var id: Int64?

        public var namespaceId: String?

        public var organizationAlias: String?

        public var organizationId: String?

        public var organizationName: String?

        public var organizationRole: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.namespaceId != nil {
                map["namespaceId"] = self.namespaceId!
            }
            if self.organizationAlias != nil {
                map["organizationAlias"] = self.organizationAlias!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.organizationName != nil {
                map["organizationName"] = self.organizationName!
            }
            if self.organizationRole != nil {
                map["organizationRole"] = self.organizationRole!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["namespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["organizationAlias"] as? String {
                self.organizationAlias = value
            }
            if let value = dict["organizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["organizationName"] as? String {
                self.organizationName = value
            }
            if let value = dict["organizationRole"] as? String {
                self.organizationRole = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListOrganizationsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListOrganizationsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListOrganizationsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListOrganizationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOrganizationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListOrganizationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPipelineGroupPipelinesRequest : Tea.TeaModel {
    public var createEndTime: Int64?

    public var createStartTime: Int64?

    public var executeEndTime: Int64?

    public var executeStartTime: Int64?

    public var maxResults: Int64?

    public var nextToken: String?

    public var pipelineName: String?

    public var resultStatusList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createEndTime != nil {
            map["createEndTime"] = self.createEndTime!
        }
        if self.createStartTime != nil {
            map["createStartTime"] = self.createStartTime!
        }
        if self.executeEndTime != nil {
            map["executeEndTime"] = self.executeEndTime!
        }
        if self.executeStartTime != nil {
            map["executeStartTime"] = self.executeStartTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelineName != nil {
            map["pipelineName"] = self.pipelineName!
        }
        if self.resultStatusList != nil {
            map["resultStatusList"] = self.resultStatusList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["createEndTime"] as? Int64 {
            self.createEndTime = value
        }
        if let value = dict["createStartTime"] as? Int64 {
            self.createStartTime = value
        }
        if let value = dict["executeEndTime"] as? Int64 {
            self.executeEndTime = value
        }
        if let value = dict["executeStartTime"] as? Int64 {
            self.executeStartTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["pipelineName"] as? String {
            self.pipelineName = value
        }
        if let value = dict["resultStatusList"] as? String {
            self.resultStatusList = value
        }
    }
}

public class ListPipelineGroupPipelinesResponseBody : Tea.TeaModel {
    public class Pipelines : Tea.TeaModel {
        public var createTime: Int64?

        public var pipelineId: Int64?

        public var pipelineName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineName != nil {
                map["pipelineName"] = self.pipelineName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["pipelineId"] as? Int64 {
                self.pipelineId = value
            }
            if let value = dict["pipelineName"] as? String {
                self.pipelineName = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nextToken: String?

    public var pipelines: [ListPipelineGroupPipelinesResponseBody.Pipelines]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelines != nil {
            var tmp : [Any] = []
            for k in self.pipelines! {
                tmp.append(k.toMap())
            }
            map["pipelines"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["pipelines"] as? [Any?] {
            var tmp : [ListPipelineGroupPipelinesResponseBody.Pipelines] = []
            for v in value {
                if v != nil {
                    var model = ListPipelineGroupPipelinesResponseBody.Pipelines()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.pipelines = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["totalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListPipelineGroupPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineGroupPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPipelineGroupPipelinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPipelineGroupsRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
    }
}

public class ListPipelineGroupsResponseBody : Tea.TeaModel {
    public class PipelineGroups : Tea.TeaModel {
        public var createTime: Int64?

        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nextToken: String?

    public var pipelineGroups: [ListPipelineGroupsResponseBody.PipelineGroups]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelineGroups != nil {
            var tmp : [Any] = []
            for k in self.pipelineGroups! {
                tmp.append(k.toMap())
            }
            map["pipelineGroups"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["pipelineGroups"] as? [Any?] {
            var tmp : [ListPipelineGroupsResponseBody.PipelineGroups] = []
            for v in value {
                if v != nil {
                    var model = ListPipelineGroupsResponseBody.PipelineGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.pipelineGroups = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["totalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListPipelineGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPipelineGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPipelineJobHistorysRequest : Tea.TeaModel {
    public var category: String?

    public var identifier: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["category"] as? String {
            self.category = value
        }
        if let value = dict["identifier"] as? String {
            self.identifier = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
    }
}

public class ListPipelineJobHistorysResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public var executeNumber: Int32?

        public var identifier: String?

        public var jobId: Int64?

        public var jobName: String?

        public var operatorAccountId: String?

        public var pipelineId: Int64?

        public var pipelineRunId: Int64?

        public var sources: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.executeNumber != nil {
                map["executeNumber"] = self.executeNumber!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.jobId != nil {
                map["jobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["jobName"] = self.jobName!
            }
            if self.operatorAccountId != nil {
                map["operatorAccountId"] = self.operatorAccountId!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineRunId != nil {
                map["pipelineRunId"] = self.pipelineRunId!
            }
            if self.sources != nil {
                map["sources"] = self.sources!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["executeNumber"] as? Int32 {
                self.executeNumber = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["jobId"] as? Int64 {
                self.jobId = value
            }
            if let value = dict["jobName"] as? String {
                self.jobName = value
            }
            if let value = dict["operatorAccountId"] as? String {
                self.operatorAccountId = value
            }
            if let value = dict["pipelineId"] as? Int64 {
                self.pipelineId = value
            }
            if let value = dict["pipelineRunId"] as? Int64 {
                self.pipelineRunId = value
            }
            if let value = dict["sources"] as? String {
                self.sources = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var jobs: [ListPipelineJobHistorysResponseBody.Jobs]?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["jobs"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["jobs"] as? [Any?] {
            var tmp : [ListPipelineJobHistorysResponseBody.Jobs] = []
            for v in value {
                if v != nil {
                    var model = ListPipelineJobHistorysResponseBody.Jobs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.jobs = tmp
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["totalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListPipelineJobHistorysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineJobHistorysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPipelineJobHistorysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPipelineJobsRequest : Tea.TeaModel {
    public var category: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["category"] as? String {
            self.category = value
        }
    }
}

public class ListPipelineJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public var identifier: String?

        public var jobName: String?

        public var lastJobId: Int64?

        public var lastJobParams: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.jobName != nil {
                map["jobName"] = self.jobName!
            }
            if self.lastJobId != nil {
                map["lastJobId"] = self.lastJobId!
            }
            if self.lastJobParams != nil {
                map["lastJobParams"] = self.lastJobParams!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["jobName"] as? String {
                self.jobName = value
            }
            if let value = dict["lastJobId"] as? Int64 {
                self.lastJobId = value
            }
            if let value = dict["lastJobParams"] as? String {
                self.lastJobParams = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var jobs: [ListPipelineJobsResponseBody.Jobs]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["jobs"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["jobs"] as? [Any?] {
            var tmp : [ListPipelineJobsResponseBody.Jobs] = []
            for v in value {
                if v != nil {
                    var model = ListPipelineJobsResponseBody.Jobs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.jobs = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListPipelineJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPipelineJobsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPipelineRelationsRequest : Tea.TeaModel {
    public var relObjectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relObjectType != nil {
            map["relObjectType"] = self.relObjectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["relObjectType"] as? String {
            self.relObjectType = value
        }
    }
}

public class ListPipelineRelationsResponseBody : Tea.TeaModel {
    public class PipelineRelations : Tea.TeaModel {
        public var refObjectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.refObjectId != nil {
                map["refObjectId"] = self.refObjectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["refObjectId"] as? Int64 {
                self.refObjectId = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelineRelations: [ListPipelineRelationsResponseBody.PipelineRelations]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelineRelations != nil {
            var tmp : [Any] = []
            for k in self.pipelineRelations! {
                tmp.append(k.toMap())
            }
            map["pipelineRelations"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["pipelineRelations"] as? [Any?] {
            var tmp : [ListPipelineRelationsResponseBody.PipelineRelations] = []
            for v in value {
                if v != nil {
                    var model = ListPipelineRelationsResponseBody.PipelineRelations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.pipelineRelations = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListPipelineRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPipelineRelationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPipelineRunsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: Int64?

    public var status: String?

    public var triggerMode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.triggerMode != nil {
            map["triggerMode"] = self.triggerMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["startTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["status"] as? String {
            self.status = value
        }
        if let value = dict["triggerMode"] as? Int32 {
            self.triggerMode = value
        }
    }
}

public class ListPipelineRunsResponseBody : Tea.TeaModel {
    public class PipelineRuns : Tea.TeaModel {
        public var creatorAccountId: String?

        public var endTime: Int64?

        public var pipelineId: Int64?

        public var pipelineRunId: Int64?

        public var startTime: Int64?

        public var status: String?

        public var triggerMode: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineRunId != nil {
                map["pipelineRunId"] = self.pipelineRunId!
            }
            if self.startTime != nil {
                map["startTime"] = self.startTime!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.triggerMode != nil {
                map["triggerMode"] = self.triggerMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["creatorAccountId"] as? String {
                self.creatorAccountId = value
            }
            if let value = dict["endTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["pipelineId"] as? Int64 {
                self.pipelineId = value
            }
            if let value = dict["pipelineRunId"] as? Int64 {
                self.pipelineRunId = value
            }
            if let value = dict["startTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["triggerMode"] as? Int64 {
                self.triggerMode = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nextToken: String?

    public var pipelineRuns: [ListPipelineRunsResponseBody.PipelineRuns]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelineRuns != nil {
            var tmp : [Any] = []
            for k in self.pipelineRuns! {
                tmp.append(k.toMap())
            }
            map["pipelineRuns"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["pipelineRuns"] as? [Any?] {
            var tmp : [ListPipelineRunsResponseBody.PipelineRuns] = []
            for v in value {
                if v != nil {
                    var model = ListPipelineRunsResponseBody.PipelineRuns()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.pipelineRuns = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListPipelineRunsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineRunsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPipelineRunsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPipelinesRequest : Tea.TeaModel {
    public var createEndTime: Int64?

    public var createStartTime: Int64?

    public var creatorAccountIds: String?

    public var executeAccountIds: String?

    public var executeEndTime: Int64?

    public var executeStartTime: Int64?

    public var maxResults: Int64?

    public var nextToken: String?

    public var pipelineName: String?

    public var statusList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createEndTime != nil {
            map["createEndTime"] = self.createEndTime!
        }
        if self.createStartTime != nil {
            map["createStartTime"] = self.createStartTime!
        }
        if self.creatorAccountIds != nil {
            map["creatorAccountIds"] = self.creatorAccountIds!
        }
        if self.executeAccountIds != nil {
            map["executeAccountIds"] = self.executeAccountIds!
        }
        if self.executeEndTime != nil {
            map["executeEndTime"] = self.executeEndTime!
        }
        if self.executeStartTime != nil {
            map["executeStartTime"] = self.executeStartTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelineName != nil {
            map["pipelineName"] = self.pipelineName!
        }
        if self.statusList != nil {
            map["statusList"] = self.statusList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["createEndTime"] as? Int64 {
            self.createEndTime = value
        }
        if let value = dict["createStartTime"] as? Int64 {
            self.createStartTime = value
        }
        if let value = dict["creatorAccountIds"] as? String {
            self.creatorAccountIds = value
        }
        if let value = dict["executeAccountIds"] as? String {
            self.executeAccountIds = value
        }
        if let value = dict["executeEndTime"] as? Int64 {
            self.executeEndTime = value
        }
        if let value = dict["executeStartTime"] as? Int64 {
            self.executeStartTime = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["pipelineName"] as? String {
            self.pipelineName = value
        }
        if let value = dict["statusList"] as? String {
            self.statusList = value
        }
    }
}

public class ListPipelinesResponseBody : Tea.TeaModel {
    public class Pipelines : Tea.TeaModel {
        public var createTime: Int64?

        public var creatorAccountId: String?

        public var groupId: Int64?

        public var pipelineId: Int64?

        public var pipelineName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.groupId != nil {
                map["groupId"] = self.groupId!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineName != nil {
                map["pipelineName"] = self.pipelineName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["creatorAccountId"] as? String {
                self.creatorAccountId = value
            }
            if let value = dict["groupId"] as? Int64 {
                self.groupId = value
            }
            if let value = dict["pipelineId"] as? Int64 {
                self.pipelineId = value
            }
            if let value = dict["pipelineName"] as? String {
                self.pipelineName = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nextToken: String?

    public var pipelines: [ListPipelinesResponseBody.Pipelines]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelines != nil {
            var tmp : [Any] = []
            for k in self.pipelines! {
                tmp.append(k.toMap())
            }
            map["pipelines"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["pipelines"] as? [Any?] {
            var tmp : [ListPipelinesResponseBody.Pipelines] = []
            for v in value {
                if v != nil {
                    var model = ListPipelinesResponseBody.Pipelines()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.pipelines = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPipelinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectLabelsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int32?

    public var pageSize: Int64?

    public var repositoryIdentity: String?

    public var search: String?

    public var sort: String?

    public var withCounts: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.withCounts != nil {
            map["withCounts"] = self.withCounts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["orderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
        if let value = dict["search"] as? String {
            self.search = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
        if let value = dict["withCounts"] as? Bool {
            self.withCounts = value
        }
    }
}

public class ListProjectLabelsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var color: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public var openMergeRequestsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.color != nil {
                map["color"] = self.color!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.openMergeRequestsCount != nil {
                map["openMergeRequestsCount"] = self.openMergeRequestsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["color"] as? String {
                self.color = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["openMergeRequestsCount"] as? Int64 {
                self.openMergeRequestsCount = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListProjectLabelsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListProjectLabelsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListProjectLabelsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListProjectLabelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectLabelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectLabelsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectMembersRequest : Tea.TeaModel {
    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.targetType != nil {
            map["targetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["targetType"] as? String {
            self.targetType = value
        }
    }
}

public class ListProjectMembersResponseBody : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public class Division : Tea.TeaModel {
            public var identifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
            }
        }
        public class OrganizationUserInfo : Tea.TeaModel {
            public var organizationIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.organizationIdentifier != nil {
                    map["organizationIdentifier"] = self.organizationIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["organizationIdentifier"] as? String {
                    self.organizationIdentifier = value
                }
            }
        }
        public var account: String?

        public var avatar: String?

        public var dingTalkId: String?

        public var displayName: String?

        public var displayNickName: String?

        public var displayRealName: String?

        public var division: ListProjectMembersResponseBody.Members.Division?

        public var email: String?

        public var gender: String?

        public var identifier: String?

        public var mobile: String?

        public var nameEn: String?

        public var nickName: String?

        public var nickNamePinyin: String?

        public var organizationUserInfo: ListProjectMembersResponseBody.Members.OrganizationUserInfo?

        public var realName: String?

        public var realNamePinyin: String?

        public var roleName: String?

        public var stamp: String?

        public var tbRoleId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.division?.validate()
            try self.organizationUserInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                map["account"] = self.account!
            }
            if self.avatar != nil {
                map["avatar"] = self.avatar!
            }
            if self.dingTalkId != nil {
                map["dingTalkId"] = self.dingTalkId!
            }
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            if self.displayNickName != nil {
                map["displayNickName"] = self.displayNickName!
            }
            if self.displayRealName != nil {
                map["displayRealName"] = self.displayRealName!
            }
            if self.division != nil {
                map["division"] = self.division?.toMap()
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.gender != nil {
                map["gender"] = self.gender!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.mobile != nil {
                map["mobile"] = self.mobile!
            }
            if self.nameEn != nil {
                map["nameEn"] = self.nameEn!
            }
            if self.nickName != nil {
                map["nickName"] = self.nickName!
            }
            if self.nickNamePinyin != nil {
                map["nickNamePinyin"] = self.nickNamePinyin!
            }
            if self.organizationUserInfo != nil {
                map["organizationUserInfo"] = self.organizationUserInfo?.toMap()
            }
            if self.realName != nil {
                map["realName"] = self.realName!
            }
            if self.realNamePinyin != nil {
                map["realNamePinyin"] = self.realNamePinyin!
            }
            if self.roleName != nil {
                map["roleName"] = self.roleName!
            }
            if self.stamp != nil {
                map["stamp"] = self.stamp!
            }
            if self.tbRoleId != nil {
                map["tbRoleId"] = self.tbRoleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["account"] as? String {
                self.account = value
            }
            if let value = dict["avatar"] as? String {
                self.avatar = value
            }
            if let value = dict["dingTalkId"] as? String {
                self.dingTalkId = value
            }
            if let value = dict["displayName"] as? String {
                self.displayName = value
            }
            if let value = dict["displayNickName"] as? String {
                self.displayNickName = value
            }
            if let value = dict["displayRealName"] as? String {
                self.displayRealName = value
            }
            if let value = dict["division"] as? [String: Any?] {
                var model = ListProjectMembersResponseBody.Members.Division()
                model.fromMap(value)
                self.division = model
            }
            if let value = dict["email"] as? String {
                self.email = value
            }
            if let value = dict["gender"] as? String {
                self.gender = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["mobile"] as? String {
                self.mobile = value
            }
            if let value = dict["nameEn"] as? String {
                self.nameEn = value
            }
            if let value = dict["nickName"] as? String {
                self.nickName = value
            }
            if let value = dict["nickNamePinyin"] as? String {
                self.nickNamePinyin = value
            }
            if let value = dict["organizationUserInfo"] as? [String: Any?] {
                var model = ListProjectMembersResponseBody.Members.OrganizationUserInfo()
                model.fromMap(value)
                self.organizationUserInfo = model
            }
            if let value = dict["realName"] as? String {
                self.realName = value
            }
            if let value = dict["realNamePinyin"] as? String {
                self.realNamePinyin = value
            }
            if let value = dict["roleName"] as? String {
                self.roleName = value
            }
            if let value = dict["stamp"] as? String {
                self.stamp = value
            }
            if let value = dict["tbRoleId"] as? String {
                self.tbRoleId = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var members: [ListProjectMembersResponseBody.Members]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["members"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["members"] as? [Any?] {
            var tmp : [ListProjectMembersResponseBody.Members] = []
            for v in value {
                if v != nil {
                    var model = ListProjectMembersResponseBody.Members()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.members = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListProjectMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectMembersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectTemplatesRequest : Tea.TeaModel {
    public var category: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["category"] as? String {
            self.category = value
        }
    }
}

public class ListProjectTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public var copyFrom: String?

        public var creator: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var icon: String?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var nameEn: String?

        public var resourceCategory: String?

        public var resourceType: String?

        public var spaceIdentifier: String?

        public var spaceType: String?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.copyFrom != nil {
                map["copyFrom"] = self.copyFrom!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.icon != nil {
                map["icon"] = self.icon!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameEn != nil {
                map["nameEn"] = self.nameEn!
            }
            if self.resourceCategory != nil {
                map["resourceCategory"] = self.resourceCategory!
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["copyFrom"] as? String {
                self.copyFrom = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["icon"] as? String {
                self.icon = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameEn"] as? String {
                self.nameEn = value
            }
            if let value = dict["resourceCategory"] as? String {
                self.resourceCategory = value
            }
            if let value = dict["resourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["spaceType"] as? String {
                self.spaceType = value
            }
            if let value = dict["type"] as? Int64 {
                self.type = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var templates: [ListProjectTemplatesResponseBody.Templates]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.templates != nil {
            var tmp : [Any] = []
            for k in self.templates! {
                tmp.append(k.toMap())
            }
            map["templates"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["templates"] as? [Any?] {
            var tmp : [ListProjectTemplatesResponseBody.Templates] = []
            for v in value {
                if v != nil {
                    var model = ListProjectTemplatesResponseBody.Templates()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.templates = tmp
        }
    }
}

public class ListProjectTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectWorkitemTypesRequest : Tea.TeaModel {
    public var category: String?

    public var spaceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["category"] as? String {
            self.category = value
        }
        if let value = dict["spaceType"] as? String {
            self.spaceType = value
        }
    }
}

public class ListProjectWorkitemTypesResponseBody : Tea.TeaModel {
    public class WorkitemTypes : Tea.TeaModel {
        public var addUser: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var defaultType: Bool?

        public var description_: String?

        public var enable: Bool?

        public var gmtAdd: Int64?

        public var gmtCreate: Int64?

        public var identifier: String?

        public var name: String?

        public var nameEn: String?

        public var systemDefault: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addUser != nil {
                map["addUser"] = self.addUser!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.defaultType != nil {
                map["defaultType"] = self.defaultType!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.gmtAdd != nil {
                map["gmtAdd"] = self.gmtAdd!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameEn != nil {
                map["nameEn"] = self.nameEn!
            }
            if self.systemDefault != nil {
                map["systemDefault"] = self.systemDefault!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["addUser"] as? String {
                self.addUser = value
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["defaultType"] as? Bool {
                self.defaultType = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["enable"] as? Bool {
                self.enable = value
            }
            if let value = dict["gmtAdd"] as? Int64 {
                self.gmtAdd = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameEn"] as? String {
                self.nameEn = value
            }
            if let value = dict["systemDefault"] as? Bool {
                self.systemDefault = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workitemTypes: [ListProjectWorkitemTypesResponseBody.WorkitemTypes]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitemTypes != nil {
            var tmp : [Any] = []
            for k in self.workitemTypes! {
                tmp.append(k.toMap())
            }
            map["workitemTypes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["workitemTypes"] as? [Any?] {
            var tmp : [ListProjectWorkitemTypesResponseBody.WorkitemTypes] = []
            for v in value {
                if v != nil {
                    var model = ListProjectWorkitemTypesResponseBody.WorkitemTypes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.workitemTypes = tmp
        }
    }
}

public class ListProjectWorkitemTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectWorkitemTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectWorkitemTypesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProjectsRequest : Tea.TeaModel {
    public var category: String?

    public var conditions: String?

    public var extraConditions: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var scope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.conditions != nil {
            map["conditions"] = self.conditions!
        }
        if self.extraConditions != nil {
            map["extraConditions"] = self.extraConditions!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["category"] as? String {
            self.category = value
        }
        if let value = dict["conditions"] as? String {
            self.conditions = value
        }
        if let value = dict["extraConditions"] as? String {
            self.extraConditions = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["scope"] as? String {
            self.scope = value
        }
    }
}

public class ListProjectsResponseBody : Tea.TeaModel {
    public class Projects : Tea.TeaModel {
        public var categoryIdentifier: String?

        public var creator: String?

        public var customCode: String?

        public var deleteTime: Int64?

        public var description_: String?

        public var gmtCreate: Int64?

        public var icon: String?

        public var identifier: String?

        public var logicalStatus: String?

        public var name: String?

        public var scope: String?

        public var statusStageIdentifier: String?

        public var typeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.customCode != nil {
                map["customCode"] = self.customCode!
            }
            if self.deleteTime != nil {
                map["deleteTime"] = self.deleteTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.icon != nil {
                map["icon"] = self.icon!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.typeIdentifier != nil {
                map["typeIdentifier"] = self.typeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["customCode"] as? String {
                self.customCode = value
            }
            if let value = dict["deleteTime"] as? Int64 {
                self.deleteTime = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["icon"] as? String {
                self.icon = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["logicalStatus"] as? String {
                self.logicalStatus = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["scope"] as? String {
                self.scope = value
            }
            if let value = dict["statusStageIdentifier"] as? String {
                self.statusStageIdentifier = value
            }
            if let value = dict["typeIdentifier"] as? String {
                self.typeIdentifier = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var projects: [ListProjectsResponseBody.Projects]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.projects != nil {
            var tmp : [Any] = []
            for k in self.projects! {
                tmp.append(k.toMap())
            }
            map["projects"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["projects"] as? [Any?] {
            var tmp : [ListProjectsResponseBody.Projects] = []
            for v in value {
                if v != nil {
                    var model = ListProjectsResponseBody.Projects()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.projects = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProjectsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListProtectedBranchesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ListProtectedBranchesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AllowMergeUsers : Tea.TeaModel {
            public var avatar: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatar"] as? String {
                    self.avatar = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public class AllowPushUsers : Tea.TeaModel {
            public var avatar: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatar"] as? String {
                    self.avatar = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public class MergeRequestSetting : Tea.TeaModel {
            public class DefaultAssignees : Tea.TeaModel {
                public var avatar: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avatar != nil {
                        map["avatar"] = self.avatar!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["avatar"] as? String {
                        self.avatar = value
                    }
                    if let value = dict["email"] as? String {
                        self.email = value
                    }
                    if let value = dict["id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["username"] as? String {
                        self.username = value
                    }
                }
            }
            public var allowMergeRequestRoles: [Int32]?

            public var defaultAssignees: [ListProtectedBranchesResponseBody.Result.MergeRequestSetting.DefaultAssignees]?

            public var isAllowSelfApproval: Bool?

            public var isRequireDiscussionProcessed: Bool?

            public var isRequired: Bool?

            public var isResetApprovalWhenNewPush: Bool?

            public var minimumApproval: Int32?

            public var mrMode: String?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowMergeRequestRoles != nil {
                    map["allowMergeRequestRoles"] = self.allowMergeRequestRoles!
                }
                if self.defaultAssignees != nil {
                    var tmp : [Any] = []
                    for k in self.defaultAssignees! {
                        tmp.append(k.toMap())
                    }
                    map["defaultAssignees"] = tmp
                }
                if self.isAllowSelfApproval != nil {
                    map["isAllowSelfApproval"] = self.isAllowSelfApproval!
                }
                if self.isRequireDiscussionProcessed != nil {
                    map["isRequireDiscussionProcessed"] = self.isRequireDiscussionProcessed!
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.isResetApprovalWhenNewPush != nil {
                    map["isResetApprovalWhenNewPush"] = self.isResetApprovalWhenNewPush!
                }
                if self.minimumApproval != nil {
                    map["minimumApproval"] = self.minimumApproval!
                }
                if self.mrMode != nil {
                    map["mrMode"] = self.mrMode!
                }
                if self.whiteList != nil {
                    map["whiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["allowMergeRequestRoles"] as? [Int32] {
                    self.allowMergeRequestRoles = value
                }
                if let value = dict["defaultAssignees"] as? [Any?] {
                    var tmp : [ListProtectedBranchesResponseBody.Result.MergeRequestSetting.DefaultAssignees] = []
                    for v in value {
                        if v != nil {
                            var model = ListProtectedBranchesResponseBody.Result.MergeRequestSetting.DefaultAssignees()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.defaultAssignees = tmp
                }
                if let value = dict["isAllowSelfApproval"] as? Bool {
                    self.isAllowSelfApproval = value
                }
                if let value = dict["isRequireDiscussionProcessed"] as? Bool {
                    self.isRequireDiscussionProcessed = value
                }
                if let value = dict["isRequired"] as? Bool {
                    self.isRequired = value
                }
                if let value = dict["isResetApprovalWhenNewPush"] as? Bool {
                    self.isResetApprovalWhenNewPush = value
                }
                if let value = dict["minimumApproval"] as? Int32 {
                    self.minimumApproval = value
                }
                if let value = dict["mrMode"] as? String {
                    self.mrMode = value
                }
                if let value = dict["whiteList"] as? String {
                    self.whiteList = value
                }
            }
        }
        public class TestSettingDTO : Tea.TeaModel {
            public class CheckConfig : Tea.TeaModel {
                public class CheckItems : Tea.TeaModel {
                    public var isRequired: Bool?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isRequired != nil {
                            map["isRequired"] = self.isRequired!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["isRequired"] as? Bool {
                            self.isRequired = value
                        }
                        if let value = dict["name"] as? String {
                            self.name = value
                        }
                    }
                }
                public var checkItems: [ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkItems != nil {
                        var tmp : [Any] = []
                        for k in self.checkItems! {
                            tmp.append(k.toMap())
                        }
                        map["checkItems"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["checkItems"] as? [Any?] {
                        var tmp : [ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems] = []
                        for v in value {
                            if v != nil {
                                var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.checkItems = tmp
                    }
                }
            }
            public class CheckTaskQualityConfig : Tea.TeaModel {
                public var bizNo: String?

                public var enabled: Bool?

                public var message: String?

                public var taskName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizNo != nil {
                        map["bizNo"] = self.bizNo!
                    }
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    if self.taskName != nil {
                        map["taskName"] = self.taskName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["bizNo"] as? String {
                        self.bizNo = value
                    }
                    if let value = dict["enabled"] as? Bool {
                        self.enabled = value
                    }
                    if let value = dict["message"] as? String {
                        self.message = value
                    }
                    if let value = dict["taskName"] as? String {
                        self.taskName = value
                    }
                }
            }
            public class CodeGuidelinesDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["enabled"] as? Bool {
                        self.enabled = value
                    }
                    if let value = dict["message"] as? String {
                        self.message = value
                    }
                }
            }
            public class SensitiveInfoDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["enabled"] as? Bool {
                        self.enabled = value
                    }
                    if let value = dict["message"] as? String {
                        self.message = value
                    }
                }
            }
            public var checkConfig: ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig?

            public var checkTaskQualityConfig: ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig?

            public var codeGuidelinesDetection: ListProtectedBranchesResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection?

            public var isRequired: Bool?

            public var sensitiveInfoDetection: ListProtectedBranchesResponseBody.Result.TestSettingDTO.SensitiveInfoDetection?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.checkConfig?.validate()
                try self.checkTaskQualityConfig?.validate()
                try self.codeGuidelinesDetection?.validate()
                try self.sensitiveInfoDetection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkConfig != nil {
                    map["checkConfig"] = self.checkConfig?.toMap()
                }
                if self.checkTaskQualityConfig != nil {
                    map["checkTaskQualityConfig"] = self.checkTaskQualityConfig?.toMap()
                }
                if self.codeGuidelinesDetection != nil {
                    map["codeGuidelinesDetection"] = self.codeGuidelinesDetection?.toMap()
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.sensitiveInfoDetection != nil {
                    map["sensitiveInfoDetection"] = self.sensitiveInfoDetection?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["checkConfig"] as? [String: Any?] {
                    var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig()
                    model.fromMap(value)
                    self.checkConfig = model
                }
                if let value = dict["checkTaskQualityConfig"] as? [String: Any?] {
                    var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig()
                    model.fromMap(value)
                    self.checkTaskQualityConfig = model
                }
                if let value = dict["codeGuidelinesDetection"] as? [String: Any?] {
                    var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection()
                    model.fromMap(value)
                    self.codeGuidelinesDetection = model
                }
                if let value = dict["isRequired"] as? Bool {
                    self.isRequired = value
                }
                if let value = dict["sensitiveInfoDetection"] as? [String: Any?] {
                    var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO.SensitiveInfoDetection()
                    model.fromMap(value)
                    self.sensitiveInfoDetection = model
                }
            }
        }
        public var allowMergeRoles: [Int32]?

        public var allowMergeUserIds: [Int64]?

        public var allowMergeUsers: [ListProtectedBranchesResponseBody.Result.AllowMergeUsers]?

        public var allowPushRoles: [Int32]?

        public var allowPushUserIds: [Int64]?

        public var allowPushUsers: [ListProtectedBranchesResponseBody.Result.AllowPushUsers]?

        public var branch: String?

        public var createdAt: String?

        public var id: Int64?

        public var matches: [String]?

        public var mergeRequestSetting: ListProtectedBranchesResponseBody.Result.MergeRequestSetting?

        public var testSettingDTO: ListProtectedBranchesResponseBody.Result.TestSettingDTO?

        public var updatedAt: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mergeRequestSetting?.validate()
            try self.testSettingDTO?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowMergeRoles != nil {
                map["allowMergeRoles"] = self.allowMergeRoles!
            }
            if self.allowMergeUserIds != nil {
                map["allowMergeUserIds"] = self.allowMergeUserIds!
            }
            if self.allowMergeUsers != nil {
                var tmp : [Any] = []
                for k in self.allowMergeUsers! {
                    tmp.append(k.toMap())
                }
                map["allowMergeUsers"] = tmp
            }
            if self.allowPushRoles != nil {
                map["allowPushRoles"] = self.allowPushRoles!
            }
            if self.allowPushUserIds != nil {
                map["allowPushUserIds"] = self.allowPushUserIds!
            }
            if self.allowPushUsers != nil {
                var tmp : [Any] = []
                for k in self.allowPushUsers! {
                    tmp.append(k.toMap())
                }
                map["allowPushUsers"] = tmp
            }
            if self.branch != nil {
                map["branch"] = self.branch!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.matches != nil {
                map["matches"] = self.matches!
            }
            if self.mergeRequestSetting != nil {
                map["mergeRequestSetting"] = self.mergeRequestSetting?.toMap()
            }
            if self.testSettingDTO != nil {
                map["testSettingDTO"] = self.testSettingDTO?.toMap()
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["allowMergeRoles"] as? [Int32] {
                self.allowMergeRoles = value
            }
            if let value = dict["allowMergeUserIds"] as? [Int64] {
                self.allowMergeUserIds = value
            }
            if let value = dict["allowMergeUsers"] as? [Any?] {
                var tmp : [ListProtectedBranchesResponseBody.Result.AllowMergeUsers] = []
                for v in value {
                    if v != nil {
                        var model = ListProtectedBranchesResponseBody.Result.AllowMergeUsers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.allowMergeUsers = tmp
            }
            if let value = dict["allowPushRoles"] as? [Int32] {
                self.allowPushRoles = value
            }
            if let value = dict["allowPushUserIds"] as? [Int64] {
                self.allowPushUserIds = value
            }
            if let value = dict["allowPushUsers"] as? [Any?] {
                var tmp : [ListProtectedBranchesResponseBody.Result.AllowPushUsers] = []
                for v in value {
                    if v != nil {
                        var model = ListProtectedBranchesResponseBody.Result.AllowPushUsers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.allowPushUsers = tmp
            }
            if let value = dict["branch"] as? String {
                self.branch = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["matches"] as? [String] {
                self.matches = value
            }
            if let value = dict["mergeRequestSetting"] as? [String: Any?] {
                var model = ListProtectedBranchesResponseBody.Result.MergeRequestSetting()
                model.fromMap(value)
                self.mergeRequestSetting = model
            }
            if let value = dict["testSettingDTO"] as? [String: Any?] {
                var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO()
                model.fromMap(value)
                self.testSettingDTO = model
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListProtectedBranchesResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListProtectedBranchesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListProtectedBranchesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListProtectedBranchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProtectedBranchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListProtectedBranchesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPushRulesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ListPushRulesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class RuleInfos : Tea.TeaModel {
            public var checkerName: String?

            public var checkerType: String?

            public var extraMessage: String?

            public var fileRuleRegexes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkerName != nil {
                    map["checkerName"] = self.checkerName!
                }
                if self.checkerType != nil {
                    map["checkerType"] = self.checkerType!
                }
                if self.extraMessage != nil {
                    map["extraMessage"] = self.extraMessage!
                }
                if self.fileRuleRegexes != nil {
                    map["fileRuleRegexes"] = self.fileRuleRegexes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["checkerName"] as? String {
                    self.checkerName = value
                }
                if let value = dict["checkerType"] as? String {
                    self.checkerType = value
                }
                if let value = dict["extraMessage"] as? String {
                    self.extraMessage = value
                }
                if let value = dict["fileRuleRegexes"] as? [String] {
                    self.fileRuleRegexes = value
                }
            }
        }
        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var ruleInfos: [ListPushRulesResponseBody.Result.RuleInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleInfos != nil {
                var tmp : [Any] = []
                for k in self.ruleInfos! {
                    tmp.append(k.toMap())
                }
                map["ruleInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["gmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ruleInfos"] as? [Any?] {
                var tmp : [ListPushRulesResponseBody.Result.RuleInfos] = []
                for v in value {
                    if v != nil {
                        var model = ListPushRulesResponseBody.Result.RuleInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ruleInfos = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListPushRulesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListPushRulesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListPushRulesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListPushRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPushRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPushRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRepositoriesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var archived: Bool?

    public var minAccessLevel: Int32?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int64?

    public var perPage: Int64?

    public var search: String?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.archived != nil {
            map["archived"] = self.archived!
        }
        if self.minAccessLevel != nil {
            map["minAccessLevel"] = self.minAccessLevel!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["archived"] as? Bool {
            self.archived = value
        }
        if let value = dict["minAccessLevel"] as? Int32 {
            self.minAccessLevel = value
        }
        if let value = dict["orderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["perPage"] as? Int64 {
            self.perPage = value
        }
        if let value = dict["search"] as? String {
            self.search = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
    }
}

public class ListRepositoriesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var id: Int64?

        public var accessLevel: Int32?

        public var archive: Bool?

        public var avatarUrl: String?

        public var createdAt: String?

        public var description_: String?

        public var importStatus: String?

        public var lastActivityAt: String?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespaceId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var star: Bool?

        public var starCount: Int64?

        public var updatedAt: String?

        public var visibilityLevel: String?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.archive != nil {
                map["archive"] = self.archive!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.importStatus != nil {
                map["importStatus"] = self.importStatus!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespaceId != nil {
                map["namespaceId"] = self.namespaceId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.star != nil {
                map["star"] = self.star!
            }
            if self.starCount != nil {
                map["starCount"] = self.starCount!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["archive"] as? Bool {
                self.archive = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["importStatus"] as? String {
                self.importStatus = value
            }
            if let value = dict["lastActivityAt"] as? String {
                self.lastActivityAt = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["namespaceId"] as? Int64 {
                self.namespaceId = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["pathWithNamespace"] as? String {
                self.pathWithNamespace = value
            }
            if let value = dict["star"] as? Bool {
                self.star = value
            }
            if let value = dict["starCount"] as? Int64 {
                self.starCount = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["visibilityLevel"] as? String {
                self.visibilityLevel = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: Int32?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoriesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? Int32 {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListRepositoriesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListRepositoriesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListRepositoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRepositoriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRepositoryBranchesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var search: String?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["search"] as? String {
            self.search = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
    }
}

public class ListRepositoryBranchesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var committedDate: String?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["authorEmail"] as? String {
                    self.authorEmail = value
                }
                if let value = dict["authorName"] as? String {
                    self.authorName = value
                }
                if let value = dict["authoredDate"] as? String {
                    self.authoredDate = value
                }
                if let value = dict["committedDate"] as? String {
                    self.committedDate = value
                }
                if let value = dict["committerEmail"] as? String {
                    self.committerEmail = value
                }
                if let value = dict["committerName"] as? String {
                    self.committerName = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["parentIds"] as? [String] {
                    self.parentIds = value
                }
                if let value = dict["shortId"] as? String {
                    self.shortId = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public var commit: ListRepositoryBranchesResponseBody.Result.Commit?

        public var name: String?

        public var protected: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.protected != nil {
                map["protected"] = self.protected!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["commit"] as? [String: Any?] {
                var model = ListRepositoryBranchesResponseBody.Result.Commit()
                model.fromMap(value)
                self.commit = model
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["protected"] as? String {
                self.protected = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryBranchesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListRepositoryBranchesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListRepositoryBranchesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListRepositoryBranchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryBranchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRepositoryBranchesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRepositoryCommitDiffRequest : Tea.TeaModel {
    public var accessToken: String?

    public var contextLine: Int32?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.contextLine != nil {
            map["contextLine"] = self.contextLine!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["contextLine"] as? Int32 {
            self.contextLine = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ListRepositoryCommitDiffResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var aMode: String?

        public var bMode: String?

        public var deletedFile: Bool?

        public var diff: String?

        public var isBinary: Bool?

        public var isNewLfs: Bool?

        public var isOldLfs: Bool?

        public var newFile: Bool?

        public var newId: String?

        public var newPath: String?

        public var oldId: String?

        public var oldPath: String?

        public var renamedFile: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aMode != nil {
                map["aMode"] = self.aMode!
            }
            if self.bMode != nil {
                map["bMode"] = self.bMode!
            }
            if self.deletedFile != nil {
                map["deletedFile"] = self.deletedFile!
            }
            if self.diff != nil {
                map["diff"] = self.diff!
            }
            if self.isBinary != nil {
                map["isBinary"] = self.isBinary!
            }
            if self.isNewLfs != nil {
                map["isNewLfs"] = self.isNewLfs!
            }
            if self.isOldLfs != nil {
                map["isOldLfs"] = self.isOldLfs!
            }
            if self.newFile != nil {
                map["newFile"] = self.newFile!
            }
            if self.newId != nil {
                map["newId"] = self.newId!
            }
            if self.newPath != nil {
                map["newPath"] = self.newPath!
            }
            if self.oldId != nil {
                map["oldId"] = self.oldId!
            }
            if self.oldPath != nil {
                map["oldPath"] = self.oldPath!
            }
            if self.renamedFile != nil {
                map["renamedFile"] = self.renamedFile!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["aMode"] as? String {
                self.aMode = value
            }
            if let value = dict["bMode"] as? String {
                self.bMode = value
            }
            if let value = dict["deletedFile"] as? Bool {
                self.deletedFile = value
            }
            if let value = dict["diff"] as? String {
                self.diff = value
            }
            if let value = dict["isBinary"] as? Bool {
                self.isBinary = value
            }
            if let value = dict["isNewLfs"] as? Bool {
                self.isNewLfs = value
            }
            if let value = dict["isOldLfs"] as? Bool {
                self.isOldLfs = value
            }
            if let value = dict["newFile"] as? Bool {
                self.newFile = value
            }
            if let value = dict["newId"] as? String {
                self.newId = value
            }
            if let value = dict["newPath"] as? String {
                self.newPath = value
            }
            if let value = dict["oldId"] as? String {
                self.oldId = value
            }
            if let value = dict["oldPath"] as? String {
                self.oldPath = value
            }
            if let value = dict["renamedFile"] as? Bool {
                self.renamedFile = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryCommitDiffResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListRepositoryCommitDiffResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListRepositoryCommitDiffResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListRepositoryCommitDiffResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryCommitDiffResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRepositoryCommitDiffResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRepositoryCommitsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var end: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var path: String?

    public var refName: String?

    public var search: String?

    public var showCommentsCount: Bool?

    public var showSignature: Bool?

    public var start: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.end != nil {
            map["end"] = self.end!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.refName != nil {
            map["refName"] = self.refName!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.showCommentsCount != nil {
            map["showCommentsCount"] = self.showCommentsCount!
        }
        if self.showSignature != nil {
            map["showSignature"] = self.showSignature!
        }
        if self.start != nil {
            map["start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["end"] as? String {
            self.end = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["path"] as? String {
            self.path = value
        }
        if let value = dict["refName"] as? String {
            self.refName = value
        }
        if let value = dict["search"] as? String {
            self.search = value
        }
        if let value = dict["showCommentsCount"] as? Bool {
            self.showCommentsCount = value
        }
        if let value = dict["showSignature"] as? Bool {
            self.showSignature = value
        }
        if let value = dict["start"] as? String {
            self.start = value
        }
    }
}

public class ListRepositoryCommitsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
                if let value = dict["websiteUrl"] as? String {
                    self.websiteUrl = value
                }
            }
        }
        public class Committer : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
                if let value = dict["websiteUrl"] as? String {
                    self.websiteUrl = value
                }
            }
        }
        public class Signature : Tea.TeaModel {
            public var gpgKeyId: String?

            public var verificationStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gpgKeyId != nil {
                    map["gpgKeyId"] = self.gpgKeyId!
                }
                if self.verificationStatus != nil {
                    map["verificationStatus"] = self.verificationStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["gpgKeyId"] as? String {
                    self.gpgKeyId = value
                }
                if let value = dict["verificationStatus"] as? String {
                    self.verificationStatus = value
                }
            }
        }
        public var author: ListRepositoryCommitsResponseBody.Result.Author?

        public var authorEmail: String?

        public var authorName: String?

        public var authoredDate: String?

        public var commentsCount: Int64?

        public var committedDate: String?

        public var committer: ListRepositoryCommitsResponseBody.Result.Committer?

        public var committerEmail: String?

        public var committerName: String?

        public var createdAt: String?

        public var id: String?

        public var message: String?

        public var parentIds: [String]?

        public var shortId: String?

        public var signature: ListRepositoryCommitsResponseBody.Result.Signature?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.committer?.validate()
            try self.signature?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.authorEmail != nil {
                map["authorEmail"] = self.authorEmail!
            }
            if self.authorName != nil {
                map["authorName"] = self.authorName!
            }
            if self.authoredDate != nil {
                map["authoredDate"] = self.authoredDate!
            }
            if self.commentsCount != nil {
                map["commentsCount"] = self.commentsCount!
            }
            if self.committedDate != nil {
                map["committedDate"] = self.committedDate!
            }
            if self.committer != nil {
                map["committer"] = self.committer?.toMap()
            }
            if self.committerEmail != nil {
                map["committerEmail"] = self.committerEmail!
            }
            if self.committerName != nil {
                map["committerName"] = self.committerName!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.parentIds != nil {
                map["parentIds"] = self.parentIds!
            }
            if self.shortId != nil {
                map["shortId"] = self.shortId!
            }
            if self.signature != nil {
                map["signature"] = self.signature?.toMap()
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["author"] as? [String: Any?] {
                var model = ListRepositoryCommitsResponseBody.Result.Author()
                model.fromMap(value)
                self.author = model
            }
            if let value = dict["authorEmail"] as? String {
                self.authorEmail = value
            }
            if let value = dict["authorName"] as? String {
                self.authorName = value
            }
            if let value = dict["authoredDate"] as? String {
                self.authoredDate = value
            }
            if let value = dict["commentsCount"] as? Int64 {
                self.commentsCount = value
            }
            if let value = dict["committedDate"] as? String {
                self.committedDate = value
            }
            if let value = dict["committer"] as? [String: Any?] {
                var model = ListRepositoryCommitsResponseBody.Result.Committer()
                model.fromMap(value)
                self.committer = model
            }
            if let value = dict["committerEmail"] as? String {
                self.committerEmail = value
            }
            if let value = dict["committerName"] as? String {
                self.committerName = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["message"] as? String {
                self.message = value
            }
            if let value = dict["parentIds"] as? [String] {
                self.parentIds = value
            }
            if let value = dict["shortId"] as? String {
                self.shortId = value
            }
            if let value = dict["signature"] as? [String: Any?] {
                var model = ListRepositoryCommitsResponseBody.Result.Signature()
                model.fromMap(value)
                self.signature = model
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryCommitsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListRepositoryCommitsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListRepositoryCommitsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListRepositoryCommitsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryCommitsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRepositoryCommitsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRepositoryGroupsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var includePersonal: Bool?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var parentId: Int64?

    public var search: String?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.includePersonal != nil {
            map["includePersonal"] = self.includePersonal!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.parentId != nil {
            map["parentId"] = self.parentId!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["includePersonal"] as? Bool {
            self.includePersonal = value
        }
        if let value = dict["orderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["parentId"] as? Int64 {
            self.parentId = value
        }
        if let value = dict["search"] as? String {
            self.search = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
    }
}

public class ListRepositoryGroupsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var createdAt: String?

        public var description_: String?

        public var groupCount: Int64?

        public var id: Int64?

        public var name: String?

        public var nameWithNamespace: String?

        public var ownerId: Int64?

        public var parentId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var projectCount: Int64?

        public var type: String?

        public var updatedAt: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.groupCount != nil {
                map["groupCount"] = self.groupCount!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.projectCount != nil {
                map["projectCount"] = self.projectCount!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["groupCount"] as? Int64 {
                self.groupCount = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["ownerId"] as? Int64 {
                self.ownerId = value
            }
            if let value = dict["parentId"] as? Int64 {
                self.parentId = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["pathWithNamespace"] as? String {
                self.pathWithNamespace = value
            }
            if let value = dict["projectCount"] as? Int64 {
                self.projectCount = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["visibilityLevel"] as? Int32 {
                self.visibilityLevel = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryGroupsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListRepositoryGroupsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListRepositoryGroupsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListRepositoryGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRepositoryGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRepositoryMemberWithInheritedRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ListRepositoryMemberWithInheritedResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Inherited : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public var nameWithNamespace: String?

            public var path: String?

            public var pathWithNamespace: String?

            public var type: String?

            public var visibilityLevel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.nameWithNamespace != nil {
                    map["nameWithNamespace"] = self.nameWithNamespace!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.pathWithNamespace != nil {
                    map["pathWithNamespace"] = self.pathWithNamespace!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.visibilityLevel != nil {
                    map["visibilityLevel"] = self.visibilityLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["nameWithNamespace"] as? String {
                    self.nameWithNamespace = value
                }
                if let value = dict["path"] as? String {
                    self.path = value
                }
                if let value = dict["pathWithNamespace"] as? String {
                    self.pathWithNamespace = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["visibilityLevel"] as? String {
                    self.visibilityLevel = value
                }
            }
        }
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var inherited: ListRepositoryMemberWithInheritedResponseBody.Result.Inherited?

        public var name: String?

        public var state: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inherited?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.inherited != nil {
                map["inherited"] = self.inherited?.toMap()
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["email"] as? String {
                self.email = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["inherited"] as? [String: Any?] {
                var model = ListRepositoryMemberWithInheritedResponseBody.Result.Inherited()
                model.fromMap(value)
                self.inherited = model
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["username"] as? String {
                self.username = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryMemberWithInheritedResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListRepositoryMemberWithInheritedResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListRepositoryMemberWithInheritedResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListRepositoryMemberWithInheritedResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryMemberWithInheritedResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRepositoryMemberWithInheritedResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRepositoryTagsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var search: String?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["search"] as? String {
            self.search = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
    }
}

public class ListRepositoryTagsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public class Signature : Tea.TeaModel {
                public var gpgKeyId: String?

                public var verificationStatus: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gpgKeyId != nil {
                        map["gpgKeyId"] = self.gpgKeyId!
                    }
                    if self.verificationStatus != nil {
                        map["verificationStatus"] = self.verificationStatus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["gpgKeyId"] as? String {
                        self.gpgKeyId = value
                    }
                    if let value = dict["verificationStatus"] as? String {
                        self.verificationStatus = value
                    }
                }
            }
            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var committedDate: String?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var signature: ListRepositoryTagsResponseBody.Result.Commit.Signature?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.signature?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.signature != nil {
                    map["signature"] = self.signature?.toMap()
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["authorEmail"] as? String {
                    self.authorEmail = value
                }
                if let value = dict["authorName"] as? String {
                    self.authorName = value
                }
                if let value = dict["authoredDate"] as? String {
                    self.authoredDate = value
                }
                if let value = dict["committedDate"] as? String {
                    self.committedDate = value
                }
                if let value = dict["committerEmail"] as? String {
                    self.committerEmail = value
                }
                if let value = dict["committerName"] as? String {
                    self.committerName = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["parentIds"] as? [String] {
                    self.parentIds = value
                }
                if let value = dict["shortId"] as? String {
                    self.shortId = value
                }
                if let value = dict["signature"] as? [String: Any?] {
                    var model = ListRepositoryTagsResponseBody.Result.Commit.Signature()
                    model.fromMap(value)
                    self.signature = model
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public var commit: ListRepositoryTagsResponseBody.Result.Commit?

        public var id: String?

        public var message: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["commit"] as? [String: Any?] {
                var model = ListRepositoryTagsResponseBody.Result.Commit()
                model.fromMap(value)
                self.commit = model
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["message"] as? String {
                self.message = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryTagsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListRepositoryTagsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListRepositoryTagsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListRepositoryTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRepositoryTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRepositoryTreeRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var path: String?

    public var refName: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.refName != nil {
            map["refName"] = self.refName!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["path"] as? String {
            self.path = value
        }
        if let value = dict["refName"] as? String {
            self.refName = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
    }
}

public class ListRepositoryTreeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var id: String?

        public var isLFS: Bool?

        public var mode: String?

        public var name: String?

        public var path: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isLFS != nil {
                map["isLFS"] = self.isLFS!
            }
            if self.mode != nil {
                map["mode"] = self.mode!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["isLFS"] as? Bool {
                self.isLFS = value
            }
            if let value = dict["mode"] as? String {
                self.mode = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryTreeResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListRepositoryTreeResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListRepositoryTreeResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListRepositoryTreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryTreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRepositoryTreeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRepositoryWebhookRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class ListRepositoryWebhookResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var description_: String?

        public var enableSslVerification: Bool?

        public var id: Int64?

        public var lastTestResult: String?

        public var mergeRequestsEvents: Bool?

        public var noteEvents: Bool?

        public var projectId: Int64?

        public var pushEvents: Bool?

        public var secretToken: String?

        public var tagPushEvents: Bool?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.enableSslVerification != nil {
                map["enableSslVerification"] = self.enableSslVerification!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastTestResult != nil {
                map["lastTestResult"] = self.lastTestResult!
            }
            if self.mergeRequestsEvents != nil {
                map["mergeRequestsEvents"] = self.mergeRequestsEvents!
            }
            if self.noteEvents != nil {
                map["noteEvents"] = self.noteEvents!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.pushEvents != nil {
                map["pushEvents"] = self.pushEvents!
            }
            if self.secretToken != nil {
                map["secretToken"] = self.secretToken!
            }
            if self.tagPushEvents != nil {
                map["tagPushEvents"] = self.tagPushEvents!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["enableSslVerification"] as? Bool {
                self.enableSslVerification = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["lastTestResult"] as? String {
                self.lastTestResult = value
            }
            if let value = dict["mergeRequestsEvents"] as? Bool {
                self.mergeRequestsEvents = value
            }
            if let value = dict["noteEvents"] as? Bool {
                self.noteEvents = value
            }
            if let value = dict["projectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["pushEvents"] as? Bool {
                self.pushEvents = value
            }
            if let value = dict["secretToken"] as? String {
                self.secretToken = value
            }
            if let value = dict["tagPushEvents"] as? Bool {
                self.tagPushEvents = value
            }
            if let value = dict["url"] as? String {
                self.url = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryWebhookResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListRepositoryWebhookResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListRepositoryWebhookResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListRepositoryWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRepositoryWebhookResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListResourceMembersResponseBody : Tea.TeaModel {
    public class ResourceMembers : Tea.TeaModel {
        public var accountId: String?

        public var roleName: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            if self.roleName != nil {
                map["roleName"] = self.roleName!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accountId"] as? String {
                self.accountId = value
            }
            if let value = dict["roleName"] as? String {
                self.roleName = value
            }
            if let value = dict["username"] as? String {
                self.username = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var resourceMembers: [ListResourceMembersResponseBody.ResourceMembers]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resourceMembers != nil {
            var tmp : [Any] = []
            for k in self.resourceMembers! {
                tmp.append(k.toMap())
            }
            map["resourceMembers"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["resourceMembers"] as? [Any?] {
            var tmp : [ListResourceMembersResponseBody.ResourceMembers] = []
            for v in value {
                if v != nil {
                    var model = ListResourceMembersResponseBody.ResourceMembers()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.resourceMembers = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListResourceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListResourceMembersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSearchCommitRequest : Tea.TeaModel {
    public class RepoPath : Tea.TeaModel {
        public var matchType: String?

        public var operatorType: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchType != nil {
                map["matchType"] = self.matchType!
            }
            if self.operatorType != nil {
                map["operatorType"] = self.operatorType!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["matchType"] as? String {
                self.matchType = value
            }
            if let value = dict["operatorType"] as? String {
                self.operatorType = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public var keyword: String?

    public var order: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var repoPath: ListSearchCommitRequest.RepoPath?

    public var scope: String?

    public var sort: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.repoPath?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["keyword"] = self.keyword!
        }
        if self.order != nil {
            map["order"] = self.order!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.repoPath != nil {
            map["repoPath"] = self.repoPath?.toMap()
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["order"] as? String {
            self.order = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["repoPath"] as? [String: Any?] {
            var model = ListSearchCommitRequest.RepoPath()
            model.fromMap(value)
            self.repoPath = model
        }
        if let value = dict["scope"] as? String {
            self.scope = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ListSearchCommitResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class HighlightTextMap : Tea.TeaModel {
            public var commitId: String?

            public var commitMessage: String?

            public var organizationId: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commitId != nil {
                    map["commitId"] = self.commitId!
                }
                if self.commitMessage != nil {
                    map["commitMessage"] = self.commitMessage!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["commitId"] as? String {
                    self.commitId = value
                }
                if let value = dict["commitMessage"] as? String {
                    self.commitMessage = value
                }
                if let value = dict["organizationId"] as? String {
                    self.organizationId = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public class Source : Tea.TeaModel {
            public class Author : Tea.TeaModel {
                public var email: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["email"] as? String {
                        self.email = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                }
            }
            public var author: ListSearchCommitResponseBody.Result.Source.Author?

            public var authorTime: String?

            public var commitId: String?

            public var commitMessage: String?

            public var organizationId: String?

            public var repoPath: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.author?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.author != nil {
                    map["author"] = self.author?.toMap()
                }
                if self.authorTime != nil {
                    map["authorTime"] = self.authorTime!
                }
                if self.commitId != nil {
                    map["commitId"] = self.commitId!
                }
                if self.commitMessage != nil {
                    map["commitMessage"] = self.commitMessage!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.repoPath != nil {
                    map["repoPath"] = self.repoPath!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["author"] as? [String: Any?] {
                    var model = ListSearchCommitResponseBody.Result.Source.Author()
                    model.fromMap(value)
                    self.author = model
                }
                if let value = dict["authorTime"] as? String {
                    self.authorTime = value
                }
                if let value = dict["commitId"] as? String {
                    self.commitId = value
                }
                if let value = dict["commitMessage"] as? String {
                    self.commitMessage = value
                }
                if let value = dict["organizationId"] as? String {
                    self.organizationId = value
                }
                if let value = dict["repoPath"] as? String {
                    self.repoPath = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public var docId: String?

        public var highlightTextMap: ListSearchCommitResponseBody.Result.HighlightTextMap?

        public var source: ListSearchCommitResponseBody.Result.Source?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.highlightTextMap?.validate()
            try self.source?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.docId != nil {
                map["docId"] = self.docId!
            }
            if self.highlightTextMap != nil {
                map["highlightTextMap"] = self.highlightTextMap?.toMap()
            }
            if self.source != nil {
                map["source"] = self.source?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["docId"] as? String {
                self.docId = value
            }
            if let value = dict["highlightTextMap"] as? [String: Any?] {
                var model = ListSearchCommitResponseBody.Result.HighlightTextMap()
                model.fromMap(value)
                self.highlightTextMap = model
            }
            if let value = dict["source"] as? [String: Any?] {
                var model = ListSearchCommitResponseBody.Result.Source()
                model.fromMap(value)
                self.source = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListSearchCommitResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListSearchCommitResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListSearchCommitResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListSearchCommitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSearchCommitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSearchCommitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSearchRepositoryRequest : Tea.TeaModel {
    public class RepoPath : Tea.TeaModel {
        public var matchType: String?

        public var operatorType: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchType != nil {
                map["matchType"] = self.matchType!
            }
            if self.operatorType != nil {
                map["operatorType"] = self.operatorType!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["matchType"] as? String {
                self.matchType = value
            }
            if let value = dict["operatorType"] as? String {
                self.operatorType = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public var aliyunPk: String?

    public var keyword: String?

    public var order: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var repoPath: ListSearchRepositoryRequest.RepoPath?

    public var scope: String?

    public var sort: String?

    public var visibilityLevel: Int32?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.repoPath?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunPk != nil {
            map["aliyunPk"] = self.aliyunPk!
        }
        if self.keyword != nil {
            map["keyword"] = self.keyword!
        }
        if self.order != nil {
            map["order"] = self.order!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.repoPath != nil {
            map["repoPath"] = self.repoPath?.toMap()
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.visibilityLevel != nil {
            map["visibilityLevel"] = self.visibilityLevel!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["aliyunPk"] as? String {
            self.aliyunPk = value
        }
        if let value = dict["keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["order"] as? String {
            self.order = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["repoPath"] as? [String: Any?] {
            var model = ListSearchRepositoryRequest.RepoPath()
            model.fromMap(value)
            self.repoPath = model
        }
        if let value = dict["scope"] as? String {
            self.scope = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
        if let value = dict["visibilityLevel"] as? Int32 {
            self.visibilityLevel = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ListSearchRepositoryResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class HighlightTextMap : Tea.TeaModel {
            public var creatorUserId: String?

            public var description_: String?

            public var organizationId: String?

            public var readMe: String?

            public var repoNameWithNamespace: String?

            public var repoPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creatorUserId != nil {
                    map["creatorUserId"] = self.creatorUserId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.readMe != nil {
                    map["readMe"] = self.readMe!
                }
                if self.repoNameWithNamespace != nil {
                    map["repoNameWithNamespace"] = self.repoNameWithNamespace!
                }
                if self.repoPath != nil {
                    map["repoPath"] = self.repoPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["creatorUserId"] as? String {
                    self.creatorUserId = value
                }
                if let value = dict["description"] as? String {
                    self.description_ = value
                }
                if let value = dict["organizationId"] as? String {
                    self.organizationId = value
                }
                if let value = dict["readMe"] as? String {
                    self.readMe = value
                }
                if let value = dict["repoNameWithNamespace"] as? String {
                    self.repoNameWithNamespace = value
                }
                if let value = dict["repoPath"] as? String {
                    self.repoPath = value
                }
            }
        }
        public class Source : Tea.TeaModel {
            public var createTime: String?

            public var description_: String?

            public var lastActivityTime: String?

            public var organizationId: String?

            public var readMe: String?

            public var repoName: String?

            public var repoPath: String?

            public var visibilityLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["createTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.lastActivityTime != nil {
                    map["lastActivityTime"] = self.lastActivityTime!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.readMe != nil {
                    map["readMe"] = self.readMe!
                }
                if self.repoName != nil {
                    map["repoName"] = self.repoName!
                }
                if self.repoPath != nil {
                    map["repoPath"] = self.repoPath!
                }
                if self.visibilityLevel != nil {
                    map["visibilityLevel"] = self.visibilityLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["createTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["description"] as? String {
                    self.description_ = value
                }
                if let value = dict["lastActivityTime"] as? String {
                    self.lastActivityTime = value
                }
                if let value = dict["organizationId"] as? String {
                    self.organizationId = value
                }
                if let value = dict["readMe"] as? String {
                    self.readMe = value
                }
                if let value = dict["repoName"] as? String {
                    self.repoName = value
                }
                if let value = dict["repoPath"] as? String {
                    self.repoPath = value
                }
                if let value = dict["visibilityLevel"] as? Int32 {
                    self.visibilityLevel = value
                }
            }
        }
        public var docId: String?

        public var highlightTextMap: ListSearchRepositoryResponseBody.Result.HighlightTextMap?

        public var source: ListSearchRepositoryResponseBody.Result.Source?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.highlightTextMap?.validate()
            try self.source?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.docId != nil {
                map["docId"] = self.docId!
            }
            if self.highlightTextMap != nil {
                map["highlightTextMap"] = self.highlightTextMap?.toMap()
            }
            if self.source != nil {
                map["source"] = self.source?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["docId"] as? String {
                self.docId = value
            }
            if let value = dict["highlightTextMap"] as? [String: Any?] {
                var model = ListSearchRepositoryResponseBody.Result.HighlightTextMap()
                model.fromMap(value)
                self.highlightTextMap = model
            }
            if let value = dict["source"] as? [String: Any?] {
                var model = ListSearchRepositoryResponseBody.Result.Source()
                model.fromMap(value)
                self.source = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListSearchRepositoryResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListSearchRepositoryResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListSearchRepositoryResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListSearchRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSearchRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSearchRepositoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSearchSourceCodeRequest : Tea.TeaModel {
    public class FilePath : Tea.TeaModel {
        public var matchType: String?

        public var operatorType: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchType != nil {
                map["matchType"] = self.matchType!
            }
            if self.operatorType != nil {
                map["operatorType"] = self.operatorType!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["matchType"] as? String {
                self.matchType = value
            }
            if let value = dict["operatorType"] as? String {
                self.operatorType = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public class RepoPath : Tea.TeaModel {
        public var matchType: String?

        public var operatorType: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchType != nil {
                map["matchType"] = self.matchType!
            }
            if self.operatorType != nil {
                map["operatorType"] = self.operatorType!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["matchType"] as? String {
                self.matchType = value
            }
            if let value = dict["operatorType"] as? String {
                self.operatorType = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public var filePath: ListSearchSourceCodeRequest.FilePath?

    public var isCodeBlock: Bool?

    public var keyword: String?

    public var language: String?

    public var order: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var repoPath: ListSearchSourceCodeRequest.RepoPath?

    public var scope: String?

    public var sort: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filePath?.validate()
        try self.repoPath?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["filePath"] = self.filePath?.toMap()
        }
        if self.isCodeBlock != nil {
            map["isCodeBlock"] = self.isCodeBlock!
        }
        if self.keyword != nil {
            map["keyword"] = self.keyword!
        }
        if self.language != nil {
            map["language"] = self.language!
        }
        if self.order != nil {
            map["order"] = self.order!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.repoPath != nil {
            map["repoPath"] = self.repoPath?.toMap()
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["filePath"] as? [String: Any?] {
            var model = ListSearchSourceCodeRequest.FilePath()
            model.fromMap(value)
            self.filePath = model
        }
        if let value = dict["isCodeBlock"] as? Bool {
            self.isCodeBlock = value
        }
        if let value = dict["keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["language"] as? String {
            self.language = value
        }
        if let value = dict["order"] as? String {
            self.order = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["repoPath"] as? [String: Any?] {
            var model = ListSearchSourceCodeRequest.RepoPath()
            model.fromMap(value)
            self.repoPath = model
        }
        if let value = dict["scope"] as? String {
            self.scope = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ListSearchSourceCodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class HighlightTextMap : Tea.TeaModel {
            public var clob: String?

            public var fileName: String?

            public var language: String?

            public var organizationId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clob != nil {
                    map["clob"] = self.clob!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                if self.language != nil {
                    map["language"] = self.language!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["clob"] as? String {
                    self.clob = value
                }
                if let value = dict["fileName"] as? String {
                    self.fileName = value
                }
                if let value = dict["language"] as? String {
                    self.language = value
                }
                if let value = dict["organizationId"] as? String {
                    self.organizationId = value
                }
            }
        }
        public class Source : Tea.TeaModel {
            public var branch: String?

            public var checkinDate: String?

            public var fileName: String?

            public var filePath: String?

            public var language: String?

            public var organizationId: String?

            public var repoPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.branch != nil {
                    map["branch"] = self.branch!
                }
                if self.checkinDate != nil {
                    map["checkinDate"] = self.checkinDate!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                if self.filePath != nil {
                    map["filePath"] = self.filePath!
                }
                if self.language != nil {
                    map["language"] = self.language!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.repoPath != nil {
                    map["repoPath"] = self.repoPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["branch"] as? String {
                    self.branch = value
                }
                if let value = dict["checkinDate"] as? String {
                    self.checkinDate = value
                }
                if let value = dict["fileName"] as? String {
                    self.fileName = value
                }
                if let value = dict["filePath"] as? String {
                    self.filePath = value
                }
                if let value = dict["language"] as? String {
                    self.language = value
                }
                if let value = dict["organizationId"] as? String {
                    self.organizationId = value
                }
                if let value = dict["repoPath"] as? String {
                    self.repoPath = value
                }
            }
        }
        public var docId: String?

        public var highlightTextMap: ListSearchSourceCodeResponseBody.Result.HighlightTextMap?

        public var source: ListSearchSourceCodeResponseBody.Result.Source?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.highlightTextMap?.validate()
            try self.source?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.docId != nil {
                map["docId"] = self.docId!
            }
            if self.highlightTextMap != nil {
                map["highlightTextMap"] = self.highlightTextMap?.toMap()
            }
            if self.source != nil {
                map["source"] = self.source?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["docId"] as? String {
                self.docId = value
            }
            if let value = dict["highlightTextMap"] as? [String: Any?] {
                var model = ListSearchSourceCodeResponseBody.Result.HighlightTextMap()
                model.fromMap(value)
                self.highlightTextMap = model
            }
            if let value = dict["source"] as? [String: Any?] {
                var model = ListSearchSourceCodeResponseBody.Result.Source()
                model.fromMap(value)
                self.source = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListSearchSourceCodeResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListSearchSourceCodeResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListSearchSourceCodeResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListSearchSourceCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSearchSourceCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSearchSourceCodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListServiceAuthsRequest : Tea.TeaModel {
    public var serviceAuthType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serviceAuthType != nil {
            map["serviceAuthType"] = self.serviceAuthType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["serviceAuthType"] as? String {
            self.serviceAuthType = value
        }
    }
}

public class ListServiceAuthsResponseBody : Tea.TeaModel {
    public class ServiceAuths : Tea.TeaModel {
        public var id: Int64?

        public var ownerName: String?

        public var ownerStaffId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ownerName != nil {
                map["ownerName"] = self.ownerName!
            }
            if self.ownerStaffId != nil {
                map["ownerStaffId"] = self.ownerStaffId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ownerName"] as? String {
                self.ownerName = value
            }
            if let value = dict["ownerStaffId"] as? String {
                self.ownerStaffId = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var serviceAuths: [ListServiceAuthsResponseBody.ServiceAuths]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.serviceAuths != nil {
            var tmp : [Any] = []
            for k in self.serviceAuths! {
                tmp.append(k.toMap())
            }
            map["serviceAuths"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["serviceAuths"] as? [Any?] {
            var tmp : [ListServiceAuthsResponseBody.ServiceAuths] = []
            for v in value {
                if v != nil {
                    var model = ListServiceAuthsResponseBody.ServiceAuths()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.serviceAuths = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListServiceAuthsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceAuthsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListServiceAuthsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListServiceConnectionsRequest : Tea.TeaModel {
    public var sericeConnectionType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sericeConnectionType != nil {
            map["sericeConnectionType"] = self.sericeConnectionType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["sericeConnectionType"] as? String {
            self.sericeConnectionType = value
        }
    }
}

public class ListServiceConnectionsResponseBody : Tea.TeaModel {
    public class ServiceConnections : Tea.TeaModel {
        public var createTime: Int64?

        public var id: Int64?

        public var name: String?

        public var ownerAccountId: Int64?

        public var type: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerAccountId != nil {
                map["ownerAccountId"] = self.ownerAccountId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.uuid != nil {
                map["uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["ownerAccountId"] as? Int64 {
                self.ownerAccountId = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["uuid"] as? String {
                self.uuid = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var serviceConnections: [ListServiceConnectionsResponseBody.ServiceConnections]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.serviceConnections != nil {
            var tmp : [Any] = []
            for k in self.serviceConnections! {
                tmp.append(k.toMap())
            }
            map["serviceConnections"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["serviceConnections"] as? [Any?] {
            var tmp : [ListServiceConnectionsResponseBody.ServiceConnections] = []
            for v in value {
                if v != nil {
                    var model = ListServiceConnectionsResponseBody.ServiceConnections()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.serviceConnections = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListServiceConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListServiceConnectionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListServiceCredentialsRequest : Tea.TeaModel {
    public var serviceCredentialType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serviceCredentialType != nil {
            map["serviceCredentialType"] = self.serviceCredentialType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["serviceCredentialType"] as? String {
            self.serviceCredentialType = value
        }
    }
}

public class ListServiceCredentialsResponseBody : Tea.TeaModel {
    public class ServiceCredentials : Tea.TeaModel {
        public var id: Int64?

        public var ownerName: String?

        public var ownerStaffId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ownerName != nil {
                map["ownerName"] = self.ownerName!
            }
            if self.ownerStaffId != nil {
                map["ownerStaffId"] = self.ownerStaffId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ownerName"] as? String {
                self.ownerName = value
            }
            if let value = dict["ownerStaffId"] as? String {
                self.ownerStaffId = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var serviceCredentials: [ListServiceCredentialsResponseBody.ServiceCredentials]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.serviceCredentials != nil {
            var tmp : [Any] = []
            for k in self.serviceCredentials! {
                tmp.append(k.toMap())
            }
            map["serviceCredentials"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["serviceCredentials"] as? [Any?] {
            var tmp : [ListServiceCredentialsResponseBody.ServiceCredentials] = []
            for v in value {
                if v != nil {
                    var model = ListServiceCredentialsResponseBody.ServiceCredentials()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.serviceCredentials = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListServiceCredentialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceCredentialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListServiceCredentialsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSprintsRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public var spaceIdentifier: String?

    public var spaceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["spaceIdentifier"] as? String {
            self.spaceIdentifier = value
        }
        if let value = dict["spaceType"] as? String {
            self.spaceType = value
        }
    }
}

public class ListSprintsResponseBody : Tea.TeaModel {
    public class Sprints : Tea.TeaModel {
        public var creator: String?

        public var description_: String?

        public var endDate: Int64?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var scope: String?

        public var spaceIdentifier: String?

        public var startDate: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endDate != nil {
                map["endDate"] = self.endDate!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.startDate != nil {
                map["startDate"] = self.startDate!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["endDate"] as? Int64 {
                self.endDate = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["scope"] as? String {
                self.scope = value
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["startDate"] as? Int64 {
                self.startDate = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var sprints: [ListSprintsResponseBody.Sprints]?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.sprints != nil {
            var tmp : [Any] = []
            for k in self.sprints! {
                tmp.append(k.toMap())
            }
            map["sprints"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["sprints"] as? [Any?] {
            var tmp : [ListSprintsResponseBody.Sprints] = []
            for v in value {
                if v != nil {
                    var model = ListSprintsResponseBody.Sprints()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.sprints = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListSprintsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSprintsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSprintsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTestCaseFieldsRequest : Tea.TeaModel {
    public var spaceIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["spaceIdentifier"] as? String {
            self.spaceIdentifier = value
        }
    }
}

public class ListTestCaseFieldsResponseBody : Tea.TeaModel {
    public class Fields : Tea.TeaModel {
        public class Options : Tea.TeaModel {
            public var displayValue: String?

            public var fieldIdentifier: String?

            public var identifier: String?

            public var level: Int64?

            public var position: Int64?

            public var value: String?

            public var valueEn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayValue != nil {
                    map["displayValue"] = self.displayValue!
                }
                if self.fieldIdentifier != nil {
                    map["fieldIdentifier"] = self.fieldIdentifier!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.level != nil {
                    map["level"] = self.level!
                }
                if self.position != nil {
                    map["position"] = self.position!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                if self.valueEn != nil {
                    map["valueEn"] = self.valueEn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["displayValue"] as? String {
                    self.displayValue = value
                }
                if let value = dict["fieldIdentifier"] as? String {
                    self.fieldIdentifier = value
                }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["level"] as? Int64 {
                    self.level = value
                }
                if let value = dict["position"] as? Int64 {
                    self.position = value
                }
                if let value = dict["value"] as? String {
                    self.value = value
                }
                if let value = dict["valueEn"] as? String {
                    self.valueEn = value
                }
            }
        }
        public var className: String?

        public var creator: String?

        public var defaultValue: String?

        public var description_: String?

        public var format: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var isRequired: Bool?

        public var isShowWhenCreate: Bool?

        public var isSystemRequired: Bool?

        public var linkWithService: String?

        public var modifier: String?

        public var name: String?

        public var options: [ListTestCaseFieldsResponseBody.Fields.Options]?

        public var resourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.className != nil {
                map["className"] = self.className!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.defaultValue != nil {
                map["defaultValue"] = self.defaultValue!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.format != nil {
                map["format"] = self.format!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.isShowWhenCreate != nil {
                map["isShowWhenCreate"] = self.isShowWhenCreate!
            }
            if self.isSystemRequired != nil {
                map["isSystemRequired"] = self.isSystemRequired!
            }
            if self.linkWithService != nil {
                map["linkWithService"] = self.linkWithService!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.options != nil {
                var tmp : [Any] = []
                for k in self.options! {
                    tmp.append(k.toMap())
                }
                map["options"] = tmp
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["className"] as? String {
                self.className = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["defaultValue"] as? String {
                self.defaultValue = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["format"] as? String {
                self.format = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["isRequired"] as? Bool {
                self.isRequired = value
            }
            if let value = dict["isShowWhenCreate"] as? Bool {
                self.isShowWhenCreate = value
            }
            if let value = dict["isSystemRequired"] as? Bool {
                self.isSystemRequired = value
            }
            if let value = dict["linkWithService"] as? String {
                self.linkWithService = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["options"] as? [Any?] {
                var tmp : [ListTestCaseFieldsResponseBody.Fields.Options] = []
                for v in value {
                    if v != nil {
                        var model = ListTestCaseFieldsResponseBody.Fields.Options()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.options = tmp
            }
            if let value = dict["resourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var fields: [ListTestCaseFieldsResponseBody.Fields]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.fields != nil {
            var tmp : [Any] = []
            for k in self.fields! {
                tmp.append(k.toMap())
            }
            map["fields"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["fields"] as? [Any?] {
            var tmp : [ListTestCaseFieldsResponseBody.Fields] = []
            for v in value {
                if v != nil {
                    var model = ListTestCaseFieldsResponseBody.Fields()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.fields = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListTestCaseFieldsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTestCaseFieldsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTestCaseFieldsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListUserDrawRecordByPkRequest : Tea.TeaModel {
    public var aliyunPk: String?

    public var drawGroup: String?

    public var drawPoolName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunPk != nil {
            map["aliyunPk"] = self.aliyunPk!
        }
        if self.drawGroup != nil {
            map["drawGroup"] = self.drawGroup!
        }
        if self.drawPoolName != nil {
            map["drawPoolName"] = self.drawPoolName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["aliyunPk"] as? String {
            self.aliyunPk = value
        }
        if let value = dict["drawGroup"] as? String {
            self.drawGroup = value
        }
        if let value = dict["drawPoolName"] as? String {
            self.drawPoolName = value
        }
    }
}

public class ListUserDrawRecordByPkResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var aliyunPk: String?

        public var drawGroup: String?

        public var drawPoolName: String?

        public var drawResult: String?

        public var gmtCreate: String?

        public var taskGroupId: String?

        public var uccId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunPk != nil {
                map["aliyunPk"] = self.aliyunPk!
            }
            if self.drawGroup != nil {
                map["drawGroup"] = self.drawGroup!
            }
            if self.drawPoolName != nil {
                map["drawPoolName"] = self.drawPoolName!
            }
            if self.drawResult != nil {
                map["drawResult"] = self.drawResult!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.taskGroupId != nil {
                map["taskGroupId"] = self.taskGroupId!
            }
            if self.uccId != nil {
                map["uccId"] = self.uccId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["aliyunPk"] as? String {
                self.aliyunPk = value
            }
            if let value = dict["drawGroup"] as? String {
                self.drawGroup = value
            }
            if let value = dict["drawPoolName"] as? String {
                self.drawPoolName = value
            }
            if let value = dict["drawResult"] as? String {
                self.drawResult = value
            }
            if let value = dict["gmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["taskGroupId"] as? String {
                self.taskGroupId = value
            }
            if let value = dict["uccId"] as? String {
                self.uccId = value
            }
        }
    }
    public var code: String?

    public var data: [ListUserDrawRecordByPkResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["code"] as? String {
            self.code = value
        }
        if let value = dict["data"] as? [Any?] {
            var tmp : [ListUserDrawRecordByPkResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListUserDrawRecordByPkResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["message"] as? String {
            self.message = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListUserDrawRecordByPkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserDrawRecordByPkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListUserDrawRecordByPkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListUserKeysRequest : Tea.TeaModel {
    public var accessToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["orderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
    }
}

public class ListUserKeysResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var expireTime: String?

        public var fingerPrint: String?

        public var id: Int64?

        public var keyScope: String?

        public var lastUsedTime: String?

        public var publicKey: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.expireTime != nil {
                map["expireTime"] = self.expireTime!
            }
            if self.fingerPrint != nil {
                map["fingerPrint"] = self.fingerPrint!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.keyScope != nil {
                map["keyScope"] = self.keyScope!
            }
            if self.lastUsedTime != nil {
                map["lastUsedTime"] = self.lastUsedTime!
            }
            if self.publicKey != nil {
                map["publicKey"] = self.publicKey!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["expireTime"] as? String {
                self.expireTime = value
            }
            if let value = dict["fingerPrint"] as? String {
                self.fingerPrint = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["keyScope"] as? String {
                self.keyScope = value
            }
            if let value = dict["lastUsedTime"] as? String {
                self.lastUsedTime = value
            }
            if let value = dict["publicKey"] as? String {
                self.publicKey = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListUserKeysResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListUserKeysResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListUserKeysResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListUserKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListUserKeysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListUserResourcesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.userIds != nil {
            map["userIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["pageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["userIds"] as? String {
            self.userIds = value
        }
    }
}

public class ListUserResourcesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class GroupInfos : Tea.TeaModel {
            public class GroupInfo : Tea.TeaModel {
                public var createdAt: String?

                public var description_: String?

                public var id: Int64?

                public var name: String?

                public var nameWithNamespace: String?

                public var ownerId: Int64?

                public var parentId: Int64?

                public var path: String?

                public var pathWithNamespace: String?

                public var updatedAt: String?

                public var visibilityLevel: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.createdAt != nil {
                        map["createdAt"] = self.createdAt!
                    }
                    if self.description_ != nil {
                        map["description"] = self.description_!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.nameWithNamespace != nil {
                        map["nameWithNamespace"] = self.nameWithNamespace!
                    }
                    if self.ownerId != nil {
                        map["ownerId"] = self.ownerId!
                    }
                    if self.parentId != nil {
                        map["parentId"] = self.parentId!
                    }
                    if self.path != nil {
                        map["path"] = self.path!
                    }
                    if self.pathWithNamespace != nil {
                        map["pathWithNamespace"] = self.pathWithNamespace!
                    }
                    if self.updatedAt != nil {
                        map["updatedAt"] = self.updatedAt!
                    }
                    if self.visibilityLevel != nil {
                        map["visibilityLevel"] = self.visibilityLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["createdAt"] as? String {
                        self.createdAt = value
                    }
                    if let value = dict["description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["nameWithNamespace"] as? String {
                        self.nameWithNamespace = value
                    }
                    if let value = dict["ownerId"] as? Int64 {
                        self.ownerId = value
                    }
                    if let value = dict["parentId"] as? Int64 {
                        self.parentId = value
                    }
                    if let value = dict["path"] as? String {
                        self.path = value
                    }
                    if let value = dict["pathWithNamespace"] as? String {
                        self.pathWithNamespace = value
                    }
                    if let value = dict["updatedAt"] as? String {
                        self.updatedAt = value
                    }
                    if let value = dict["visibilityLevel"] as? Int32 {
                        self.visibilityLevel = value
                    }
                }
            }
            public class GroupRole : Tea.TeaModel {
                public var accessLevel: Int32?

                public var cnRoleName: String?

                public var enRoleName: String?

                public var sourceId: Int64?

                public var sourceType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessLevel != nil {
                        map["accessLevel"] = self.accessLevel!
                    }
                    if self.cnRoleName != nil {
                        map["cnRoleName"] = self.cnRoleName!
                    }
                    if self.enRoleName != nil {
                        map["enRoleName"] = self.enRoleName!
                    }
                    if self.sourceId != nil {
                        map["sourceId"] = self.sourceId!
                    }
                    if self.sourceType != nil {
                        map["sourceType"] = self.sourceType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["accessLevel"] as? Int32 {
                        self.accessLevel = value
                    }
                    if let value = dict["cnRoleName"] as? String {
                        self.cnRoleName = value
                    }
                    if let value = dict["enRoleName"] as? String {
                        self.enRoleName = value
                    }
                    if let value = dict["sourceId"] as? Int64 {
                        self.sourceId = value
                    }
                    if let value = dict["sourceType"] as? String {
                        self.sourceType = value
                    }
                }
            }
            public var groupInfo: ListUserResourcesResponseBody.Result.GroupInfos.GroupInfo?

            public var groupRole: ListUserResourcesResponseBody.Result.GroupInfos.GroupRole?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.groupInfo?.validate()
                try self.groupRole?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupInfo != nil {
                    map["groupInfo"] = self.groupInfo?.toMap()
                }
                if self.groupRole != nil {
                    map["groupRole"] = self.groupRole?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["groupInfo"] as? [String: Any?] {
                    var model = ListUserResourcesResponseBody.Result.GroupInfos.GroupInfo()
                    model.fromMap(value)
                    self.groupInfo = model
                }
                if let value = dict["groupRole"] as? [String: Any?] {
                    var model = ListUserResourcesResponseBody.Result.GroupInfos.GroupRole()
                    model.fromMap(value)
                    self.groupRole = model
                }
            }
        }
        public class RepositoryInfos : Tea.TeaModel {
            public class RepositoryInfo : Tea.TeaModel {
                public var accessLevel: Int32?

                public var archived: Bool?

                public var createdAt: String?

                public var creatorId: Int64?

                public var description_: String?

                public var encrypted: Bool?

                public var id: Int64?

                public var lastActivityAt: String?

                public var name: String?

                public var nameWithNamespace: String?

                public var namespaceId: Int64?

                public var path: String?

                public var pathWithNamespace: String?

                public var updatedAt: String?

                public var visibilityLevel: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessLevel != nil {
                        map["accessLevel"] = self.accessLevel!
                    }
                    if self.archived != nil {
                        map["archived"] = self.archived!
                    }
                    if self.createdAt != nil {
                        map["createdAt"] = self.createdAt!
                    }
                    if self.creatorId != nil {
                        map["creatorId"] = self.creatorId!
                    }
                    if self.description_ != nil {
                        map["description"] = self.description_!
                    }
                    if self.encrypted != nil {
                        map["encrypted"] = self.encrypted!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.lastActivityAt != nil {
                        map["lastActivityAt"] = self.lastActivityAt!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.nameWithNamespace != nil {
                        map["nameWithNamespace"] = self.nameWithNamespace!
                    }
                    if self.namespaceId != nil {
                        map["namespaceId"] = self.namespaceId!
                    }
                    if self.path != nil {
                        map["path"] = self.path!
                    }
                    if self.pathWithNamespace != nil {
                        map["pathWithNamespace"] = self.pathWithNamespace!
                    }
                    if self.updatedAt != nil {
                        map["updatedAt"] = self.updatedAt!
                    }
                    if self.visibilityLevel != nil {
                        map["visibilityLevel"] = self.visibilityLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["accessLevel"] as? Int32 {
                        self.accessLevel = value
                    }
                    if let value = dict["archived"] as? Bool {
                        self.archived = value
                    }
                    if let value = dict["createdAt"] as? String {
                        self.createdAt = value
                    }
                    if let value = dict["creatorId"] as? Int64 {
                        self.creatorId = value
                    }
                    if let value = dict["description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["encrypted"] as? Bool {
                        self.encrypted = value
                    }
                    if let value = dict["id"] as? Int64 {
                        self.id = value
                    }
                    if let value = dict["lastActivityAt"] as? String {
                        self.lastActivityAt = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["nameWithNamespace"] as? String {
                        self.nameWithNamespace = value
                    }
                    if let value = dict["namespaceId"] as? Int64 {
                        self.namespaceId = value
                    }
                    if let value = dict["path"] as? String {
                        self.path = value
                    }
                    if let value = dict["pathWithNamespace"] as? String {
                        self.pathWithNamespace = value
                    }
                    if let value = dict["updatedAt"] as? String {
                        self.updatedAt = value
                    }
                    if let value = dict["visibilityLevel"] as? Int32 {
                        self.visibilityLevel = value
                    }
                }
            }
            public class RepositoryRole : Tea.TeaModel {
                public var accessLevel: Int32?

                public var cnRoleName: String?

                public var enRoleName: String?

                public var sourceId: Int64?

                public var sourceType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessLevel != nil {
                        map["accessLevel"] = self.accessLevel!
                    }
                    if self.cnRoleName != nil {
                        map["cnRoleName"] = self.cnRoleName!
                    }
                    if self.enRoleName != nil {
                        map["enRoleName"] = self.enRoleName!
                    }
                    if self.sourceId != nil {
                        map["sourceId"] = self.sourceId!
                    }
                    if self.sourceType != nil {
                        map["sourceType"] = self.sourceType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["accessLevel"] as? Int32 {
                        self.accessLevel = value
                    }
                    if let value = dict["cnRoleName"] as? String {
                        self.cnRoleName = value
                    }
                    if let value = dict["enRoleName"] as? String {
                        self.enRoleName = value
                    }
                    if let value = dict["sourceId"] as? Int64 {
                        self.sourceId = value
                    }
                    if let value = dict["sourceType"] as? String {
                        self.sourceType = value
                    }
                }
            }
            public var repositoryInfo: ListUserResourcesResponseBody.Result.RepositoryInfos.RepositoryInfo?

            public var repositoryRole: ListUserResourcesResponseBody.Result.RepositoryInfos.RepositoryRole?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.repositoryInfo?.validate()
                try self.repositoryRole?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.repositoryInfo != nil {
                    map["repositoryInfo"] = self.repositoryInfo?.toMap()
                }
                if self.repositoryRole != nil {
                    map["repositoryRole"] = self.repositoryRole?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["repositoryInfo"] as? [String: Any?] {
                    var model = ListUserResourcesResponseBody.Result.RepositoryInfos.RepositoryInfo()
                    model.fromMap(value)
                    self.repositoryInfo = model
                }
                if let value = dict["repositoryRole"] as? [String: Any?] {
                    var model = ListUserResourcesResponseBody.Result.RepositoryInfos.RepositoryRole()
                    model.fromMap(value)
                    self.repositoryRole = model
                }
            }
        }
        public class UserInfo : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatarUrl"] as? String {
                    self.avatarUrl = value
                }
                if let value = dict["email"] as? String {
                    self.email = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["state"] as? String {
                    self.state = value
                }
                if let value = dict["username"] as? String {
                    self.username = value
                }
            }
        }
        public var groupInfos: [ListUserResourcesResponseBody.Result.GroupInfos]?

        public var repositoryInfos: [ListUserResourcesResponseBody.Result.RepositoryInfos]?

        public var userInfo: ListUserResourcesResponseBody.Result.UserInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.userInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupInfos != nil {
                var tmp : [Any] = []
                for k in self.groupInfos! {
                    tmp.append(k.toMap())
                }
                map["groupInfos"] = tmp
            }
            if self.repositoryInfos != nil {
                var tmp : [Any] = []
                for k in self.repositoryInfos! {
                    tmp.append(k.toMap())
                }
                map["repositoryInfos"] = tmp
            }
            if self.userInfo != nil {
                map["userInfo"] = self.userInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["groupInfos"] as? [Any?] {
                var tmp : [ListUserResourcesResponseBody.Result.GroupInfos] = []
                for v in value {
                    if v != nil {
                        var model = ListUserResourcesResponseBody.Result.GroupInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.groupInfos = tmp
            }
            if let value = dict["repositoryInfos"] as? [Any?] {
                var tmp : [ListUserResourcesResponseBody.Result.RepositoryInfos] = []
                for v in value {
                    if v != nil {
                        var model = ListUserResourcesResponseBody.Result.RepositoryInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.repositoryInfos = tmp
            }
            if let value = dict["userInfo"] as? [String: Any?] {
                var model = ListUserResourcesResponseBody.Result.UserInfo()
                model.fromMap(value)
                self.userInfo = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListUserResourcesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [Any?] {
            var tmp : [ListUserResourcesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListUserResourcesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["total"] as? Int64 {
            self.total = value
        }
    }
}

public class ListUserResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListUserResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListVariableGroupsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var pageOrder: String?

    public var pageSort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pageOrder != nil {
            map["pageOrder"] = self.pageOrder!
        }
        if self.pageSort != nil {
            map["pageSort"] = self.pageSort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["maxResults"] as? Int32 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["pageOrder"] as? String {
            self.pageOrder = value
        }
        if let value = dict["pageSort"] as? String {
            self.pageSort = value
        }
    }
}

public class ListVariableGroupsResponseBody : Tea.TeaModel {
    public class VariableGroups : Tea.TeaModel {
        public class RelatedPipelines : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public class Variables : Tea.TeaModel {
            public var isEncrypted: Bool?

            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isEncrypted != nil {
                    map["isEncrypted"] = self.isEncrypted!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["isEncrypted"] as? Bool {
                    self.isEncrypted = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["value"] as? String {
                    self.value = value
                }
            }
        }
        public var createTime: Int64?

        public var creatorAccountId: String?

        public var description_: String?

        public var id: Int64?

        public var modifierAccountId: String?

        public var name: String?

        public var relatedPipelines: [ListVariableGroupsResponseBody.VariableGroups.RelatedPipelines]?

        public var updateTime: Int64?

        public var variables: [ListVariableGroupsResponseBody.VariableGroups.Variables]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.relatedPipelines != nil {
                var tmp : [Any] = []
                for k in self.relatedPipelines! {
                    tmp.append(k.toMap())
                }
                map["relatedPipelines"] = tmp
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.variables != nil {
                var tmp : [Any] = []
                for k in self.variables! {
                    tmp.append(k.toMap())
                }
                map["variables"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["creatorAccountId"] as? String {
                self.creatorAccountId = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["modifierAccountId"] as? String {
                self.modifierAccountId = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["relatedPipelines"] as? [Any?] {
                var tmp : [ListVariableGroupsResponseBody.VariableGroups.RelatedPipelines] = []
                for v in value {
                    if v != nil {
                        var model = ListVariableGroupsResponseBody.VariableGroups.RelatedPipelines()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.relatedPipelines = tmp
            }
            if let value = dict["updateTime"] as? Int64 {
                self.updateTime = value
            }
            if let value = dict["variables"] as? [Any?] {
                var tmp : [ListVariableGroupsResponseBody.VariableGroups.Variables] = []
                for v in value {
                    if v != nil {
                        var model = ListVariableGroupsResponseBody.VariableGroups.Variables()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.variables = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var variableGroups: [ListVariableGroupsResponseBody.VariableGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.variableGroups != nil {
            var tmp : [Any] = []
            for k in self.variableGroups! {
                tmp.append(k.toMap())
            }
            map["variableGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
        if let value = dict["variableGroups"] as? [Any?] {
            var tmp : [ListVariableGroupsResponseBody.VariableGroups] = []
            for v in value {
                if v != nil {
                    var model = ListVariableGroupsResponseBody.VariableGroups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.variableGroups = tmp
        }
    }
}

public class ListVariableGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVariableGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListVariableGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWorkItemAllFieldsRequest : Tea.TeaModel {
    public var spaceIdentifier: String?

    public var spaceType: String?

    public var workitemTypeIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        if self.workitemTypeIdentifier != nil {
            map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["spaceIdentifier"] as? String {
            self.spaceIdentifier = value
        }
        if let value = dict["spaceType"] as? String {
            self.spaceType = value
        }
        if let value = dict["workitemTypeIdentifier"] as? String {
            self.workitemTypeIdentifier = value
        }
    }
}

public class ListWorkItemAllFieldsResponseBody : Tea.TeaModel {
    public class Fields : Tea.TeaModel {
        public class Options : Tea.TeaModel {
            public var displayValue: String?

            public var fieldIdentifier: String?

            public var identifier: String?

            public var level: Int64?

            public var position: Int64?

            public var value: String?

            public var valueEn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayValue != nil {
                    map["displayValue"] = self.displayValue!
                }
                if self.fieldIdentifier != nil {
                    map["fieldIdentifier"] = self.fieldIdentifier!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.level != nil {
                    map["level"] = self.level!
                }
                if self.position != nil {
                    map["position"] = self.position!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                if self.valueEn != nil {
                    map["valueEn"] = self.valueEn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["displayValue"] as? String {
                    self.displayValue = value
                }
                if let value = dict["fieldIdentifier"] as? String {
                    self.fieldIdentifier = value
                }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["level"] as? Int64 {
                    self.level = value
                }
                if let value = dict["position"] as? Int64 {
                    self.position = value
                }
                if let value = dict["value"] as? String {
                    self.value = value
                }
                if let value = dict["valueEn"] as? String {
                    self.valueEn = value
                }
            }
        }
        public var className: String?

        public var creator: String?

        public var defaultValue: String?

        public var description_: String?

        public var format: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var isRequired: Bool?

        public var isShowWhenCreate: Bool?

        public var isSystemRequired: Bool?

        public var linkWithService: String?

        public var modifier: String?

        public var name: String?

        public var options: [ListWorkItemAllFieldsResponseBody.Fields.Options]?

        public var resourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.className != nil {
                map["className"] = self.className!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.defaultValue != nil {
                map["defaultValue"] = self.defaultValue!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.format != nil {
                map["format"] = self.format!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.isShowWhenCreate != nil {
                map["isShowWhenCreate"] = self.isShowWhenCreate!
            }
            if self.isSystemRequired != nil {
                map["isSystemRequired"] = self.isSystemRequired!
            }
            if self.linkWithService != nil {
                map["linkWithService"] = self.linkWithService!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.options != nil {
                var tmp : [Any] = []
                for k in self.options! {
                    tmp.append(k.toMap())
                }
                map["options"] = tmp
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["className"] as? String {
                self.className = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["defaultValue"] as? String {
                self.defaultValue = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["format"] as? String {
                self.format = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["isRequired"] as? Bool {
                self.isRequired = value
            }
            if let value = dict["isShowWhenCreate"] as? Bool {
                self.isShowWhenCreate = value
            }
            if let value = dict["isSystemRequired"] as? Bool {
                self.isSystemRequired = value
            }
            if let value = dict["linkWithService"] as? String {
                self.linkWithService = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["options"] as? [Any?] {
                var tmp : [ListWorkItemAllFieldsResponseBody.Fields.Options] = []
                for v in value {
                    if v != nil {
                        var model = ListWorkItemAllFieldsResponseBody.Fields.Options()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.options = tmp
            }
            if let value = dict["resourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var fields: [ListWorkItemAllFieldsResponseBody.Fields]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.fields != nil {
            var tmp : [Any] = []
            for k in self.fields! {
                tmp.append(k.toMap())
            }
            map["fields"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["fields"] as? [Any?] {
            var tmp : [ListWorkItemAllFieldsResponseBody.Fields] = []
            for v in value {
                if v != nil {
                    var model = ListWorkItemAllFieldsResponseBody.Fields()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.fields = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListWorkItemAllFieldsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkItemAllFieldsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWorkItemAllFieldsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWorkItemWorkFlowStatusRequest : Tea.TeaModel {
    public var spaceIdentifier: String?

    public var spaceType: String?

    public var workitemCategoryIdentifier: String?

    public var workitemTypeIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        if self.workitemCategoryIdentifier != nil {
            map["workitemCategoryIdentifier"] = self.workitemCategoryIdentifier!
        }
        if self.workitemTypeIdentifier != nil {
            map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["spaceIdentifier"] as? String {
            self.spaceIdentifier = value
        }
        if let value = dict["spaceType"] as? String {
            self.spaceType = value
        }
        if let value = dict["workitemCategoryIdentifier"] as? String {
            self.workitemCategoryIdentifier = value
        }
        if let value = dict["workitemTypeIdentifier"] as? String {
            self.workitemTypeIdentifier = value
        }
    }
}

public class ListWorkItemWorkFlowStatusResponseBody : Tea.TeaModel {
    public class Statuses : Tea.TeaModel {
        public var creator: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var resourceType: String?

        public var source: String?

        public var workflowStageIdentifier: String?

        public var workflowStageName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.workflowStageIdentifier != nil {
                map["workflowStageIdentifier"] = self.workflowStageIdentifier!
            }
            if self.workflowStageName != nil {
                map["workflowStageName"] = self.workflowStageName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["resourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["workflowStageIdentifier"] as? String {
                self.workflowStageIdentifier = value
            }
            if let value = dict["workflowStageName"] as? String {
                self.workflowStageName = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var statuses: [ListWorkItemWorkFlowStatusResponseBody.Statuses]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.statuses != nil {
            var tmp : [Any] = []
            for k in self.statuses! {
                tmp.append(k.toMap())
            }
            map["statuses"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["statuses"] as? [Any?] {
            var tmp : [ListWorkItemWorkFlowStatusResponseBody.Statuses] = []
            for v in value {
                if v != nil {
                    var model = ListWorkItemWorkFlowStatusResponseBody.Statuses()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.statuses = tmp
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListWorkItemWorkFlowStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkItemWorkFlowStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWorkItemWorkFlowStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWorkitemAttachmentsResponseBody : Tea.TeaModel {
    public class Attachments : Tea.TeaModel {
        public var creator: String?

        public var fileIdentifier: String?

        public var fileName: String?

        public var fileSuffix: String?

        public var gmtCreate: Int64?

        public var size: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.fileIdentifier != nil {
                map["fileIdentifier"] = self.fileIdentifier!
            }
            if self.fileName != nil {
                map["fileName"] = self.fileName!
            }
            if self.fileSuffix != nil {
                map["fileSuffix"] = self.fileSuffix!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.size != nil {
                map["size"] = self.size!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["fileIdentifier"] as? String {
                self.fileIdentifier = value
            }
            if let value = dict["fileName"] as? String {
                self.fileName = value
            }
            if let value = dict["fileSuffix"] as? String {
                self.fileSuffix = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["size"] as? String {
                self.size = value
            }
            if let value = dict["url"] as? String {
                self.url = value
            }
        }
    }
    public var attachments: [ListWorkitemAttachmentsResponseBody.Attachments]?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachments != nil {
            var tmp : [Any] = []
            for k in self.attachments! {
                tmp.append(k.toMap())
            }
            map["attachments"] = tmp
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["attachments"] as? [Any?] {
            var tmp : [ListWorkitemAttachmentsResponseBody.Attachments] = []
            for v in value {
                if v != nil {
                    var model = ListWorkitemAttachmentsResponseBody.Attachments()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.attachments = tmp
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ListWorkitemAttachmentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkitemAttachmentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWorkitemAttachmentsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWorkitemEstimateResponseBody : Tea.TeaModel {
    public class WorkitemTimeEstimate : Tea.TeaModel {
        public class RecordUser : Tea.TeaModel {
            public var identifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtEnd: Int64?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var identifier: String?

        public var recordUser: ListWorkitemEstimateResponseBody.WorkitemTimeEstimate.RecordUser?

        public var spentTime: Double?

        public var type: String?

        public var workitemIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordUser?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtEnd != nil {
                map["gmtEnd"] = self.gmtEnd!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.recordUser != nil {
                map["recordUser"] = self.recordUser?.toMap()
            }
            if self.spentTime != nil {
                map["spentTime"] = self.spentTime!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.workitemIdentifier != nil {
                map["workitemIdentifier"] = self.workitemIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtEnd"] as? Int64 {
                self.gmtEnd = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["gmtStart"] as? Int64 {
                self.gmtStart = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["recordUser"] as? [String: Any?] {
                var model = ListWorkitemEstimateResponseBody.WorkitemTimeEstimate.RecordUser()
                model.fromMap(value)
                self.recordUser = model
            }
            if let value = dict["spentTime"] as? Double {
                self.spentTime = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["workitemIdentifier"] as? String {
                self.workitemIdentifier = value
            }
        }
    }
    public var code: Int64?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var workitemTimeEstimate: [ListWorkitemEstimateResponseBody.WorkitemTimeEstimate]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitemTimeEstimate != nil {
            var tmp : [Any] = []
            for k in self.workitemTimeEstimate! {
                tmp.append(k.toMap())
            }
            map["workitemTimeEstimate"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["code"] as? Int64 {
            self.code = value
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["workitemTimeEstimate"] as? [Any?] {
            var tmp : [ListWorkitemEstimateResponseBody.WorkitemTimeEstimate] = []
            for v in value {
                if v != nil {
                    var model = ListWorkitemEstimateResponseBody.WorkitemTimeEstimate()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.workitemTimeEstimate = tmp
        }
    }
}

public class ListWorkitemEstimateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkitemEstimateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWorkitemEstimateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWorkitemTimeResponseBody : Tea.TeaModel {
    public class WorkitemTime : Tea.TeaModel {
        public var actualTime: Double?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtEnd: Int64?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var identifier: String?

        public var recordUser: String?

        public var type: String?

        public var workitemIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualTime != nil {
                map["actualTime"] = self.actualTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtEnd != nil {
                map["gmtEnd"] = self.gmtEnd!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.recordUser != nil {
                map["recordUser"] = self.recordUser!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.workitemIdentifier != nil {
                map["workitemIdentifier"] = self.workitemIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["actualTime"] as? Double {
                self.actualTime = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtEnd"] as? Int64 {
                self.gmtEnd = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["gmtStart"] as? Int64 {
                self.gmtStart = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["recordUser"] as? String {
                self.recordUser = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["workitemIdentifier"] as? String {
                self.workitemIdentifier = value
            }
        }
    }
    public var code: Int64?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var workitemTime: [ListWorkitemTimeResponseBody.WorkitemTime]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitemTime != nil {
            var tmp : [Any] = []
            for k in self.workitemTime! {
                tmp.append(k.toMap())
            }
            map["workitemTime"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["code"] as? Int64 {
            self.code = value
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["workitemTime"] as? [Any?] {
            var tmp : [ListWorkitemTimeResponseBody.WorkitemTime] = []
            for v in value {
                if v != nil {
                    var model = ListWorkitemTimeResponseBody.WorkitemTime()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.workitemTime = tmp
        }
    }
}

public class ListWorkitemTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkitemTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWorkitemTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWorkitemsRequest : Tea.TeaModel {
    public var category: String?

    public var conditions: String?

    public var extraConditions: String?

    public var groupCondition: String?

    public var maxResults: String?

    public var nextToken: String?

    public var orderBy: String?

    public var searchType: String?

    public var spaceIdentifier: String?

    public var spaceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.conditions != nil {
            map["conditions"] = self.conditions!
        }
        if self.extraConditions != nil {
            map["extraConditions"] = self.extraConditions!
        }
        if self.groupCondition != nil {
            map["groupCondition"] = self.groupCondition!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.searchType != nil {
            map["searchType"] = self.searchType!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["category"] as? String {
            self.category = value
        }
        if let value = dict["conditions"] as? String {
            self.conditions = value
        }
        if let value = dict["extraConditions"] as? String {
            self.extraConditions = value
        }
        if let value = dict["groupCondition"] as? String {
            self.groupCondition = value
        }
        if let value = dict["maxResults"] as? String {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["orderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["searchType"] as? String {
            self.searchType = value
        }
        if let value = dict["spaceIdentifier"] as? String {
            self.spaceIdentifier = value
        }
        if let value = dict["spaceType"] as? String {
            self.spaceType = value
        }
    }
}

public class ListWorkitemsResponseBody : Tea.TeaModel {
    public class Workitems : Tea.TeaModel {
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var document: String?

        public var finishTime: Int64?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var parentIdentifier: String?

        public var serialNumber: String?

        public var spaceIdentifier: String?

        public var spaceName: String?

        public var spaceType: String?

        public var sprintIdentifier: String?

        public var status: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subject: String?

        public var updateStatusAt: Int64?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.document != nil {
                map["document"] = self.document!
            }
            if self.finishTime != nil {
                map["finishTime"] = self.finishTime!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceName != nil {
                map["spaceName"] = self.spaceName!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.sprintIdentifier != nil {
                map["sprintIdentifier"] = self.sprintIdentifier!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.updateStatusAt != nil {
                map["updateStatusAt"] = self.updateStatusAt!
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedTo"] as? String {
                self.assignedTo = value
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["document"] as? String {
                self.document = value
            }
            if let value = dict["finishTime"] as? Int64 {
                self.finishTime = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["logicalStatus"] as? String {
                self.logicalStatus = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["parentIdentifier"] as? String {
                self.parentIdentifier = value
            }
            if let value = dict["serialNumber"] as? String {
                self.serialNumber = value
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["spaceName"] as? String {
                self.spaceName = value
            }
            if let value = dict["spaceType"] as? String {
                self.spaceType = value
            }
            if let value = dict["sprintIdentifier"] as? String {
                self.sprintIdentifier = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["statusIdentifier"] as? String {
                self.statusIdentifier = value
            }
            if let value = dict["statusStageIdentifier"] as? String {
                self.statusStageIdentifier = value
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
            if let value = dict["updateStatusAt"] as? Int64 {
                self.updateStatusAt = value
            }
            if let value = dict["workitemTypeIdentifier"] as? String {
                self.workitemTypeIdentifier = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var workitems: [ListWorkitemsResponseBody.Workitems]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.workitems != nil {
            var tmp : [Any] = []
            for k in self.workitems! {
                tmp.append(k.toMap())
            }
            map["workitems"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["maxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["totalCount"] as? Int64 {
            self.totalCount = value
        }
        if let value = dict["workitems"] as? [Any?] {
            var tmp : [ListWorkitemsResponseBody.Workitems] = []
            for v in value {
                if v != nil {
                    var model = ListWorkitemsResponseBody.Workitems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.workitems = tmp
        }
    }
}

public class ListWorkitemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkitemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWorkitemsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class LogPipelineJobRunResponseBody : Tea.TeaModel {
    public class Log : Tea.TeaModel {
        public var content: String?

        public var more: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.more != nil {
                map["more"] = self.more!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["more"] as? Bool {
                self.more = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var log: LogPipelineJobRunResponseBody.Log?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.log?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.log != nil {
            map["log"] = self.log?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["log"] as? [String: Any?] {
            var model = LogPipelineJobRunResponseBody.Log()
            model.fromMap(value)
            self.log = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class LogPipelineJobRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LogPipelineJobRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = LogPipelineJobRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class LogVMDeployMachineResponseBody : Tea.TeaModel {
    public class DeployMachineLog : Tea.TeaModel {
        public var aliyunRegion: String?

        public var deployBeginTime: Int64?

        public var deployEndTime: Int64?

        public var deployLog: String?

        public var deployLogPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunRegion != nil {
                map["aliyunRegion"] = self.aliyunRegion!
            }
            if self.deployBeginTime != nil {
                map["deployBeginTime"] = self.deployBeginTime!
            }
            if self.deployEndTime != nil {
                map["deployEndTime"] = self.deployEndTime!
            }
            if self.deployLog != nil {
                map["deployLog"] = self.deployLog!
            }
            if self.deployLogPath != nil {
                map["deployLogPath"] = self.deployLogPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["aliyunRegion"] as? String {
                self.aliyunRegion = value
            }
            if let value = dict["deployBeginTime"] as? Int64 {
                self.deployBeginTime = value
            }
            if let value = dict["deployEndTime"] as? Int64 {
                self.deployEndTime = value
            }
            if let value = dict["deployLog"] as? String {
                self.deployLog = value
            }
            if let value = dict["deployLogPath"] as? String {
                self.deployLogPath = value
            }
        }
    }
    public var deployMachineLog: LogVMDeployMachineResponseBody.DeployMachineLog?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployMachineLog?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployMachineLog != nil {
            map["deployMachineLog"] = self.deployMachineLog?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["deployMachineLog"] as? [String: Any?] {
            var model = LogVMDeployMachineResponseBody.DeployMachineLog()
            model.fromMap(value)
            self.deployMachineLog = model
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class LogVMDeployMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LogVMDeployMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = LogVMDeployMachineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MergeMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var mergeMessage: String?

    public var mergeType: String?

    public var removeSourceBranch: Bool?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.mergeMessage != nil {
            map["mergeMessage"] = self.mergeMessage!
        }
        if self.mergeType != nil {
            map["mergeType"] = self.mergeType!
        }
        if self.removeSourceBranch != nil {
            map["removeSourceBranch"] = self.removeSourceBranch!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["mergeMessage"] as? String {
            self.mergeMessage = value
        }
        if let value = dict["mergeType"] as? String {
            self.mergeType = value
        }
        if let value = dict["removeSourceBranch"] as? Bool {
            self.removeSourceBranch = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class MergeMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var bizId: String?

        public var localId: Int64?

        public var mergedRevision: String?

        public var projectId: Int64?

        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizId != nil {
                map["bizId"] = self.bizId!
            }
            if self.localId != nil {
                map["localId"] = self.localId!
            }
            if self.mergedRevision != nil {
                map["mergedRevision"] = self.mergedRevision!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["bizId"] as? String {
                self.bizId = value
            }
            if let value = dict["localId"] as? Int64 {
                self.localId = value
            }
            if let value = dict["mergedRevision"] as? String {
                self.mergedRevision = value
            }
            if let value = dict["projectId"] as? Int64 {
                self.projectId = value
            }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: MergeMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = MergeMergeRequestResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class MergeMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MergeMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MergeMergeRequestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PassPipelineValidateResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class PassPipelineValidateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PassPipelineValidateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PassPipelineValidateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PassReleaseStagePipelineValidateRequest : Tea.TeaModel {
    public var jobId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["jobId"] = self.jobId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["jobId"] as? String {
            self.jobId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class PassReleaseStagePipelineValidateResponseBody : Tea.TeaModel {
    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class PassReleaseStagePipelineValidateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PassReleaseStagePipelineValidateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PassReleaseStagePipelineValidateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RefusePipelineValidateResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class RefusePipelineValidateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefusePipelineValidateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RefusePipelineValidateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RefuseReleaseStagePipelineValidateRequest : Tea.TeaModel {
    public var jobId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["jobId"] = self.jobId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["jobId"] as? String {
            self.jobId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class RefuseReleaseStagePipelineValidateResponseBody : Tea.TeaModel {
    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class RefuseReleaseStagePipelineValidateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefuseReleaseStagePipelineValidateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RefuseReleaseStagePipelineValidateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReopenMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ReopenMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: ReopenMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = ReopenMergeRequestResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ReopenMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReopenMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReopenMergeRequestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResetSshKeyResponseBody : Tea.TeaModel {
    public class SshKey : Tea.TeaModel {
        public var id: Int64?

        public var publicKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.publicKey != nil {
                map["publicKey"] = self.publicKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["publicKey"] as? String {
                self.publicKey = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sshKey: ResetSshKeyResponseBody.SshKey?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sshKey?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.sshKey != nil {
            map["sshKey"] = self.sshKey?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["sshKey"] as? [String: Any?] {
            var model = ResetSshKeyResponseBody.SshKey()
            model.fromMap(value)
            self.sshKey = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ResetSshKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetSshKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResetSshKeyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResumeVMDeployOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ResumeVMDeployOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeVMDeployOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResumeVMDeployOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RetryPipelineJobRunResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class RetryPipelineJobRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryPipelineJobRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RetryPipelineJobRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RetryVMDeployMachineResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class RetryVMDeployMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryVMDeployMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RetryVMDeployMachineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReviewMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var draftCommentIds: [String]?

    public var reviewComment: String?

    public var reviewOpinion: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.draftCommentIds != nil {
            map["draftCommentIds"] = self.draftCommentIds!
        }
        if self.reviewComment != nil {
            map["reviewComment"] = self.reviewComment!
        }
        if self.reviewOpinion != nil {
            map["reviewOpinion"] = self.reviewOpinion!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["draftCommentIds"] as? [String] {
            self.draftCommentIds = value
        }
        if let value = dict["reviewComment"] as? String {
            self.reviewComment = value
        }
        if let value = dict["reviewOpinion"] as? String {
            self.reviewOpinion = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class ReviewMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: ReviewMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = ReviewMergeRequestResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class ReviewMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReviewMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReviewMergeRequestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SkipPipelineJobRunResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class SkipPipelineJobRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SkipPipelineJobRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SkipPipelineJobRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SkipVMDeployMachineResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class SkipVMDeployMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SkipVMDeployMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SkipVMDeployMachineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartPipelineRunRequest : Tea.TeaModel {
    public var params: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.params != nil {
            map["params"] = self.params!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["params"] as? String {
            self.params = value
        }
    }
}

public class StartPipelineRunResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelineRunId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelineRunId != nil {
            map["pipelineRunId"] = self.pipelineRunId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["pipelineRunId"] as? Int64 {
            self.pipelineRunId = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class StartPipelineRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartPipelineRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartPipelineRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopPipelineJobRunResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class StopPipelineJobRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopPipelineJobRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopPipelineJobRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopPipelineRunResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class StopPipelineRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopPipelineRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopPipelineRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopVMDeployOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class StopVMDeployOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopVMDeployOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopVMDeployOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TransferRepositoryRequest : Tea.TeaModel {
    public var accessToken: String?

    public var groupId: String?

    public var organizationId: String?

    public var repositoryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.groupId != nil {
            map["groupId"] = self.groupId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryId != nil {
            map["repositoryId"] = self.repositoryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["groupId"] as? String {
            self.groupId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryId"] as? String {
            self.repositoryId = value
        }
    }
}

public class TransferRepositoryResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var archived: Bool?

        public var createdAt: String?

        public var creatorId: Int64?

        public var demoProject: Bool?

        public var description_: String?

        public var encrypted: Bool?

        public var id: Int64?

        public var lastActivityAt: String?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespaceId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var starCount: Int64?

        public var starred: Bool?

        public var updatedAt: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.archived != nil {
                map["archived"] = self.archived!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.demoProject != nil {
                map["demoProject"] = self.demoProject!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.encrypted != nil {
                map["encrypted"] = self.encrypted!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespaceId != nil {
                map["namespaceId"] = self.namespaceId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.starCount != nil {
                map["starCount"] = self.starCount!
            }
            if self.starred != nil {
                map["starred"] = self.starred!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["archived"] as? Bool {
                self.archived = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["creatorId"] as? Int64 {
                self.creatorId = value
            }
            if let value = dict["demoProject"] as? Bool {
                self.demoProject = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["encrypted"] as? Bool {
                self.encrypted = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["lastActivityAt"] as? String {
                self.lastActivityAt = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["namespaceId"] as? Int64 {
                self.namespaceId = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["pathWithNamespace"] as? String {
                self.pathWithNamespace = value
            }
            if let value = dict["starCount"] as? Int64 {
                self.starCount = value
            }
            if let value = dict["starred"] as? Bool {
                self.starred = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["visibilityLevel"] as? Int32 {
                self.visibilityLevel = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: TransferRepositoryResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = TransferRepositoryResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class TransferRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransferRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TransferRepositoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TriggerRepositoryMirrorSyncRequest : Tea.TeaModel {
    public var accessToken: String?

    public var account: String?

    public var organizationId: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.account != nil {
            map["account"] = self.account!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.token != nil {
            map["token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["account"] as? String {
            self.account = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["token"] as? String {
            self.token = value
        }
    }
}

public class TriggerRepositoryMirrorSyncResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: TriggerRepositoryMirrorSyncResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = TriggerRepositoryMirrorSyncResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class TriggerRepositoryMirrorSyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TriggerRepositoryMirrorSyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TriggerRepositoryMirrorSyncResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAppMemberRequest : Tea.TeaModel {
    public class Player : Tea.TeaModel {
        public var id: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var player: UpdateAppMemberRequest.Player?

    public var roleNames: [String]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.player?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.player != nil {
            map["player"] = self.player?.toMap()
        }
        if self.roleNames != nil {
            map["roleNames"] = self.roleNames!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["player"] as? [String: Any?] {
            var model = UpdateAppMemberRequest.Player()
            model.fromMap(value)
            self.player = model
        }
        if let value = dict["roleNames"] as? [String] {
            self.roleNames = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class UpdateAppMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class UpdateApplicationRequest : Tea.TeaModel {
    public var ownerAccountId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccountId != nil {
            map["ownerAccountId"] = self.ownerAccountId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ownerAccountId"] as? String {
            self.ownerAccountId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class UpdateApplicationResponseBody : Tea.TeaModel {
    public var creatorAccountId: String?

    public var description_: String?

    public var gmtCreate: String?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creatorAccountId != nil {
            map["creatorAccountId"] = self.creatorAccountId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["creatorAccountId"] as? String {
            self.creatorAccountId = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["gmtCreate"] as? String {
            self.gmtCreate = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCheckRunRequest : Tea.TeaModel {
    public class Annotations : Tea.TeaModel {
        public var annotationLevel: String?

        public var endColumn: Int64?

        public var endLine: Int64?

        public var message: String?

        public var path: String?

        public var rawDetails: String?

        public var startColumn: Int64?

        public var startLine: Int64?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotationLevel != nil {
                map["annotationLevel"] = self.annotationLevel!
            }
            if self.endColumn != nil {
                map["endColumn"] = self.endColumn!
            }
            if self.endLine != nil {
                map["endLine"] = self.endLine!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.rawDetails != nil {
                map["rawDetails"] = self.rawDetails!
            }
            if self.startColumn != nil {
                map["startColumn"] = self.startColumn!
            }
            if self.startLine != nil {
                map["startLine"] = self.startLine!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["annotationLevel"] as? String {
                self.annotationLevel = value
            }
            if let value = dict["endColumn"] as? Int64 {
                self.endColumn = value
            }
            if let value = dict["endLine"] as? Int64 {
                self.endLine = value
            }
            if let value = dict["message"] as? String {
                self.message = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["rawDetails"] as? String {
                self.rawDetails = value
            }
            if let value = dict["startColumn"] as? Int64 {
                self.startColumn = value
            }
            if let value = dict["startLine"] as? Int64 {
                self.startLine = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
        }
    }
    public class Output : Tea.TeaModel {
        public class Images : Tea.TeaModel {
            public var alt: String?

            public var caption: String?

            public var imageUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alt != nil {
                    map["alt"] = self.alt!
                }
                if self.caption != nil {
                    map["caption"] = self.caption!
                }
                if self.imageUrl != nil {
                    map["imageUrl"] = self.imageUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["alt"] as? String {
                    self.alt = value
                }
                if let value = dict["caption"] as? String {
                    self.caption = value
                }
                if let value = dict["imageUrl"] as? String {
                    self.imageUrl = value
                }
            }
        }
        public var images: [UpdateCheckRunRequest.Output.Images]?

        public var summary: String?

        public var text: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.images != nil {
                var tmp : [Any] = []
                for k in self.images! {
                    tmp.append(k.toMap())
                }
                map["images"] = tmp
            }
            if self.summary != nil {
                map["summary"] = self.summary!
            }
            if self.text != nil {
                map["text"] = self.text!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["images"] as? [Any?] {
                var tmp : [UpdateCheckRunRequest.Output.Images] = []
                for v in value {
                    if v != nil {
                        var model = UpdateCheckRunRequest.Output.Images()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.images = tmp
            }
            if let value = dict["summary"] as? String {
                self.summary = value
            }
            if let value = dict["text"] as? String {
                self.text = value
            }
            if let value = dict["title"] as? String {
                self.title = value
            }
        }
    }
    public var accessToken: String?

    public var annotations: [UpdateCheckRunRequest.Annotations]?

    public var completedAt: String?

    public var conclusion: String?

    public var detailsUrl: String?

    public var externalId: String?

    public var name: String?

    public var output: UpdateCheckRunRequest.Output?

    public var startedAt: String?

    public var status: String?

    public var checkRunId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.output?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.annotations != nil {
            var tmp : [Any] = []
            for k in self.annotations! {
                tmp.append(k.toMap())
            }
            map["annotations"] = tmp
        }
        if self.completedAt != nil {
            map["completedAt"] = self.completedAt!
        }
        if self.conclusion != nil {
            map["conclusion"] = self.conclusion!
        }
        if self.detailsUrl != nil {
            map["detailsUrl"] = self.detailsUrl!
        }
        if self.externalId != nil {
            map["externalId"] = self.externalId!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.output != nil {
            map["output"] = self.output?.toMap()
        }
        if self.startedAt != nil {
            map["startedAt"] = self.startedAt!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.checkRunId != nil {
            map["checkRunId"] = self.checkRunId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["annotations"] as? [Any?] {
            var tmp : [UpdateCheckRunRequest.Annotations] = []
            for v in value {
                if v != nil {
                    var model = UpdateCheckRunRequest.Annotations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.annotations = tmp
        }
        if let value = dict["completedAt"] as? String {
            self.completedAt = value
        }
        if let value = dict["conclusion"] as? String {
            self.conclusion = value
        }
        if let value = dict["detailsUrl"] as? String {
            self.detailsUrl = value
        }
        if let value = dict["externalId"] as? String {
            self.externalId = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["output"] as? [String: Any?] {
            var model = UpdateCheckRunRequest.Output()
            model.fromMap(value)
            self.output = model
        }
        if let value = dict["startedAt"] as? String {
            self.startedAt = value
        }
        if let value = dict["status"] as? String {
            self.status = value
        }
        if let value = dict["checkRunId"] as? Int64 {
            self.checkRunId = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class UpdateCheckRunResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var annotationLevel: String?

            public var endColumn: Int64?

            public var endLine: Int64?

            public var id: Int64?

            public var message: String?

            public var path: String?

            public var rawDetails: String?

            public var startColumn: Int64?

            public var startLine: Int64?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotationLevel != nil {
                    map["annotationLevel"] = self.annotationLevel!
                }
                if self.endColumn != nil {
                    map["endColumn"] = self.endColumn!
                }
                if self.endLine != nil {
                    map["endLine"] = self.endLine!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.rawDetails != nil {
                    map["rawDetails"] = self.rawDetails!
                }
                if self.startColumn != nil {
                    map["startColumn"] = self.startColumn!
                }
                if self.startLine != nil {
                    map["startLine"] = self.startLine!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["annotationLevel"] as? String {
                    self.annotationLevel = value
                }
                if let value = dict["endColumn"] as? Int64 {
                    self.endColumn = value
                }
                if let value = dict["endLine"] as? Int64 {
                    self.endLine = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["path"] as? String {
                    self.path = value
                }
                if let value = dict["rawDetails"] as? String {
                    self.rawDetails = value
                }
                if let value = dict["startColumn"] as? Int64 {
                    self.startColumn = value
                }
                if let value = dict["startLine"] as? Int64 {
                    self.startLine = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public class CheckSuite : Tea.TeaModel {
            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class Images : Tea.TeaModel {
                public var alt: String?

                public var caption: String?

                public var imageUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alt != nil {
                        map["alt"] = self.alt!
                    }
                    if self.caption != nil {
                        map["caption"] = self.caption!
                    }
                    if self.imageUrl != nil {
                        map["imageUrl"] = self.imageUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["alt"] as? String {
                        self.alt = value
                    }
                    if let value = dict["caption"] as? String {
                        self.caption = value
                    }
                    if let value = dict["imageUrl"] as? String {
                        self.imageUrl = value
                    }
                }
            }
            public var images: [UpdateCheckRunResponseBody.Result.Output.Images]?

            public var summary: String?

            public var text: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.images != nil {
                    var tmp : [Any] = []
                    for k in self.images! {
                        tmp.append(k.toMap())
                    }
                    map["images"] = tmp
                }
                if self.summary != nil {
                    map["summary"] = self.summary!
                }
                if self.text != nil {
                    map["text"] = self.text!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["images"] as? [Any?] {
                    var tmp : [UpdateCheckRunResponseBody.Result.Output.Images] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateCheckRunResponseBody.Result.Output.Images()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.images = tmp
                }
                if let value = dict["summary"] as? String {
                    self.summary = value
                }
                if let value = dict["text"] as? String {
                    self.text = value
                }
                if let value = dict["title"] as? String {
                    self.title = value
                }
            }
        }
        public class Writer : Tea.TeaModel {
            public var id: String?

            public var logoUrl: String?

            public var name: String?

            public var slug: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.logoUrl != nil {
                    map["logoUrl"] = self.logoUrl!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.slug != nil {
                    map["slug"] = self.slug!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["id"] as? String {
                    self.id = value
                }
                if let value = dict["logoUrl"] as? String {
                    self.logoUrl = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["slug"] as? String {
                    self.slug = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public var annotations: [UpdateCheckRunResponseBody.Result.Annotations]?

        public var checkSuite: UpdateCheckRunResponseBody.Result.CheckSuite?

        public var completedAt: String?

        public var conclusion: String?

        public var createdAt: String?

        public var detailsUrl: String?

        public var externalId: String?

        public var headSha: String?

        public var id: Int64?

        public var name: String?

        public var output: UpdateCheckRunResponseBody.Result.Output?

        public var startedAt: String?

        public var status: String?

        public var updatedAt: String?

        public var writer: UpdateCheckRunResponseBody.Result.Writer?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkSuite?.validate()
            try self.output?.validate()
            try self.writer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["annotations"] = tmp
            }
            if self.checkSuite != nil {
                map["checkSuite"] = self.checkSuite?.toMap()
            }
            if self.completedAt != nil {
                map["completedAt"] = self.completedAt!
            }
            if self.conclusion != nil {
                map["conclusion"] = self.conclusion!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.detailsUrl != nil {
                map["detailsUrl"] = self.detailsUrl!
            }
            if self.externalId != nil {
                map["externalId"] = self.externalId!
            }
            if self.headSha != nil {
                map["headSha"] = self.headSha!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.output != nil {
                map["output"] = self.output?.toMap()
            }
            if self.startedAt != nil {
                map["startedAt"] = self.startedAt!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.writer != nil {
                map["writer"] = self.writer?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["annotations"] as? [Any?] {
                var tmp : [UpdateCheckRunResponseBody.Result.Annotations] = []
                for v in value {
                    if v != nil {
                        var model = UpdateCheckRunResponseBody.Result.Annotations()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.annotations = tmp
            }
            if let value = dict["checkSuite"] as? [String: Any?] {
                var model = UpdateCheckRunResponseBody.Result.CheckSuite()
                model.fromMap(value)
                self.checkSuite = model
            }
            if let value = dict["completedAt"] as? String {
                self.completedAt = value
            }
            if let value = dict["conclusion"] as? String {
                self.conclusion = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["detailsUrl"] as? String {
                self.detailsUrl = value
            }
            if let value = dict["externalId"] as? String {
                self.externalId = value
            }
            if let value = dict["headSha"] as? String {
                self.headSha = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["output"] as? [String: Any?] {
                var model = UpdateCheckRunResponseBody.Result.Output()
                model.fromMap(value)
                self.output = model
            }
            if let value = dict["startedAt"] as? String {
                self.startedAt = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["writer"] as? [String: Any?] {
                var model = UpdateCheckRunResponseBody.Result.Writer()
                model.fromMap(value)
                self.writer = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateCheckRunResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdateCheckRunResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateCheckRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCheckRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCheckRunResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateFileRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var commitMessage: String?

    public var content: String?

    public var encoding: String?

    public var newPath: String?

    public var oldPath: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.commitMessage != nil {
            map["commitMessage"] = self.commitMessage!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.encoding != nil {
            map["encoding"] = self.encoding!
        }
        if self.newPath != nil {
            map["newPath"] = self.newPath!
        }
        if self.oldPath != nil {
            map["oldPath"] = self.oldPath!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["branchName"] as? String {
            self.branchName = value
        }
        if let value = dict["commitMessage"] as? String {
            self.commitMessage = value
        }
        if let value = dict["content"] as? String {
            self.content = value
        }
        if let value = dict["encoding"] as? String {
            self.encoding = value
        }
        if let value = dict["newPath"] as? String {
            self.newPath = value
        }
        if let value = dict["oldPath"] as? String {
            self.oldPath = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class UpdateFileResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var branchName: String?

        public var filePath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["branchName"] = self.branchName!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["branchName"] as? String {
                self.branchName = value
            }
            if let value = dict["filePath"] as? String {
                self.filePath = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateFileResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdateFileResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateFlowTagRequest : Tea.TeaModel {
    public var color: String?

    public var flowTagGroupId: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.color != nil {
            map["color"] = self.color!
        }
        if self.flowTagGroupId != nil {
            map["flowTagGroupId"] = self.flowTagGroupId!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["color"] as? String {
            self.color = value
        }
        if let value = dict["flowTagGroupId"] as? Int64 {
            self.flowTagGroupId = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
    }
}

public class UpdateFlowTagResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateFlowTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFlowTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateFlowTagResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateFlowTagGroupRequest : Tea.TeaModel {
    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["name"] as? String {
            self.name = value
        }
    }
}

public class UpdateFlowTagGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateFlowTagGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFlowTagGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateFlowTagGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateGroupRequest : Tea.TeaModel {
    public var accessToken: String?

    public var avatarUrl: String?

    public var description_: String?

    public var name: String?

    public var path: String?

    public var pathWithNamespace: String?

    public var visibilityLevel: Int32?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.avatarUrl != nil {
            map["avatarUrl"] = self.avatarUrl!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.pathWithNamespace != nil {
            map["pathWithNamespace"] = self.pathWithNamespace!
        }
        if self.visibilityLevel != nil {
            map["visibilityLevel"] = self.visibilityLevel!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["avatarUrl"] as? String {
            self.avatarUrl = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["path"] as? String {
            self.path = value
        }
        if let value = dict["pathWithNamespace"] as? String {
            self.pathWithNamespace = value
        }
        if let value = dict["visibilityLevel"] as? Int32 {
            self.visibilityLevel = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class UpdateGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var avatarUrl: String?

        public var description_: String?

        public var id: Int64?

        public var name: String?

        public var nameWithNamespace: String?

        public var ownerId: Int64?

        public var parentId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var type: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["ownerId"] as? Int64 {
                self.ownerId = value
            }
            if let value = dict["parentId"] as? Int64 {
                self.parentId = value
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["pathWithNamespace"] as? String {
                self.pathWithNamespace = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["visibilityLevel"] as? Int32 {
                self.visibilityLevel = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateGroupResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdateGroupResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateGroupMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var aliyunPk: String?

    public var accessLevel: Int32?

    public var memberType: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.aliyunPk != nil {
            map["aliyunPk"] = self.aliyunPk!
        }
        if self.accessLevel != nil {
            map["accessLevel"] = self.accessLevel!
        }
        if self.memberType != nil {
            map["memberType"] = self.memberType!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["aliyunPk"] as? String {
            self.aliyunPk = value
        }
        if let value = dict["accessLevel"] as? Int32 {
            self.accessLevel = value
        }
        if let value = dict["memberType"] as? String {
            self.memberType = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class UpdateGroupMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var memberType: String?

        public var name: String?

        public var sourceId: Int64?

        public var state: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.memberType != nil {
                map["memberType"] = self.memberType!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["email"] as? String {
                self.email = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["memberType"] as? String {
                self.memberType = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceId"] as? Int64 {
                self.sourceId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["username"] as? String {
                self.username = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateGroupMemberResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdateGroupMemberResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateGroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateGroupMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateHostGroupRequest : Tea.TeaModel {
    public var aliyunRegion: String?

    public var ecsLabelKey: String?

    public var ecsLabelValue: String?

    public var ecsType: String?

    public var envId: String?

    public var machineInfos: String?

    public var name: String?

    public var serviceConnectionId: Int64?

    public var tagIds: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunRegion != nil {
            map["aliyunRegion"] = self.aliyunRegion!
        }
        if self.ecsLabelKey != nil {
            map["ecsLabelKey"] = self.ecsLabelKey!
        }
        if self.ecsLabelValue != nil {
            map["ecsLabelValue"] = self.ecsLabelValue!
        }
        if self.ecsType != nil {
            map["ecsType"] = self.ecsType!
        }
        if self.envId != nil {
            map["envId"] = self.envId!
        }
        if self.machineInfos != nil {
            map["machineInfos"] = self.machineInfos!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.serviceConnectionId != nil {
            map["serviceConnectionId"] = self.serviceConnectionId!
        }
        if self.tagIds != nil {
            map["tagIds"] = self.tagIds!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["aliyunRegion"] as? String {
            self.aliyunRegion = value
        }
        if let value = dict["ecsLabelKey"] as? String {
            self.ecsLabelKey = value
        }
        if let value = dict["ecsLabelValue"] as? String {
            self.ecsLabelValue = value
        }
        if let value = dict["ecsType"] as? String {
            self.ecsType = value
        }
        if let value = dict["envId"] as? String {
            self.envId = value
        }
        if let value = dict["machineInfos"] as? String {
            self.machineInfos = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["serviceConnectionId"] as? Int64 {
            self.serviceConnectionId = value
        }
        if let value = dict["tagIds"] as? String {
            self.tagIds = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
    }
}

public class UpdateHostGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateHostGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHostGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateHostGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var description_: String?

    public var title: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["title"] as? String {
            self.title = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class UpdateMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdateMergeRequestResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateMergeRequestResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateMergeRequestPersonnelRequest : Tea.TeaModel {
    public var accessToken: String?

    public var newUserIdList: [String]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.newUserIdList != nil {
            map["newUserIdList"] = self.newUserIdList!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["newUserIdList"] as? [String] {
            self.newUserIdList = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class UpdateMergeRequestPersonnelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateMergeRequestPersonnelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdateMergeRequestPersonnelResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateMergeRequestPersonnelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMergeRequestPersonnelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateMergeRequestPersonnelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateOrganizationMemberRequest : Tea.TeaModel {
    public var organizationMemberName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationMemberName != nil {
            map["organizationMemberName"] = self.organizationMemberName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["organizationMemberName"] as? String {
            self.organizationMemberName = value
        }
    }
}

public class UpdateOrganizationMemberResponseBody : Tea.TeaModel {
    public class Member : Tea.TeaModel {
        public var accountId: String?

        public var organizationMemberName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            if self.organizationMemberName != nil {
                map["organizationMemberName"] = self.organizationMemberName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accountId"] as? String {
                self.accountId = value
            }
            if let value = dict["organizationMemberName"] as? String {
                self.organizationMemberName = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var member: UpdateOrganizationMemberResponseBody.Member?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.member?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.member != nil {
            map["member"] = self.member?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["member"] as? [String: Any?] {
            var model = UpdateOrganizationMemberResponseBody.Member()
            model.fromMap(value)
            self.member = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateOrganizationMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateOrganizationMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateOrganizationMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePipelineRequest : Tea.TeaModel {
    public var content: String?

    public var name: String?

    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.pipelineId != nil {
            map["pipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["content"] as? String {
            self.content = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["pipelineId"] as? String {
            self.pipelineId = value
        }
    }
}

public class UpdatePipelineResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePipelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePipelineBaseInfoRequest : Tea.TeaModel {
    public var envId: Int64?

    public var pipelineName: String?

    public var tagList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envId != nil {
            map["envId"] = self.envId!
        }
        if self.pipelineName != nil {
            map["pipelineName"] = self.pipelineName!
        }
        if self.tagList != nil {
            map["tagList"] = self.tagList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["envId"] as? Int64 {
            self.envId = value
        }
        if let value = dict["pipelineName"] as? String {
            self.pipelineName = value
        }
        if let value = dict["tagList"] as? String {
            self.tagList = value
        }
    }
}

public class UpdatePipelineBaseInfoResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdatePipelineBaseInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineBaseInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePipelineBaseInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePipelineGroupRequest : Tea.TeaModel {
    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["name"] as? String {
            self.name = value
        }
    }
}

public class UpdatePipelineGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdatePipelineGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePipelineGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateProjectFieldRequest : Tea.TeaModel {
    public class UpdateBasicFieldRequestList : Tea.TeaModel {
        public var propertyKey: String?

        public var propertyValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.propertyKey != nil {
                map["propertyKey"] = self.propertyKey!
            }
            if self.propertyValue != nil {
                map["propertyValue"] = self.propertyValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["propertyKey"] as? String {
                self.propertyKey = value
            }
            if let value = dict["propertyValue"] as? String {
                self.propertyValue = value
            }
        }
    }
    public class UpdateForOpenApiList : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fieldIdentifier"] as? String {
                self.fieldIdentifier = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public var statusIdentifier: String?

    public var updateBasicFieldRequestList: [UpdateProjectFieldRequest.UpdateBasicFieldRequestList]?

    public var updateForOpenApiList: [UpdateProjectFieldRequest.UpdateForOpenApiList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.statusIdentifier != nil {
            map["statusIdentifier"] = self.statusIdentifier!
        }
        if self.updateBasicFieldRequestList != nil {
            var tmp : [Any] = []
            for k in self.updateBasicFieldRequestList! {
                tmp.append(k.toMap())
            }
            map["updateBasicFieldRequestList"] = tmp
        }
        if self.updateForOpenApiList != nil {
            var tmp : [Any] = []
            for k in self.updateForOpenApiList! {
                tmp.append(k.toMap())
            }
            map["updateForOpenApiList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["statusIdentifier"] as? String {
            self.statusIdentifier = value
        }
        if let value = dict["updateBasicFieldRequestList"] as? [Any?] {
            var tmp : [UpdateProjectFieldRequest.UpdateBasicFieldRequestList] = []
            for v in value {
                if v != nil {
                    var model = UpdateProjectFieldRequest.UpdateBasicFieldRequestList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.updateBasicFieldRequestList = tmp
        }
        if let value = dict["updateForOpenApiList"] as? [Any?] {
            var tmp : [UpdateProjectFieldRequest.UpdateForOpenApiList] = []
            for v in value {
                if v != nil {
                    var model = UpdateProjectFieldRequest.UpdateForOpenApiList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.updateForOpenApiList = tmp
        }
    }
}

public class UpdateProjectFieldResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public class FieldList : Tea.TeaModel {
            public var displayName: String?

            public var identifier: String?

            public var value: String?

            public var valueType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                if self.valueType != nil {
                    map["valueType"] = self.valueType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["displayName"] as? String {
                    self.displayName = value
                }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["value"] as? String {
                    self.value = value
                }
                if let value = dict["valueType"] as? String {
                    self.valueType = value
                }
            }
        }
        public var category: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var customCode: String?

        public var description_: String?

        public var fieldList: [UpdateProjectFieldResponseBody.Project.FieldList]?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var icon: String?

        public var iconBig: String?

        public var iconGroup: String?

        public var iconSmall: String?

        public var id: String?

        public var identifier: String?

        public var identifierPath: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var name: String?

        public var organizationIdentifier: String?

        public var parentIdentifier: String?

        public var scope: String?

        public var statusIdentifier: String?

        public var statusName: String?

        public var statusStageIdentifier: String?

        public var subType: String?

        public var typeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["category"] = self.category!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.customCode != nil {
                map["customCode"] = self.customCode!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.fieldList != nil {
                var tmp : [Any] = []
                for k in self.fieldList! {
                    tmp.append(k.toMap())
                }
                map["fieldList"] = tmp
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.icon != nil {
                map["icon"] = self.icon!
            }
            if self.iconBig != nil {
                map["iconBig"] = self.iconBig!
            }
            if self.iconGroup != nil {
                map["iconGroup"] = self.iconGroup!
            }
            if self.iconSmall != nil {
                map["iconSmall"] = self.iconSmall!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.identifierPath != nil {
                map["identifierPath"] = self.identifierPath!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationIdentifier != nil {
                map["organizationIdentifier"] = self.organizationIdentifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusName != nil {
                map["statusName"] = self.statusName!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subType != nil {
                map["subType"] = self.subType!
            }
            if self.typeIdentifier != nil {
                map["typeIdentifier"] = self.typeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["category"] as? String {
                self.category = value
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["customCode"] as? String {
                self.customCode = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["fieldList"] as? [Any?] {
                var tmp : [UpdateProjectFieldResponseBody.Project.FieldList] = []
                for v in value {
                    if v != nil {
                        var model = UpdateProjectFieldResponseBody.Project.FieldList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.fieldList = tmp
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["icon"] as? String {
                self.icon = value
            }
            if let value = dict["iconBig"] as? String {
                self.iconBig = value
            }
            if let value = dict["iconGroup"] as? String {
                self.iconGroup = value
            }
            if let value = dict["iconSmall"] as? String {
                self.iconSmall = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["identifierPath"] as? String {
                self.identifierPath = value
            }
            if let value = dict["logicalStatus"] as? String {
                self.logicalStatus = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["organizationIdentifier"] as? String {
                self.organizationIdentifier = value
            }
            if let value = dict["parentIdentifier"] as? String {
                self.parentIdentifier = value
            }
            if let value = dict["scope"] as? String {
                self.scope = value
            }
            if let value = dict["statusIdentifier"] as? String {
                self.statusIdentifier = value
            }
            if let value = dict["statusName"] as? String {
                self.statusName = value
            }
            if let value = dict["statusStageIdentifier"] as? String {
                self.statusStageIdentifier = value
            }
            if let value = dict["subType"] as? String {
                self.subType = value
            }
            if let value = dict["typeIdentifier"] as? String {
                self.typeIdentifier = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var project: UpdateProjectFieldResponseBody.Project?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.project != nil {
            map["project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["project"] as? [String: Any?] {
            var model = UpdateProjectFieldResponseBody.Project()
            model.fromMap(value)
            self.project = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateProjectFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProjectFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateProjectFieldResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateProjectLabelRequest : Tea.TeaModel {
    public var accessToken: String?

    public var color: String?

    public var description_: String?

    public var name: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.color != nil {
            map["color"] = self.color!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["color"] as? String {
            self.color = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["repositoryIdentity"] as? String {
            self.repositoryIdentity = value
        }
    }
}

public class UpdateProjectLabelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var color: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.color != nil {
                map["color"] = self.color!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["color"] as? String {
                self.color = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateProjectLabelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdateProjectLabelResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateProjectLabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProjectLabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateProjectLabelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateProjectMemberRequest : Tea.TeaModel {
    public var roleIdentifier: String?

    public var targetIdentifier: String?

    public var targetType: String?

    public var userIdentifier: String?

    public var userType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roleIdentifier != nil {
            map["roleIdentifier"] = self.roleIdentifier!
        }
        if self.targetIdentifier != nil {
            map["targetIdentifier"] = self.targetIdentifier!
        }
        if self.targetType != nil {
            map["targetType"] = self.targetType!
        }
        if self.userIdentifier != nil {
            map["userIdentifier"] = self.userIdentifier!
        }
        if self.userType != nil {
            map["userType"] = self.userType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["roleIdentifier"] as? String {
            self.roleIdentifier = value
        }
        if let value = dict["targetIdentifier"] as? String {
            self.targetIdentifier = value
        }
        if let value = dict["targetType"] as? String {
            self.targetType = value
        }
        if let value = dict["userIdentifier"] as? String {
            self.userIdentifier = value
        }
        if let value = dict["userType"] as? String {
            self.userType = value
        }
    }
}

public class UpdateProjectMemberResponseBody : Tea.TeaModel {
    public class Member : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: String?

        public var roleIdentifier: String?

        public var targetIdentifier: String?

        public var targetType: String?

        public var userIdentifier: String?

        public var userType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.roleIdentifier != nil {
                map["roleIdentifier"] = self.roleIdentifier!
            }
            if self.targetIdentifier != nil {
                map["targetIdentifier"] = self.targetIdentifier!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.userIdentifier != nil {
                map["userIdentifier"] = self.userIdentifier!
            }
            if self.userType != nil {
                map["userType"] = self.userType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["roleIdentifier"] as? String {
                self.roleIdentifier = value
            }
            if let value = dict["targetIdentifier"] as? String {
                self.targetIdentifier = value
            }
            if let value = dict["targetType"] as? String {
                self.targetType = value
            }
            if let value = dict["userIdentifier"] as? String {
                self.userIdentifier = value
            }
            if let value = dict["userType"] as? String {
                self.userType = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var member: UpdateProjectMemberResponseBody.Member?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.member?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.member != nil {
            map["member"] = self.member?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["member"] as? [String: Any?] {
            var model = UpdateProjectMemberResponseBody.Member()
            model.fromMap(value)
            self.member = model
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateProjectMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateProtectedBranchesRequest : Tea.TeaModel {
    public class MergeRequestSetting : Tea.TeaModel {
        public var allowMergeRequestRoles: [Int32]?

        public var defaultAssignees: [String]?

        public var isAllowSelfApproval: Bool?

        public var isRequireDiscussionProcessed: Bool?

        public var isRequired: Bool?

        public var isResetApprovalWhenNewPush: Bool?

        public var minimumApproval: Int32?

        public var mrMode: String?

        public var whiteList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowMergeRequestRoles != nil {
                map["allowMergeRequestRoles"] = self.allowMergeRequestRoles!
            }
            if self.defaultAssignees != nil {
                map["defaultAssignees"] = self.defaultAssignees!
            }
            if self.isAllowSelfApproval != nil {
                map["isAllowSelfApproval"] = self.isAllowSelfApproval!
            }
            if self.isRequireDiscussionProcessed != nil {
                map["isRequireDiscussionProcessed"] = self.isRequireDiscussionProcessed!
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.isResetApprovalWhenNewPush != nil {
                map["isResetApprovalWhenNewPush"] = self.isResetApprovalWhenNewPush!
            }
            if self.minimumApproval != nil {
                map["minimumApproval"] = self.minimumApproval!
            }
            if self.mrMode != nil {
                map["mrMode"] = self.mrMode!
            }
            if self.whiteList != nil {
                map["whiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["allowMergeRequestRoles"] as? [Int32] {
                self.allowMergeRequestRoles = value
            }
            if let value = dict["defaultAssignees"] as? [String] {
                self.defaultAssignees = value
            }
            if let value = dict["isAllowSelfApproval"] as? Bool {
                self.isAllowSelfApproval = value
            }
            if let value = dict["isRequireDiscussionProcessed"] as? Bool {
                self.isRequireDiscussionProcessed = value
            }
            if let value = dict["isRequired"] as? Bool {
                self.isRequired = value
            }
            if let value = dict["isResetApprovalWhenNewPush"] as? Bool {
                self.isResetApprovalWhenNewPush = value
            }
            if let value = dict["minimumApproval"] as? Int32 {
                self.minimumApproval = value
            }
            if let value = dict["mrMode"] as? String {
                self.mrMode = value
            }
            if let value = dict["whiteList"] as? String {
                self.whiteList = value
            }
        }
    }
    public class TestSettingDTO : Tea.TeaModel {
        public class CheckConfig : Tea.TeaModel {
            public class CheckItems : Tea.TeaModel {
                public var isRequired: Bool?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isRequired != nil {
                        map["isRequired"] = self.isRequired!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["isRequired"] as? Bool {
                        self.isRequired = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                }
            }
            public var checkItems: [UpdateProtectedBranchesRequest.TestSettingDTO.CheckConfig.CheckItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkItems != nil {
                    var tmp : [Any] = []
                    for k in self.checkItems! {
                        tmp.append(k.toMap())
                    }
                    map["checkItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["checkItems"] as? [Any?] {
                    var tmp : [UpdateProtectedBranchesRequest.TestSettingDTO.CheckConfig.CheckItems] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateProtectedBranchesRequest.TestSettingDTO.CheckConfig.CheckItems()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.checkItems = tmp
                }
            }
        }
        public class CheckTaskQualityConfig : Tea.TeaModel {
            public var bizNo: String?

            public var enabled: Bool?

            public var message: String?

            public var taskName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizNo != nil {
                    map["bizNo"] = self.bizNo!
                }
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.taskName != nil {
                    map["taskName"] = self.taskName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["bizNo"] as? String {
                    self.bizNo = value
                }
                if let value = dict["enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
                if let value = dict["taskName"] as? String {
                    self.taskName = value
                }
            }
        }
        public class CodeGuidelinesDetection : Tea.TeaModel {
            public var enabled: Bool?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
            }
        }
        public class SensitiveInfoDetection : Tea.TeaModel {
            public var enabled: Bool?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["enabled"] as? Bool {
                    self.enabled = value
                }
                if let value = dict["message"] as? String {
                    self.message = value
                }
            }
        }
        public var checkConfig: UpdateProtectedBranchesRequest.TestSettingDTO.CheckConfig?

        public var checkTaskQualityConfig: UpdateProtectedBranchesRequest.TestSettingDTO.CheckTaskQualityConfig?

        public var codeGuidelinesDetection: UpdateProtectedBranchesRequest.TestSettingDTO.CodeGuidelinesDetection?

        public var isRequired: Bool?

        public var sensitiveInfoDetection: UpdateProtectedBranchesRequest.TestSettingDTO.SensitiveInfoDetection?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkConfig?.validate()
            try self.checkTaskQualityConfig?.validate()
            try self.codeGuidelinesDetection?.validate()
            try self.sensitiveInfoDetection?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkConfig != nil {
                map["checkConfig"] = self.checkConfig?.toMap()
            }
            if self.checkTaskQualityConfig != nil {
                map["checkTaskQualityConfig"] = self.checkTaskQualityConfig?.toMap()
            }
            if self.codeGuidelinesDetection != nil {
                map["codeGuidelinesDetection"] = self.codeGuidelinesDetection?.toMap()
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.sensitiveInfoDetection != nil {
                map["sensitiveInfoDetection"] = self.sensitiveInfoDetection?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["checkConfig"] as? [String: Any?] {
                var model = UpdateProtectedBranchesRequest.TestSettingDTO.CheckConfig()
                model.fromMap(value)
                self.checkConfig = model
            }
            if let value = dict["checkTaskQualityConfig"] as? [String: Any?] {
                var model = UpdateProtectedBranchesRequest.TestSettingDTO.CheckTaskQualityConfig()
                model.fromMap(value)
                self.checkTaskQualityConfig = model
            }
            if let value = dict["codeGuidelinesDetection"] as? [String: Any?] {
                var model = UpdateProtectedBranchesRequest.TestSettingDTO.CodeGuidelinesDetection()
                model.fromMap(value)
                self.codeGuidelinesDetection = model
            }
            if let value = dict["isRequired"] as? Bool {
                self.isRequired = value
            }
            if let value = dict["sensitiveInfoDetection"] as? [String: Any?] {
                var model = UpdateProtectedBranchesRequest.TestSettingDTO.SensitiveInfoDetection()
                model.fromMap(value)
                self.sensitiveInfoDetection = model
            }
        }
    }
    public var accessToken: String?

    public var allowMergeRoles: [Int32]?

    public var allowMergeUserIds: [String]?

    public var allowPushRoles: [Int32]?

    public var allowPushUserIds: [String]?

    public var branch: String?

    public var id: Int64?

    public var mergeRequestSetting: UpdateProtectedBranchesRequest.MergeRequestSetting?

    public var testSettingDTO: UpdateProtectedBranchesRequest.TestSettingDTO?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mergeRequestSetting?.validate()
        try self.testSettingDTO?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.allowMergeRoles != nil {
            map["allowMergeRoles"] = self.allowMergeRoles!
        }
        if self.allowMergeUserIds != nil {
            map["allowMergeUserIds"] = self.allowMergeUserIds!
        }
        if self.allowPushRoles != nil {
            map["allowPushRoles"] = self.allowPushRoles!
        }
        if self.allowPushUserIds != nil {
            map["allowPushUserIds"] = self.allowPushUserIds!
        }
        if self.branch != nil {
            map["branch"] = self.branch!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.mergeRequestSetting != nil {
            map["mergeRequestSetting"] = self.mergeRequestSetting?.toMap()
        }
        if self.testSettingDTO != nil {
            map["testSettingDTO"] = self.testSettingDTO?.toMap()
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["allowMergeRoles"] as? [Int32] {
            self.allowMergeRoles = value
        }
        if let value = dict["allowMergeUserIds"] as? [String] {
            self.allowMergeUserIds = value
        }
        if let value = dict["allowPushRoles"] as? [Int32] {
            self.allowPushRoles = value
        }
        if let value = dict["allowPushUserIds"] as? [String] {
            self.allowPushUserIds = value
        }
        if let value = dict["branch"] as? String {
            self.branch = value
        }
        if let value = dict["id"] as? Int64 {
            self.id = value
        }
        if let value = dict["mergeRequestSetting"] as? [String: Any?] {
            var model = UpdateProtectedBranchesRequest.MergeRequestSetting()
            model.fromMap(value)
            self.mergeRequestSetting = model
        }
        if let value = dict["testSettingDTO"] as? [String: Any?] {
            var model = UpdateProtectedBranchesRequest.TestSettingDTO()
            model.fromMap(value)
            self.testSettingDTO = model
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class UpdateProtectedBranchesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class MergeRequestSetting : Tea.TeaModel {
            public var allowMergeRequestRoles: [Int32]?

            public var defaultAssignees: [String]?

            public var isAllowSelfApproval: Bool?

            public var isRequireDiscussionProcessed: Bool?

            public var isRequired: Bool?

            public var isResetApprovalWhenNewPush: Bool?

            public var minimumApproval: Int32?

            public var mrMode: String?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowMergeRequestRoles != nil {
                    map["allowMergeRequestRoles"] = self.allowMergeRequestRoles!
                }
                if self.defaultAssignees != nil {
                    map["defaultAssignees"] = self.defaultAssignees!
                }
                if self.isAllowSelfApproval != nil {
                    map["isAllowSelfApproval"] = self.isAllowSelfApproval!
                }
                if self.isRequireDiscussionProcessed != nil {
                    map["isRequireDiscussionProcessed"] = self.isRequireDiscussionProcessed!
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.isResetApprovalWhenNewPush != nil {
                    map["isResetApprovalWhenNewPush"] = self.isResetApprovalWhenNewPush!
                }
                if self.minimumApproval != nil {
                    map["minimumApproval"] = self.minimumApproval!
                }
                if self.mrMode != nil {
                    map["mrMode"] = self.mrMode!
                }
                if self.whiteList != nil {
                    map["whiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["allowMergeRequestRoles"] as? [Int32] {
                    self.allowMergeRequestRoles = value
                }
                if let value = dict["defaultAssignees"] as? [String] {
                    self.defaultAssignees = value
                }
                if let value = dict["isAllowSelfApproval"] as? Bool {
                    self.isAllowSelfApproval = value
                }
                if let value = dict["isRequireDiscussionProcessed"] as? Bool {
                    self.isRequireDiscussionProcessed = value
                }
                if let value = dict["isRequired"] as? Bool {
                    self.isRequired = value
                }
                if let value = dict["isResetApprovalWhenNewPush"] as? Bool {
                    self.isResetApprovalWhenNewPush = value
                }
                if let value = dict["minimumApproval"] as? Int32 {
                    self.minimumApproval = value
                }
                if let value = dict["mrMode"] as? String {
                    self.mrMode = value
                }
                if let value = dict["whiteList"] as? String {
                    self.whiteList = value
                }
            }
        }
        public class TestSettingDTO : Tea.TeaModel {
            public class CheckConfig : Tea.TeaModel {
                public class CheckItems : Tea.TeaModel {
                    public var isRequired: Bool?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isRequired != nil {
                            map["isRequired"] = self.isRequired!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["isRequired"] as? Bool {
                            self.isRequired = value
                        }
                        if let value = dict["name"] as? String {
                            self.name = value
                        }
                    }
                }
                public var checkItems: [UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkItems != nil {
                        var tmp : [Any] = []
                        for k in self.checkItems! {
                            tmp.append(k.toMap())
                        }
                        map["checkItems"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["checkItems"] as? [Any?] {
                        var tmp : [UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems] = []
                        for v in value {
                            if v != nil {
                                var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.checkItems = tmp
                    }
                }
            }
            public class CheckTaskQualityConfig : Tea.TeaModel {
                public var bizNo: String?

                public var enabled: Bool?

                public var message: String?

                public var taskName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizNo != nil {
                        map["bizNo"] = self.bizNo!
                    }
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    if self.taskName != nil {
                        map["taskName"] = self.taskName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["bizNo"] as? String {
                        self.bizNo = value
                    }
                    if let value = dict["enabled"] as? Bool {
                        self.enabled = value
                    }
                    if let value = dict["message"] as? String {
                        self.message = value
                    }
                    if let value = dict["taskName"] as? String {
                        self.taskName = value
                    }
                }
            }
            public class CodeGuidelinesDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["enabled"] as? Bool {
                        self.enabled = value
                    }
                    if let value = dict["message"] as? String {
                        self.message = value
                    }
                }
            }
            public class SensitiveInfoDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["enabled"] as? Bool {
                        self.enabled = value
                    }
                    if let value = dict["message"] as? String {
                        self.message = value
                    }
                }
            }
            public var checkConfig: UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig?

            public var checkTaskQualityConfig: UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig?

            public var codeGuidelinesDetection: UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection?

            public var isRequired: Bool?

            public var sensitiveInfoDetection: UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.SensitiveInfoDetection?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.checkConfig?.validate()
                try self.checkTaskQualityConfig?.validate()
                try self.codeGuidelinesDetection?.validate()
                try self.sensitiveInfoDetection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkConfig != nil {
                    map["checkConfig"] = self.checkConfig?.toMap()
                }
                if self.checkTaskQualityConfig != nil {
                    map["checkTaskQualityConfig"] = self.checkTaskQualityConfig?.toMap()
                }
                if self.codeGuidelinesDetection != nil {
                    map["codeGuidelinesDetection"] = self.codeGuidelinesDetection?.toMap()
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.sensitiveInfoDetection != nil {
                    map["sensitiveInfoDetection"] = self.sensitiveInfoDetection?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["checkConfig"] as? [String: Any?] {
                    var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig()
                    model.fromMap(value)
                    self.checkConfig = model
                }
                if let value = dict["checkTaskQualityConfig"] as? [String: Any?] {
                    var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig()
                    model.fromMap(value)
                    self.checkTaskQualityConfig = model
                }
                if let value = dict["codeGuidelinesDetection"] as? [String: Any?] {
                    var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection()
                    model.fromMap(value)
                    self.codeGuidelinesDetection = model
                }
                if let value = dict["isRequired"] as? Bool {
                    self.isRequired = value
                }
                if let value = dict["sensitiveInfoDetection"] as? [String: Any?] {
                    var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.SensitiveInfoDetection()
                    model.fromMap(value)
                    self.sensitiveInfoDetection = model
                }
            }
        }
        public var allowMergeRoles: [Int32]?

        public var allowMergeUserIds: [Int64]?

        public var allowPushRoles: [Int32]?

        public var allowPushUserIds: [Int64]?

        public var branch: String?

        public var id: Int64?

        public var mergeRequestSetting: UpdateProtectedBranchesResponseBody.Result.MergeRequestSetting?

        public var testSettingDTO: UpdateProtectedBranchesResponseBody.Result.TestSettingDTO?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mergeRequestSetting?.validate()
            try self.testSettingDTO?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowMergeRoles != nil {
                map["allowMergeRoles"] = self.allowMergeRoles!
            }
            if self.allowMergeUserIds != nil {
                map["allowMergeUserIds"] = self.allowMergeUserIds!
            }
            if self.allowPushRoles != nil {
                map["allowPushRoles"] = self.allowPushRoles!
            }
            if self.allowPushUserIds != nil {
                map["allowPushUserIds"] = self.allowPushUserIds!
            }
            if self.branch != nil {
                map["branch"] = self.branch!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.mergeRequestSetting != nil {
                map["mergeRequestSetting"] = self.mergeRequestSetting?.toMap()
            }
            if self.testSettingDTO != nil {
                map["testSettingDTO"] = self.testSettingDTO?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["allowMergeRoles"] as? [Int32] {
                self.allowMergeRoles = value
            }
            if let value = dict["allowMergeUserIds"] as? [Int64] {
                self.allowMergeUserIds = value
            }
            if let value = dict["allowPushRoles"] as? [Int32] {
                self.allowPushRoles = value
            }
            if let value = dict["allowPushUserIds"] as? [Int64] {
                self.allowPushUserIds = value
            }
            if let value = dict["branch"] as? String {
                self.branch = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["mergeRequestSetting"] as? [String: Any?] {
                var model = UpdateProtectedBranchesResponseBody.Result.MergeRequestSetting()
                model.fromMap(value)
                self.mergeRequestSetting = model
            }
            if let value = dict["testSettingDTO"] as? [String: Any?] {
                var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO()
                model.fromMap(value)
                self.testSettingDTO = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateProtectedBranchesResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdateProtectedBranchesResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateProtectedBranchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProtectedBranchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateProtectedBranchesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePushReviewOnOffRequest : Tea.TeaModel {
    public var organizationId: String?

    public var trunkMode: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.trunkMode != nil {
            map["trunkMode"] = self.trunkMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
        if let value = dict["trunkMode"] as? Bool {
            self.trunkMode = value
        }
    }
}

public class UpdatePushReviewOnOffResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["result"] as? Bool {
                self.result = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdatePushReviewOnOffResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdatePushReviewOnOffResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdatePushReviewOnOffResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePushReviewOnOffResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePushReviewOnOffResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePushRuleRequest : Tea.TeaModel {
    public class RuleInfos : Tea.TeaModel {
        public var checkerName: String?

        public var checkerType: String?

        public var extraMessage: String?

        public var fileRuleRegexes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkerName != nil {
                map["checkerName"] = self.checkerName!
            }
            if self.checkerType != nil {
                map["checkerType"] = self.checkerType!
            }
            if self.extraMessage != nil {
                map["extraMessage"] = self.extraMessage!
            }
            if self.fileRuleRegexes != nil {
                map["fileRuleRegexes"] = self.fileRuleRegexes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["checkerName"] as? String {
                self.checkerName = value
            }
            if let value = dict["checkerType"] as? String {
                self.checkerType = value
            }
            if let value = dict["extraMessage"] as? String {
                self.extraMessage = value
            }
            if let value = dict["fileRuleRegexes"] as? [String] {
                self.fileRuleRegexes = value
            }
        }
    }
    public var accessToken: String?

    public var ruleInfos: [UpdatePushRuleRequest.RuleInfos]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.ruleInfos != nil {
            var tmp : [Any] = []
            for k in self.ruleInfos! {
                tmp.append(k.toMap())
            }
            map["ruleInfos"] = tmp
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["ruleInfos"] as? [Any?] {
            var tmp : [UpdatePushRuleRequest.RuleInfos] = []
            for v in value {
                if v != nil {
                    var model = UpdatePushRuleRequest.RuleInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ruleInfos = tmp
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class UpdatePushRuleResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class RuleInfos : Tea.TeaModel {
            public var checkerName: String?

            public var checkerType: String?

            public var extraMessage: String?

            public var fileRuleRegexes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkerName != nil {
                    map["checkerName"] = self.checkerName!
                }
                if self.checkerType != nil {
                    map["checkerType"] = self.checkerType!
                }
                if self.extraMessage != nil {
                    map["extraMessage"] = self.extraMessage!
                }
                if self.fileRuleRegexes != nil {
                    map["fileRuleRegexes"] = self.fileRuleRegexes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["checkerName"] as? String {
                    self.checkerName = value
                }
                if let value = dict["checkerType"] as? String {
                    self.checkerType = value
                }
                if let value = dict["extraMessage"] as? String {
                    self.extraMessage = value
                }
                if let value = dict["fileRuleRegexes"] as? [String] {
                    self.fileRuleRegexes = value
                }
            }
        }
        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var ruleInfos: [UpdatePushRuleResponseBody.Result.RuleInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleInfos != nil {
                var tmp : [Any] = []
                for k in self.ruleInfos! {
                    tmp.append(k.toMap())
                }
                map["ruleInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["gmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ruleInfos"] as? [Any?] {
                var tmp : [UpdatePushRuleResponseBody.Result.RuleInfos] = []
                for v in value {
                    if v != nil {
                        var model = UpdatePushRuleResponseBody.Result.RuleInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ruleInfos = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdatePushRuleResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdatePushRuleResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdatePushRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePushRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePushRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRepositoryRequest : Tea.TeaModel {
    public class ProjectCloneDownloadMethodList : Tea.TeaModel {
        public var allowed: Bool?

        public var permissionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowed != nil {
                map["allowed"] = self.allowed!
            }
            if self.permissionCode != nil {
                map["permissionCode"] = self.permissionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["allowed"] as? Bool {
                self.allowed = value
            }
            if let value = dict["permissionCode"] as? String {
                self.permissionCode = value
            }
        }
    }
    public class ProjectCloneDownloadRoleList : Tea.TeaModel {
        public var allowed: Bool?

        public var roleCode: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowed != nil {
                map["allowed"] = self.allowed!
            }
            if self.roleCode != nil {
                map["roleCode"] = self.roleCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["allowed"] as? Bool {
                self.allowed = value
            }
            if let value = dict["roleCode"] as? Int32 {
                self.roleCode = value
            }
        }
    }
    public var accessToken: String?

    public var adminSettingLanguage: String?

    public var avatar: String?

    public var buildsEnabled: Bool?

    public var checkEmail: Bool?

    public var defaultBranch: String?

    public var description_: String?

    public var id: Int64?

    public var issuesEnabled: Bool?

    public var mergeRequestsEnabled: Bool?

    public var name: String?

    public var openCloneDownloadControl: Bool?

    public var path: String?

    public var projectCloneDownloadMethodList: [UpdateRepositoryRequest.ProjectCloneDownloadMethodList]?

    public var projectCloneDownloadRoleList: [UpdateRepositoryRequest.ProjectCloneDownloadRoleList]?

    public var snippetsEnabled: Bool?

    public var visibilityLevel: Int32?

    public var wikiEnabled: Bool?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.adminSettingLanguage != nil {
            map["adminSettingLanguage"] = self.adminSettingLanguage!
        }
        if self.avatar != nil {
            map["avatar"] = self.avatar!
        }
        if self.buildsEnabled != nil {
            map["buildsEnabled"] = self.buildsEnabled!
        }
        if self.checkEmail != nil {
            map["checkEmail"] = self.checkEmail!
        }
        if self.defaultBranch != nil {
            map["defaultBranch"] = self.defaultBranch!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.issuesEnabled != nil {
            map["issuesEnabled"] = self.issuesEnabled!
        }
        if self.mergeRequestsEnabled != nil {
            map["mergeRequestsEnabled"] = self.mergeRequestsEnabled!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.openCloneDownloadControl != nil {
            map["openCloneDownloadControl"] = self.openCloneDownloadControl!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.projectCloneDownloadMethodList != nil {
            var tmp : [Any] = []
            for k in self.projectCloneDownloadMethodList! {
                tmp.append(k.toMap())
            }
            map["projectCloneDownloadMethodList"] = tmp
        }
        if self.projectCloneDownloadRoleList != nil {
            var tmp : [Any] = []
            for k in self.projectCloneDownloadRoleList! {
                tmp.append(k.toMap())
            }
            map["projectCloneDownloadRoleList"] = tmp
        }
        if self.snippetsEnabled != nil {
            map["snippetsEnabled"] = self.snippetsEnabled!
        }
        if self.visibilityLevel != nil {
            map["visibilityLevel"] = self.visibilityLevel!
        }
        if self.wikiEnabled != nil {
            map["wikiEnabled"] = self.wikiEnabled!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["adminSettingLanguage"] as? String {
            self.adminSettingLanguage = value
        }
        if let value = dict["avatar"] as? String {
            self.avatar = value
        }
        if let value = dict["buildsEnabled"] as? Bool {
            self.buildsEnabled = value
        }
        if let value = dict["checkEmail"] as? Bool {
            self.checkEmail = value
        }
        if let value = dict["defaultBranch"] as? String {
            self.defaultBranch = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["id"] as? Int64 {
            self.id = value
        }
        if let value = dict["issuesEnabled"] as? Bool {
            self.issuesEnabled = value
        }
        if let value = dict["mergeRequestsEnabled"] as? Bool {
            self.mergeRequestsEnabled = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["openCloneDownloadControl"] as? Bool {
            self.openCloneDownloadControl = value
        }
        if let value = dict["path"] as? String {
            self.path = value
        }
        if let value = dict["projectCloneDownloadMethodList"] as? [Any?] {
            var tmp : [UpdateRepositoryRequest.ProjectCloneDownloadMethodList] = []
            for v in value {
                if v != nil {
                    var model = UpdateRepositoryRequest.ProjectCloneDownloadMethodList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.projectCloneDownloadMethodList = tmp
        }
        if let value = dict["projectCloneDownloadRoleList"] as? [Any?] {
            var tmp : [UpdateRepositoryRequest.ProjectCloneDownloadRoleList] = []
            for v in value {
                if v != nil {
                    var model = UpdateRepositoryRequest.ProjectCloneDownloadRoleList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.projectCloneDownloadRoleList = tmp
        }
        if let value = dict["snippetsEnabled"] as? Bool {
            self.snippetsEnabled = value
        }
        if let value = dict["visibilityLevel"] as? Int32 {
            self.visibilityLevel = value
        }
        if let value = dict["wikiEnabled"] as? Bool {
            self.wikiEnabled = value
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class UpdateRepositoryResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Namespace : Tea.TeaModel {
            public var avatar: String?

            public var createdAt: String?

            public var description_: String?

            public var id: Int64?

            public var name: String?

            public var ownerId: Int64?

            public var path: String?

            public var updatedAt: String?

            public var visibilityLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.ownerId != nil {
                    map["ownerId"] = self.ownerId!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.updatedAt != nil {
                    map["updatedAt"] = self.updatedAt!
                }
                if self.visibilityLevel != nil {
                    map["visibilityLevel"] = self.visibilityLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["avatar"] as? String {
                    self.avatar = value
                }
                if let value = dict["createdAt"] as? String {
                    self.createdAt = value
                }
                if let value = dict["description"] as? String {
                    self.description_ = value
                }
                if let value = dict["id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["ownerId"] as? Int64 {
                    self.ownerId = value
                }
                if let value = dict["path"] as? String {
                    self.path = value
                }
                if let value = dict["updatedAt"] as? String {
                    self.updatedAt = value
                }
                if let value = dict["visibilityLevel"] as? Int32 {
                    self.visibilityLevel = value
                }
            }
        }
        public var archived: Bool?

        public var avatarUrl: String?

        public var buildsEnabled: Bool?

        public var createdAt: String?

        public var creatorId: Int64?

        public var defaultBranch: String?

        public var description_: String?

        public var httpUrlToRepo: String?

        public var id: Int64?

        public var issuesEnabled: Bool?

        public var lastActivityAt: String?

        public var mergeRequestsEnabled: Bool?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespace: UpdateRepositoryResponseBody.Result.Namespace?

        public var path: String?

        public var pathWithNamespace: String?

        public var snippetsEnabled: Bool?

        public var sshUrlToRepo: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public var wikiEnabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.namespace?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archived != nil {
                map["archived"] = self.archived!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.buildsEnabled != nil {
                map["buildsEnabled"] = self.buildsEnabled!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.defaultBranch != nil {
                map["defaultBranch"] = self.defaultBranch!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.httpUrlToRepo != nil {
                map["httpUrlToRepo"] = self.httpUrlToRepo!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.issuesEnabled != nil {
                map["issuesEnabled"] = self.issuesEnabled!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.mergeRequestsEnabled != nil {
                map["mergeRequestsEnabled"] = self.mergeRequestsEnabled!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespace != nil {
                map["namespace"] = self.namespace?.toMap()
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.snippetsEnabled != nil {
                map["snippetsEnabled"] = self.snippetsEnabled!
            }
            if self.sshUrlToRepo != nil {
                map["sshUrlToRepo"] = self.sshUrlToRepo!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            if self.wikiEnabled != nil {
                map["wikiEnabled"] = self.wikiEnabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["archived"] as? Bool {
                self.archived = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["buildsEnabled"] as? Bool {
                self.buildsEnabled = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["creatorId"] as? Int64 {
                self.creatorId = value
            }
            if let value = dict["defaultBranch"] as? String {
                self.defaultBranch = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["httpUrlToRepo"] as? String {
                self.httpUrlToRepo = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["issuesEnabled"] as? Bool {
                self.issuesEnabled = value
            }
            if let value = dict["lastActivityAt"] as? String {
                self.lastActivityAt = value
            }
            if let value = dict["mergeRequestsEnabled"] as? Bool {
                self.mergeRequestsEnabled = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["nameWithNamespace"] as? String {
                self.nameWithNamespace = value
            }
            if let value = dict["namespace"] as? [String: Any?] {
                var model = UpdateRepositoryResponseBody.Result.Namespace()
                model.fromMap(value)
                self.namespace = model
            }
            if let value = dict["path"] as? String {
                self.path = value
            }
            if let value = dict["pathWithNamespace"] as? String {
                self.pathWithNamespace = value
            }
            if let value = dict["snippetsEnabled"] as? Bool {
                self.snippetsEnabled = value
            }
            if let value = dict["sshUrlToRepo"] as? String {
                self.sshUrlToRepo = value
            }
            if let value = dict["visibilityLevel"] as? Int32 {
                self.visibilityLevel = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
            if let value = dict["wikiEnabled"] as? Bool {
                self.wikiEnabled = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateRepositoryResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdateRepositoryResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRepositoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRepositoryMemberRequest : Tea.TeaModel {
    public class RelatedInfos : Tea.TeaModel {
        public var relatedId: String?

        public var sourceId: Int64?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.relatedId != nil {
                map["relatedId"] = self.relatedId!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["relatedId"] as? String {
                self.relatedId = value
            }
            if let value = dict["sourceId"] as? Int64 {
                self.sourceId = value
            }
            if let value = dict["sourceType"] as? String {
                self.sourceType = value
            }
        }
    }
    public var accessToken: String?

    public var accessLevel: Int32?

    public var expireAt: String?

    public var memberType: String?

    public var relatedId: String?

    public var relatedInfos: [UpdateRepositoryMemberRequest.RelatedInfos]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.accessLevel != nil {
            map["accessLevel"] = self.accessLevel!
        }
        if self.expireAt != nil {
            map["expireAt"] = self.expireAt!
        }
        if self.memberType != nil {
            map["memberType"] = self.memberType!
        }
        if self.relatedId != nil {
            map["relatedId"] = self.relatedId!
        }
        if self.relatedInfos != nil {
            var tmp : [Any] = []
            for k in self.relatedInfos! {
                tmp.append(k.toMap())
            }
            map["relatedInfos"] = tmp
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessToken"] as? String {
            self.accessToken = value
        }
        if let value = dict["accessLevel"] as? Int32 {
            self.accessLevel = value
        }
        if let value = dict["expireAt"] as? String {
            self.expireAt = value
        }
        if let value = dict["memberType"] as? String {
            self.memberType = value
        }
        if let value = dict["relatedId"] as? String {
            self.relatedId = value
        }
        if let value = dict["relatedInfos"] as? [Any?] {
            var tmp : [UpdateRepositoryMemberRequest.RelatedInfos] = []
            for v in value {
                if v != nil {
                    var model = UpdateRepositoryMemberRequest.RelatedInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.relatedInfos = tmp
        }
        if let value = dict["organizationId"] as? String {
            self.organizationId = value
        }
    }
}

public class UpdateRepositoryMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var expireAt: String?

        public var id: Int64?

        public var memberName: String?

        public var memberType: String?

        public var name: String?

        public var sourceId: Int64?

        public var sourceType: String?

        public var state: String?

        public var username: String?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.expireAt != nil {
                map["expireAt"] = self.expireAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.memberName != nil {
                map["memberName"] = self.memberName!
            }
            if self.memberType != nil {
                map["memberType"] = self.memberType!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["accessLevel"] as? Int32 {
                self.accessLevel = value
            }
            if let value = dict["avatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["email"] as? String {
                self.email = value
            }
            if let value = dict["expireAt"] as? String {
                self.expireAt = value
            }
            if let value = dict["id"] as? Int64 {
                self.id = value
            }
            if let value = dict["memberName"] as? String {
                self.memberName = value
            }
            if let value = dict["memberType"] as? String {
                self.memberType = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceId"] as? Int64 {
                self.sourceId = value
            }
            if let value = dict["sourceType"] as? String {
                self.sourceType = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["username"] as? String {
                self.username = value
            }
            if let value = dict["webUrl"] as? String {
                self.webUrl = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateRepositoryMemberResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["result"] as? [String: Any?] {
            var model = UpdateRepositoryMemberResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateRepositoryMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRepositoryMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRepositoryMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateResourceMemberRequest : Tea.TeaModel {
    public var roleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roleName != nil {
            map["roleName"] = self.roleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["roleName"] as? String {
            self.roleName = value
        }
    }
}

public class UpdateResourceMemberResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateResourceMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateResourceMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateResourceMemberResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTestCaseRequest : Tea.TeaModel {
    public class UpdateWorkitemPropertyRequest : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fieldIdentifier"] as? String {
                self.fieldIdentifier = value
            }
            if let value = dict["fieldValue"] as? String {
                self.fieldValue = value
            }
        }
    }
    public var updateWorkitemPropertyRequest: [UpdateTestCaseRequest.UpdateWorkitemPropertyRequest]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateWorkitemPropertyRequest != nil {
            var tmp : [Any] = []
            for k in self.updateWorkitemPropertyRequest! {
                tmp.append(k.toMap())
            }
            map["updateWorkitemPropertyRequest"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["updateWorkitemPropertyRequest"] as? [Any?] {
            var tmp : [UpdateTestCaseRequest.UpdateWorkitemPropertyRequest] = []
            for v in value {
                if v != nil {
                    var model = UpdateTestCaseRequest.UpdateWorkitemPropertyRequest()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.updateWorkitemPropertyRequest = tmp
        }
    }
}

public class UpdateTestCaseResponseBody : Tea.TeaModel {
    public class Testcase : Tea.TeaModel {
        public class AssignedTo : Tea.TeaModel {
            public var assignIdentifier: String?

            public var name: String?

            public var tbRoleId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assignIdentifier != nil {
                    map["assignIdentifier"] = self.assignIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.tbRoleId != nil {
                    map["tbRoleId"] = self.tbRoleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["assignIdentifier"] as? String {
                    self.assignIdentifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["tbRoleId"] as? String {
                    self.tbRoleId = value
                }
            }
        }
        public class Creator : Tea.TeaModel {
            public var createIdentifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createIdentifier != nil {
                    map["createIdentifier"] = self.createIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["createIdentifier"] as? String {
                    self.createIdentifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public class DetailInfo : Tea.TeaModel {
            public class ExpectedResult : Tea.TeaModel {
                public var expectContent: String?

                public var expectContentType: String?

                public var expectIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expectContent != nil {
                        map["expectContent"] = self.expectContent!
                    }
                    if self.expectContentType != nil {
                        map["expectContentType"] = self.expectContentType!
                    }
                    if self.expectIdentifier != nil {
                        map["expectIdentifier"] = self.expectIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["expectContent"] as? String {
                        self.expectContent = value
                    }
                    if let value = dict["expectContentType"] as? String {
                        self.expectContentType = value
                    }
                    if let value = dict["expectIdentifier"] as? String {
                        self.expectIdentifier = value
                    }
                }
            }
            public class Precondition : Tea.TeaModel {
                public var preContent: String?

                public var preContentType: String?

                public var preIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.preContent != nil {
                        map["preContent"] = self.preContent!
                    }
                    if self.preContentType != nil {
                        map["preContentType"] = self.preContentType!
                    }
                    if self.preIdentifier != nil {
                        map["preIdentifier"] = self.preIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["preContent"] as? String {
                        self.preContent = value
                    }
                    if let value = dict["preContentType"] as? String {
                        self.preContentType = value
                    }
                    if let value = dict["preIdentifier"] as? String {
                        self.preIdentifier = value
                    }
                }
            }
            public class StepContent : Tea.TeaModel {
                public var stepContent: String?

                public var stepContentType: String?

                public var stepIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.stepContent != nil {
                        map["stepContent"] = self.stepContent!
                    }
                    if self.stepContentType != nil {
                        map["stepContentType"] = self.stepContentType!
                    }
                    if self.stepIdentifier != nil {
                        map["stepIdentifier"] = self.stepIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["stepContent"] as? String {
                        self.stepContent = value
                    }
                    if let value = dict["stepContentType"] as? String {
                        self.stepContentType = value
                    }
                    if let value = dict["stepIdentifier"] as? String {
                        self.stepIdentifier = value
                    }
                }
            }
            public var expectedResult: UpdateTestCaseResponseBody.Testcase.DetailInfo.ExpectedResult?

            public var precondition: UpdateTestCaseResponseBody.Testcase.DetailInfo.Precondition?

            public var stepContent: UpdateTestCaseResponseBody.Testcase.DetailInfo.StepContent?

            public var stepType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.expectedResult?.validate()
                try self.precondition?.validate()
                try self.stepContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expectedResult != nil {
                    map["expectedResult"] = self.expectedResult?.toMap()
                }
                if self.precondition != nil {
                    map["precondition"] = self.precondition?.toMap()
                }
                if self.stepContent != nil {
                    map["stepContent"] = self.stepContent?.toMap()
                }
                if self.stepType != nil {
                    map["stepType"] = self.stepType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["expectedResult"] as? [String: Any?] {
                    var model = UpdateTestCaseResponseBody.Testcase.DetailInfo.ExpectedResult()
                    model.fromMap(value)
                    self.expectedResult = model
                }
                if let value = dict["precondition"] as? [String: Any?] {
                    var model = UpdateTestCaseResponseBody.Testcase.DetailInfo.Precondition()
                    model.fromMap(value)
                    self.precondition = model
                }
                if let value = dict["stepContent"] as? [String: Any?] {
                    var model = UpdateTestCaseResponseBody.Testcase.DetailInfo.StepContent()
                    model.fromMap(value)
                    self.stepContent = model
                }
                if let value = dict["stepType"] as? String {
                    self.stepType = value
                }
            }
        }
        public class Directory : Tea.TeaModel {
            public var childIdentifier: String?

            public var directoryIdentifier: String?

            public var name: String?

            public var pathName: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.childIdentifier != nil {
                    map["childIdentifier"] = self.childIdentifier!
                }
                if self.directoryIdentifier != nil {
                    map["directoryIdentifier"] = self.directoryIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.pathName != nil {
                    map["pathName"] = self.pathName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["childIdentifier"] as? String {
                    self.childIdentifier = value
                }
                if let value = dict["directoryIdentifier"] as? String {
                    self.directoryIdentifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["pathName"] as? [String] {
                    self.pathName = value
                }
            }
        }
        public class Modifier : Tea.TeaModel {
            public var modifyIdentifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.modifyIdentifier != nil {
                    map["modifyIdentifier"] = self.modifyIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["modifyIdentifier"] as? String {
                    self.modifyIdentifier = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
            }
        }
        public var assignedTo: UpdateTestCaseResponseBody.Testcase.AssignedTo?

        public var categoryIdentifier: String?

        public var creator: UpdateTestCaseResponseBody.Testcase.Creator?

        public var detailInfo: UpdateTestCaseResponseBody.Testcase.DetailInfo?

        public var directory: UpdateTestCaseResponseBody.Testcase.Directory?

        public var identifier: String?

        public var modifier: UpdateTestCaseResponseBody.Testcase.Modifier?

        public var spaceIdentifier: String?

        public var spaceType: String?

        public var subject: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.assignedTo?.validate()
            try self.creator?.validate()
            try self.detailInfo?.validate()
            try self.directory?.validate()
            try self.modifier?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo?.toMap()
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator?.toMap()
            }
            if self.detailInfo != nil {
                map["detailInfo"] = self.detailInfo?.toMap()
            }
            if self.directory != nil {
                map["directory"] = self.directory?.toMap()
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier?.toMap()
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedTo"] as? [String: Any?] {
                var model = UpdateTestCaseResponseBody.Testcase.AssignedTo()
                model.fromMap(value)
                self.assignedTo = model
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? [String: Any?] {
                var model = UpdateTestCaseResponseBody.Testcase.Creator()
                model.fromMap(value)
                self.creator = model
            }
            if let value = dict["detailInfo"] as? [String: Any?] {
                var model = UpdateTestCaseResponseBody.Testcase.DetailInfo()
                model.fromMap(value)
                self.detailInfo = model
            }
            if let value = dict["directory"] as? [String: Any?] {
                var model = UpdateTestCaseResponseBody.Testcase.Directory()
                model.fromMap(value)
                self.directory = model
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["modifier"] as? [String: Any?] {
                var model = UpdateTestCaseResponseBody.Testcase.Modifier()
                model.fromMap(value)
                self.modifier = model
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["spaceType"] as? String {
                self.spaceType = value
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
        }
    }
    public var testcase: UpdateTestCaseResponseBody.Testcase?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.testcase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.testcase != nil {
            map["Testcase"] = self.testcase?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Testcase"] as? [String: Any?] {
            var model = UpdateTestCaseResponseBody.Testcase()
            model.fromMap(value)
            self.testcase = model
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateTestCaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTestCaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTestCaseResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTestResultRequest : Tea.TeaModel {
    public var executor: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executor != nil {
            map["executor"] = self.executor!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["executor"] as? String {
            self.executor = value
        }
        if let value = dict["status"] as? String {
            self.status = value
        }
    }
}

public class UpdateTestResultResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateTestResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTestResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTestResultResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateVariableGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var variables: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.variables != nil {
            map["variables"] = self.variables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["variables"] as? String {
            self.variables = value
        }
    }
}

public class UpdateVariableGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateVariableGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVariableGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateVariableGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWorkItemRequest : Tea.TeaModel {
    public var fieldType: String?

    public var identifier: String?

    public var propertyKey: String?

    public var propertyValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fieldType != nil {
            map["fieldType"] = self.fieldType!
        }
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        if self.propertyKey != nil {
            map["propertyKey"] = self.propertyKey!
        }
        if self.propertyValue != nil {
            map["propertyValue"] = self.propertyValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["fieldType"] as? String {
            self.fieldType = value
        }
        if let value = dict["identifier"] as? String {
            self.identifier = value
        }
        if let value = dict["propertyKey"] as? String {
            self.propertyKey = value
        }
        if let value = dict["propertyValue"] as? String {
            self.propertyValue = value
        }
    }
}

public class UpdateWorkItemResponseBody : Tea.TeaModel {
    public class Workitem : Tea.TeaModel {
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var document: String?

        public var documentFormat: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var parentIdentifier: String?

        public var serialNumber: String?

        public var spaceIdentifier: String?

        public var spaceName: String?

        public var spaceType: String?

        public var sprintIdentifier: String?

        public var status: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subject: String?

        public var updateStatusAt: Int64?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.document != nil {
                map["document"] = self.document!
            }
            if self.documentFormat != nil {
                map["documentFormat"] = self.documentFormat!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceName != nil {
                map["spaceName"] = self.spaceName!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.sprintIdentifier != nil {
                map["sprintIdentifier"] = self.sprintIdentifier!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.updateStatusAt != nil {
                map["updateStatusAt"] = self.updateStatusAt!
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedTo"] as? String {
                self.assignedTo = value
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["document"] as? String {
                self.document = value
            }
            if let value = dict["documentFormat"] as? String {
                self.documentFormat = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["logicalStatus"] as? String {
                self.logicalStatus = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["parentIdentifier"] as? String {
                self.parentIdentifier = value
            }
            if let value = dict["serialNumber"] as? String {
                self.serialNumber = value
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["spaceName"] as? String {
                self.spaceName = value
            }
            if let value = dict["spaceType"] as? String {
                self.spaceType = value
            }
            if let value = dict["sprintIdentifier"] as? String {
                self.sprintIdentifier = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["statusIdentifier"] as? String {
                self.statusIdentifier = value
            }
            if let value = dict["statusStageIdentifier"] as? String {
                self.statusStageIdentifier = value
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
            if let value = dict["updateStatusAt"] as? Int64 {
                self.updateStatusAt = value
            }
            if let value = dict["workitemTypeIdentifier"] as? String {
                self.workitemTypeIdentifier = value
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workitem: UpdateWorkItemResponseBody.Workitem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitem != nil {
            map["workitem"] = self.workitem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["workitem"] as? [String: Any?] {
            var model = UpdateWorkItemResponseBody.Workitem()
            model.fromMap(value)
            self.workitem = model
        }
    }
}

public class UpdateWorkItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateWorkItemResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWorkitemCommentRequest : Tea.TeaModel {
    public var commentId: Int64?

    public var content: String?

    public var formatType: String?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commentId != nil {
            map["commentId"] = self.commentId!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.formatType != nil {
            map["formatType"] = self.formatType!
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["commentId"] as? Int64 {
            self.commentId = value
        }
        if let value = dict["content"] as? String {
            self.content = value
        }
        if let value = dict["formatType"] as? String {
            self.formatType = value
        }
        if let value = dict["workitemIdentifier"] as? String {
            self.workitemIdentifier = value
        }
    }
}

public class UpdateWorkitemCommentResponseBody : Tea.TeaModel {
    public class Comment : Tea.TeaModel {
        public class User : Tea.TeaModel {
            public var account: String?

            public var avatar: String?

            public var displayName: String?

            public var identifier: String?

            public var nickName: String?

            public var realName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["account"] = self.account!
                }
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.nickName != nil {
                    map["nickName"] = self.nickName!
                }
                if self.realName != nil {
                    map["realName"] = self.realName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["account"] as? String {
                    self.account = value
                }
                if let value = dict["avatar"] as? String {
                    self.avatar = value
                }
                if let value = dict["displayName"] as? String {
                    self.displayName = value
                }
                if let value = dict["identifier"] as? String {
                    self.identifier = value
                }
                if let value = dict["nickName"] as? String {
                    self.nickName = value
                }
                if let value = dict["realName"] as? String {
                    self.realName = value
                }
            }
        }
        public var content: String?

        public var createTime: Int64?

        public var formatType: String?

        public var id: String?

        public var isTop: Bool?

        public var modifiedTime: Int64?

        public var parentId: Int64?

        public var targetIdentifier: String?

        public var targetType: String?

        public var topTime: Int64?

        public var user: UpdateWorkitemCommentResponseBody.Comment.User?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.user?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.formatType != nil {
                map["formatType"] = self.formatType!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isTop != nil {
                map["isTop"] = self.isTop!
            }
            if self.modifiedTime != nil {
                map["modifiedTime"] = self.modifiedTime!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.targetIdentifier != nil {
                map["targetIdentifier"] = self.targetIdentifier!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.topTime != nil {
                map["topTime"] = self.topTime!
            }
            if self.user != nil {
                map["user"] = self.user?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["formatType"] as? String {
                self.formatType = value
            }
            if let value = dict["id"] as? String {
                self.id = value
            }
            if let value = dict["isTop"] as? Bool {
                self.isTop = value
            }
            if let value = dict["modifiedTime"] as? Int64 {
                self.modifiedTime = value
            }
            if let value = dict["parentId"] as? Int64 {
                self.parentId = value
            }
            if let value = dict["targetIdentifier"] as? String {
                self.targetIdentifier = value
            }
            if let value = dict["targetType"] as? String {
                self.targetType = value
            }
            if let value = dict["topTime"] as? Int64 {
                self.topTime = value
            }
            if let value = dict["user"] as? [String: Any?] {
                var model = UpdateWorkitemCommentResponseBody.Comment.User()
                model.fromMap(value)
                self.user = model
            }
        }
    }
    public var comment: UpdateWorkitemCommentResponseBody.Comment?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.comment?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["comment"] = self.comment?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["comment"] as? [String: Any?] {
            var model = UpdateWorkitemCommentResponseBody.Comment()
            model.fromMap(value)
            self.comment = model
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
    }
}

public class UpdateWorkitemCommentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkitemCommentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateWorkitemCommentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWorkitemFieldRequest : Tea.TeaModel {
    public class UpdateWorkitemPropertyRequest : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fieldIdentifier"] as? String {
                self.fieldIdentifier = value
            }
            if let value = dict["fieldValue"] as? String {
                self.fieldValue = value
            }
        }
    }
    public var updateWorkitemPropertyRequest: [UpdateWorkitemFieldRequest.UpdateWorkitemPropertyRequest]?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateWorkitemPropertyRequest != nil {
            var tmp : [Any] = []
            for k in self.updateWorkitemPropertyRequest! {
                tmp.append(k.toMap())
            }
            map["updateWorkitemPropertyRequest"] = tmp
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["updateWorkitemPropertyRequest"] as? [Any?] {
            var tmp : [UpdateWorkitemFieldRequest.UpdateWorkitemPropertyRequest] = []
            for v in value {
                if v != nil {
                    var model = UpdateWorkitemFieldRequest.UpdateWorkitemPropertyRequest()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.updateWorkitemPropertyRequest = tmp
        }
        if let value = dict["workitemIdentifier"] as? String {
            self.workitemIdentifier = value
        }
    }
}

public class UpdateWorkitemFieldResponseBody : Tea.TeaModel {
    public class Workitem : Tea.TeaModel {
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var document: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var parentIdentifier: String?

        public var serialNumber: String?

        public var spaceIdentifier: String?

        public var spaceName: String?

        public var spaceType: String?

        public var sprintIdentifier: String?

        public var status: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subject: String?

        public var updateStatusAt: Int64?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.document != nil {
                map["document"] = self.document!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceName != nil {
                map["spaceName"] = self.spaceName!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.sprintIdentifier != nil {
                map["sprintIdentifier"] = self.sprintIdentifier!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.updateStatusAt != nil {
                map["updateStatusAt"] = self.updateStatusAt!
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["assignedTo"] as? String {
                self.assignedTo = value
            }
            if let value = dict["categoryIdentifier"] as? String {
                self.categoryIdentifier = value
            }
            if let value = dict["creator"] as? String {
                self.creator = value
            }
            if let value = dict["document"] as? String {
                self.document = value
            }
            if let value = dict["gmtCreate"] as? Int64 {
                self.gmtCreate = value
            }
            if let value = dict["gmtModified"] as? Int64 {
                self.gmtModified = value
            }
            if let value = dict["identifier"] as? String {
                self.identifier = value
            }
            if let value = dict["logicalStatus"] as? String {
                self.logicalStatus = value
            }
            if let value = dict["modifier"] as? String {
                self.modifier = value
            }
            if let value = dict["parentIdentifier"] as? String {
                self.parentIdentifier = value
            }
            if let value = dict["serialNumber"] as? String {
                self.serialNumber = value
            }
            if let value = dict["spaceIdentifier"] as? String {
                self.spaceIdentifier = value
            }
            if let value = dict["spaceName"] as? String {
                self.spaceName = value
            }
            if let value = dict["spaceType"] as? String {
                self.spaceType = value
            }
            if let value = dict["sprintIdentifier"] as? String {
                self.sprintIdentifier = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["statusIdentifier"] as? String {
                self.statusIdentifier = value
            }
            if let value = dict["statusStageIdentifier"] as? String {
                self.statusStageIdentifier = value
            }
            if let value = dict["subject"] as? String {
                self.subject = value
            }
            if let value = dict["updateStatusAt"] as? Int64 {
                self.updateStatusAt = value
            }
            if let value = dict["workitemTypeIdentifier"] as? String {
                self.workitemTypeIdentifier = value
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var workitem: UpdateWorkitemFieldResponseBody.Workitem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitem != nil {
            map["workitem"] = self.workitem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMsg"] as? String {
            self.errorMsg = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
        if let value = dict["workitem"] as? [String: Any?] {
            var model = UpdateWorkitemFieldResponseBody.Workitem()
            model.fromMap(value)
            self.workitem = model
        }
    }
}

public class UpdateWorkitemFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkitemFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateWorkitemFieldResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class WorkitemAttachmentCreateRequest : Tea.TeaModel {
    public var fileKey: String?

    public var originalFilename: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileKey != nil {
            map["fileKey"] = self.fileKey!
        }
        if self.originalFilename != nil {
            map["originalFilename"] = self.originalFilename!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["fileKey"] as? String {
            self.fileKey = value
        }
        if let value = dict["originalFilename"] as? String {
            self.originalFilename = value
        }
    }
}

public class WorkitemAttachmentCreateResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? String {
            self.success = value
        }
    }
}

public class WorkitemAttachmentCreateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WorkitemAttachmentCreateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WorkitemAttachmentCreateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
