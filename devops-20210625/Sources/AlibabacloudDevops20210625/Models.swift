import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddGroupMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var accessLevel: Int32?

    public var aliyunPks: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.accessLevel != nil {
            map["accessLevel"] = self.accessLevel!
        }
        if self.aliyunPks != nil {
            map["aliyunPks"] = self.aliyunPks!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("accessLevel") {
            self.accessLevel = dict["accessLevel"] as! Int32
        }
        if dict.keys.contains("aliyunPks") {
            self.aliyunPks = dict["aliyunPks"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class AddGroupMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var name: String?

        public var sourceId: Int64?

        public var state: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceId") {
                self.sourceId = dict["sourceId"] as! Int64
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("username") {
                self.username = dict["username"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [AddGroupMemberResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [AddGroupMemberResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = AddGroupMemberResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class AddGroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddGroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddGroupMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPipelineRelationsRequest : Tea.TeaModel {
    public var relObjectIds: String?

    public var relObjectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relObjectIds != nil {
            map["relObjectIds"] = self.relObjectIds!
        }
        if self.relObjectType != nil {
            map["relObjectType"] = self.relObjectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("relObjectIds") {
            self.relObjectIds = dict["relObjectIds"] as! String
        }
        if dict.keys.contains("relObjectType") {
            self.relObjectType = dict["relObjectType"] as! String
        }
    }
}

public class AddPipelineRelationsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class AddPipelineRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPipelineRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPipelineRelationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddRepositoryMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var accessLevel: Int32?

    public var aliyunPks: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.accessLevel != nil {
            map["accessLevel"] = self.accessLevel!
        }
        if self.aliyunPks != nil {
            map["aliyunPks"] = self.aliyunPks!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("accessLevel") {
            self.accessLevel = dict["accessLevel"] as! Int32
        }
        if dict.keys.contains("aliyunPks") {
            self.aliyunPks = dict["aliyunPks"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class AddRepositoryMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [AddRepositoryMemberResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [AddRepositoryMemberResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = AddRepositoryMemberResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class AddRepositoryMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRepositoryMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddRepositoryMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWebhookRequest : Tea.TeaModel {
    public var accessToken: String?

    public var description_: String?

    public var enableSslVerification: Bool?

    public var mergeRequestsEvents: Bool?

    public var noteEvents: Bool?

    public var pushEvents: Bool?

    public var secretToken: String?

    public var tagPushEvents: Bool?

    public var url: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.enableSslVerification != nil {
            map["enableSslVerification"] = self.enableSslVerification!
        }
        if self.mergeRequestsEvents != nil {
            map["mergeRequestsEvents"] = self.mergeRequestsEvents!
        }
        if self.noteEvents != nil {
            map["noteEvents"] = self.noteEvents!
        }
        if self.pushEvents != nil {
            map["pushEvents"] = self.pushEvents!
        }
        if self.secretToken != nil {
            map["secretToken"] = self.secretToken!
        }
        if self.tagPushEvents != nil {
            map["tagPushEvents"] = self.tagPushEvents!
        }
        if self.url != nil {
            map["url"] = self.url!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("enableSslVerification") {
            self.enableSslVerification = dict["enableSslVerification"] as! Bool
        }
        if dict.keys.contains("mergeRequestsEvents") {
            self.mergeRequestsEvents = dict["mergeRequestsEvents"] as! Bool
        }
        if dict.keys.contains("noteEvents") {
            self.noteEvents = dict["noteEvents"] as! Bool
        }
        if dict.keys.contains("pushEvents") {
            self.pushEvents = dict["pushEvents"] as! Bool
        }
        if dict.keys.contains("secretToken") {
            self.secretToken = dict["secretToken"] as! String
        }
        if dict.keys.contains("tagPushEvents") {
            self.tagPushEvents = dict["tagPushEvents"] as! Bool
        }
        if dict.keys.contains("url") {
            self.url = dict["url"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class AddWebhookResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var description_: String?

        public var enableSslVerification: Bool?

        public var id: Int64?

        public var lastTestResult: String?

        public var mergeRequestsEvents: Bool?

        public var noteEvents: Bool?

        public var pushEvents: Bool?

        public var repositoryId: Int64?

        public var secretToken: String?

        public var tagPushEvents: Bool?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.enableSslVerification != nil {
                map["enableSslVerification"] = self.enableSslVerification!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastTestResult != nil {
                map["lastTestResult"] = self.lastTestResult!
            }
            if self.mergeRequestsEvents != nil {
                map["mergeRequestsEvents"] = self.mergeRequestsEvents!
            }
            if self.noteEvents != nil {
                map["noteEvents"] = self.noteEvents!
            }
            if self.pushEvents != nil {
                map["pushEvents"] = self.pushEvents!
            }
            if self.repositoryId != nil {
                map["repositoryId"] = self.repositoryId!
            }
            if self.secretToken != nil {
                map["secretToken"] = self.secretToken!
            }
            if self.tagPushEvents != nil {
                map["tagPushEvents"] = self.tagPushEvents!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("enableSslVerification") {
                self.enableSslVerification = dict["enableSslVerification"] as! Bool
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("lastTestResult") {
                self.lastTestResult = dict["lastTestResult"] as! String
            }
            if dict.keys.contains("mergeRequestsEvents") {
                self.mergeRequestsEvents = dict["mergeRequestsEvents"] as! Bool
            }
            if dict.keys.contains("noteEvents") {
                self.noteEvents = dict["noteEvents"] as! Bool
            }
            if dict.keys.contains("pushEvents") {
                self.pushEvents = dict["pushEvents"] as! Bool
            }
            if dict.keys.contains("repositoryId") {
                self.repositoryId = dict["repositoryId"] as! Int64
            }
            if dict.keys.contains("secretToken") {
                self.secretToken = dict["secretToken"] as! String
            }
            if dict.keys.contains("tagPushEvents") {
                self.tagPushEvents = dict["tagPushEvents"] as! Bool
            }
            if dict.keys.contains("url") {
                self.url = dict["url"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: AddWebhookResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = AddWebhookResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class AddWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddWebhookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloseMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CloseMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CloseMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CloseMergeRequestResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CloseMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloseMergeRequestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAppMembersRequest : Tea.TeaModel {
    public class PlayerList : Tea.TeaModel {
        public var id: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var playerList: [CreateAppMembersRequest.PlayerList]?

    public var roleNames: [String]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.playerList != nil {
            var tmp : [Any] = []
            for k in self.playerList! {
                tmp.append(k.toMap())
            }
            map["playerList"] = tmp
        }
        if self.roleNames != nil {
            map["roleNames"] = self.roleNames!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("playerList") {
            var tmp : [CreateAppMembersRequest.PlayerList] = []
            for v in dict["playerList"] as! [Any] {
                var model = CreateAppMembersRequest.PlayerList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.playerList = tmp
        }
        if dict.keys.contains("roleNames") {
            self.roleNames = dict["roleNames"] as! [String]
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CreateAppMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class CreateBranchRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var ref: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.ref != nil {
            map["ref"] = self.ref!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("branchName") {
            self.branchName = dict["branchName"] as! String
        }
        if dict.keys.contains("ref") {
            self.ref = dict["ref"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CreateBranchResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var committedDate: String?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("authorEmail") {
                    self.authorEmail = dict["authorEmail"] as! String
                }
                if dict.keys.contains("authorName") {
                    self.authorName = dict["authorName"] as! String
                }
                if dict.keys.contains("authoredDate") {
                    self.authoredDate = dict["authoredDate"] as! String
                }
                if dict.keys.contains("committedDate") {
                    self.committedDate = dict["committedDate"] as! String
                }
                if dict.keys.contains("committerEmail") {
                    self.committerEmail = dict["committerEmail"] as! String
                }
                if dict.keys.contains("committerName") {
                    self.committerName = dict["committerName"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("parentIds") {
                    self.parentIds = dict["parentIds"] as! [String]
                }
                if dict.keys.contains("shortId") {
                    self.shortId = dict["shortId"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public var commit: CreateBranchResponseBody.Result.Commit?

        public var name: String?

        public var protected: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.protected != nil {
                map["protected"] = self.protected!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("commit") {
                var model = CreateBranchResponseBody.Result.Commit()
                model.fromMap(dict["commit"] as! [String: Any])
                self.commit = model
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("protected") {
                self.protected = dict["protected"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateBranchResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateBranchResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateBranchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBranchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBranchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateChangeRequestRequest : Tea.TeaModel {
    public var appCodeRepoSn: String?

    public var autoDeleteBranchWhenEnd: Bool?

    public var branchName: String?

    public var createBranch: Bool?

    public var ownerAccountId: String?

    public var ownerId: String?

    public var title: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCodeRepoSn != nil {
            map["appCodeRepoSn"] = self.appCodeRepoSn!
        }
        if self.autoDeleteBranchWhenEnd != nil {
            map["autoDeleteBranchWhenEnd"] = self.autoDeleteBranchWhenEnd!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.createBranch != nil {
            map["createBranch"] = self.createBranch!
        }
        if self.ownerAccountId != nil {
            map["ownerAccountId"] = self.ownerAccountId!
        }
        if self.ownerId != nil {
            map["ownerId"] = self.ownerId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("appCodeRepoSn") {
            self.appCodeRepoSn = dict["appCodeRepoSn"] as! String
        }
        if dict.keys.contains("autoDeleteBranchWhenEnd") {
            self.autoDeleteBranchWhenEnd = dict["autoDeleteBranchWhenEnd"] as! Bool
        }
        if dict.keys.contains("branchName") {
            self.branchName = dict["branchName"] as! String
        }
        if dict.keys.contains("createBranch") {
            self.createBranch = dict["createBranch"] as! Bool
        }
        if dict.keys.contains("ownerAccountId") {
            self.ownerAccountId = dict["ownerAccountId"] as! String
        }
        if dict.keys.contains("ownerId") {
            self.ownerId = dict["ownerId"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CreateChangeRequestResponseBody : Tea.TeaModel {
    public var appCodeRepoSn: String?

    public var appName: String?

    public var autoDeleteBranchWhenEnd: Bool?

    public var branch: String?

    public var creatorAccountId: String?

    public var creatorId: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var name: String?

    public var originBranch: String?

    public var originBranchRevisionSha: String?

    public var ownerAccountId: String?

    public var ownerId: String?

    public var sn: String?

    public var state: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCodeRepoSn != nil {
            map["appCodeRepoSn"] = self.appCodeRepoSn!
        }
        if self.appName != nil {
            map["appName"] = self.appName!
        }
        if self.autoDeleteBranchWhenEnd != nil {
            map["autoDeleteBranchWhenEnd"] = self.autoDeleteBranchWhenEnd!
        }
        if self.branch != nil {
            map["branch"] = self.branch!
        }
        if self.creatorAccountId != nil {
            map["creatorAccountId"] = self.creatorAccountId!
        }
        if self.creatorId != nil {
            map["creatorId"] = self.creatorId!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["gmtModified"] = self.gmtModified!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.originBranch != nil {
            map["originBranch"] = self.originBranch!
        }
        if self.originBranchRevisionSha != nil {
            map["originBranchRevisionSha"] = self.originBranchRevisionSha!
        }
        if self.ownerAccountId != nil {
            map["ownerAccountId"] = self.ownerAccountId!
        }
        if self.ownerId != nil {
            map["ownerId"] = self.ownerId!
        }
        if self.sn != nil {
            map["sn"] = self.sn!
        }
        if self.state != nil {
            map["state"] = self.state!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("appCodeRepoSn") {
            self.appCodeRepoSn = dict["appCodeRepoSn"] as! String
        }
        if dict.keys.contains("appName") {
            self.appName = dict["appName"] as! String
        }
        if dict.keys.contains("autoDeleteBranchWhenEnd") {
            self.autoDeleteBranchWhenEnd = dict["autoDeleteBranchWhenEnd"] as! Bool
        }
        if dict.keys.contains("branch") {
            self.branch = dict["branch"] as! String
        }
        if dict.keys.contains("creatorAccountId") {
            self.creatorAccountId = dict["creatorAccountId"] as! String
        }
        if dict.keys.contains("creatorId") {
            self.creatorId = dict["creatorId"] as! String
        }
        if dict.keys.contains("gmtCreate") {
            self.gmtCreate = dict["gmtCreate"] as! String
        }
        if dict.keys.contains("gmtModified") {
            self.gmtModified = dict["gmtModified"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("originBranch") {
            self.originBranch = dict["originBranch"] as! String
        }
        if dict.keys.contains("originBranchRevisionSha") {
            self.originBranchRevisionSha = dict["originBranchRevisionSha"] as! String
        }
        if dict.keys.contains("ownerAccountId") {
            self.ownerAccountId = dict["ownerAccountId"] as! String
        }
        if dict.keys.contains("ownerId") {
            self.ownerId = dict["ownerId"] as! String
        }
        if dict.keys.contains("sn") {
            self.sn = dict["sn"] as! String
        }
        if dict.keys.contains("state") {
            self.state = dict["state"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class CreateChangeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateChangeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateChangeRequestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCheckRunRequest : Tea.TeaModel {
    public class Annotations : Tea.TeaModel {
        public var annotationLevel: String?

        public var endColumn: Int64?

        public var endLine: Int64?

        public var message: String?

        public var path: String?

        public var rawDetails: String?

        public var startColumn: Int64?

        public var startLine: Int64?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotationLevel != nil {
                map["annotationLevel"] = self.annotationLevel!
            }
            if self.endColumn != nil {
                map["endColumn"] = self.endColumn!
            }
            if self.endLine != nil {
                map["endLine"] = self.endLine!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.rawDetails != nil {
                map["rawDetails"] = self.rawDetails!
            }
            if self.startColumn != nil {
                map["startColumn"] = self.startColumn!
            }
            if self.startLine != nil {
                map["startLine"] = self.startLine!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("annotationLevel") {
                self.annotationLevel = dict["annotationLevel"] as! String
            }
            if dict.keys.contains("endColumn") {
                self.endColumn = dict["endColumn"] as! Int64
            }
            if dict.keys.contains("endLine") {
                self.endLine = dict["endLine"] as! Int64
            }
            if dict.keys.contains("message") {
                self.message = dict["message"] as! String
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("rawDetails") {
                self.rawDetails = dict["rawDetails"] as! String
            }
            if dict.keys.contains("startColumn") {
                self.startColumn = dict["startColumn"] as! Int64
            }
            if dict.keys.contains("startLine") {
                self.startLine = dict["startLine"] as! Int64
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public class Images : Tea.TeaModel {
            public var alt: String?

            public var caption: String?

            public var imageUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alt != nil {
                    map["alt"] = self.alt!
                }
                if self.caption != nil {
                    map["caption"] = self.caption!
                }
                if self.imageUrl != nil {
                    map["imageUrl"] = self.imageUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("alt") {
                    self.alt = dict["alt"] as! String
                }
                if dict.keys.contains("caption") {
                    self.caption = dict["caption"] as! String
                }
                if dict.keys.contains("imageUrl") {
                    self.imageUrl = dict["imageUrl"] as! String
                }
            }
        }
        public var images: [CreateCheckRunRequest.Output.Images]?

        public var summary: String?

        public var text: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.images != nil {
                var tmp : [Any] = []
                for k in self.images! {
                    tmp.append(k.toMap())
                }
                map["images"] = tmp
            }
            if self.summary != nil {
                map["summary"] = self.summary!
            }
            if self.text != nil {
                map["text"] = self.text!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("images") {
                var tmp : [CreateCheckRunRequest.Output.Images] = []
                for v in dict["images"] as! [Any] {
                    var model = CreateCheckRunRequest.Output.Images()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.images = tmp
            }
            if dict.keys.contains("summary") {
                self.summary = dict["summary"] as! String
            }
            if dict.keys.contains("text") {
                self.text = dict["text"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var accessToken: String?

    public var annotations: [CreateCheckRunRequest.Annotations]?

    public var completedAt: String?

    public var conclusion: String?

    public var detailsUrl: String?

    public var externalId: String?

    public var headSha: String?

    public var name: String?

    public var output: CreateCheckRunRequest.Output?

    public var startedAt: String?

    public var status: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.output?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.annotations != nil {
            var tmp : [Any] = []
            for k in self.annotations! {
                tmp.append(k.toMap())
            }
            map["annotations"] = tmp
        }
        if self.completedAt != nil {
            map["completedAt"] = self.completedAt!
        }
        if self.conclusion != nil {
            map["conclusion"] = self.conclusion!
        }
        if self.detailsUrl != nil {
            map["detailsUrl"] = self.detailsUrl!
        }
        if self.externalId != nil {
            map["externalId"] = self.externalId!
        }
        if self.headSha != nil {
            map["headSha"] = self.headSha!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.output != nil {
            map["output"] = self.output?.toMap()
        }
        if self.startedAt != nil {
            map["startedAt"] = self.startedAt!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("annotations") {
            var tmp : [CreateCheckRunRequest.Annotations] = []
            for v in dict["annotations"] as! [Any] {
                var model = CreateCheckRunRequest.Annotations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.annotations = tmp
        }
        if dict.keys.contains("completedAt") {
            self.completedAt = dict["completedAt"] as! String
        }
        if dict.keys.contains("conclusion") {
            self.conclusion = dict["conclusion"] as! String
        }
        if dict.keys.contains("detailsUrl") {
            self.detailsUrl = dict["detailsUrl"] as! String
        }
        if dict.keys.contains("externalId") {
            self.externalId = dict["externalId"] as! String
        }
        if dict.keys.contains("headSha") {
            self.headSha = dict["headSha"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("output") {
            var model = CreateCheckRunRequest.Output()
            model.fromMap(dict["output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("startedAt") {
            self.startedAt = dict["startedAt"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class CreateCheckRunResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var annotationLevel: String?

            public var endColumn: Int64?

            public var endLine: Int64?

            public var id: Int64?

            public var message: String?

            public var path: String?

            public var rawDetails: String?

            public var startColumn: Int64?

            public var startLine: Int64?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotationLevel != nil {
                    map["annotationLevel"] = self.annotationLevel!
                }
                if self.endColumn != nil {
                    map["endColumn"] = self.endColumn!
                }
                if self.endLine != nil {
                    map["endLine"] = self.endLine!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.rawDetails != nil {
                    map["rawDetails"] = self.rawDetails!
                }
                if self.startColumn != nil {
                    map["startColumn"] = self.startColumn!
                }
                if self.startLine != nil {
                    map["startLine"] = self.startLine!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("annotationLevel") {
                    self.annotationLevel = dict["annotationLevel"] as! String
                }
                if dict.keys.contains("endColumn") {
                    self.endColumn = dict["endColumn"] as! Int64
                }
                if dict.keys.contains("endLine") {
                    self.endLine = dict["endLine"] as! Int64
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("rawDetails") {
                    self.rawDetails = dict["rawDetails"] as! String
                }
                if dict.keys.contains("startColumn") {
                    self.startColumn = dict["startColumn"] as! Int64
                }
                if dict.keys.contains("startLine") {
                    self.startLine = dict["startLine"] as! Int64
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class CheckSuite : Tea.TeaModel {
            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class Images : Tea.TeaModel {
                public var alt: String?

                public var caption: String?

                public var imageUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alt != nil {
                        map["alt"] = self.alt!
                    }
                    if self.caption != nil {
                        map["caption"] = self.caption!
                    }
                    if self.imageUrl != nil {
                        map["imageUrl"] = self.imageUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("alt") {
                        self.alt = dict["alt"] as! String
                    }
                    if dict.keys.contains("caption") {
                        self.caption = dict["caption"] as! String
                    }
                    if dict.keys.contains("imageUrl") {
                        self.imageUrl = dict["imageUrl"] as! String
                    }
                }
            }
            public var images: [CreateCheckRunResponseBody.Result.Output.Images]?

            public var summary: String?

            public var text: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.images != nil {
                    var tmp : [Any] = []
                    for k in self.images! {
                        tmp.append(k.toMap())
                    }
                    map["images"] = tmp
                }
                if self.summary != nil {
                    map["summary"] = self.summary!
                }
                if self.text != nil {
                    map["text"] = self.text!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("images") {
                    var tmp : [CreateCheckRunResponseBody.Result.Output.Images] = []
                    for v in dict["images"] as! [Any] {
                        var model = CreateCheckRunResponseBody.Result.Output.Images()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.images = tmp
                }
                if dict.keys.contains("summary") {
                    self.summary = dict["summary"] as! String
                }
                if dict.keys.contains("text") {
                    self.text = dict["text"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class Writer : Tea.TeaModel {
            public var id: String?

            public var logoUrl: String?

            public var name: String?

            public var slug: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.logoUrl != nil {
                    map["logoUrl"] = self.logoUrl!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.slug != nil {
                    map["slug"] = self.slug!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("logoUrl") {
                    self.logoUrl = dict["logoUrl"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("slug") {
                    self.slug = dict["slug"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var annotations: [CreateCheckRunResponseBody.Result.Annotations]?

        public var checkSuite: CreateCheckRunResponseBody.Result.CheckSuite?

        public var completedAt: String?

        public var conclusion: String?

        public var createdAt: String?

        public var detailsUrl: String?

        public var externalId: String?

        public var headSha: String?

        public var id: Int64?

        public var name: String?

        public var output: CreateCheckRunResponseBody.Result.Output?

        public var startedAt: String?

        public var status: String?

        public var updatedAt: String?

        public var writer: CreateCheckRunResponseBody.Result.Writer?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkSuite?.validate()
            try self.output?.validate()
            try self.writer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["annotations"] = tmp
            }
            if self.checkSuite != nil {
                map["checkSuite"] = self.checkSuite?.toMap()
            }
            if self.completedAt != nil {
                map["completedAt"] = self.completedAt!
            }
            if self.conclusion != nil {
                map["conclusion"] = self.conclusion!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.detailsUrl != nil {
                map["detailsUrl"] = self.detailsUrl!
            }
            if self.externalId != nil {
                map["externalId"] = self.externalId!
            }
            if self.headSha != nil {
                map["headSha"] = self.headSha!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.output != nil {
                map["output"] = self.output?.toMap()
            }
            if self.startedAt != nil {
                map["startedAt"] = self.startedAt!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.writer != nil {
                map["writer"] = self.writer?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("annotations") {
                var tmp : [CreateCheckRunResponseBody.Result.Annotations] = []
                for v in dict["annotations"] as! [Any] {
                    var model = CreateCheckRunResponseBody.Result.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("checkSuite") {
                var model = CreateCheckRunResponseBody.Result.CheckSuite()
                model.fromMap(dict["checkSuite"] as! [String: Any])
                self.checkSuite = model
            }
            if dict.keys.contains("completedAt") {
                self.completedAt = dict["completedAt"] as! String
            }
            if dict.keys.contains("conclusion") {
                self.conclusion = dict["conclusion"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("detailsUrl") {
                self.detailsUrl = dict["detailsUrl"] as! String
            }
            if dict.keys.contains("externalId") {
                self.externalId = dict["externalId"] as! String
            }
            if dict.keys.contains("headSha") {
                self.headSha = dict["headSha"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("output") {
                var model = CreateCheckRunResponseBody.Result.Output()
                model.fromMap(dict["output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("startedAt") {
                self.startedAt = dict["startedAt"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("writer") {
                var model = CreateCheckRunResponseBody.Result.Writer()
                model.fromMap(dict["writer"] as! [String: Any])
                self.writer = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateCheckRunResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateCheckRunResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateCheckRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCheckRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCheckRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCommentRequest : Tea.TeaModel {
    public var accessToken: String?

    public var commentType: String?

    public var content: String?

    public var draft: Bool?

    public var filePath: String?

    public var lineNumber: Int32?

    public var parentCommentBizId: String?

    public var patchSetBizId: String?

    public var resolved: Bool?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.commentType != nil {
            map["commentType"] = self.commentType!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.draft != nil {
            map["draft"] = self.draft!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.lineNumber != nil {
            map["lineNumber"] = self.lineNumber!
        }
        if self.parentCommentBizId != nil {
            map["parentCommentBizId"] = self.parentCommentBizId!
        }
        if self.patchSetBizId != nil {
            map["patchSetBizId"] = self.patchSetBizId!
        }
        if self.resolved != nil {
            map["resolved"] = self.resolved!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("commentType") {
            self.commentType = dict["commentType"] as! String
        }
        if dict.keys.contains("content") {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("draft") {
            self.draft = dict["draft"] as! Bool
        }
        if dict.keys.contains("filePath") {
            self.filePath = dict["filePath"] as! String
        }
        if dict.keys.contains("lineNumber") {
            self.lineNumber = dict["lineNumber"] as! Int32
        }
        if dict.keys.contains("parentCommentBizId") {
            self.parentCommentBizId = dict["parentCommentBizId"] as! String
        }
        if dict.keys.contains("patchSetBizId") {
            self.patchSetBizId = dict["patchSetBizId"] as! String
        }
        if dict.keys.contains("resolved") {
            self.resolved = dict["resolved"] as! Bool
        }
        if dict.keys.contains("localId") {
            self.localId = dict["localId"] as! Int64
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class CreateCommentResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliyunPk") {
                    self.aliyunPk = dict["aliyunPk"] as! String
                }
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public class RelatedPatchSet : Tea.TeaModel {
            public var commitId: String?

            public var createdAt: String?

            public var patchSetBizId: String?

            public var patchSetName: String?

            public var patchSetNo: String?

            public var relatedMergeItemType: String?

            public var shortId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commitId != nil {
                    map["commitId"] = self.commitId!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.patchSetBizId != nil {
                    map["patchSetBizId"] = self.patchSetBizId!
                }
                if self.patchSetName != nil {
                    map["patchSetName"] = self.patchSetName!
                }
                if self.patchSetNo != nil {
                    map["patchSetNo"] = self.patchSetNo!
                }
                if self.relatedMergeItemType != nil {
                    map["relatedMergeItemType"] = self.relatedMergeItemType!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("commitId") {
                    self.commitId = dict["commitId"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("patchSetBizId") {
                    self.patchSetBizId = dict["patchSetBizId"] as! String
                }
                if dict.keys.contains("patchSetName") {
                    self.patchSetName = dict["patchSetName"] as! String
                }
                if dict.keys.contains("patchSetNo") {
                    self.patchSetNo = dict["patchSetNo"] as! String
                }
                if dict.keys.contains("relatedMergeItemType") {
                    self.relatedMergeItemType = dict["relatedMergeItemType"] as! String
                }
                if dict.keys.contains("shortId") {
                    self.shortId = dict["shortId"] as! String
                }
            }
        }
        public var author: CreateCommentResponseBody.Result.Author?

        public var commentBizId: String?

        public var commentTime: String?

        public var commentType: String?

        public var content: String?

        public var deleted: Bool?

        public var filePath: String?

        public var lastEditTime: String?

        public var lineNumber: String?

        public var parentCommentBizId: String?

        public var relatedPatchSet: CreateCommentResponseBody.Result.RelatedPatchSet?

        public var resolved: Bool?

        public var rootCommentBizId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.relatedPatchSet?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.commentBizId != nil {
                map["commentBizId"] = self.commentBizId!
            }
            if self.commentTime != nil {
                map["commentTime"] = self.commentTime!
            }
            if self.commentType != nil {
                map["commentType"] = self.commentType!
            }
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.deleted != nil {
                map["deleted"] = self.deleted!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            if self.lastEditTime != nil {
                map["lastEditTime"] = self.lastEditTime!
            }
            if self.lineNumber != nil {
                map["lineNumber"] = self.lineNumber!
            }
            if self.parentCommentBizId != nil {
                map["parentCommentBizId"] = self.parentCommentBizId!
            }
            if self.relatedPatchSet != nil {
                map["relatedPatchSet"] = self.relatedPatchSet?.toMap()
            }
            if self.resolved != nil {
                map["resolved"] = self.resolved!
            }
            if self.rootCommentBizId != nil {
                map["rootCommentBizId"] = self.rootCommentBizId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("author") {
                var model = CreateCommentResponseBody.Result.Author()
                model.fromMap(dict["author"] as! [String: Any])
                self.author = model
            }
            if dict.keys.contains("commentBizId") {
                self.commentBizId = dict["commentBizId"] as! String
            }
            if dict.keys.contains("commentTime") {
                self.commentTime = dict["commentTime"] as! String
            }
            if dict.keys.contains("commentType") {
                self.commentType = dict["commentType"] as! String
            }
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("deleted") {
                self.deleted = dict["deleted"] as! Bool
            }
            if dict.keys.contains("filePath") {
                self.filePath = dict["filePath"] as! String
            }
            if dict.keys.contains("lastEditTime") {
                self.lastEditTime = dict["lastEditTime"] as! String
            }
            if dict.keys.contains("lineNumber") {
                self.lineNumber = dict["lineNumber"] as! String
            }
            if dict.keys.contains("parentCommentBizId") {
                self.parentCommentBizId = dict["parentCommentBizId"] as! String
            }
            if dict.keys.contains("relatedPatchSet") {
                var model = CreateCommentResponseBody.Result.RelatedPatchSet()
                model.fromMap(dict["relatedPatchSet"] as! [String: Any])
                self.relatedPatchSet = model
            }
            if dict.keys.contains("resolved") {
                self.resolved = dict["resolved"] as! Bool
            }
            if dict.keys.contains("rootCommentBizId") {
                self.rootCommentBizId = dict["rootCommentBizId"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateCommentResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateCommentResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateCommentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCommentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCommentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCommitStatusRequest : Tea.TeaModel {
    public var accessToken: String?

    public var context: String?

    public var description_: String?

    public var state: String?

    public var targetUrl: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public var sha: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.context != nil {
            map["context"] = self.context!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.state != nil {
            map["state"] = self.state!
        }
        if self.targetUrl != nil {
            map["targetUrl"] = self.targetUrl!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        if self.sha != nil {
            map["sha"] = self.sha!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("context") {
            self.context = dict["context"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("state") {
            self.state = dict["state"] as! String
        }
        if dict.keys.contains("targetUrl") {
            self.targetUrl = dict["targetUrl"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
        if dict.keys.contains("sha") {
            self.sha = dict["sha"] as! String
        }
    }
}

public class CreateCommitStatusResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Creator : Tea.TeaModel {
            public var aliyunPk: Int64?

            public var avatarUrl: String?

            public var login: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.login != nil {
                    map["login"] = self.login!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliyunPk") {
                    self.aliyunPk = dict["aliyunPk"] as! Int64
                }
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("login") {
                    self.login = dict["login"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var context: String?

        public var creator: CreateCommitStatusResponseBody.Result.Creator?

        public var description_: String?

        public var id: Int64?

        public var sha: String?

        public var state: String?

        public var targetUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.creator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.context != nil {
                map["context"] = self.context!
            }
            if self.creator != nil {
                map["creator"] = self.creator?.toMap()
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.sha != nil {
                map["sha"] = self.sha!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.targetUrl != nil {
                map["targetUrl"] = self.targetUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("context") {
                self.context = dict["context"] as! String
            }
            if dict.keys.contains("creator") {
                var model = CreateCommitStatusResponseBody.Result.Creator()
                model.fromMap(dict["creator"] as! [String: Any])
                self.creator = model
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("sha") {
                self.sha = dict["sha"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("targetUrl") {
                self.targetUrl = dict["targetUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateCommitStatusResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateCommitStatusResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateCommitStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCommitStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCommitStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCommitWithMultipleFilesRequest : Tea.TeaModel {
    public class Actions : Tea.TeaModel {
        public var action: String?

        public var content: String?

        public var filePath: String?

        public var previousPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["action"] = self.action!
            }
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            if self.previousPath != nil {
                map["previousPath"] = self.previousPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("action") {
                self.action = dict["action"] as! String
            }
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("filePath") {
                self.filePath = dict["filePath"] as! String
            }
            if dict.keys.contains("previousPath") {
                self.previousPath = dict["previousPath"] as! String
            }
        }
    }
    public var accessToken: String?

    public var actions: [CreateCommitWithMultipleFilesRequest.Actions]?

    public var branch: String?

    public var commitMessage: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.actions != nil {
            var tmp : [Any] = []
            for k in self.actions! {
                tmp.append(k.toMap())
            }
            map["actions"] = tmp
        }
        if self.branch != nil {
            map["branch"] = self.branch!
        }
        if self.commitMessage != nil {
            map["commitMessage"] = self.commitMessage!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("actions") {
            var tmp : [CreateCommitWithMultipleFilesRequest.Actions] = []
            for v in dict["actions"] as! [Any] {
                var model = CreateCommitWithMultipleFilesRequest.Actions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.actions = tmp
        }
        if dict.keys.contains("branch") {
            self.branch = dict["branch"] as! String
        }
        if dict.keys.contains("commitMessage") {
            self.commitMessage = dict["commitMessage"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class CreateCommitWithMultipleFilesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliyunPk") {
                    self.aliyunPk = dict["aliyunPk"] as! String
                }
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
                if dict.keys.contains("websiteUrl") {
                    self.websiteUrl = dict["websiteUrl"] as! String
                }
            }
        }
        public class Committer : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliyunPk") {
                    self.aliyunPk = dict["aliyunPk"] as! String
                }
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
                if dict.keys.contains("websiteUrl") {
                    self.websiteUrl = dict["websiteUrl"] as! String
                }
            }
        }
        public var author: CreateCommitWithMultipleFilesResponseBody.Result.Author?

        public var authorEmail: String?

        public var authorName: String?

        public var authoredDate: String?

        public var committedDate: String?

        public var committer: CreateCommitWithMultipleFilesResponseBody.Result.Committer?

        public var committerEmail: String?

        public var committerName: String?

        public var createdAt: String?

        public var id: String?

        public var message: String?

        public var parentIds: [String]?

        public var shortId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.committer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.authorEmail != nil {
                map["authorEmail"] = self.authorEmail!
            }
            if self.authorName != nil {
                map["authorName"] = self.authorName!
            }
            if self.authoredDate != nil {
                map["authoredDate"] = self.authoredDate!
            }
            if self.committedDate != nil {
                map["committedDate"] = self.committedDate!
            }
            if self.committer != nil {
                map["committer"] = self.committer?.toMap()
            }
            if self.committerEmail != nil {
                map["committerEmail"] = self.committerEmail!
            }
            if self.committerName != nil {
                map["committerName"] = self.committerName!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.parentIds != nil {
                map["parentIds"] = self.parentIds!
            }
            if self.shortId != nil {
                map["shortId"] = self.shortId!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("author") {
                var model = CreateCommitWithMultipleFilesResponseBody.Result.Author()
                model.fromMap(dict["author"] as! [String: Any])
                self.author = model
            }
            if dict.keys.contains("authorEmail") {
                self.authorEmail = dict["authorEmail"] as! String
            }
            if dict.keys.contains("authorName") {
                self.authorName = dict["authorName"] as! String
            }
            if dict.keys.contains("authoredDate") {
                self.authoredDate = dict["authoredDate"] as! String
            }
            if dict.keys.contains("committedDate") {
                self.committedDate = dict["committedDate"] as! String
            }
            if dict.keys.contains("committer") {
                var model = CreateCommitWithMultipleFilesResponseBody.Result.Committer()
                model.fromMap(dict["committer"] as! [String: Any])
                self.committer = model
            }
            if dict.keys.contains("committerEmail") {
                self.committerEmail = dict["committerEmail"] as! String
            }
            if dict.keys.contains("committerName") {
                self.committerName = dict["committerName"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("message") {
                self.message = dict["message"] as! String
            }
            if dict.keys.contains("parentIds") {
                self.parentIds = dict["parentIds"] as! [String]
            }
            if dict.keys.contains("shortId") {
                self.shortId = dict["shortId"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var result: CreateCommitWithMultipleFilesResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateCommitWithMultipleFilesResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateCommitWithMultipleFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCommitWithMultipleFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCommitWithMultipleFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDeployKeyRequest : Tea.TeaModel {
    public var accessToken: String?

    public var key: String?

    public var title: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.key != nil {
            map["key"] = self.key!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("key") {
            self.key = dict["key"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CreateDeployKeyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var fingerprint: String?

        public var id: Int64?

        public var key: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.fingerprint != nil {
                map["fingerprint"] = self.fingerprint!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("fingerprint") {
                self.fingerprint = dict["fingerprint"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("key") {
                self.key = dict["key"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateDeployKeyResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateDeployKeyResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateDeployKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDeployKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDeployKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFileRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var commitMessage: String?

    public var content: String?

    public var encoding: String?

    public var filePath: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.commitMessage != nil {
            map["commitMessage"] = self.commitMessage!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.encoding != nil {
            map["encoding"] = self.encoding!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("branchName") {
            self.branchName = dict["branchName"] as! String
        }
        if dict.keys.contains("commitMessage") {
            self.commitMessage = dict["commitMessage"] as! String
        }
        if dict.keys.contains("content") {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("encoding") {
            self.encoding = dict["encoding"] as! String
        }
        if dict.keys.contains("filePath") {
            self.filePath = dict["filePath"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CreateFileResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var branchName: String?

        public var filePath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["branchName"] = self.branchName!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("branchName") {
                self.branchName = dict["branchName"] as! String
            }
            if dict.keys.contains("filePath") {
                self.filePath = dict["filePath"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateFileResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateFileResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowTagRequest : Tea.TeaModel {
    public var color: String?

    public var flowTagGroupId: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.color != nil {
            map["color"] = self.color!
        }
        if self.flowTagGroupId != nil {
            map["flowTagGroupId"] = self.flowTagGroupId!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("color") {
            self.color = dict["color"] as! String
        }
        if dict.keys.contains("flowTagGroupId") {
            self.flowTagGroupId = dict["flowTagGroupId"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
    }
}

public class CreateFlowTagResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var id: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateFlowTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFlowTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowTagGroupRequest : Tea.TeaModel {
    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
    }
}

public class CreateFlowTagGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var id: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateFlowTagGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowTagGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFlowTagGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHostGroupRequest : Tea.TeaModel {
    public var aliyunRegion: String?

    public var ecsLabelKey: String?

    public var ecsLabelValue: String?

    public var ecsType: String?

    public var envId: String?

    public var machineInfos: String?

    public var name: String?

    public var serviceConnectionId: Int64?

    public var tagIds: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunRegion != nil {
            map["aliyunRegion"] = self.aliyunRegion!
        }
        if self.ecsLabelKey != nil {
            map["ecsLabelKey"] = self.ecsLabelKey!
        }
        if self.ecsLabelValue != nil {
            map["ecsLabelValue"] = self.ecsLabelValue!
        }
        if self.ecsType != nil {
            map["ecsType"] = self.ecsType!
        }
        if self.envId != nil {
            map["envId"] = self.envId!
        }
        if self.machineInfos != nil {
            map["machineInfos"] = self.machineInfos!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.serviceConnectionId != nil {
            map["serviceConnectionId"] = self.serviceConnectionId!
        }
        if self.tagIds != nil {
            map["tagIds"] = self.tagIds!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("aliyunRegion") {
            self.aliyunRegion = dict["aliyunRegion"] as! String
        }
        if dict.keys.contains("ecsLabelKey") {
            self.ecsLabelKey = dict["ecsLabelKey"] as! String
        }
        if dict.keys.contains("ecsLabelValue") {
            self.ecsLabelValue = dict["ecsLabelValue"] as! String
        }
        if dict.keys.contains("ecsType") {
            self.ecsType = dict["ecsType"] as! String
        }
        if dict.keys.contains("envId") {
            self.envId = dict["envId"] as! String
        }
        if dict.keys.contains("machineInfos") {
            self.machineInfos = dict["machineInfos"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("serviceConnectionId") {
            self.serviceConnectionId = dict["serviceConnectionId"] as! Int64
        }
        if dict.keys.contains("tagIds") {
            self.tagIds = dict["tagIds"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class CreateHostGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var hostGroupId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.hostGroupId != nil {
            map["hostGroupId"] = self.hostGroupId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("hostGroupId") {
            self.hostGroupId = dict["hostGroupId"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateHostGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHostGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateHostGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var createFrom: String?

    public var description_: String?

    public var reviewerIds: [String]?

    public var sourceBranch: String?

    public var sourceProjectId: Int64?

    public var targetBranch: String?

    public var targetProjectId: Int64?

    public var title: String?

    public var workItemIds: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.createFrom != nil {
            map["createFrom"] = self.createFrom!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.reviewerIds != nil {
            map["reviewerIds"] = self.reviewerIds!
        }
        if self.sourceBranch != nil {
            map["sourceBranch"] = self.sourceBranch!
        }
        if self.sourceProjectId != nil {
            map["sourceProjectId"] = self.sourceProjectId!
        }
        if self.targetBranch != nil {
            map["targetBranch"] = self.targetBranch!
        }
        if self.targetProjectId != nil {
            map["targetProjectId"] = self.targetProjectId!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.workItemIds != nil {
            map["workItemIds"] = self.workItemIds!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("createFrom") {
            self.createFrom = dict["createFrom"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("reviewerIds") {
            self.reviewerIds = dict["reviewerIds"] as! [String]
        }
        if dict.keys.contains("sourceBranch") {
            self.sourceBranch = dict["sourceBranch"] as! String
        }
        if dict.keys.contains("sourceProjectId") {
            self.sourceProjectId = dict["sourceProjectId"] as! Int64
        }
        if dict.keys.contains("targetBranch") {
            self.targetBranch = dict["targetBranch"] as! String
        }
        if dict.keys.contains("targetProjectId") {
            self.targetProjectId = dict["targetProjectId"] as! Int64
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("workItemIds") {
            self.workItemIds = dict["workItemIds"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CreateMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public class Reviewers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var hasReviewed: Bool?

            public var id: Int64?

            public var name: String?

            public var reviewOpinionStatus: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.hasReviewed != nil {
                    map["hasReviewed"] = self.hasReviewed!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.reviewOpinionStatus != nil {
                    map["reviewOpinionStatus"] = self.reviewOpinionStatus!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("hasReviewed") {
                    self.hasReviewed = dict["hasReviewed"] as! Bool
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("reviewOpinionStatus") {
                    self.reviewOpinionStatus = dict["reviewOpinionStatus"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public class Subscribers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public var ahead: Int32?

        public var allRequirementsPass: Bool?

        public var author: CreateMergeRequestResponseBody.Result.Author?

        public var behind: Int32?

        public var createFrom: String?

        public var createTime: String?

        public var description_: String?

        public var detailUrl: String?

        public var localId: Int64?

        public var mrBizId: String?

        public var mrType: String?

        public var projectId: Int64?

        public var reviewers: [CreateMergeRequestResponseBody.Result.Reviewers]?

        public var sourceBranch: String?

        public var sourceProjectId: Int64?

        public var status: String?

        public var subscribers: [CreateMergeRequestResponseBody.Result.Subscribers]?

        public var supportMergeFastForwardOnly: Bool?

        public var targetBranch: String?

        public var targetProjectId: Int64?

        public var title: String?

        public var updateTime: String?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ahead != nil {
                map["ahead"] = self.ahead!
            }
            if self.allRequirementsPass != nil {
                map["allRequirementsPass"] = self.allRequirementsPass!
            }
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.behind != nil {
                map["behind"] = self.behind!
            }
            if self.createFrom != nil {
                map["createFrom"] = self.createFrom!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.detailUrl != nil {
                map["detailUrl"] = self.detailUrl!
            }
            if self.localId != nil {
                map["localId"] = self.localId!
            }
            if self.mrBizId != nil {
                map["mrBizId"] = self.mrBizId!
            }
            if self.mrType != nil {
                map["mrType"] = self.mrType!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.reviewers != nil {
                var tmp : [Any] = []
                for k in self.reviewers! {
                    tmp.append(k.toMap())
                }
                map["reviewers"] = tmp
            }
            if self.sourceBranch != nil {
                map["sourceBranch"] = self.sourceBranch!
            }
            if self.sourceProjectId != nil {
                map["sourceProjectId"] = self.sourceProjectId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.subscribers != nil {
                var tmp : [Any] = []
                for k in self.subscribers! {
                    tmp.append(k.toMap())
                }
                map["subscribers"] = tmp
            }
            if self.supportMergeFastForwardOnly != nil {
                map["supportMergeFastForwardOnly"] = self.supportMergeFastForwardOnly!
            }
            if self.targetBranch != nil {
                map["targetBranch"] = self.targetBranch!
            }
            if self.targetProjectId != nil {
                map["targetProjectId"] = self.targetProjectId!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ahead") {
                self.ahead = dict["ahead"] as! Int32
            }
            if dict.keys.contains("allRequirementsPass") {
                self.allRequirementsPass = dict["allRequirementsPass"] as! Bool
            }
            if dict.keys.contains("author") {
                var model = CreateMergeRequestResponseBody.Result.Author()
                model.fromMap(dict["author"] as! [String: Any])
                self.author = model
            }
            if dict.keys.contains("behind") {
                self.behind = dict["behind"] as! Int32
            }
            if dict.keys.contains("createFrom") {
                self.createFrom = dict["createFrom"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("detailUrl") {
                self.detailUrl = dict["detailUrl"] as! String
            }
            if dict.keys.contains("localId") {
                self.localId = dict["localId"] as! Int64
            }
            if dict.keys.contains("mrBizId") {
                self.mrBizId = dict["mrBizId"] as! String
            }
            if dict.keys.contains("mrType") {
                self.mrType = dict["mrType"] as! String
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! Int64
            }
            if dict.keys.contains("reviewers") {
                var tmp : [CreateMergeRequestResponseBody.Result.Reviewers] = []
                for v in dict["reviewers"] as! [Any] {
                    var model = CreateMergeRequestResponseBody.Result.Reviewers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reviewers = tmp
            }
            if dict.keys.contains("sourceBranch") {
                self.sourceBranch = dict["sourceBranch"] as! String
            }
            if dict.keys.contains("sourceProjectId") {
                self.sourceProjectId = dict["sourceProjectId"] as! Int64
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("subscribers") {
                var tmp : [CreateMergeRequestResponseBody.Result.Subscribers] = []
                for v in dict["subscribers"] as! [Any] {
                    var model = CreateMergeRequestResponseBody.Result.Subscribers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.subscribers = tmp
            }
            if dict.keys.contains("supportMergeFastForwardOnly") {
                self.supportMergeFastForwardOnly = dict["supportMergeFastForwardOnly"] as! Bool
            }
            if dict.keys.contains("targetBranch") {
                self.targetBranch = dict["targetBranch"] as! String
            }
            if dict.keys.contains("targetProjectId") {
                self.targetProjectId = dict["targetProjectId"] as! Int64
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! String
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateMergeRequestResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMergeRequestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOAuthTokenRequest : Tea.TeaModel {
    public var clientId: String?

    public var clientSecret: String?

    public var code: String?

    public var grantType: String?

    public var login: String?

    public var scope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientId != nil {
            map["clientId"] = self.clientId!
        }
        if self.clientSecret != nil {
            map["clientSecret"] = self.clientSecret!
        }
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.grantType != nil {
            map["grantType"] = self.grantType!
        }
        if self.login != nil {
            map["login"] = self.login!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientId") {
            self.clientId = dict["clientId"] as! String
        }
        if dict.keys.contains("clientSecret") {
            self.clientSecret = dict["clientSecret"] as! String
        }
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("grantType") {
            self.grantType = dict["grantType"] as! String
        }
        if dict.keys.contains("login") {
            self.login = dict["login"] as! String
        }
        if dict.keys.contains("scope") {
            self.scope = dict["scope"] as! String
        }
    }
}

public class CreateOAuthTokenResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessToken: String?

        public var id: String?

        public var scope: String?

        public var tokenType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessToken != nil {
                map["accessToken"] = self.accessToken!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.tokenType != nil {
                map["tokenType"] = self.tokenType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessToken") {
                self.accessToken = dict["accessToken"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("scope") {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("tokenType") {
                self.tokenType = dict["tokenType"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateOAuthTokenResponseBody.Result?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateOAuthTokenResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
    }
}

public class CreateOAuthTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOAuthTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOAuthTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePipelineRequest : Tea.TeaModel {
    public var content: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
    }
}

public class CreatePipelineResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelinId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelinId != nil {
            map["pipelinId"] = self.pipelinId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("pipelinId") {
            self.pipelinId = dict["pipelinId"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePipelineGroupRequest : Tea.TeaModel {
    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
    }
}

public class CreatePipelineGroupResponseBody : Tea.TeaModel {
    public class PipelineGroup : Tea.TeaModel {
        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelineGroup: CreatePipelineGroupResponseBody.PipelineGroup?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipelineGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelineGroup != nil {
            map["pipelineGroup"] = self.pipelineGroup?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("pipelineGroup") {
            var model = CreatePipelineGroupResponseBody.PipelineGroup()
            model.fromMap(dict["pipelineGroup"] as! [String: Any])
            self.pipelineGroup = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreatePipelineGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePipelineGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePipelineGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProjectRequest : Tea.TeaModel {
    public var customCode: String?

    public var name: String?

    public var scope: String?

    public var templateIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customCode != nil {
            map["customCode"] = self.customCode!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.templateIdentifier != nil {
            map["templateIdentifier"] = self.templateIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("customCode") {
            self.customCode = dict["customCode"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("scope") {
            self.scope = dict["scope"] as! String
        }
        if dict.keys.contains("templateIdentifier") {
            self.templateIdentifier = dict["templateIdentifier"] as! String
        }
    }
}

public class CreateProjectResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var categoryIdentifier: String?

        public var creator: String?

        public var customCode: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var icon: String?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var name: String?

        public var organizationIdentifier: String?

        public var scope: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var typeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.customCode != nil {
                map["customCode"] = self.customCode!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.icon != nil {
                map["icon"] = self.icon!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationIdentifier != nil {
                map["organizationIdentifier"] = self.organizationIdentifier!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.typeIdentifier != nil {
                map["typeIdentifier"] = self.typeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("customCode") {
                self.customCode = dict["customCode"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("icon") {
                self.icon = dict["icon"] as! String
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("logicalStatus") {
                self.logicalStatus = dict["logicalStatus"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("organizationIdentifier") {
                self.organizationIdentifier = dict["organizationIdentifier"] as! String
            }
            if dict.keys.contains("scope") {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("statusIdentifier") {
                self.statusIdentifier = dict["statusIdentifier"] as! String
            }
            if dict.keys.contains("statusStageIdentifier") {
                self.statusStageIdentifier = dict["statusStageIdentifier"] as! String
            }
            if dict.keys.contains("typeIdentifier") {
                self.typeIdentifier = dict["typeIdentifier"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var project: CreateProjectResponseBody.Project?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.project != nil {
            map["project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("project") {
            var model = CreateProjectResponseBody.Project()
            model.fromMap(dict["project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProjectLabelRequest : Tea.TeaModel {
    public var accessToken: String?

    public var color: String?

    public var description_: String?

    public var name: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.color != nil {
            map["color"] = self.color!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("color") {
            self.color = dict["color"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class CreateProjectLabelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var color: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.color != nil {
                map["color"] = self.color!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("color") {
                self.color = dict["color"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateProjectLabelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateProjectLabelResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateProjectLabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProjectLabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProjectLabelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateProtectdBranchRequest : Tea.TeaModel {
    public class MergeRequestSetting : Tea.TeaModel {
        public var allowMergeRequestRoles: [Int32]?

        public var defaultAssignees: [String]?

        public var isAllowSelfApproval: Bool?

        public var isRequireDiscussionProcessed: Bool?

        public var isRequired: Bool?

        public var isResetApprovalWhenNewPush: Bool?

        public var minimumApproval: Int32?

        public var mrMode: String?

        public var whiteList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowMergeRequestRoles != nil {
                map["allowMergeRequestRoles"] = self.allowMergeRequestRoles!
            }
            if self.defaultAssignees != nil {
                map["defaultAssignees"] = self.defaultAssignees!
            }
            if self.isAllowSelfApproval != nil {
                map["isAllowSelfApproval"] = self.isAllowSelfApproval!
            }
            if self.isRequireDiscussionProcessed != nil {
                map["isRequireDiscussionProcessed"] = self.isRequireDiscussionProcessed!
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.isResetApprovalWhenNewPush != nil {
                map["isResetApprovalWhenNewPush"] = self.isResetApprovalWhenNewPush!
            }
            if self.minimumApproval != nil {
                map["minimumApproval"] = self.minimumApproval!
            }
            if self.mrMode != nil {
                map["mrMode"] = self.mrMode!
            }
            if self.whiteList != nil {
                map["whiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("allowMergeRequestRoles") {
                self.allowMergeRequestRoles = dict["allowMergeRequestRoles"] as! [Int32]
            }
            if dict.keys.contains("defaultAssignees") {
                self.defaultAssignees = dict["defaultAssignees"] as! [String]
            }
            if dict.keys.contains("isAllowSelfApproval") {
                self.isAllowSelfApproval = dict["isAllowSelfApproval"] as! Bool
            }
            if dict.keys.contains("isRequireDiscussionProcessed") {
                self.isRequireDiscussionProcessed = dict["isRequireDiscussionProcessed"] as! Bool
            }
            if dict.keys.contains("isRequired") {
                self.isRequired = dict["isRequired"] as! Bool
            }
            if dict.keys.contains("isResetApprovalWhenNewPush") {
                self.isResetApprovalWhenNewPush = dict["isResetApprovalWhenNewPush"] as! Bool
            }
            if dict.keys.contains("minimumApproval") {
                self.minimumApproval = dict["minimumApproval"] as! Int32
            }
            if dict.keys.contains("mrMode") {
                self.mrMode = dict["mrMode"] as! String
            }
            if dict.keys.contains("whiteList") {
                self.whiteList = dict["whiteList"] as! String
            }
        }
    }
    public class TestSettingDTO : Tea.TeaModel {
        public class CheckConfig : Tea.TeaModel {
            public class CheckItems : Tea.TeaModel {
                public var isRequired: Bool?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isRequired != nil {
                        map["isRequired"] = self.isRequired!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("isRequired") {
                        self.isRequired = dict["isRequired"] as! Bool
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                }
            }
            public var checkItems: [CreateProtectdBranchRequest.TestSettingDTO.CheckConfig.CheckItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkItems != nil {
                    var tmp : [Any] = []
                    for k in self.checkItems! {
                        tmp.append(k.toMap())
                    }
                    map["checkItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("checkItems") {
                    var tmp : [CreateProtectdBranchRequest.TestSettingDTO.CheckConfig.CheckItems] = []
                    for v in dict["checkItems"] as! [Any] {
                        var model = CreateProtectdBranchRequest.TestSettingDTO.CheckConfig.CheckItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.checkItems = tmp
                }
            }
        }
        public class CheckTaskQualityConfig : Tea.TeaModel {
            public var bizNo: String?

            public var enabled: Bool?

            public var message: String?

            public var taskName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizNo != nil {
                    map["bizNo"] = self.bizNo!
                }
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.taskName != nil {
                    map["taskName"] = self.taskName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("bizNo") {
                    self.bizNo = dict["bizNo"] as! String
                }
                if dict.keys.contains("enabled") {
                    self.enabled = dict["enabled"] as! Bool
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("taskName") {
                    self.taskName = dict["taskName"] as! String
                }
            }
        }
        public class CodeGuidelinesDetection : Tea.TeaModel {
            public var enabled: Bool?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("enabled") {
                    self.enabled = dict["enabled"] as! Bool
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
            }
        }
        public class SensitiveInfoDetection : Tea.TeaModel {
            public var enabled: Bool?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("enabled") {
                    self.enabled = dict["enabled"] as! Bool
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
            }
        }
        public var checkConfig: CreateProtectdBranchRequest.TestSettingDTO.CheckConfig?

        public var checkTaskQualityConfig: CreateProtectdBranchRequest.TestSettingDTO.CheckTaskQualityConfig?

        public var codeGuidelinesDetection: CreateProtectdBranchRequest.TestSettingDTO.CodeGuidelinesDetection?

        public var isRequired: Bool?

        public var sensitiveInfoDetection: CreateProtectdBranchRequest.TestSettingDTO.SensitiveInfoDetection?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkConfig?.validate()
            try self.checkTaskQualityConfig?.validate()
            try self.codeGuidelinesDetection?.validate()
            try self.sensitiveInfoDetection?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkConfig != nil {
                map["checkConfig"] = self.checkConfig?.toMap()
            }
            if self.checkTaskQualityConfig != nil {
                map["checkTaskQualityConfig"] = self.checkTaskQualityConfig?.toMap()
            }
            if self.codeGuidelinesDetection != nil {
                map["codeGuidelinesDetection"] = self.codeGuidelinesDetection?.toMap()
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.sensitiveInfoDetection != nil {
                map["sensitiveInfoDetection"] = self.sensitiveInfoDetection?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("checkConfig") {
                var model = CreateProtectdBranchRequest.TestSettingDTO.CheckConfig()
                model.fromMap(dict["checkConfig"] as! [String: Any])
                self.checkConfig = model
            }
            if dict.keys.contains("checkTaskQualityConfig") {
                var model = CreateProtectdBranchRequest.TestSettingDTO.CheckTaskQualityConfig()
                model.fromMap(dict["checkTaskQualityConfig"] as! [String: Any])
                self.checkTaskQualityConfig = model
            }
            if dict.keys.contains("codeGuidelinesDetection") {
                var model = CreateProtectdBranchRequest.TestSettingDTO.CodeGuidelinesDetection()
                model.fromMap(dict["codeGuidelinesDetection"] as! [String: Any])
                self.codeGuidelinesDetection = model
            }
            if dict.keys.contains("isRequired") {
                self.isRequired = dict["isRequired"] as! Bool
            }
            if dict.keys.contains("sensitiveInfoDetection") {
                var model = CreateProtectdBranchRequest.TestSettingDTO.SensitiveInfoDetection()
                model.fromMap(dict["sensitiveInfoDetection"] as! [String: Any])
                self.sensitiveInfoDetection = model
            }
        }
    }
    public var accessToken: String?

    public var allowMergeRoles: [Int32]?

    public var allowMergeUserIds: [String]?

    public var allowPushRoles: [Int32]?

    public var allowPushUserIds: [String]?

    public var branch: String?

    public var id: Int64?

    public var mergeRequestSetting: CreateProtectdBranchRequest.MergeRequestSetting?

    public var testSettingDTO: CreateProtectdBranchRequest.TestSettingDTO?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mergeRequestSetting?.validate()
        try self.testSettingDTO?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.allowMergeRoles != nil {
            map["allowMergeRoles"] = self.allowMergeRoles!
        }
        if self.allowMergeUserIds != nil {
            map["allowMergeUserIds"] = self.allowMergeUserIds!
        }
        if self.allowPushRoles != nil {
            map["allowPushRoles"] = self.allowPushRoles!
        }
        if self.allowPushUserIds != nil {
            map["allowPushUserIds"] = self.allowPushUserIds!
        }
        if self.branch != nil {
            map["branch"] = self.branch!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.mergeRequestSetting != nil {
            map["mergeRequestSetting"] = self.mergeRequestSetting?.toMap()
        }
        if self.testSettingDTO != nil {
            map["testSettingDTO"] = self.testSettingDTO?.toMap()
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("allowMergeRoles") {
            self.allowMergeRoles = dict["allowMergeRoles"] as! [Int32]
        }
        if dict.keys.contains("allowMergeUserIds") {
            self.allowMergeUserIds = dict["allowMergeUserIds"] as! [String]
        }
        if dict.keys.contains("allowPushRoles") {
            self.allowPushRoles = dict["allowPushRoles"] as! [Int32]
        }
        if dict.keys.contains("allowPushUserIds") {
            self.allowPushUserIds = dict["allowPushUserIds"] as! [String]
        }
        if dict.keys.contains("branch") {
            self.branch = dict["branch"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("mergeRequestSetting") {
            var model = CreateProtectdBranchRequest.MergeRequestSetting()
            model.fromMap(dict["mergeRequestSetting"] as! [String: Any])
            self.mergeRequestSetting = model
        }
        if dict.keys.contains("testSettingDTO") {
            var model = CreateProtectdBranchRequest.TestSettingDTO()
            model.fromMap(dict["testSettingDTO"] as! [String: Any])
            self.testSettingDTO = model
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CreateProtectdBranchResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class MergeRequestSetting : Tea.TeaModel {
            public var allowMergeRequestRoles: [Int32]?

            public var defaultAssignees: [String]?

            public var isAllowSelfApproval: Bool?

            public var isRequireDiscussionProcessed: Bool?

            public var isRequired: Bool?

            public var isResetApprovalWhenNewPush: Bool?

            public var minimumApproval: Int32?

            public var mrMode: String?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowMergeRequestRoles != nil {
                    map["allowMergeRequestRoles"] = self.allowMergeRequestRoles!
                }
                if self.defaultAssignees != nil {
                    map["defaultAssignees"] = self.defaultAssignees!
                }
                if self.isAllowSelfApproval != nil {
                    map["isAllowSelfApproval"] = self.isAllowSelfApproval!
                }
                if self.isRequireDiscussionProcessed != nil {
                    map["isRequireDiscussionProcessed"] = self.isRequireDiscussionProcessed!
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.isResetApprovalWhenNewPush != nil {
                    map["isResetApprovalWhenNewPush"] = self.isResetApprovalWhenNewPush!
                }
                if self.minimumApproval != nil {
                    map["minimumApproval"] = self.minimumApproval!
                }
                if self.mrMode != nil {
                    map["mrMode"] = self.mrMode!
                }
                if self.whiteList != nil {
                    map["whiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("allowMergeRequestRoles") {
                    self.allowMergeRequestRoles = dict["allowMergeRequestRoles"] as! [Int32]
                }
                if dict.keys.contains("defaultAssignees") {
                    self.defaultAssignees = dict["defaultAssignees"] as! [String]
                }
                if dict.keys.contains("isAllowSelfApproval") {
                    self.isAllowSelfApproval = dict["isAllowSelfApproval"] as! Bool
                }
                if dict.keys.contains("isRequireDiscussionProcessed") {
                    self.isRequireDiscussionProcessed = dict["isRequireDiscussionProcessed"] as! Bool
                }
                if dict.keys.contains("isRequired") {
                    self.isRequired = dict["isRequired"] as! Bool
                }
                if dict.keys.contains("isResetApprovalWhenNewPush") {
                    self.isResetApprovalWhenNewPush = dict["isResetApprovalWhenNewPush"] as! Bool
                }
                if dict.keys.contains("minimumApproval") {
                    self.minimumApproval = dict["minimumApproval"] as! Int32
                }
                if dict.keys.contains("mrMode") {
                    self.mrMode = dict["mrMode"] as! String
                }
                if dict.keys.contains("whiteList") {
                    self.whiteList = dict["whiteList"] as! String
                }
            }
        }
        public class TestSettingDTO : Tea.TeaModel {
            public class CheckConfig : Tea.TeaModel {
                public class CheckItems : Tea.TeaModel {
                    public var isRequired: Bool?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isRequired != nil {
                            map["isRequired"] = self.isRequired!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("isRequired") {
                            self.isRequired = dict["isRequired"] as! Bool
                        }
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                    }
                }
                public var checkItems: [CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkItems != nil {
                        var tmp : [Any] = []
                        for k in self.checkItems! {
                            tmp.append(k.toMap())
                        }
                        map["checkItems"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("checkItems") {
                        var tmp : [CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems] = []
                        for v in dict["checkItems"] as! [Any] {
                            var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.checkItems = tmp
                    }
                }
            }
            public class CheckTaskQualityConfig : Tea.TeaModel {
                public var bizNo: String?

                public var enabled: Bool?

                public var message: String?

                public var taskName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizNo != nil {
                        map["bizNo"] = self.bizNo!
                    }
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    if self.taskName != nil {
                        map["taskName"] = self.taskName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("bizNo") {
                        self.bizNo = dict["bizNo"] as! String
                    }
                    if dict.keys.contains("enabled") {
                        self.enabled = dict["enabled"] as! Bool
                    }
                    if dict.keys.contains("message") {
                        self.message = dict["message"] as! String
                    }
                    if dict.keys.contains("taskName") {
                        self.taskName = dict["taskName"] as! String
                    }
                }
            }
            public class CodeGuidelinesDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("enabled") {
                        self.enabled = dict["enabled"] as! Bool
                    }
                    if dict.keys.contains("message") {
                        self.message = dict["message"] as! String
                    }
                }
            }
            public class SensitiveInfoDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("enabled") {
                        self.enabled = dict["enabled"] as! Bool
                    }
                    if dict.keys.contains("message") {
                        self.message = dict["message"] as! String
                    }
                }
            }
            public var checkConfig: CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckConfig?

            public var checkTaskQualityConfig: CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig?

            public var codeGuidelinesDetection: CreateProtectdBranchResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection?

            public var isRequired: Bool?

            public var sensitiveInfoDetection: CreateProtectdBranchResponseBody.Result.TestSettingDTO.SensitiveInfoDetection?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.checkConfig?.validate()
                try self.checkTaskQualityConfig?.validate()
                try self.codeGuidelinesDetection?.validate()
                try self.sensitiveInfoDetection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkConfig != nil {
                    map["checkConfig"] = self.checkConfig?.toMap()
                }
                if self.checkTaskQualityConfig != nil {
                    map["checkTaskQualityConfig"] = self.checkTaskQualityConfig?.toMap()
                }
                if self.codeGuidelinesDetection != nil {
                    map["codeGuidelinesDetection"] = self.codeGuidelinesDetection?.toMap()
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.sensitiveInfoDetection != nil {
                    map["sensitiveInfoDetection"] = self.sensitiveInfoDetection?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("checkConfig") {
                    var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckConfig()
                    model.fromMap(dict["checkConfig"] as! [String: Any])
                    self.checkConfig = model
                }
                if dict.keys.contains("checkTaskQualityConfig") {
                    var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig()
                    model.fromMap(dict["checkTaskQualityConfig"] as! [String: Any])
                    self.checkTaskQualityConfig = model
                }
                if dict.keys.contains("codeGuidelinesDetection") {
                    var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection()
                    model.fromMap(dict["codeGuidelinesDetection"] as! [String: Any])
                    self.codeGuidelinesDetection = model
                }
                if dict.keys.contains("isRequired") {
                    self.isRequired = dict["isRequired"] as! Bool
                }
                if dict.keys.contains("sensitiveInfoDetection") {
                    var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO.SensitiveInfoDetection()
                    model.fromMap(dict["sensitiveInfoDetection"] as! [String: Any])
                    self.sensitiveInfoDetection = model
                }
            }
        }
        public var allowMergeRoles: [Int32]?

        public var allowMergeUserIds: [Int64]?

        public var allowPushRoles: [Int32]?

        public var allowPushUserIds: [Int64]?

        public var branch: String?

        public var id: Int64?

        public var mergeRequestSetting: CreateProtectdBranchResponseBody.Result.MergeRequestSetting?

        public var testSettingDTO: CreateProtectdBranchResponseBody.Result.TestSettingDTO?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mergeRequestSetting?.validate()
            try self.testSettingDTO?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowMergeRoles != nil {
                map["allowMergeRoles"] = self.allowMergeRoles!
            }
            if self.allowMergeUserIds != nil {
                map["allowMergeUserIds"] = self.allowMergeUserIds!
            }
            if self.allowPushRoles != nil {
                map["allowPushRoles"] = self.allowPushRoles!
            }
            if self.allowPushUserIds != nil {
                map["allowPushUserIds"] = self.allowPushUserIds!
            }
            if self.branch != nil {
                map["branch"] = self.branch!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.mergeRequestSetting != nil {
                map["mergeRequestSetting"] = self.mergeRequestSetting?.toMap()
            }
            if self.testSettingDTO != nil {
                map["testSettingDTO"] = self.testSettingDTO?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("allowMergeRoles") {
                self.allowMergeRoles = dict["allowMergeRoles"] as! [Int32]
            }
            if dict.keys.contains("allowMergeUserIds") {
                self.allowMergeUserIds = dict["allowMergeUserIds"] as! [Int64]
            }
            if dict.keys.contains("allowPushRoles") {
                self.allowPushRoles = dict["allowPushRoles"] as! [Int32]
            }
            if dict.keys.contains("allowPushUserIds") {
                self.allowPushUserIds = dict["allowPushUserIds"] as! [Int64]
            }
            if dict.keys.contains("branch") {
                self.branch = dict["branch"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("mergeRequestSetting") {
                var model = CreateProtectdBranchResponseBody.Result.MergeRequestSetting()
                model.fromMap(dict["mergeRequestSetting"] as! [String: Any])
                self.mergeRequestSetting = model
            }
            if dict.keys.contains("testSettingDTO") {
                var model = CreateProtectdBranchResponseBody.Result.TestSettingDTO()
                model.fromMap(dict["testSettingDTO"] as! [String: Any])
                self.testSettingDTO = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateProtectdBranchResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateProtectdBranchResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateProtectdBranchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateProtectdBranchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateProtectdBranchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePushRuleRequest : Tea.TeaModel {
    public class RuleInfos : Tea.TeaModel {
        public var checkerName: String?

        public var checkerType: String?

        public var extraMessage: String?

        public var fileRuleRegexes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkerName != nil {
                map["checkerName"] = self.checkerName!
            }
            if self.checkerType != nil {
                map["checkerType"] = self.checkerType!
            }
            if self.extraMessage != nil {
                map["extraMessage"] = self.extraMessage!
            }
            if self.fileRuleRegexes != nil {
                map["fileRuleRegexes"] = self.fileRuleRegexes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("checkerName") {
                self.checkerName = dict["checkerName"] as! String
            }
            if dict.keys.contains("checkerType") {
                self.checkerType = dict["checkerType"] as! String
            }
            if dict.keys.contains("extraMessage") {
                self.extraMessage = dict["extraMessage"] as! String
            }
            if dict.keys.contains("fileRuleRegexes") {
                self.fileRuleRegexes = dict["fileRuleRegexes"] as! [String]
            }
        }
    }
    public var accessToken: String?

    public var ruleInfos: [CreatePushRuleRequest.RuleInfos]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.ruleInfos != nil {
            var tmp : [Any] = []
            for k in self.ruleInfos! {
                tmp.append(k.toMap())
            }
            map["ruleInfos"] = tmp
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("ruleInfos") {
            var tmp : [CreatePushRuleRequest.RuleInfos] = []
            for v in dict["ruleInfos"] as! [Any] {
                var model = CreatePushRuleRequest.RuleInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ruleInfos = tmp
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CreatePushRuleResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class RuleInfos : Tea.TeaModel {
            public var checkerName: String?

            public var checkerType: String?

            public var extraMessage: String?

            public var fileRuleRegexes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkerName != nil {
                    map["checkerName"] = self.checkerName!
                }
                if self.checkerType != nil {
                    map["checkerType"] = self.checkerType!
                }
                if self.extraMessage != nil {
                    map["extraMessage"] = self.extraMessage!
                }
                if self.fileRuleRegexes != nil {
                    map["fileRuleRegexes"] = self.fileRuleRegexes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("checkerName") {
                    self.checkerName = dict["checkerName"] as! String
                }
                if dict.keys.contains("checkerType") {
                    self.checkerType = dict["checkerType"] as! String
                }
                if dict.keys.contains("extraMessage") {
                    self.extraMessage = dict["extraMessage"] as! String
                }
                if dict.keys.contains("fileRuleRegexes") {
                    self.fileRuleRegexes = dict["fileRuleRegexes"] as! [String]
                }
            }
        }
        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var ruleInfos: [CreatePushRuleResponseBody.Result.RuleInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleInfos != nil {
                var tmp : [Any] = []
                for k in self.ruleInfos! {
                    tmp.append(k.toMap())
                }
                map["ruleInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("ruleInfos") {
                var tmp : [CreatePushRuleResponseBody.Result.RuleInfos] = []
                for v in dict["ruleInfos"] as! [Any] {
                    var model = CreatePushRuleResponseBody.Result.RuleInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleInfos = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreatePushRuleResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreatePushRuleResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreatePushRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePushRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePushRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRepositoryRequest : Tea.TeaModel {
    public var accessToken: String?

    public var avatarUrl: String?

    public var description_: String?

    public var gitignoreType: String?

    public var importAccount: String?

    public var importDemoProject: Bool?

    public var importRepoType: String?

    public var importToken: String?

    public var importTokenEncrypted: String?

    public var importUrl: String?

    public var initStandardService: Bool?

    public var isCryptoEnabled: Bool?

    public var localImportUrl: String?

    public var name: String?

    public var namespaceId: Int64?

    public var path: String?

    public var readmeType: String?

    public var visibilityLevel: Int32?

    public var createParentPath: Bool?

    public var organizationId: String?

    public var sync: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.avatarUrl != nil {
            map["avatarUrl"] = self.avatarUrl!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.gitignoreType != nil {
            map["gitignoreType"] = self.gitignoreType!
        }
        if self.importAccount != nil {
            map["importAccount"] = self.importAccount!
        }
        if self.importDemoProject != nil {
            map["importDemoProject"] = self.importDemoProject!
        }
        if self.importRepoType != nil {
            map["importRepoType"] = self.importRepoType!
        }
        if self.importToken != nil {
            map["importToken"] = self.importToken!
        }
        if self.importTokenEncrypted != nil {
            map["importTokenEncrypted"] = self.importTokenEncrypted!
        }
        if self.importUrl != nil {
            map["importUrl"] = self.importUrl!
        }
        if self.initStandardService != nil {
            map["initStandardService"] = self.initStandardService!
        }
        if self.isCryptoEnabled != nil {
            map["isCryptoEnabled"] = self.isCryptoEnabled!
        }
        if self.localImportUrl != nil {
            map["localImportUrl"] = self.localImportUrl!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.namespaceId != nil {
            map["namespaceId"] = self.namespaceId!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.readmeType != nil {
            map["readmeType"] = self.readmeType!
        }
        if self.visibilityLevel != nil {
            map["visibilityLevel"] = self.visibilityLevel!
        }
        if self.createParentPath != nil {
            map["createParentPath"] = self.createParentPath!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.sync != nil {
            map["sync"] = self.sync!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("avatarUrl") {
            self.avatarUrl = dict["avatarUrl"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("gitignoreType") {
            self.gitignoreType = dict["gitignoreType"] as! String
        }
        if dict.keys.contains("importAccount") {
            self.importAccount = dict["importAccount"] as! String
        }
        if dict.keys.contains("importDemoProject") {
            self.importDemoProject = dict["importDemoProject"] as! Bool
        }
        if dict.keys.contains("importRepoType") {
            self.importRepoType = dict["importRepoType"] as! String
        }
        if dict.keys.contains("importToken") {
            self.importToken = dict["importToken"] as! String
        }
        if dict.keys.contains("importTokenEncrypted") {
            self.importTokenEncrypted = dict["importTokenEncrypted"] as! String
        }
        if dict.keys.contains("importUrl") {
            self.importUrl = dict["importUrl"] as! String
        }
        if dict.keys.contains("initStandardService") {
            self.initStandardService = dict["initStandardService"] as! Bool
        }
        if dict.keys.contains("isCryptoEnabled") {
            self.isCryptoEnabled = dict["isCryptoEnabled"] as! Bool
        }
        if dict.keys.contains("localImportUrl") {
            self.localImportUrl = dict["localImportUrl"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("namespaceId") {
            self.namespaceId = dict["namespaceId"] as! Int64
        }
        if dict.keys.contains("path") {
            self.path = dict["path"] as! String
        }
        if dict.keys.contains("readmeType") {
            self.readmeType = dict["readmeType"] as! String
        }
        if dict.keys.contains("visibilityLevel") {
            self.visibilityLevel = dict["visibilityLevel"] as! Int32
        }
        if dict.keys.contains("createParentPath") {
            self.createParentPath = dict["createParentPath"] as! Bool
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("sync") {
            self.sync = dict["sync"] as! Bool
        }
    }
}

public class CreateRepositoryResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Namespace : Tea.TeaModel {
            public var avatar: String?

            public var createdAt: String?

            public var description_: String?

            public var id: Int64?

            public var name: String?

            public var ownerId: Int64?

            public var path: String?

            public var public_: Bool?

            public var updatedAt: String?

            public var visibilityLevel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.ownerId != nil {
                    map["ownerId"] = self.ownerId!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.public_ != nil {
                    map["public"] = self.public_!
                }
                if self.updatedAt != nil {
                    map["updatedAt"] = self.updatedAt!
                }
                if self.visibilityLevel != nil {
                    map["visibilityLevel"] = self.visibilityLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatar") {
                    self.avatar = dict["avatar"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("ownerId") {
                    self.ownerId = dict["ownerId"] as! Int64
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("public") {
                    self.public_ = dict["public"] as! Bool
                }
                if dict.keys.contains("updatedAt") {
                    self.updatedAt = dict["updatedAt"] as! String
                }
                if dict.keys.contains("visibilityLevel") {
                    self.visibilityLevel = dict["visibilityLevel"] as! String
                }
            }
        }
        public var importFromSvn: Bool?

        public var archived: Bool?

        public var avatarUrl: String?

        public var createdAt: String?

        public var creatorId: Int64?

        public var defaultBranch: String?

        public var demoProject: Bool?

        public var description_: String?

        public var httpUrlToRepo: String?

        public var id: Int64?

        public var lastActivityAt: String?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespace: CreateRepositoryResponseBody.Result.Namespace?

        public var path: String?

        public var pathWithNamespace: String?

        public var sshUrlToRepo: String?

        public var visibilityLevel: String?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.namespace?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.importFromSvn != nil {
                map["Import_from_svn"] = self.importFromSvn!
            }
            if self.archived != nil {
                map["archived"] = self.archived!
            }
            if self.avatarUrl != nil {
                map["avatar_url"] = self.avatarUrl!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.defaultBranch != nil {
                map["defaultBranch"] = self.defaultBranch!
            }
            if self.demoProject != nil {
                map["demoProject"] = self.demoProject!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.httpUrlToRepo != nil {
                map["httpUrlToRepo"] = self.httpUrlToRepo!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespace != nil {
                map["namespace"] = self.namespace?.toMap()
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.sshUrlToRepo != nil {
                map["sshUrlToRepo"] = self.sshUrlToRepo!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Import_from_svn") {
                self.importFromSvn = dict["Import_from_svn"] as! Bool
            }
            if dict.keys.contains("archived") {
                self.archived = dict["archived"] as! Bool
            }
            if dict.keys.contains("avatar_url") {
                self.avatarUrl = dict["avatar_url"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("creatorId") {
                self.creatorId = dict["creatorId"] as! Int64
            }
            if dict.keys.contains("defaultBranch") {
                self.defaultBranch = dict["defaultBranch"] as! String
            }
            if dict.keys.contains("demoProject") {
                self.demoProject = dict["demoProject"] as! Bool
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("httpUrlToRepo") {
                self.httpUrlToRepo = dict["httpUrlToRepo"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("lastActivityAt") {
                self.lastActivityAt = dict["lastActivityAt"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("namespace") {
                var model = CreateRepositoryResponseBody.Result.Namespace()
                model.fromMap(dict["namespace"] as! [String: Any])
                self.namespace = model
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("pathWithNamespace") {
                self.pathWithNamespace = dict["pathWithNamespace"] as! String
            }
            if dict.keys.contains("sshUrlToRepo") {
                self.sshUrlToRepo = dict["sshUrlToRepo"] as! String
            }
            if dict.keys.contains("visibilityLevel") {
                self.visibilityLevel = dict["visibilityLevel"] as! String
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateRepositoryResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateRepositoryResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRepositoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRepositoryGroupRequest : Tea.TeaModel {
    public var accessToken: String?

    public var avatarUrl: String?

    public var description_: String?

    public var name: String?

    public var parentId: Int64?

    public var path: String?

    public var visibilityLevel: Int32?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.avatarUrl != nil {
            map["avatarUrl"] = self.avatarUrl!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.parentId != nil {
            map["parentId"] = self.parentId!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.visibilityLevel != nil {
            map["visibilityLevel"] = self.visibilityLevel!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("avatarUrl") {
            self.avatarUrl = dict["avatarUrl"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("parentId") {
            self.parentId = dict["parentId"] as! Int64
        }
        if dict.keys.contains("path") {
            self.path = dict["path"] as! String
        }
        if dict.keys.contains("visibilityLevel") {
            self.visibilityLevel = dict["visibilityLevel"] as! Int32
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CreateRepositoryGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var avatarUrl: String?

        public var description_: String?

        public var id: Int64?

        public var name: String?

        public var nameWithNamespace: String?

        public var ownerId: Int64?

        public var parentId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var type: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("ownerId") {
                self.ownerId = dict["ownerId"] as! Int64
            }
            if dict.keys.contains("parentId") {
                self.parentId = dict["parentId"] as! Int64
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("pathWithNamespace") {
                self.pathWithNamespace = dict["pathWithNamespace"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("visibilityLevel") {
                self.visibilityLevel = dict["visibilityLevel"] as! Int32
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateRepositoryGroupResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateRepositoryGroupResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateRepositoryGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRepositoryGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRepositoryGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateResourceMemberRequest : Tea.TeaModel {
    public var accountId: String?

    public var roleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        if self.roleName != nil {
            map["roleName"] = self.roleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accountId") {
            self.accountId = dict["accountId"] as! String
        }
        if dict.keys.contains("roleName") {
            self.roleName = dict["roleName"] as! String
        }
    }
}

public class CreateResourceMemberResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateResourceMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateResourceMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateResourceMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateServiceAuthRequest : Tea.TeaModel {
    public var serviceAuthType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serviceAuthType != nil {
            map["serviceAuthType"] = self.serviceAuthType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("serviceAuthType") {
            self.serviceAuthType = dict["serviceAuthType"] as! String
        }
    }
}

public class CreateServiceAuthResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var id: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateServiceAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateServiceAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateServiceConnectionRequest : Tea.TeaModel {
    public var authType: String?

    public var connectionName: String?

    public var connectionType: String?

    public var scope: String?

    public var serviceAuthId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authType != nil {
            map["authType"] = self.authType!
        }
        if self.connectionName != nil {
            map["connectionName"] = self.connectionName!
        }
        if self.connectionType != nil {
            map["connectionType"] = self.connectionType!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.serviceAuthId != nil {
            map["serviceAuthId"] = self.serviceAuthId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("authType") {
            self.authType = dict["authType"] as! String
        }
        if dict.keys.contains("connectionName") {
            self.connectionName = dict["connectionName"] as! String
        }
        if dict.keys.contains("connectionType") {
            self.connectionType = dict["connectionType"] as! String
        }
        if dict.keys.contains("scope") {
            self.scope = dict["scope"] as! String
        }
        if dict.keys.contains("serviceAuthId") {
            self.serviceAuthId = dict["serviceAuthId"] as! Int64
        }
    }
}

public class CreateServiceConnectionResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var id: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateServiceConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateServiceConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateServiceCredentialRequest : Tea.TeaModel {
    public var name: String?

    public var password: String?

    public var scope: String?

    public var type: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.username != nil {
            map["username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("password") {
            self.password = dict["password"] as! String
        }
        if dict.keys.contains("scope") {
            self.scope = dict["scope"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
        if dict.keys.contains("username") {
            self.username = dict["username"] as! String
        }
    }
}

public class CreateServiceCredentialResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var id: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateServiceCredentialResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceCredentialResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateServiceCredentialResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSprintRequest : Tea.TeaModel {
    public var endDate: String?

    public var name: String?

    public var spaceIdentifier: String?

    public var staffIds: [String]?

    public var startDate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endDate != nil {
            map["endDate"] = self.endDate!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.staffIds != nil {
            map["staffIds"] = self.staffIds!
        }
        if self.startDate != nil {
            map["startDate"] = self.startDate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endDate") {
            self.endDate = dict["endDate"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("spaceIdentifier") {
            self.spaceIdentifier = dict["spaceIdentifier"] as! String
        }
        if dict.keys.contains("staffIds") {
            self.staffIds = dict["staffIds"] as! [String]
        }
        if dict.keys.contains("startDate") {
            self.startDate = dict["startDate"] as! String
        }
    }
}

public class CreateSprintResponseBody : Tea.TeaModel {
    public class Sprint : Tea.TeaModel {
        public var creator: String?

        public var description_: String?

        public var endDate: Int64?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var scope: String?

        public var spaceIdentifier: String?

        public var startDate: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endDate != nil {
                map["endDate"] = self.endDate!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.startDate != nil {
                map["startDate"] = self.startDate!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("endDate") {
                self.endDate = dict["endDate"] as! Int64
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("scope") {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("startDate") {
                self.startDate = dict["startDate"] as! Int64
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var sprint: CreateSprintResponseBody.Sprint?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sprint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.sprint != nil {
            map["sprint"] = self.sprint?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("sprint") {
            var model = CreateSprintResponseBody.Sprint()
            model.fromMap(dict["sprint"] as! [String: Any])
            self.sprint = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateSprintResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSprintResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSprintResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSshKeyResponseBody : Tea.TeaModel {
    public class SshKey : Tea.TeaModel {
        public var id: Int64?

        public var publicKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.publicKey != nil {
                map["publicKey"] = self.publicKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("publicKey") {
                self.publicKey = dict["publicKey"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sshKey: CreateSshKeyResponseBody.SshKey?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sshKey?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.sshKey != nil {
            map["sshKey"] = self.sshKey?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("sshKey") {
            var model = CreateSshKeyResponseBody.SshKey()
            model.fromMap(dict["sshKey"] as! [String: Any])
            self.sshKey = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateSshKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSshKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSshKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTagRequest : Tea.TeaModel {
    public var accessToken: String?

    public var message: String?

    public var ref: String?

    public var tagName: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.ref != nil {
            map["ref"] = self.ref!
        }
        if self.tagName != nil {
            map["tagName"] = self.tagName!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("ref") {
            self.ref = dict["ref"] as! String
        }
        if dict.keys.contains("tagName") {
            self.tagName = dict["tagName"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CreateTagResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var committedDate: String?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("authorEmail") {
                    self.authorEmail = dict["authorEmail"] as! String
                }
                if dict.keys.contains("authorName") {
                    self.authorName = dict["authorName"] as! String
                }
                if dict.keys.contains("authoredDate") {
                    self.authoredDate = dict["authoredDate"] as! String
                }
                if dict.keys.contains("committedDate") {
                    self.committedDate = dict["committedDate"] as! String
                }
                if dict.keys.contains("committerEmail") {
                    self.committerEmail = dict["committerEmail"] as! String
                }
                if dict.keys.contains("committerName") {
                    self.committerName = dict["committerName"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("parentIds") {
                    self.parentIds = dict["parentIds"] as! [String]
                }
                if dict.keys.contains("shortId") {
                    self.shortId = dict["shortId"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public var commit: CreateTagResponseBody.Result.Commit?

        public var id: String?

        public var message: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("commit") {
                var model = CreateTagResponseBody.Result.Commit()
                model.fromMap(dict["commit"] as! [String: Any])
                self.commit = model
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("message") {
                self.message = dict["message"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateTagResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateTagResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTestCaseRequest : Tea.TeaModel {
    public class FieldValueList : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldIdentifier") {
                self.fieldIdentifier = dict["fieldIdentifier"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public class TestcaseStepContentInfo : Tea.TeaModel {
        public class StepResultList : Tea.TeaModel {
            public var expected: String?

            public var step: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expected != nil {
                    map["expected"] = self.expected!
                }
                if self.step != nil {
                    map["step"] = self.step!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("expected") {
                    self.expected = dict["expected"] as! String
                }
                if dict.keys.contains("step") {
                    self.step = dict["step"] as! String
                }
            }
        }
        public var precondition: String?

        public var stepResultList: [CreateTestCaseRequest.TestcaseStepContentInfo.StepResultList]?

        public var stepType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.precondition != nil {
                map["precondition"] = self.precondition!
            }
            if self.stepResultList != nil {
                var tmp : [Any] = []
                for k in self.stepResultList! {
                    tmp.append(k.toMap())
                }
                map["stepResultList"] = tmp
            }
            if self.stepType != nil {
                map["stepType"] = self.stepType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("precondition") {
                self.precondition = dict["precondition"] as! String
            }
            if dict.keys.contains("stepResultList") {
                var tmp : [CreateTestCaseRequest.TestcaseStepContentInfo.StepResultList] = []
                for v in dict["stepResultList"] as! [Any] {
                    var model = CreateTestCaseRequest.TestcaseStepContentInfo.StepResultList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.stepResultList = tmp
            }
            if dict.keys.contains("stepType") {
                self.stepType = dict["stepType"] as! String
            }
        }
    }
    public var assignedTo: String?

    public var directoryIdentifier: String?

    public var fieldValueList: [CreateTestCaseRequest.FieldValueList]?

    public var priority: String?

    public var spaceIdentifier: String?

    public var subject: String?

    public var tags: [String]?

    public var testcaseStepContentInfo: CreateTestCaseRequest.TestcaseStepContentInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.testcaseStepContentInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedTo != nil {
            map["assignedTo"] = self.assignedTo!
        }
        if self.directoryIdentifier != nil {
            map["directoryIdentifier"] = self.directoryIdentifier!
        }
        if self.fieldValueList != nil {
            var tmp : [Any] = []
            for k in self.fieldValueList! {
                tmp.append(k.toMap())
            }
            map["fieldValueList"] = tmp
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        if self.testcaseStepContentInfo != nil {
            map["testcaseStepContentInfo"] = self.testcaseStepContentInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assignedTo") {
            self.assignedTo = dict["assignedTo"] as! String
        }
        if dict.keys.contains("directoryIdentifier") {
            self.directoryIdentifier = dict["directoryIdentifier"] as! String
        }
        if dict.keys.contains("fieldValueList") {
            var tmp : [CreateTestCaseRequest.FieldValueList] = []
            for v in dict["fieldValueList"] as! [Any] {
                var model = CreateTestCaseRequest.FieldValueList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fieldValueList = tmp
        }
        if dict.keys.contains("priority") {
            self.priority = dict["priority"] as! String
        }
        if dict.keys.contains("spaceIdentifier") {
            self.spaceIdentifier = dict["spaceIdentifier"] as! String
        }
        if dict.keys.contains("subject") {
            self.subject = dict["subject"] as! String
        }
        if dict.keys.contains("tags") {
            self.tags = dict["tags"] as! [String]
        }
        if dict.keys.contains("testcaseStepContentInfo") {
            var model = CreateTestCaseRequest.TestcaseStepContentInfo()
            model.fromMap(dict["testcaseStepContentInfo"] as! [String: Any])
            self.testcaseStepContentInfo = model
        }
    }
}

public class CreateTestCaseResponseBody : Tea.TeaModel {
    public class Testcase : Tea.TeaModel {
        public class AssignedTo : Tea.TeaModel {
            public var assignIdentifier: String?

            public var name: String?

            public var tbRoleId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assignIdentifier != nil {
                    map["assignIdentifier"] = self.assignIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.tbRoleId != nil {
                    map["tbRoleId"] = self.tbRoleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("assignIdentifier") {
                    self.assignIdentifier = dict["assignIdentifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("tbRoleId") {
                    self.tbRoleId = dict["tbRoleId"] as! String
                }
            }
        }
        public class Creator : Tea.TeaModel {
            public var createIdentifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createIdentifier != nil {
                    map["createIdentifier"] = self.createIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("createIdentifier") {
                    self.createIdentifier = dict["createIdentifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class DetailInfo : Tea.TeaModel {
            public class ExpectedResult : Tea.TeaModel {
                public var expectContent: String?

                public var expectContentType: String?

                public var expectIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expectContent != nil {
                        map["expectContent"] = self.expectContent!
                    }
                    if self.expectContentType != nil {
                        map["expectContentType"] = self.expectContentType!
                    }
                    if self.expectIdentifier != nil {
                        map["expectIdentifier"] = self.expectIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("expectContent") {
                        self.expectContent = dict["expectContent"] as! String
                    }
                    if dict.keys.contains("expectContentType") {
                        self.expectContentType = dict["expectContentType"] as! String
                    }
                    if dict.keys.contains("expectIdentifier") {
                        self.expectIdentifier = dict["expectIdentifier"] as! String
                    }
                }
            }
            public class Precondition : Tea.TeaModel {
                public var preContent: String?

                public var preContentType: String?

                public var preIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.preContent != nil {
                        map["preContent"] = self.preContent!
                    }
                    if self.preContentType != nil {
                        map["preContentType"] = self.preContentType!
                    }
                    if self.preIdentifier != nil {
                        map["preIdentifier"] = self.preIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("preContent") {
                        self.preContent = dict["preContent"] as! String
                    }
                    if dict.keys.contains("preContentType") {
                        self.preContentType = dict["preContentType"] as! String
                    }
                    if dict.keys.contains("preIdentifier") {
                        self.preIdentifier = dict["preIdentifier"] as! String
                    }
                }
            }
            public class StepContent : Tea.TeaModel {
                public var stepContent: String?

                public var stepContentType: String?

                public var stepIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.stepContent != nil {
                        map["stepContent"] = self.stepContent!
                    }
                    if self.stepContentType != nil {
                        map["stepContentType"] = self.stepContentType!
                    }
                    if self.stepIdentifier != nil {
                        map["stepIdentifier"] = self.stepIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("stepContent") {
                        self.stepContent = dict["stepContent"] as! String
                    }
                    if dict.keys.contains("stepContentType") {
                        self.stepContentType = dict["stepContentType"] as! String
                    }
                    if dict.keys.contains("stepIdentifier") {
                        self.stepIdentifier = dict["stepIdentifier"] as! String
                    }
                }
            }
            public var expectedResult: CreateTestCaseResponseBody.Testcase.DetailInfo.ExpectedResult?

            public var precondition: CreateTestCaseResponseBody.Testcase.DetailInfo.Precondition?

            public var stepContent: CreateTestCaseResponseBody.Testcase.DetailInfo.StepContent?

            public var stepType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.expectedResult?.validate()
                try self.precondition?.validate()
                try self.stepContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expectedResult != nil {
                    map["expectedResult"] = self.expectedResult?.toMap()
                }
                if self.precondition != nil {
                    map["precondition"] = self.precondition?.toMap()
                }
                if self.stepContent != nil {
                    map["stepContent"] = self.stepContent?.toMap()
                }
                if self.stepType != nil {
                    map["stepType"] = self.stepType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("expectedResult") {
                    var model = CreateTestCaseResponseBody.Testcase.DetailInfo.ExpectedResult()
                    model.fromMap(dict["expectedResult"] as! [String: Any])
                    self.expectedResult = model
                }
                if dict.keys.contains("precondition") {
                    var model = CreateTestCaseResponseBody.Testcase.DetailInfo.Precondition()
                    model.fromMap(dict["precondition"] as! [String: Any])
                    self.precondition = model
                }
                if dict.keys.contains("stepContent") {
                    var model = CreateTestCaseResponseBody.Testcase.DetailInfo.StepContent()
                    model.fromMap(dict["stepContent"] as! [String: Any])
                    self.stepContent = model
                }
                if dict.keys.contains("stepType") {
                    self.stepType = dict["stepType"] as! String
                }
            }
        }
        public class Directory : Tea.TeaModel {
            public var childIdentifier: String?

            public var directoryIdentifier: String?

            public var name: String?

            public var pathName: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.childIdentifier != nil {
                    map["childIdentifier"] = self.childIdentifier!
                }
                if self.directoryIdentifier != nil {
                    map["directoryIdentifier"] = self.directoryIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.pathName != nil {
                    map["pathName"] = self.pathName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("childIdentifier") {
                    self.childIdentifier = dict["childIdentifier"] as! String
                }
                if dict.keys.contains("directoryIdentifier") {
                    self.directoryIdentifier = dict["directoryIdentifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("pathName") {
                    self.pathName = dict["pathName"] as! [String]
                }
            }
        }
        public class Modifier : Tea.TeaModel {
            public var modifyIdentifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.modifyIdentifier != nil {
                    map["modifyIdentifier"] = self.modifyIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("modifyIdentifier") {
                    self.modifyIdentifier = dict["modifyIdentifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public var assignedTo: CreateTestCaseResponseBody.Testcase.AssignedTo?

        public var categoryIdentifier: String?

        public var creator: CreateTestCaseResponseBody.Testcase.Creator?

        public var detailInfo: CreateTestCaseResponseBody.Testcase.DetailInfo?

        public var directory: CreateTestCaseResponseBody.Testcase.Directory?

        public var identifier: String?

        public var modifier: CreateTestCaseResponseBody.Testcase.Modifier?

        public var spaceIdentifier: String?

        public var spaceType: String?

        public var subject: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.assignedTo?.validate()
            try self.creator?.validate()
            try self.detailInfo?.validate()
            try self.directory?.validate()
            try self.modifier?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo?.toMap()
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator?.toMap()
            }
            if self.detailInfo != nil {
                map["detailInfo"] = self.detailInfo?.toMap()
            }
            if self.directory != nil {
                map["directory"] = self.directory?.toMap()
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier?.toMap()
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedTo") {
                var model = CreateTestCaseResponseBody.Testcase.AssignedTo()
                model.fromMap(dict["assignedTo"] as! [String: Any])
                self.assignedTo = model
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                var model = CreateTestCaseResponseBody.Testcase.Creator()
                model.fromMap(dict["creator"] as! [String: Any])
                self.creator = model
            }
            if dict.keys.contains("detailInfo") {
                var model = CreateTestCaseResponseBody.Testcase.DetailInfo()
                model.fromMap(dict["detailInfo"] as! [String: Any])
                self.detailInfo = model
            }
            if dict.keys.contains("directory") {
                var model = CreateTestCaseResponseBody.Testcase.Directory()
                model.fromMap(dict["directory"] as! [String: Any])
                self.directory = model
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("modifier") {
                var model = CreateTestCaseResponseBody.Testcase.Modifier()
                model.fromMap(dict["modifier"] as! [String: Any])
                self.modifier = model
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("spaceType") {
                self.spaceType = dict["spaceType"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var testcase: CreateTestCaseResponseBody.Testcase?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.testcase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.testcase != nil {
            map["testcase"] = self.testcase?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("testcase") {
            var model = CreateTestCaseResponseBody.Testcase()
            model.fromMap(dict["testcase"] as! [String: Any])
            self.testcase = model
        }
    }
}

public class CreateTestCaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTestCaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTestCaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUserKeyRequest : Tea.TeaModel {
    public var accessToken: String?

    public var expireTime: String?

    public var keyScope: String?

    public var publicKey: String?

    public var title: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.expireTime != nil {
            map["expireTime"] = self.expireTime!
        }
        if self.keyScope != nil {
            map["keyScope"] = self.keyScope!
        }
        if self.publicKey != nil {
            map["publicKey"] = self.publicKey!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("expireTime") {
            self.expireTime = dict["expireTime"] as! String
        }
        if dict.keys.contains("keyScope") {
            self.keyScope = dict["keyScope"] as! String
        }
        if dict.keys.contains("publicKey") {
            self.publicKey = dict["publicKey"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class CreateUserKeyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var expireTime: String?

        public var fingerPrint: String?

        public var id: Int64?

        public var keyScope: String?

        public var lastUsedTime: String?

        public var publicKey: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.expireTime != nil {
                map["expireTime"] = self.expireTime!
            }
            if self.fingerPrint != nil {
                map["fingerPrint"] = self.fingerPrint!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.keyScope != nil {
                map["keyScope"] = self.keyScope!
            }
            if self.lastUsedTime != nil {
                map["lastUsedTime"] = self.lastUsedTime!
            }
            if self.publicKey != nil {
                map["publicKey"] = self.publicKey!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("expireTime") {
                self.expireTime = dict["expireTime"] as! String
            }
            if dict.keys.contains("fingerPrint") {
                self.fingerPrint = dict["fingerPrint"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("keyScope") {
                self.keyScope = dict["keyScope"] as! String
            }
            if dict.keys.contains("lastUsedTime") {
                self.lastUsedTime = dict["lastUsedTime"] as! String
            }
            if dict.keys.contains("publicKey") {
                self.publicKey = dict["publicKey"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateUserKeyResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = CreateUserKeyResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateUserKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUserKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUserKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVariableGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var variables: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.variables != nil {
            map["variables"] = self.variables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("variables") {
            self.variables = dict["variables"] as! String
        }
    }
}

public class CreateVariableGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var variableGroupId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.variableGroupId != nil {
            map["variableGroupId"] = self.variableGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("variableGroupId") {
            self.variableGroupId = dict["variableGroupId"] as! Int64
        }
    }
}

public class CreateVariableGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVariableGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVariableGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkitemRequest : Tea.TeaModel {
    public class FieldValueList : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var value: String?

        public var workitemIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            if self.workitemIdentifier != nil {
                map["workitemIdentifier"] = self.workitemIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldIdentifier") {
                self.fieldIdentifier = dict["fieldIdentifier"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
            if dict.keys.contains("workitemIdentifier") {
                self.workitemIdentifier = dict["workitemIdentifier"] as! String
            }
        }
    }
    public var assignedTo: String?

    public var category: String?

    public var description_: String?

    public var descriptionFormat: String?

    public var fieldValueList: [CreateWorkitemRequest.FieldValueList]?

    public var parent: String?

    public var participant: [String]?

    public var space: String?

    public var spaceIdentifier: String?

    public var spaceType: String?

    public var sprint: [String]?

    public var subject: String?

    public var tracker: [String]?

    public var verifier: [String]?

    public var workitemType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedTo != nil {
            map["assignedTo"] = self.assignedTo!
        }
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.descriptionFormat != nil {
            map["descriptionFormat"] = self.descriptionFormat!
        }
        if self.fieldValueList != nil {
            var tmp : [Any] = []
            for k in self.fieldValueList! {
                tmp.append(k.toMap())
            }
            map["fieldValueList"] = tmp
        }
        if self.parent != nil {
            map["parent"] = self.parent!
        }
        if self.participant != nil {
            map["participant"] = self.participant!
        }
        if self.space != nil {
            map["space"] = self.space!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        if self.sprint != nil {
            map["sprint"] = self.sprint!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.tracker != nil {
            map["tracker"] = self.tracker!
        }
        if self.verifier != nil {
            map["verifier"] = self.verifier!
        }
        if self.workitemType != nil {
            map["workitemType"] = self.workitemType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assignedTo") {
            self.assignedTo = dict["assignedTo"] as! String
        }
        if dict.keys.contains("category") {
            self.category = dict["category"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("descriptionFormat") {
            self.descriptionFormat = dict["descriptionFormat"] as! String
        }
        if dict.keys.contains("fieldValueList") {
            var tmp : [CreateWorkitemRequest.FieldValueList] = []
            for v in dict["fieldValueList"] as! [Any] {
                var model = CreateWorkitemRequest.FieldValueList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fieldValueList = tmp
        }
        if dict.keys.contains("parent") {
            self.parent = dict["parent"] as! String
        }
        if dict.keys.contains("participant") {
            self.participant = dict["participant"] as! [String]
        }
        if dict.keys.contains("space") {
            self.space = dict["space"] as! String
        }
        if dict.keys.contains("spaceIdentifier") {
            self.spaceIdentifier = dict["spaceIdentifier"] as! String
        }
        if dict.keys.contains("spaceType") {
            self.spaceType = dict["spaceType"] as! String
        }
        if dict.keys.contains("sprint") {
            self.sprint = dict["sprint"] as! [String]
        }
        if dict.keys.contains("subject") {
            self.subject = dict["subject"] as! String
        }
        if dict.keys.contains("tracker") {
            self.tracker = dict["tracker"] as! [String]
        }
        if dict.keys.contains("verifier") {
            self.verifier = dict["verifier"] as! [String]
        }
        if dict.keys.contains("workitemType") {
            self.workitemType = dict["workitemType"] as! String
        }
    }
}

public class CreateWorkitemResponseBody : Tea.TeaModel {
    public class Workitem : Tea.TeaModel {
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var document: String?

        public var documentFormat: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var parentIdentifier: String?

        public var serialNumber: String?

        public var spaceIdentifier: String?

        public var spaceName: String?

        public var spaceType: String?

        public var sprintIdentifier: String?

        public var status: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subject: String?

        public var updateStatusAt: Int64?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.document != nil {
                map["document"] = self.document!
            }
            if self.documentFormat != nil {
                map["documentFormat"] = self.documentFormat!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceName != nil {
                map["spaceName"] = self.spaceName!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.sprintIdentifier != nil {
                map["sprintIdentifier"] = self.sprintIdentifier!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.updateStatusAt != nil {
                map["updateStatusAt"] = self.updateStatusAt!
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedTo") {
                self.assignedTo = dict["assignedTo"] as! String
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("document") {
                self.document = dict["document"] as! String
            }
            if dict.keys.contains("documentFormat") {
                self.documentFormat = dict["documentFormat"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("logicalStatus") {
                self.logicalStatus = dict["logicalStatus"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("parentIdentifier") {
                self.parentIdentifier = dict["parentIdentifier"] as! String
            }
            if dict.keys.contains("serialNumber") {
                self.serialNumber = dict["serialNumber"] as! String
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("spaceName") {
                self.spaceName = dict["spaceName"] as! String
            }
            if dict.keys.contains("spaceType") {
                self.spaceType = dict["spaceType"] as! String
            }
            if dict.keys.contains("sprintIdentifier") {
                self.sprintIdentifier = dict["sprintIdentifier"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("statusIdentifier") {
                self.statusIdentifier = dict["statusIdentifier"] as! String
            }
            if dict.keys.contains("statusStageIdentifier") {
                self.statusStageIdentifier = dict["statusStageIdentifier"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("updateStatusAt") {
                self.updateStatusAt = dict["updateStatusAt"] as! Int64
            }
            if dict.keys.contains("workitemTypeIdentifier") {
                self.workitemTypeIdentifier = dict["workitemTypeIdentifier"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var workitem: CreateWorkitemResponseBody.Workitem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitem != nil {
            map["workitem"] = self.workitem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("workitem") {
            var model = CreateWorkitemResponseBody.Workitem()
            model.fromMap(dict["workitem"] as! [String: Any])
            self.workitem = model
        }
    }
}

public class CreateWorkitemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkitemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWorkitemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkitemCommentRequest : Tea.TeaModel {
    public var content: String?

    public var formatType: String?

    public var parentId: String?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.formatType != nil {
            map["formatType"] = self.formatType!
        }
        if self.parentId != nil {
            map["parentId"] = self.parentId!
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("formatType") {
            self.formatType = dict["formatType"] as! String
        }
        if dict.keys.contains("parentId") {
            self.parentId = dict["parentId"] as! String
        }
        if dict.keys.contains("workitemIdentifier") {
            self.workitemIdentifier = dict["workitemIdentifier"] as! String
        }
    }
}

public class CreateWorkitemCommentResponseBody : Tea.TeaModel {
    public class Comment : Tea.TeaModel {
        public class User : Tea.TeaModel {
            public var account: String?

            public var avatar: String?

            public var displayName: String?

            public var identifier: String?

            public var nickName: String?

            public var realName: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["account"] = self.account!
                }
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.nickName != nil {
                    map["nickName"] = self.nickName!
                }
                if self.realName != nil {
                    map["realName"] = self.realName!
                }
                if self.targetType != nil {
                    map["targetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("account") {
                    self.account = dict["account"] as! String
                }
                if dict.keys.contains("avatar") {
                    self.avatar = dict["avatar"] as! String
                }
                if dict.keys.contains("displayName") {
                    self.displayName = dict["displayName"] as! String
                }
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
                if dict.keys.contains("nickName") {
                    self.nickName = dict["nickName"] as! String
                }
                if dict.keys.contains("realName") {
                    self.realName = dict["realName"] as! String
                }
                if dict.keys.contains("targetType") {
                    self.targetType = dict["targetType"] as! String
                }
            }
        }
        public var id: Int64?

        public var content: String?

        public var createTime: Int64?

        public var formatType: String?

        public var isTop: Bool?

        public var modifiedTime: Int64?

        public var parentId: Int64?

        public var targetIdentifier: String?

        public var targetType: String?

        public var topTime: Int64?

        public var user: CreateWorkitemCommentResponseBody.Comment.User?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.user?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.formatType != nil {
                map["formatType"] = self.formatType!
            }
            if self.isTop != nil {
                map["isTop"] = self.isTop!
            }
            if self.modifiedTime != nil {
                map["modifiedTime"] = self.modifiedTime!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.targetIdentifier != nil {
                map["targetIdentifier"] = self.targetIdentifier!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.topTime != nil {
                map["topTime"] = self.topTime!
            }
            if self.user != nil {
                map["user"] = self.user?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("formatType") {
                self.formatType = dict["formatType"] as! String
            }
            if dict.keys.contains("isTop") {
                self.isTop = dict["isTop"] as! Bool
            }
            if dict.keys.contains("modifiedTime") {
                self.modifiedTime = dict["modifiedTime"] as! Int64
            }
            if dict.keys.contains("parentId") {
                self.parentId = dict["parentId"] as! Int64
            }
            if dict.keys.contains("targetIdentifier") {
                self.targetIdentifier = dict["targetIdentifier"] as! String
            }
            if dict.keys.contains("targetType") {
                self.targetType = dict["targetType"] as! String
            }
            if dict.keys.contains("topTime") {
                self.topTime = dict["topTime"] as! Int64
            }
            if dict.keys.contains("user") {
                var model = CreateWorkitemCommentResponseBody.Comment.User()
                model.fromMap(dict["user"] as! [String: Any])
                self.user = model
            }
        }
    }
    public var comment: CreateWorkitemCommentResponseBody.Comment?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.comment?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            var model = CreateWorkitemCommentResponseBody.Comment()
            model.fromMap(dict["Comment"] as! [String: Any])
            self.comment = model
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
    }
}

public class CreateWorkitemCommentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkitemCommentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWorkitemCommentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkitemEstimateRequest : Tea.TeaModel {
    public var description_: String?

    public var recordUserIdentifier: String?

    public var spentTime: String?

    public var type: String?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.recordUserIdentifier != nil {
            map["recordUserIdentifier"] = self.recordUserIdentifier!
        }
        if self.spentTime != nil {
            map["spentTime"] = self.spentTime!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("recordUserIdentifier") {
            self.recordUserIdentifier = dict["recordUserIdentifier"] as! String
        }
        if dict.keys.contains("spentTime") {
            self.spentTime = dict["spentTime"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
        if dict.keys.contains("workitemIdentifier") {
            self.workitemIdentifier = dict["workitemIdentifier"] as! String
        }
    }
}

public class CreateWorkitemEstimateResponseBody : Tea.TeaModel {
    public class WorkitemTimeEstimate : Tea.TeaModel {
        public class RecordUser : Tea.TeaModel {
            public var account: String?

            public var avatar: String?

            public var dingTalkId: String?

            public var displayName: String?

            public var displayNickName: String?

            public var displayRealName: String?

            public var email: String?

            public var gender: String?

            public var identifier: String?

            public var isDisabled: Bool?

            public var mobile: String?

            public var nameEn: String?

            public var nickName: String?

            public var nickNamePinyin: String?

            public var realName: String?

            public var realNamePinyin: String?

            public var stamp: String?

            public var tbRoleId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["account"] = self.account!
                }
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.dingTalkId != nil {
                    map["dingTalkId"] = self.dingTalkId!
                }
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.displayNickName != nil {
                    map["displayNickName"] = self.displayNickName!
                }
                if self.displayRealName != nil {
                    map["displayRealName"] = self.displayRealName!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.gender != nil {
                    map["gender"] = self.gender!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.isDisabled != nil {
                    map["isDisabled"] = self.isDisabled!
                }
                if self.mobile != nil {
                    map["mobile"] = self.mobile!
                }
                if self.nameEn != nil {
                    map["nameEn"] = self.nameEn!
                }
                if self.nickName != nil {
                    map["nickName"] = self.nickName!
                }
                if self.nickNamePinyin != nil {
                    map["nickNamePinyin"] = self.nickNamePinyin!
                }
                if self.realName != nil {
                    map["realName"] = self.realName!
                }
                if self.realNamePinyin != nil {
                    map["realNamePinyin"] = self.realNamePinyin!
                }
                if self.stamp != nil {
                    map["stamp"] = self.stamp!
                }
                if self.tbRoleId != nil {
                    map["tbRoleId"] = self.tbRoleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("account") {
                    self.account = dict["account"] as! String
                }
                if dict.keys.contains("avatar") {
                    self.avatar = dict["avatar"] as! String
                }
                if dict.keys.contains("dingTalkId") {
                    self.dingTalkId = dict["dingTalkId"] as! String
                }
                if dict.keys.contains("displayName") {
                    self.displayName = dict["displayName"] as! String
                }
                if dict.keys.contains("displayNickName") {
                    self.displayNickName = dict["displayNickName"] as! String
                }
                if dict.keys.contains("displayRealName") {
                    self.displayRealName = dict["displayRealName"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("gender") {
                    self.gender = dict["gender"] as! String
                }
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
                if dict.keys.contains("isDisabled") {
                    self.isDisabled = dict["isDisabled"] as! Bool
                }
                if dict.keys.contains("mobile") {
                    self.mobile = dict["mobile"] as! String
                }
                if dict.keys.contains("nameEn") {
                    self.nameEn = dict["nameEn"] as! String
                }
                if dict.keys.contains("nickName") {
                    self.nickName = dict["nickName"] as! String
                }
                if dict.keys.contains("nickNamePinyin") {
                    self.nickNamePinyin = dict["nickNamePinyin"] as! String
                }
                if dict.keys.contains("realName") {
                    self.realName = dict["realName"] as! String
                }
                if dict.keys.contains("realNamePinyin") {
                    self.realNamePinyin = dict["realNamePinyin"] as! String
                }
                if dict.keys.contains("stamp") {
                    self.stamp = dict["stamp"] as! String
                }
                if dict.keys.contains("tbRoleId") {
                    self.tbRoleId = dict["tbRoleId"] as! String
                }
            }
        }
        public var description_: String?

        public var identifier: String?

        public var recordUser: CreateWorkitemEstimateResponseBody.WorkitemTimeEstimate.RecordUser?

        public var spentTime: Int64?

        public var type: String?

        public var workitemIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordUser?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.recordUser != nil {
                map["recordUser"] = self.recordUser?.toMap()
            }
            if self.spentTime != nil {
                map["spentTime"] = self.spentTime!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.workitemIdentifier != nil {
                map["workitemIdentifier"] = self.workitemIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("recordUser") {
                var model = CreateWorkitemEstimateResponseBody.WorkitemTimeEstimate.RecordUser()
                model.fromMap(dict["recordUser"] as! [String: Any])
                self.recordUser = model
            }
            if dict.keys.contains("spentTime") {
                self.spentTime = dict["spentTime"] as! Int64
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("workitemIdentifier") {
                self.workitemIdentifier = dict["workitemIdentifier"] as! String
            }
        }
    }
    public var workitemTimeEstimate: CreateWorkitemEstimateResponseBody.WorkitemTimeEstimate?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitemTimeEstimate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.workitemTimeEstimate != nil {
            map["WorkitemTimeEstimate"] = self.workitemTimeEstimate?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WorkitemTimeEstimate") {
            var model = CreateWorkitemEstimateResponseBody.WorkitemTimeEstimate()
            model.fromMap(dict["WorkitemTimeEstimate"] as! [String: Any])
            self.workitemTimeEstimate = model
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateWorkitemEstimateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkitemEstimateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWorkitemEstimateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkitemRecordRequest : Tea.TeaModel {
    public var actualTime: String?

    public var description_: String?

    public var gmtEnd: String?

    public var gmtStart: String?

    public var recordUserIdentifier: String?

    public var type: String?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actualTime != nil {
            map["actualTime"] = self.actualTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.gmtEnd != nil {
            map["gmtEnd"] = self.gmtEnd!
        }
        if self.gmtStart != nil {
            map["gmtStart"] = self.gmtStart!
        }
        if self.recordUserIdentifier != nil {
            map["recordUserIdentifier"] = self.recordUserIdentifier!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("actualTime") {
            self.actualTime = dict["actualTime"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("gmtEnd") {
            self.gmtEnd = dict["gmtEnd"] as! String
        }
        if dict.keys.contains("gmtStart") {
            self.gmtStart = dict["gmtStart"] as! String
        }
        if dict.keys.contains("recordUserIdentifier") {
            self.recordUserIdentifier = dict["recordUserIdentifier"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
        if dict.keys.contains("workitemIdentifier") {
            self.workitemIdentifier = dict["workitemIdentifier"] as! String
        }
    }
}

public class CreateWorkitemRecordResponseBody : Tea.TeaModel {
    public class WorkitemTime : Tea.TeaModel {
        public class RecordUser : Tea.TeaModel {
            public var account: String?

            public var avatar: String?

            public var dingTalkId: String?

            public var displayName: String?

            public var displayNickName: String?

            public var displayRealName: String?

            public var email: String?

            public var gender: String?

            public var identifier: String?

            public var isDisabled: Bool?

            public var mobile: String?

            public var nameEn: String?

            public var nickName: String?

            public var nickNamePinyin: String?

            public var realName: String?

            public var realNamePinyin: String?

            public var stamp: String?

            public var tbRoleId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["account"] = self.account!
                }
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.dingTalkId != nil {
                    map["dingTalkId"] = self.dingTalkId!
                }
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.displayNickName != nil {
                    map["displayNickName"] = self.displayNickName!
                }
                if self.displayRealName != nil {
                    map["displayRealName"] = self.displayRealName!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.gender != nil {
                    map["gender"] = self.gender!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.isDisabled != nil {
                    map["isDisabled"] = self.isDisabled!
                }
                if self.mobile != nil {
                    map["mobile"] = self.mobile!
                }
                if self.nameEn != nil {
                    map["nameEn"] = self.nameEn!
                }
                if self.nickName != nil {
                    map["nickName"] = self.nickName!
                }
                if self.nickNamePinyin != nil {
                    map["nickNamePinyin"] = self.nickNamePinyin!
                }
                if self.realName != nil {
                    map["realName"] = self.realName!
                }
                if self.realNamePinyin != nil {
                    map["realNamePinyin"] = self.realNamePinyin!
                }
                if self.stamp != nil {
                    map["stamp"] = self.stamp!
                }
                if self.tbRoleId != nil {
                    map["tbRoleId"] = self.tbRoleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("account") {
                    self.account = dict["account"] as! String
                }
                if dict.keys.contains("avatar") {
                    self.avatar = dict["avatar"] as! String
                }
                if dict.keys.contains("dingTalkId") {
                    self.dingTalkId = dict["dingTalkId"] as! String
                }
                if dict.keys.contains("displayName") {
                    self.displayName = dict["displayName"] as! String
                }
                if dict.keys.contains("displayNickName") {
                    self.displayNickName = dict["displayNickName"] as! String
                }
                if dict.keys.contains("displayRealName") {
                    self.displayRealName = dict["displayRealName"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("gender") {
                    self.gender = dict["gender"] as! String
                }
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
                if dict.keys.contains("isDisabled") {
                    self.isDisabled = dict["isDisabled"] as! Bool
                }
                if dict.keys.contains("mobile") {
                    self.mobile = dict["mobile"] as! String
                }
                if dict.keys.contains("nameEn") {
                    self.nameEn = dict["nameEn"] as! String
                }
                if dict.keys.contains("nickName") {
                    self.nickName = dict["nickName"] as! String
                }
                if dict.keys.contains("nickNamePinyin") {
                    self.nickNamePinyin = dict["nickNamePinyin"] as! String
                }
                if dict.keys.contains("realName") {
                    self.realName = dict["realName"] as! String
                }
                if dict.keys.contains("realNamePinyin") {
                    self.realNamePinyin = dict["realNamePinyin"] as! String
                }
                if dict.keys.contains("stamp") {
                    self.stamp = dict["stamp"] as! String
                }
                if dict.keys.contains("tbRoleId") {
                    self.tbRoleId = dict["tbRoleId"] as! String
                }
            }
        }
        public var actualTime: Int64?

        public var description_: String?

        public var gmtEnd: Int64?

        public var gmtStart: Int64?

        public var identifier: String?

        public var recordUser: CreateWorkitemRecordResponseBody.WorkitemTime.RecordUser?

        public var type: String?

        public var workitemIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordUser?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualTime != nil {
                map["actualTime"] = self.actualTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtEnd != nil {
                map["gmtEnd"] = self.gmtEnd!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.recordUser != nil {
                map["recordUser"] = self.recordUser?.toMap()
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.workitemIdentifier != nil {
                map["workitemIdentifier"] = self.workitemIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("actualTime") {
                self.actualTime = dict["actualTime"] as! Int64
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtEnd") {
                self.gmtEnd = dict["gmtEnd"] as! Int64
            }
            if dict.keys.contains("gmtStart") {
                self.gmtStart = dict["gmtStart"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("recordUser") {
                var model = CreateWorkitemRecordResponseBody.WorkitemTime.RecordUser()
                model.fromMap(dict["recordUser"] as! [String: Any])
                self.recordUser = model
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("workitemIdentifier") {
                self.workitemIdentifier = dict["workitemIdentifier"] as! String
            }
        }
    }
    public var workitemTime: CreateWorkitemRecordResponseBody.WorkitemTime?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitemTime?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.workitemTime != nil {
            map["WorkitemTime"] = self.workitemTime?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WorkitemTime") {
            var model = CreateWorkitemRecordResponseBody.WorkitemTime()
            model.fromMap(dict["WorkitemTime"] as! [String: Any])
            self.workitemTime = model
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class CreateWorkitemRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkitemRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWorkitemRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkitemV2Request : Tea.TeaModel {
    public class FieldValueList : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldIdentifier") {
                self.fieldIdentifier = dict["fieldIdentifier"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var assignedTo: String?

    public var category: String?

    public var description_: String?

    public var fieldValueList: [CreateWorkitemV2Request.FieldValueList]?

    public var parentIdentifier: String?

    public var participants: [String]?

    public var spaceIdentifier: String?

    public var sprintIdentifier: String?

    public var subject: String?

    public var tags: [String]?

    public var trackers: [String]?

    public var verifier: String?

    public var versions: [String]?

    public var workitemTypeIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedTo != nil {
            map["assignedTo"] = self.assignedTo!
        }
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.fieldValueList != nil {
            var tmp : [Any] = []
            for k in self.fieldValueList! {
                tmp.append(k.toMap())
            }
            map["fieldValueList"] = tmp
        }
        if self.parentIdentifier != nil {
            map["parentIdentifier"] = self.parentIdentifier!
        }
        if self.participants != nil {
            map["participants"] = self.participants!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.sprintIdentifier != nil {
            map["sprintIdentifier"] = self.sprintIdentifier!
        }
        if self.subject != nil {
            map["subject"] = self.subject!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        if self.trackers != nil {
            map["trackers"] = self.trackers!
        }
        if self.verifier != nil {
            map["verifier"] = self.verifier!
        }
        if self.versions != nil {
            map["versions"] = self.versions!
        }
        if self.workitemTypeIdentifier != nil {
            map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("assignedTo") {
            self.assignedTo = dict["assignedTo"] as! String
        }
        if dict.keys.contains("category") {
            self.category = dict["category"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("fieldValueList") {
            var tmp : [CreateWorkitemV2Request.FieldValueList] = []
            for v in dict["fieldValueList"] as! [Any] {
                var model = CreateWorkitemV2Request.FieldValueList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fieldValueList = tmp
        }
        if dict.keys.contains("parentIdentifier") {
            self.parentIdentifier = dict["parentIdentifier"] as! String
        }
        if dict.keys.contains("participants") {
            self.participants = dict["participants"] as! [String]
        }
        if dict.keys.contains("spaceIdentifier") {
            self.spaceIdentifier = dict["spaceIdentifier"] as! String
        }
        if dict.keys.contains("sprintIdentifier") {
            self.sprintIdentifier = dict["sprintIdentifier"] as! String
        }
        if dict.keys.contains("subject") {
            self.subject = dict["subject"] as! String
        }
        if dict.keys.contains("tags") {
            self.tags = dict["tags"] as! [String]
        }
        if dict.keys.contains("trackers") {
            self.trackers = dict["trackers"] as! [String]
        }
        if dict.keys.contains("verifier") {
            self.verifier = dict["verifier"] as! String
        }
        if dict.keys.contains("versions") {
            self.versions = dict["versions"] as! [String]
        }
        if dict.keys.contains("workitemTypeIdentifier") {
            self.workitemTypeIdentifier = dict["workitemTypeIdentifier"] as! String
        }
    }
}

public class CreateWorkitemV2ResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: String?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
        if dict.keys.contains("workitemIdentifier") {
            self.workitemIdentifier = dict["workitemIdentifier"] as! String
        }
    }
}

public class CreateWorkitemV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkitemV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWorkitemV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWorkspaceRequest : Tea.TeaModel {
    public var codeUrl: String?

    public var codeVersion: String?

    public var filePath: String?

    public var name: String?

    public var requestFrom: String?

    public var resourceIdentifier: String?

    public var reuse: Bool?

    public var workspaceTemplate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.codeUrl != nil {
            map["codeUrl"] = self.codeUrl!
        }
        if self.codeVersion != nil {
            map["codeVersion"] = self.codeVersion!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestFrom != nil {
            map["requestFrom"] = self.requestFrom!
        }
        if self.resourceIdentifier != nil {
            map["resourceIdentifier"] = self.resourceIdentifier!
        }
        if self.reuse != nil {
            map["reuse"] = self.reuse!
        }
        if self.workspaceTemplate != nil {
            map["workspaceTemplate"] = self.workspaceTemplate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("codeUrl") {
            self.codeUrl = dict["codeUrl"] as! String
        }
        if dict.keys.contains("codeVersion") {
            self.codeVersion = dict["codeVersion"] as! String
        }
        if dict.keys.contains("filePath") {
            self.filePath = dict["filePath"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestFrom") {
            self.requestFrom = dict["requestFrom"] as! String
        }
        if dict.keys.contains("resourceIdentifier") {
            self.resourceIdentifier = dict["resourceIdentifier"] as! String
        }
        if dict.keys.contains("reuse") {
            self.reuse = dict["reuse"] as! Bool
        }
        if dict.keys.contains("workspaceTemplate") {
            self.workspaceTemplate = dict["workspaceTemplate"] as! String
        }
    }
}

public class CreateWorkspaceResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public var createTime: String?

        public var creator: String?

        public var id: String?

        public var name: String?

        public var status: String?

        public var template: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.template != nil {
                map["template"] = self.template!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("template") {
                self.template = dict["template"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workspace: CreateWorkspaceResponseBody.Workspace?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workspace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workspace != nil {
            map["workspace"] = self.workspace?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("workspace") {
            var model = CreateWorkspaceResponseBody.Workspace()
            model.fromMap(dict["workspace"] as! [String: Any])
            self.workspace = model
        }
    }
}

public class CreateWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAppMemberRequest : Tea.TeaModel {
    public var organizationId: String?

    public var subjectId: String?

    public var subjectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.subjectId != nil {
            map["subjectId"] = self.subjectId!
        }
        if self.subjectType != nil {
            map["subjectType"] = self.subjectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("subjectId") {
            self.subjectId = dict["subjectId"] as! String
        }
        if dict.keys.contains("subjectType") {
            self.subjectType = dict["subjectType"] as! String
        }
    }
}

public class DeleteAppMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class DeleteBranchRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("branchName") {
            self.branchName = dict["branchName"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class DeleteBranchResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var branchName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["branchName"] = self.branchName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("branchName") {
                self.branchName = dict["branchName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteBranchResponseBody.Result?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeleteBranchResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
    }
}

public class DeleteBranchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBranchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBranchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFileRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var commitMessage: String?

    public var filePath: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.commitMessage != nil {
            map["commitMessage"] = self.commitMessage!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("branchName") {
            self.branchName = dict["branchName"] as! String
        }
        if dict.keys.contains("commitMessage") {
            self.commitMessage = dict["commitMessage"] as! String
        }
        if dict.keys.contains("filePath") {
            self.filePath = dict["filePath"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class DeleteFileResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var branchName: String?

        public var filePath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["branchName"] = self.branchName!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("branchName") {
                self.branchName = dict["branchName"] as! String
            }
            if dict.keys.contains("filePath") {
                self.filePath = dict["filePath"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteFileResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeleteFileResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFlowTagResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteFlowTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFlowTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFlowTagGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteFlowTagGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowTagGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteFlowTagGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGroupMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var aliyunPk: String?

    public var memberType: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.aliyunPk != nil {
            map["aliyunPk"] = self.aliyunPk!
        }
        if self.memberType != nil {
            map["memberType"] = self.memberType!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("aliyunPk") {
            self.aliyunPk = dict["aliyunPk"] as! String
        }
        if dict.keys.contains("memberType") {
            self.memberType = dict["memberType"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class DeleteGroupMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var id: Int64?

        public var memberType: String?

        public var name: String?

        public var sourceId: Int64?

        public var state: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.memberType != nil {
                map["memberType"] = self.memberType!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("memberType") {
                self.memberType = dict["memberType"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceId") {
                self.sourceId = dict["sourceId"] as! Int64
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("username") {
                self.username = dict["username"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteGroupMemberResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeleteGroupMemberResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteGroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGroupMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHostGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteHostGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHostGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteHostGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePipelineResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeletePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePipelineGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeletePipelineGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePipelineGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePipelineRelationsRequest : Tea.TeaModel {
    public var relObjectId: String?

    public var relObjectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relObjectId != nil {
            map["relObjectId"] = self.relObjectId!
        }
        if self.relObjectType != nil {
            map["relObjectType"] = self.relObjectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("relObjectId") {
            self.relObjectId = dict["relObjectId"] as! String
        }
        if dict.keys.contains("relObjectType") {
            self.relObjectType = dict["relObjectType"] as! String
        }
    }
}

public class DeletePipelineRelationsResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeletePipelineRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePipelineRelationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProjectRequest : Tea.TeaModel {
    public var identifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("identifier") {
            self.identifier = dict["identifier"] as! String
        }
    }
}

public class DeleteProjectResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            self.result = dict["result"] as! Bool
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProjectLabelRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class DeleteProjectLabelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteProjectLabelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeleteProjectLabelResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteProjectLabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProjectLabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProjectLabelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteProtectedBranchRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class DeleteProtectedBranchResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteProtectedBranchResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeleteProtectedBranchResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteProtectedBranchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteProtectedBranchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteProtectedBranchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePushRuleRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class DeletePushRuleResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeletePushRuleResponseBody.Result?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeletePushRuleResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
    }
}

public class DeletePushRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePushRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePushRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRepositoryRequest : Tea.TeaModel {
    public var accessToken: String?

    public var reason: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.reason != nil {
            map["reason"] = self.reason!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("reason") {
            self.reason = dict["reason"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class DeleteRepositoryResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteRepositoryResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeleteRepositoryResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRepositoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRepositoryGroupRequest : Tea.TeaModel {
    public var accessToken: String?

    public var reason: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.reason != nil {
            map["reason"] = self.reason!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("reason") {
            self.reason = dict["reason"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class DeleteRepositoryGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteRepositoryGroupResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeleteRepositoryGroupResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteRepositoryGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRepositoryGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRepositoryGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRepositoryMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var memberType: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.memberType != nil {
            map["memberType"] = self.memberType!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("memberType") {
            self.memberType = dict["memberType"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class DeleteRepositoryMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var createAt: String?

        public var id: Int64?

        public var sourceId: Int64?

        public var sourceType: String?

        public var updateAt: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.createAt != nil {
                map["createAt"] = self.createAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.updateAt != nil {
                map["updateAt"] = self.updateAt!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("createAt") {
                self.createAt = dict["createAt"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("sourceId") {
                self.sourceId = dict["sourceId"] as! Int64
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("updateAt") {
                self.updateAt = dict["updateAt"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteRepositoryMemberResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeleteRepositoryMemberResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteRepositoryMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRepositoryMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRepositoryMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRepositoryWebhookRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class DeleteRepositoryWebhookResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var buildEvents: Bool?

        public var createdAt: String?

        public var description_: String?

        public var enableSslVerification: Bool?

        public var id: Int64?

        public var issuesEvents: Bool?

        public var lastTestResult: String?

        public var mergeRequestsEvents: Bool?

        public var noteEvents: Bool?

        public var projectId: Int64?

        public var pushEvents: Bool?

        public var secretToken: String?

        public var tagPushEvents: Bool?

        public var type: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.buildEvents != nil {
                map["buildEvents"] = self.buildEvents!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.enableSslVerification != nil {
                map["enableSslVerification"] = self.enableSslVerification!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.issuesEvents != nil {
                map["issuesEvents"] = self.issuesEvents!
            }
            if self.lastTestResult != nil {
                map["lastTestResult"] = self.lastTestResult!
            }
            if self.mergeRequestsEvents != nil {
                map["mergeRequestsEvents"] = self.mergeRequestsEvents!
            }
            if self.noteEvents != nil {
                map["noteEvents"] = self.noteEvents!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.pushEvents != nil {
                map["pushEvents"] = self.pushEvents!
            }
            if self.secretToken != nil {
                map["secretToken"] = self.secretToken!
            }
            if self.tagPushEvents != nil {
                map["tagPushEvents"] = self.tagPushEvents!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("buildEvents") {
                self.buildEvents = dict["buildEvents"] as! Bool
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("enableSslVerification") {
                self.enableSslVerification = dict["enableSslVerification"] as! Bool
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("issuesEvents") {
                self.issuesEvents = dict["issuesEvents"] as! Bool
            }
            if dict.keys.contains("lastTestResult") {
                self.lastTestResult = dict["lastTestResult"] as! String
            }
            if dict.keys.contains("mergeRequestsEvents") {
                self.mergeRequestsEvents = dict["mergeRequestsEvents"] as! Bool
            }
            if dict.keys.contains("noteEvents") {
                self.noteEvents = dict["noteEvents"] as! Bool
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! Int64
            }
            if dict.keys.contains("pushEvents") {
                self.pushEvents = dict["pushEvents"] as! Bool
            }
            if dict.keys.contains("secretToken") {
                self.secretToken = dict["secretToken"] as! String
            }
            if dict.keys.contains("tagPushEvents") {
                self.tagPushEvents = dict["tagPushEvents"] as! Bool
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("url") {
                self.url = dict["url"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteRepositoryWebhookResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeleteRepositoryWebhookResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteRepositoryWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRepositoryWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRepositoryWebhookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteResourceMemberResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteResourceMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteResourceMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteResourceMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTagRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var tagName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.tagName != nil {
            map["tagName"] = self.tagName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("tagName") {
            self.tagName = dict["tagName"] as! String
        }
    }
}

public class DeleteTagResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var tagName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagName != nil {
                map["tagName"] = self.tagName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tagName") {
                self.tagName = dict["tagName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteTagResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeleteTagResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteUserKeyRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class DeleteUserKeyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var context: String?

        public var createdAt: String?

        public var expireTime: String?

        public var fingerPrint: String?

        public var id: Int64?

        public var keyScope: String?

        public var lastUsedTime: String?

        public var publicKey: String?

        public var shaContext: String?

        public var title: String?

        public var updatedAt: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.context != nil {
                map["context"] = self.context!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.expireTime != nil {
                map["expireTime"] = self.expireTime!
            }
            if self.fingerPrint != nil {
                map["fingerPrint"] = self.fingerPrint!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.keyScope != nil {
                map["keyScope"] = self.keyScope!
            }
            if self.lastUsedTime != nil {
                map["lastUsedTime"] = self.lastUsedTime!
            }
            if self.publicKey != nil {
                map["publicKey"] = self.publicKey!
            }
            if self.shaContext != nil {
                map["shaContext"] = self.shaContext!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("context") {
                self.context = dict["context"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("expireTime") {
                self.expireTime = dict["expireTime"] as! String
            }
            if dict.keys.contains("fingerPrint") {
                self.fingerPrint = dict["fingerPrint"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("keyScope") {
                self.keyScope = dict["keyScope"] as! String
            }
            if dict.keys.contains("lastUsedTime") {
                self.lastUsedTime = dict["lastUsedTime"] as! String
            }
            if dict.keys.contains("publicKey") {
                self.publicKey = dict["publicKey"] as! String
            }
            if dict.keys.contains("shaContext") {
                self.shaContext = dict["shaContext"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: DeleteUserKeyResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = DeleteUserKeyResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteUserKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteUserKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVariableGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteVariableGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVariableGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVariableGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWorkitemRequest : Tea.TeaModel {
    public var identifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("identifier") {
            self.identifier = dict["identifier"] as! String
        }
    }
}

public class DeleteWorkitemResponseBody : Tea.TeaModel {
    public var deleteFlag: Bool?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFlag != nil {
            map["deleteFlag"] = self.deleteFlag!
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("deleteFlag") {
            self.deleteFlag = dict["deleteFlag"] as! Bool
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class DeleteWorkitemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkitemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWorkitemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWorkitemAllCommentRequest : Tea.TeaModel {
    public var identifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("identifier") {
            self.identifier = dict["identifier"] as! String
        }
    }
}

public class DeleteWorkitemAllCommentResponseBody : Tea.TeaModel {
    public var deleteFlag: Bool?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFlag != nil {
            map["deleteFlag"] = self.deleteFlag!
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("deleteFlag") {
            self.deleteFlag = dict["deleteFlag"] as! Bool
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
    }
}

public class DeleteWorkitemAllCommentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkitemAllCommentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWorkitemAllCommentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWorkitemCommentRequest : Tea.TeaModel {
    public var commentId: Int64?

    public var identifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commentId != nil {
            map["commentId"] = self.commentId!
        }
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commentId") {
            self.commentId = dict["commentId"] as! Int64
        }
        if dict.keys.contains("identifier") {
            self.identifier = dict["identifier"] as! String
        }
    }
}

public class DeleteWorkitemCommentResponseBody : Tea.TeaModel {
    public var deleteFlag: Bool?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteFlag != nil {
            map["deleteFlag"] = self.deleteFlag!
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("deleteFlag") {
            self.deleteFlag = dict["deleteFlag"] as! Bool
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
    }
}

public class DeleteWorkitemCommentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWorkitemCommentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWorkitemCommentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableDeployKeyRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class EnableDeployKeyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: EnableDeployKeyResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = EnableDeployKeyResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class EnableDeployKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableDeployKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableDeployKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportInsightCustomValueRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportInsightCustomValueResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var doubleValue: Double?

        public var fieldId: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var longValue: Int64?

        public var organizationId: String?

        public var targetId: String?

        public var targetType: String?

        public var type: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.doubleValue != nil {
                map["doubleValue"] = self.doubleValue!
            }
            if self.fieldId != nil {
                map["fieldId"] = self.fieldId!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.longValue != nil {
                map["longValue"] = self.longValue!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.targetId != nil {
                map["targetId"] = self.targetId!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("doubleValue") {
                self.doubleValue = dict["doubleValue"] as! Double
            }
            if dict.keys.contains("fieldId") {
                self.fieldId = dict["fieldId"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("isDeleted") {
                self.isDeleted = dict["isDeleted"] as! String
            }
            if dict.keys.contains("longValue") {
                self.longValue = dict["longValue"] as! Int64
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("targetId") {
                self.targetId = dict["targetId"] as! String
            }
            if dict.keys.contains("targetType") {
                self.targetType = dict["targetType"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightCustomValueResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportInsightCustomValueResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportInsightCustomValueResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportInsightCustomValueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightCustomValueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportInsightCustomValueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportInsightExpectedWorkTimeRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportInsightExpectedWorkTimeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var organizationId: String?

        public var projectId: String?

        public var recorderId: String?

        public var source: String?

        public var type: String?

        public var value: Double?

        public var workitemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.recorderId != nil {
                map["recorderId"] = self.recorderId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            if self.workitemId != nil {
                map["workitemId"] = self.workitemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("isDeleted") {
                self.isDeleted = dict["isDeleted"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! String
            }
            if dict.keys.contains("recorderId") {
                self.recorderId = dict["recorderId"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! Double
            }
            if dict.keys.contains("workitemId") {
                self.workitemId = dict["workitemId"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightExpectedWorkTimeResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportInsightExpectedWorkTimeResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportInsightExpectedWorkTimeResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportInsightExpectedWorkTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightExpectedWorkTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportInsightExpectedWorkTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportInsightFieldRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportInsightFieldResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fieldId: String?

        public var fieldName: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var isSystem: String?

        public var optionValue: String?

        public var organizationId: String?

        public var position: Int32?

        public var scope: String?

        public var source: String?

        public var targetId: String?

        public var targetType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldId != nil {
                map["fieldId"] = self.fieldId!
            }
            if self.fieldName != nil {
                map["fieldName"] = self.fieldName!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.isSystem != nil {
                map["isSystem"] = self.isSystem!
            }
            if self.optionValue != nil {
                map["optionValue"] = self.optionValue!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.position != nil {
                map["position"] = self.position!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.targetId != nil {
                map["targetId"] = self.targetId!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldId") {
                self.fieldId = dict["fieldId"] as! String
            }
            if dict.keys.contains("fieldName") {
                self.fieldName = dict["fieldName"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("isDeleted") {
                self.isDeleted = dict["isDeleted"] as! String
            }
            if dict.keys.contains("isSystem") {
                self.isSystem = dict["isSystem"] as! String
            }
            if dict.keys.contains("optionValue") {
                self.optionValue = dict["optionValue"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("position") {
                self.position = dict["position"] as! Int32
            }
            if dict.keys.contains("scope") {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("targetId") {
                self.targetId = dict["targetId"] as! String
            }
            if dict.keys.contains("targetType") {
                self.targetType = dict["targetType"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightFieldResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportInsightFieldResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportInsightFieldResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportInsightFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportInsightFieldResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportInsightSpaceRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportInsightSpaceResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var category: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var name: String?

        public var organizationId: String?

        public var source: String?

        public var stage: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["category"] = self.category!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.stage != nil {
                map["stage"] = self.stage!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("category") {
                self.category = dict["category"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("isDeleted") {
                self.isDeleted = dict["isDeleted"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("stage") {
                self.stage = dict["stage"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightSpaceResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportInsightSpaceResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportInsightSpaceResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportInsightSpaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightSpaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportInsightSpaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportInsightSpaceRefRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportInsightSpaceRefResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var creatorId: String?

        public var fromId: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var modifierId: String?

        public var organizationId: String?

        public var toId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.fromId != nil {
                map["fromId"] = self.fromId!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.modifierId != nil {
                map["modifierId"] = self.modifierId!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.toId != nil {
                map["toId"] = self.toId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creatorId") {
                self.creatorId = dict["creatorId"] as! String
            }
            if dict.keys.contains("fromId") {
                self.fromId = dict["fromId"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("isDeleted") {
                self.isDeleted = dict["isDeleted"] as! String
            }
            if dict.keys.contains("modifierId") {
                self.modifierId = dict["modifierId"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("toId") {
                self.toId = dict["toId"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightSpaceRefResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportInsightSpaceRefResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportInsightSpaceRefResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportInsightSpaceRefResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightSpaceRefResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportInsightSpaceRefResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportInsightSprintRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportInsightSprintResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var actualEnd: Int64?

        public var actualStart: Int64?

        public var gmtCreate: Int64?

        public var gmtEnd: Int64?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var name: String?

        public var organizationId: String?

        public var projectId: String?

        public var source: String?

        public var status: Int32?

        public var workTimeCapacity: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualEnd != nil {
                map["actualEnd"] = self.actualEnd!
            }
            if self.actualStart != nil {
                map["actualStart"] = self.actualStart!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtEnd != nil {
                map["gmtEnd"] = self.gmtEnd!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.workTimeCapacity != nil {
                map["workTimeCapacity"] = self.workTimeCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("actualEnd") {
                self.actualEnd = dict["actualEnd"] as! Int64
            }
            if dict.keys.contains("actualStart") {
                self.actualStart = dict["actualStart"] as! Int64
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtEnd") {
                self.gmtEnd = dict["gmtEnd"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("gmtStart") {
                self.gmtStart = dict["gmtStart"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("isDeleted") {
                self.isDeleted = dict["isDeleted"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! Int32
            }
            if dict.keys.contains("workTimeCapacity") {
                self.workTimeCapacity = dict["workTimeCapacity"] as! Double
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightSprintResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportInsightSprintResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportInsightSprintResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportInsightSprintResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightSprintResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportInsightSprintResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportInsightTagRefRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportInsightTagRefResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var name: String?

        public var organizationId: String?

        public var tagId: String?

        public var targetId: String?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.tagId != nil {
                map["tagId"] = self.tagId!
            }
            if self.targetId != nil {
                map["targetId"] = self.targetId!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("isDeleted") {
                self.isDeleted = dict["isDeleted"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("tagId") {
                self.tagId = dict["tagId"] as! String
            }
            if dict.keys.contains("targetId") {
                self.targetId = dict["targetId"] as! String
            }
            if dict.keys.contains("targetType") {
                self.targetType = dict["targetType"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightTagRefResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportInsightTagRefResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportInsightTagRefResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportInsightTagRefResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightTagRefResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportInsightTagRefResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportInsightWorkTimeRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportInsightWorkTimeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var actualValue: Double?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtEnd: Int64?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var organizationId: String?

        public var projectId: String?

        public var recorderId: String?

        public var source: String?

        public var type: String?

        public var uuid: String?

        public var value: Int64?

        public var workitemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualValue != nil {
                map["actualValue"] = self.actualValue!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtEnd != nil {
                map["gmtEnd"] = self.gmtEnd!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.recorderId != nil {
                map["recorderId"] = self.recorderId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.uuid != nil {
                map["uuid"] = self.uuid!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            if self.workitemId != nil {
                map["workitemId"] = self.workitemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("actualValue") {
                self.actualValue = dict["actualValue"] as! Double
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtEnd") {
                self.gmtEnd = dict["gmtEnd"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("gmtStart") {
                self.gmtStart = dict["gmtStart"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("isDeleted") {
                self.isDeleted = dict["isDeleted"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! String
            }
            if dict.keys.contains("recorderId") {
                self.recorderId = dict["recorderId"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("uuid") {
                self.uuid = dict["uuid"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! Int64
            }
            if dict.keys.contains("workitemId") {
                self.workitemId = dict["workitemId"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightWorkTimeResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportInsightWorkTimeResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportInsightWorkTimeResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportInsightWorkTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightWorkTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportInsightWorkTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportInsightWorkitemStatusRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportInsightWorkitemStatusResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var assignedToId: String?

        public var creatorId: String?

        public var expectedWorkTime: Int64?

        public var gmtClosed: Int64?

        public var gmtCreate: Int64?

        public var gmtDue: Int64?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var gmtTodo: Int64?

        public var id: Int64?

        public var isArchived: String?

        public var isDeleted: String?

        public var isDone: String?

        public var organizationId: String?

        public var parentId: String?

        public var participantIds: String?

        public var phase: Int32?

        public var priority: Int32?

        public var productId: String?

        public var projectId: String?

        public var source: String?

        public var sprintId: String?

        public var stage: Int32?

        public var status: String?

        public var statusId: String?

        public var storyPoint: Double?

        public var subType: String?

        public var subject: String?

        public var type: Int32?

        public var versionId: String?

        public var versions: String?

        public var workTime: Int64?

        public var workitemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedToId != nil {
                map["assignedToId"] = self.assignedToId!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.expectedWorkTime != nil {
                map["expectedWorkTime"] = self.expectedWorkTime!
            }
            if self.gmtClosed != nil {
                map["gmtClosed"] = self.gmtClosed!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtDue != nil {
                map["gmtDue"] = self.gmtDue!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.gmtTodo != nil {
                map["gmtTodo"] = self.gmtTodo!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isArchived != nil {
                map["isArchived"] = self.isArchived!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.isDone != nil {
                map["isDone"] = self.isDone!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.participantIds != nil {
                map["participantIds"] = self.participantIds!
            }
            if self.phase != nil {
                map["phase"] = self.phase!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.productId != nil {
                map["productId"] = self.productId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.sprintId != nil {
                map["sprintId"] = self.sprintId!
            }
            if self.stage != nil {
                map["stage"] = self.stage!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusId != nil {
                map["statusId"] = self.statusId!
            }
            if self.storyPoint != nil {
                map["storyPoint"] = self.storyPoint!
            }
            if self.subType != nil {
                map["subType"] = self.subType!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.versionId != nil {
                map["versionId"] = self.versionId!
            }
            if self.versions != nil {
                map["versions"] = self.versions!
            }
            if self.workTime != nil {
                map["workTime"] = self.workTime!
            }
            if self.workitemId != nil {
                map["workitemId"] = self.workitemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedToId") {
                self.assignedToId = dict["assignedToId"] as! String
            }
            if dict.keys.contains("creatorId") {
                self.creatorId = dict["creatorId"] as! String
            }
            if dict.keys.contains("expectedWorkTime") {
                self.expectedWorkTime = dict["expectedWorkTime"] as! Int64
            }
            if dict.keys.contains("gmtClosed") {
                self.gmtClosed = dict["gmtClosed"] as! Int64
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtDue") {
                self.gmtDue = dict["gmtDue"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("gmtStart") {
                self.gmtStart = dict["gmtStart"] as! Int64
            }
            if dict.keys.contains("gmtTodo") {
                self.gmtTodo = dict["gmtTodo"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("isArchived") {
                self.isArchived = dict["isArchived"] as! String
            }
            if dict.keys.contains("isDeleted") {
                self.isDeleted = dict["isDeleted"] as! String
            }
            if dict.keys.contains("isDone") {
                self.isDone = dict["isDone"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("parentId") {
                self.parentId = dict["parentId"] as! String
            }
            if dict.keys.contains("participantIds") {
                self.participantIds = dict["participantIds"] as! String
            }
            if dict.keys.contains("phase") {
                self.phase = dict["phase"] as! Int32
            }
            if dict.keys.contains("priority") {
                self.priority = dict["priority"] as! Int32
            }
            if dict.keys.contains("productId") {
                self.productId = dict["productId"] as! String
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("sprintId") {
                self.sprintId = dict["sprintId"] as! String
            }
            if dict.keys.contains("stage") {
                self.stage = dict["stage"] as! Int32
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("statusId") {
                self.statusId = dict["statusId"] as! String
            }
            if dict.keys.contains("storyPoint") {
                self.storyPoint = dict["storyPoint"] as! Double
            }
            if dict.keys.contains("subType") {
                self.subType = dict["subType"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! Int32
            }
            if dict.keys.contains("versionId") {
                self.versionId = dict["versionId"] as! String
            }
            if dict.keys.contains("versions") {
                self.versions = dict["versions"] as! String
            }
            if dict.keys.contains("workTime") {
                self.workTime = dict["workTime"] as! Int64
            }
            if dict.keys.contains("workitemId") {
                self.workitemId = dict["workitemId"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightWorkitemStatusResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportInsightWorkitemStatusResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportInsightWorkitemStatusResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportInsightWorkitemStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightWorkitemStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportInsightWorkitemStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var assignedToId: String?

        public var creatorId: String?

        public var expectedWorkTime: Int64?

        public var extraId: Int64?

        public var extraIsDeleted: String?

        public var foundPhase: Int32?

        public var gmtClosed: Int64?

        public var gmtCreate: Int64?

        public var gmtDue: Int64?

        public var gmtFixed: String?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var gmtTodo: Int64?

        public var id: Int64?

        public var isArchived: String?

        public var isDeleted: String?

        public var isDone: String?

        public var isStupid: String?

        public var organizationId: String?

        public var parentId: String?

        public var participantIds: String?

        public var phase: Int32?

        public var priority: Int32?

        public var productId: String?

        public var projectId: String?

        public var reopenNum: Int32?

        public var seriousLevel: Int32?

        public var solution: String?

        public var source: String?

        public var sprintId: String?

        public var stage: Int32?

        public var status: String?

        public var statusId: String?

        public var storyPoint: Double?

        public var subType: String?

        public var subject: String?

        public var type: Int32?

        public var verifierId: String?

        public var versionId: String?

        public var versions: String?

        public var workTime: Int64?

        public var workitemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedToId != nil {
                map["assignedToId"] = self.assignedToId!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.expectedWorkTime != nil {
                map["expectedWorkTime"] = self.expectedWorkTime!
            }
            if self.extraId != nil {
                map["extraId"] = self.extraId!
            }
            if self.extraIsDeleted != nil {
                map["extraIsDeleted"] = self.extraIsDeleted!
            }
            if self.foundPhase != nil {
                map["foundPhase"] = self.foundPhase!
            }
            if self.gmtClosed != nil {
                map["gmtClosed"] = self.gmtClosed!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtDue != nil {
                map["gmtDue"] = self.gmtDue!
            }
            if self.gmtFixed != nil {
                map["gmtFixed"] = self.gmtFixed!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.gmtTodo != nil {
                map["gmtTodo"] = self.gmtTodo!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isArchived != nil {
                map["isArchived"] = self.isArchived!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.isDone != nil {
                map["isDone"] = self.isDone!
            }
            if self.isStupid != nil {
                map["isStupid"] = self.isStupid!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.participantIds != nil {
                map["participantIds"] = self.participantIds!
            }
            if self.phase != nil {
                map["phase"] = self.phase!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.productId != nil {
                map["productId"] = self.productId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.reopenNum != nil {
                map["reopenNum"] = self.reopenNum!
            }
            if self.seriousLevel != nil {
                map["seriousLevel"] = self.seriousLevel!
            }
            if self.solution != nil {
                map["solution"] = self.solution!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.sprintId != nil {
                map["sprintId"] = self.sprintId!
            }
            if self.stage != nil {
                map["stage"] = self.stage!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusId != nil {
                map["statusId"] = self.statusId!
            }
            if self.storyPoint != nil {
                map["storyPoint"] = self.storyPoint!
            }
            if self.subType != nil {
                map["subType"] = self.subType!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.verifierId != nil {
                map["verifierId"] = self.verifierId!
            }
            if self.versionId != nil {
                map["versionId"] = self.versionId!
            }
            if self.versions != nil {
                map["versions"] = self.versions!
            }
            if self.workTime != nil {
                map["workTime"] = self.workTime!
            }
            if self.workitemId != nil {
                map["workitemId"] = self.workitemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedToId") {
                self.assignedToId = dict["assignedToId"] as! String
            }
            if dict.keys.contains("creatorId") {
                self.creatorId = dict["creatorId"] as! String
            }
            if dict.keys.contains("expectedWorkTime") {
                self.expectedWorkTime = dict["expectedWorkTime"] as! Int64
            }
            if dict.keys.contains("extraId") {
                self.extraId = dict["extraId"] as! Int64
            }
            if dict.keys.contains("extraIsDeleted") {
                self.extraIsDeleted = dict["extraIsDeleted"] as! String
            }
            if dict.keys.contains("foundPhase") {
                self.foundPhase = dict["foundPhase"] as! Int32
            }
            if dict.keys.contains("gmtClosed") {
                self.gmtClosed = dict["gmtClosed"] as! Int64
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtDue") {
                self.gmtDue = dict["gmtDue"] as! Int64
            }
            if dict.keys.contains("gmtFixed") {
                self.gmtFixed = dict["gmtFixed"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("gmtStart") {
                self.gmtStart = dict["gmtStart"] as! Int64
            }
            if dict.keys.contains("gmtTodo") {
                self.gmtTodo = dict["gmtTodo"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("isArchived") {
                self.isArchived = dict["isArchived"] as! String
            }
            if dict.keys.contains("isDeleted") {
                self.isDeleted = dict["isDeleted"] as! String
            }
            if dict.keys.contains("isDone") {
                self.isDone = dict["isDone"] as! String
            }
            if dict.keys.contains("isStupid") {
                self.isStupid = dict["isStupid"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("parentId") {
                self.parentId = dict["parentId"] as! String
            }
            if dict.keys.contains("participantIds") {
                self.participantIds = dict["participantIds"] as! String
            }
            if dict.keys.contains("phase") {
                self.phase = dict["phase"] as! Int32
            }
            if dict.keys.contains("priority") {
                self.priority = dict["priority"] as! Int32
            }
            if dict.keys.contains("productId") {
                self.productId = dict["productId"] as! String
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! String
            }
            if dict.keys.contains("reopenNum") {
                self.reopenNum = dict["reopenNum"] as! Int32
            }
            if dict.keys.contains("seriousLevel") {
                self.seriousLevel = dict["seriousLevel"] as! Int32
            }
            if dict.keys.contains("solution") {
                self.solution = dict["solution"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("sprintId") {
                self.sprintId = dict["sprintId"] as! String
            }
            if dict.keys.contains("stage") {
                self.stage = dict["stage"] as! Int32
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("statusId") {
                self.statusId = dict["statusId"] as! String
            }
            if dict.keys.contains("storyPoint") {
                self.storyPoint = dict["storyPoint"] as! Double
            }
            if dict.keys.contains("subType") {
                self.subType = dict["subType"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! Int32
            }
            if dict.keys.contains("verifierId") {
                self.verifierId = dict["verifierId"] as! String
            }
            if dict.keys.contains("versionId") {
                self.versionId = dict["versionId"] as! String
            }
            if dict.keys.contains("versions") {
                self.versions = dict["versions"] as! String
            }
            if dict.keys.contains("workTime") {
                self.workTime = dict["workTime"] as! Int64
            }
            if dict.keys.contains("workitemId") {
                self.workitemId = dict["workitemId"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportInsightWorkitemVersionRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportInsightWorkitemVersionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var gmtPublish: Int64?

        public var gmtStart: Int64?

        public var id: Int64?

        public var identifier: String?

        public var isDeleted: String?

        public var lockStatus: Int32?

        public var name: String?

        public var organizationId: String?

        public var source: String?

        public var status: Int32?

        public var targetId: String?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtPublish != nil {
                map["gmtPublish"] = self.gmtPublish!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isDeleted != nil {
                map["isDeleted"] = self.isDeleted!
            }
            if self.lockStatus != nil {
                map["lockStatus"] = self.lockStatus!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.targetId != nil {
                map["targetId"] = self.targetId!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("gmtPublish") {
                self.gmtPublish = dict["gmtPublish"] as! Int64
            }
            if dict.keys.contains("gmtStart") {
                self.gmtStart = dict["gmtStart"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("isDeleted") {
                self.isDeleted = dict["isDeleted"] as! String
            }
            if dict.keys.contains("lockStatus") {
                self.lockStatus = dict["lockStatus"] as! Int32
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! Int32
            }
            if dict.keys.contains("targetId") {
                self.targetId = dict["targetId"] as! String
            }
            if dict.keys.contains("targetType") {
                self.targetType = dict["targetType"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportInsightWorkitemVersionResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportInsightWorkitemVersionResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportInsightWorkitemVersionResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportInsightWorkitemVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportInsightWorkitemVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportInsightWorkitemVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportWorkitemActivityRequest : Tea.TeaModel {
    public var endTime: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! String
        }
    }
}

public class ExportWorkitemActivityResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var gmtEvent: Int64?

        public var id: Int64?

        public var identifier: String?

        public var newValue: String?

        public var oldValue: String?

        public var organizationId: String?

        public var projectId: String?

        public var source: String?

        public var type: String?

        public var workitemId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtEvent != nil {
                map["gmtEvent"] = self.gmtEvent!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.newValue != nil {
                map["newValue"] = self.newValue!
            }
            if self.oldValue != nil {
                map["oldValue"] = self.oldValue!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.workitemId != nil {
                map["workitemId"] = self.workitemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtEvent") {
                self.gmtEvent = dict["gmtEvent"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("newValue") {
                self.newValue = dict["newValue"] as! String
            }
            if dict.keys.contains("oldValue") {
                self.oldValue = dict["oldValue"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("workitemId") {
                self.workitemId = dict["workitemId"] as! String
            }
        }
    }
    public var maxResults: Int64?

    public var nextToken: String?

    public var result: [ExportWorkitemActivityResponseBody.Result]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ExportWorkitemActivityResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ExportWorkitemActivityResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ExportWorkitemActivityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportWorkitemActivityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportWorkitemActivityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FrozenWorkspaceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class FrozenWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FrozenWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = FrozenWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetApplicationRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class GetApplicationResponseBody : Tea.TeaModel {
    public var appTemplateDisplayName: String?

    public var appTemplateName: String?

    public var creatorAccountId: String?

    public var description_: String?

    public var gmtCreate: String?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appTemplateDisplayName != nil {
            map["appTemplateDisplayName"] = self.appTemplateDisplayName!
        }
        if self.appTemplateName != nil {
            map["appTemplateName"] = self.appTemplateName!
        }
        if self.creatorAccountId != nil {
            map["creatorAccountId"] = self.creatorAccountId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("appTemplateDisplayName") {
            self.appTemplateDisplayName = dict["appTemplateDisplayName"] as! String
        }
        if dict.keys.contains("appTemplateName") {
            self.appTemplateName = dict["appTemplateName"] as! String
        }
        if dict.keys.contains("creatorAccountId") {
            self.creatorAccountId = dict["creatorAccountId"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("gmtCreate") {
            self.gmtCreate = dict["gmtCreate"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBranchInfoRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("branchName") {
            self.branchName = dict["branchName"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class GetBranchInfoResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public class Author : Tea.TeaModel {
                public var avatarUrl: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var state: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avatarUrl != nil {
                        map["avatarUrl"] = self.avatarUrl!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("avatarUrl") {
                        self.avatarUrl = dict["avatarUrl"] as! String
                    }
                    if dict.keys.contains("email") {
                        self.email = dict["email"] as! String
                    }
                    if dict.keys.contains("id") {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("state") {
                        self.state = dict["state"] as! String
                    }
                    if dict.keys.contains("username") {
                        self.username = dict["username"] as! String
                    }
                }
            }
            public class Committer : Tea.TeaModel {
                public var avatarUrl: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var state: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avatarUrl != nil {
                        map["avatarUrl"] = self.avatarUrl!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("avatarUrl") {
                        self.avatarUrl = dict["avatarUrl"] as! String
                    }
                    if dict.keys.contains("email") {
                        self.email = dict["email"] as! String
                    }
                    if dict.keys.contains("id") {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("state") {
                        self.state = dict["state"] as! String
                    }
                    if dict.keys.contains("username") {
                        self.username = dict["username"] as! String
                    }
                }
            }
            public class Signature : Tea.TeaModel {
                public var gpgKeyId: String?

                public var verificationStatus: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gpgKeyId != nil {
                        map["gpgKeyId"] = self.gpgKeyId!
                    }
                    if self.verificationStatus != nil {
                        map["verificationStatus"] = self.verificationStatus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("gpgKeyId") {
                        self.gpgKeyId = dict["gpgKeyId"] as! String
                    }
                    if dict.keys.contains("verificationStatus") {
                        self.verificationStatus = dict["verificationStatus"] as! String
                    }
                }
            }
            public var author: GetBranchInfoResponseBody.Result.Commit.Author?

            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var commentsCount: Int64?

            public var committedDate: String?

            public var committer: GetBranchInfoResponseBody.Result.Commit.Committer?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var signature: GetBranchInfoResponseBody.Result.Commit.Signature?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.author?.validate()
                try self.committer?.validate()
                try self.signature?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.author != nil {
                    map["author"] = self.author?.toMap()
                }
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.commentsCount != nil {
                    map["commentsCount"] = self.commentsCount!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committer != nil {
                    map["committer"] = self.committer?.toMap()
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.signature != nil {
                    map["signature"] = self.signature?.toMap()
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("author") {
                    var model = GetBranchInfoResponseBody.Result.Commit.Author()
                    model.fromMap(dict["author"] as! [String: Any])
                    self.author = model
                }
                if dict.keys.contains("authorEmail") {
                    self.authorEmail = dict["authorEmail"] as! String
                }
                if dict.keys.contains("authorName") {
                    self.authorName = dict["authorName"] as! String
                }
                if dict.keys.contains("authoredDate") {
                    self.authoredDate = dict["authoredDate"] as! String
                }
                if dict.keys.contains("commentsCount") {
                    self.commentsCount = dict["commentsCount"] as! Int64
                }
                if dict.keys.contains("committedDate") {
                    self.committedDate = dict["committedDate"] as! String
                }
                if dict.keys.contains("committer") {
                    var model = GetBranchInfoResponseBody.Result.Commit.Committer()
                    model.fromMap(dict["committer"] as! [String: Any])
                    self.committer = model
                }
                if dict.keys.contains("committerEmail") {
                    self.committerEmail = dict["committerEmail"] as! String
                }
                if dict.keys.contains("committerName") {
                    self.committerName = dict["committerName"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("parentIds") {
                    self.parentIds = dict["parentIds"] as! [String]
                }
                if dict.keys.contains("shortId") {
                    self.shortId = dict["shortId"] as! String
                }
                if dict.keys.contains("signature") {
                    var model = GetBranchInfoResponseBody.Result.Commit.Signature()
                    model.fromMap(dict["signature"] as! [String: Any])
                    self.signature = model
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public var commit: GetBranchInfoResponseBody.Result.Commit?

        public var name: String?

        public var protected: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.protected != nil {
                map["protected"] = self.protected!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("commit") {
                var model = GetBranchInfoResponseBody.Result.Commit()
                model.fromMap(dict["commit"] as! [String: Any])
                self.commit = model
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("protected") {
                self.protected = dict["protected"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetBranchInfoResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetBranchInfoResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetBranchInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBranchInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBranchInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCheckRunRequest : Tea.TeaModel {
    public var accessToken: String?

    public var checkRunId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.checkRunId != nil {
            map["checkRunId"] = self.checkRunId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("checkRunId") {
            self.checkRunId = dict["checkRunId"] as! Int64
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class GetCheckRunResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var annotationLevel: String?

            public var endColumn: Int64?

            public var endLine: Int64?

            public var id: Int64?

            public var message: String?

            public var path: String?

            public var rawDetails: String?

            public var startColumn: Int64?

            public var startLine: Int64?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotationLevel != nil {
                    map["annotationLevel"] = self.annotationLevel!
                }
                if self.endColumn != nil {
                    map["endColumn"] = self.endColumn!
                }
                if self.endLine != nil {
                    map["endLine"] = self.endLine!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.rawDetails != nil {
                    map["rawDetails"] = self.rawDetails!
                }
                if self.startColumn != nil {
                    map["startColumn"] = self.startColumn!
                }
                if self.startLine != nil {
                    map["startLine"] = self.startLine!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("annotationLevel") {
                    self.annotationLevel = dict["annotationLevel"] as! String
                }
                if dict.keys.contains("endColumn") {
                    self.endColumn = dict["endColumn"] as! Int64
                }
                if dict.keys.contains("endLine") {
                    self.endLine = dict["endLine"] as! Int64
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("rawDetails") {
                    self.rawDetails = dict["rawDetails"] as! String
                }
                if dict.keys.contains("startColumn") {
                    self.startColumn = dict["startColumn"] as! Int64
                }
                if dict.keys.contains("startLine") {
                    self.startLine = dict["startLine"] as! Int64
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class CheckSuite : Tea.TeaModel {
            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class Images : Tea.TeaModel {
                public var alt: String?

                public var caption: String?

                public var imageUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alt != nil {
                        map["alt"] = self.alt!
                    }
                    if self.caption != nil {
                        map["caption"] = self.caption!
                    }
                    if self.imageUrl != nil {
                        map["imageUrl"] = self.imageUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("alt") {
                        self.alt = dict["alt"] as! String
                    }
                    if dict.keys.contains("caption") {
                        self.caption = dict["caption"] as! String
                    }
                    if dict.keys.contains("imageUrl") {
                        self.imageUrl = dict["imageUrl"] as! String
                    }
                }
            }
            public var images: [GetCheckRunResponseBody.Result.Output.Images]?

            public var summary: String?

            public var text: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.images != nil {
                    var tmp : [Any] = []
                    for k in self.images! {
                        tmp.append(k.toMap())
                    }
                    map["images"] = tmp
                }
                if self.summary != nil {
                    map["summary"] = self.summary!
                }
                if self.text != nil {
                    map["text"] = self.text!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("images") {
                    var tmp : [GetCheckRunResponseBody.Result.Output.Images] = []
                    for v in dict["images"] as! [Any] {
                        var model = GetCheckRunResponseBody.Result.Output.Images()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.images = tmp
                }
                if dict.keys.contains("summary") {
                    self.summary = dict["summary"] as! String
                }
                if dict.keys.contains("text") {
                    self.text = dict["text"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class Writer : Tea.TeaModel {
            public var id: String?

            public var logoUrl: String?

            public var name: String?

            public var slug: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.logoUrl != nil {
                    map["logoUrl"] = self.logoUrl!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.slug != nil {
                    map["slug"] = self.slug!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("logoUrl") {
                    self.logoUrl = dict["logoUrl"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("slug") {
                    self.slug = dict["slug"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var annotations: [GetCheckRunResponseBody.Result.Annotations]?

        public var checkSuite: GetCheckRunResponseBody.Result.CheckSuite?

        public var completedAt: String?

        public var conclusion: String?

        public var createdAt: String?

        public var detailsUrl: String?

        public var externalId: String?

        public var headSha: String?

        public var id: Int64?

        public var name: String?

        public var output: GetCheckRunResponseBody.Result.Output?

        public var startedAt: String?

        public var status: String?

        public var updatedAt: String?

        public var writer: GetCheckRunResponseBody.Result.Writer?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkSuite?.validate()
            try self.output?.validate()
            try self.writer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["annotations"] = tmp
            }
            if self.checkSuite != nil {
                map["checkSuite"] = self.checkSuite?.toMap()
            }
            if self.completedAt != nil {
                map["completedAt"] = self.completedAt!
            }
            if self.conclusion != nil {
                map["conclusion"] = self.conclusion!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.detailsUrl != nil {
                map["detailsUrl"] = self.detailsUrl!
            }
            if self.externalId != nil {
                map["externalId"] = self.externalId!
            }
            if self.headSha != nil {
                map["headSha"] = self.headSha!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.output != nil {
                map["output"] = self.output?.toMap()
            }
            if self.startedAt != nil {
                map["startedAt"] = self.startedAt!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.writer != nil {
                map["writer"] = self.writer?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("annotations") {
                var tmp : [GetCheckRunResponseBody.Result.Annotations] = []
                for v in dict["annotations"] as! [Any] {
                    var model = GetCheckRunResponseBody.Result.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("checkSuite") {
                var model = GetCheckRunResponseBody.Result.CheckSuite()
                model.fromMap(dict["checkSuite"] as! [String: Any])
                self.checkSuite = model
            }
            if dict.keys.contains("completedAt") {
                self.completedAt = dict["completedAt"] as! String
            }
            if dict.keys.contains("conclusion") {
                self.conclusion = dict["conclusion"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("detailsUrl") {
                self.detailsUrl = dict["detailsUrl"] as! String
            }
            if dict.keys.contains("externalId") {
                self.externalId = dict["externalId"] as! String
            }
            if dict.keys.contains("headSha") {
                self.headSha = dict["headSha"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("output") {
                var model = GetCheckRunResponseBody.Result.Output()
                model.fromMap(dict["output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("startedAt") {
                self.startedAt = dict["startedAt"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("writer") {
                var model = GetCheckRunResponseBody.Result.Writer()
                model.fromMap(dict["writer"] as! [String: Any])
                self.writer = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetCheckRunResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetCheckRunResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetCheckRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCheckRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCheckRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCodeupOrganizationRequest : Tea.TeaModel {
    public var accessToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
    }
}

public class GetCodeupOrganizationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var id: Int64?

        public var namespaceId: Int64?

        public var organizationId: String?

        public var path: String?

        public var updatedAt: String?

        public var userRole: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.namespaceId != nil {
                map["namespaceId"] = self.namespaceId!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.userRole != nil {
                map["userRole"] = self.userRole!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("namespaceId") {
                self.namespaceId = dict["namespaceId"] as! Int64
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("userRole") {
                self.userRole = dict["userRole"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetCodeupOrganizationResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetCodeupOrganizationResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetCodeupOrganizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCodeupOrganizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCodeupOrganizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCompareDetailRequest : Tea.TeaModel {
    public var from: String?

    public var maxDiffByte: Int32?

    public var maxDiffFile: Int32?

    public var mergeBase: Bool?

    public var organizationId: String?

    public var to: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["from"] = self.from!
        }
        if self.maxDiffByte != nil {
            map["maxDiffByte"] = self.maxDiffByte!
        }
        if self.maxDiffFile != nil {
            map["maxDiffFile"] = self.maxDiffFile!
        }
        if self.mergeBase != nil {
            map["mergeBase"] = self.mergeBase!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.to != nil {
            map["to"] = self.to!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("from") {
            self.from = dict["from"] as! String
        }
        if dict.keys.contains("maxDiffByte") {
            self.maxDiffByte = dict["maxDiffByte"] as! Int32
        }
        if dict.keys.contains("maxDiffFile") {
            self.maxDiffFile = dict["maxDiffFile"] as! Int32
        }
        if dict.keys.contains("mergeBase") {
            self.mergeBase = dict["mergeBase"] as! Bool
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("to") {
            self.to = dict["to"] as! String
        }
    }
}

public class GetCompareDetailResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commits : Tea.TeaModel {
            public class Author : Tea.TeaModel {
                public var avatarUrl: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var state: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avatarUrl != nil {
                        map["avatarUrl"] = self.avatarUrl!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("avatarUrl") {
                        self.avatarUrl = dict["avatarUrl"] as! String
                    }
                    if dict.keys.contains("email") {
                        self.email = dict["email"] as! String
                    }
                    if dict.keys.contains("id") {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("state") {
                        self.state = dict["state"] as! String
                    }
                    if dict.keys.contains("username") {
                        self.username = dict["username"] as! String
                    }
                }
            }
            public class Committer : Tea.TeaModel {
                public var avatarUrl: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var state: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avatarUrl != nil {
                        map["avatarUrl"] = self.avatarUrl!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("avatarUrl") {
                        self.avatarUrl = dict["avatarUrl"] as! String
                    }
                    if dict.keys.contains("email") {
                        self.email = dict["email"] as! String
                    }
                    if dict.keys.contains("id") {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("state") {
                        self.state = dict["state"] as! String
                    }
                    if dict.keys.contains("username") {
                        self.username = dict["username"] as! String
                    }
                }
            }
            public var author: GetCompareDetailResponseBody.Result.Commits.Author?

            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var commentsCount: Int64?

            public var committedDate: String?

            public var committer: GetCompareDetailResponseBody.Result.Commits.Committer?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.author?.validate()
                try self.committer?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.author != nil {
                    map["author"] = self.author?.toMap()
                }
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.commentsCount != nil {
                    map["commentsCount"] = self.commentsCount!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committer != nil {
                    map["committer"] = self.committer?.toMap()
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("author") {
                    var model = GetCompareDetailResponseBody.Result.Commits.Author()
                    model.fromMap(dict["author"] as! [String: Any])
                    self.author = model
                }
                if dict.keys.contains("authorEmail") {
                    self.authorEmail = dict["authorEmail"] as! String
                }
                if dict.keys.contains("authorName") {
                    self.authorName = dict["authorName"] as! String
                }
                if dict.keys.contains("authoredDate") {
                    self.authoredDate = dict["authoredDate"] as! String
                }
                if dict.keys.contains("commentsCount") {
                    self.commentsCount = dict["commentsCount"] as! Int64
                }
                if dict.keys.contains("committedDate") {
                    self.committedDate = dict["committedDate"] as! String
                }
                if dict.keys.contains("committer") {
                    var model = GetCompareDetailResponseBody.Result.Commits.Committer()
                    model.fromMap(dict["committer"] as! [String: Any])
                    self.committer = model
                }
                if dict.keys.contains("committerEmail") {
                    self.committerEmail = dict["committerEmail"] as! String
                }
                if dict.keys.contains("committerName") {
                    self.committerName = dict["committerName"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("parentIds") {
                    self.parentIds = dict["parentIds"] as! [String]
                }
                if dict.keys.contains("shortId") {
                    self.shortId = dict["shortId"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class Diffs : Tea.TeaModel {
            public var aMode: String?

            public var bMode: String?

            public var deletedFile: Bool?

            public var diff: String?

            public var isBinary: Bool?

            public var isNewLfs: Bool?

            public var isOldLfs: Bool?

            public var newFile: Bool?

            public var newId: String?

            public var newPath: String?

            public var oldId: String?

            public var oldPath: String?

            public var renamedFile: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aMode != nil {
                    map["aMode"] = self.aMode!
                }
                if self.bMode != nil {
                    map["bMode"] = self.bMode!
                }
                if self.deletedFile != nil {
                    map["deletedFile"] = self.deletedFile!
                }
                if self.diff != nil {
                    map["diff"] = self.diff!
                }
                if self.isBinary != nil {
                    map["isBinary"] = self.isBinary!
                }
                if self.isNewLfs != nil {
                    map["isNewLfs"] = self.isNewLfs!
                }
                if self.isOldLfs != nil {
                    map["isOldLfs"] = self.isOldLfs!
                }
                if self.newFile != nil {
                    map["newFile"] = self.newFile!
                }
                if self.newId != nil {
                    map["newId"] = self.newId!
                }
                if self.newPath != nil {
                    map["newPath"] = self.newPath!
                }
                if self.oldId != nil {
                    map["oldId"] = self.oldId!
                }
                if self.oldPath != nil {
                    map["oldPath"] = self.oldPath!
                }
                if self.renamedFile != nil {
                    map["renamedFile"] = self.renamedFile!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aMode") {
                    self.aMode = dict["aMode"] as! String
                }
                if dict.keys.contains("bMode") {
                    self.bMode = dict["bMode"] as! String
                }
                if dict.keys.contains("deletedFile") {
                    self.deletedFile = dict["deletedFile"] as! Bool
                }
                if dict.keys.contains("diff") {
                    self.diff = dict["diff"] as! String
                }
                if dict.keys.contains("isBinary") {
                    self.isBinary = dict["isBinary"] as! Bool
                }
                if dict.keys.contains("isNewLfs") {
                    self.isNewLfs = dict["isNewLfs"] as! Bool
                }
                if dict.keys.contains("isOldLfs") {
                    self.isOldLfs = dict["isOldLfs"] as! Bool
                }
                if dict.keys.contains("newFile") {
                    self.newFile = dict["newFile"] as! Bool
                }
                if dict.keys.contains("newId") {
                    self.newId = dict["newId"] as! String
                }
                if dict.keys.contains("newPath") {
                    self.newPath = dict["newPath"] as! String
                }
                if dict.keys.contains("oldId") {
                    self.oldId = dict["oldId"] as! String
                }
                if dict.keys.contains("oldPath") {
                    self.oldPath = dict["oldPath"] as! String
                }
                if dict.keys.contains("renamedFile") {
                    self.renamedFile = dict["renamedFile"] as! Bool
                }
            }
        }
        public var commits: [GetCompareDetailResponseBody.Result.Commits]?

        public var diffs: [GetCompareDetailResponseBody.Result.Diffs]?

        public var messages: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commits != nil {
                var tmp : [Any] = []
                for k in self.commits! {
                    tmp.append(k.toMap())
                }
                map["commits"] = tmp
            }
            if self.diffs != nil {
                var tmp : [Any] = []
                for k in self.diffs! {
                    tmp.append(k.toMap())
                }
                map["diffs"] = tmp
            }
            if self.messages != nil {
                map["messages"] = self.messages!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("commits") {
                var tmp : [GetCompareDetailResponseBody.Result.Commits] = []
                for v in dict["commits"] as! [Any] {
                    var model = GetCompareDetailResponseBody.Result.Commits()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.commits = tmp
            }
            if dict.keys.contains("diffs") {
                var tmp : [GetCompareDetailResponseBody.Result.Diffs] = []
                for v in dict["diffs"] as! [Any] {
                    var model = GetCompareDetailResponseBody.Result.Diffs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.diffs = tmp
            }
            if dict.keys.contains("messages") {
                self.messages = dict["messages"] as! [String]
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetCompareDetailResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetCompareDetailResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetCompareDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCompareDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCompareDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCustomFieldOptionRequest : Tea.TeaModel {
    public var spaceIdentifier: String?

    public var spaceType: String?

    public var workitemTypeIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        if self.workitemTypeIdentifier != nil {
            map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("spaceIdentifier") {
            self.spaceIdentifier = dict["spaceIdentifier"] as! String
        }
        if dict.keys.contains("spaceType") {
            self.spaceType = dict["spaceType"] as! String
        }
        if dict.keys.contains("workitemTypeIdentifier") {
            self.workitemTypeIdentifier = dict["workitemTypeIdentifier"] as! String
        }
    }
}

public class GetCustomFieldOptionResponseBody : Tea.TeaModel {
    public class Fileds : Tea.TeaModel {
        public var displayValue: String?

        public var fieldIdentifier: String?

        public var identifier: String?

        public var level: Int64?

        public var position: Int64?

        public var value: String?

        public var valueEn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayValue != nil {
                map["displayValue"] = self.displayValue!
            }
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.level != nil {
                map["level"] = self.level!
            }
            if self.position != nil {
                map["position"] = self.position!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            if self.valueEn != nil {
                map["valueEn"] = self.valueEn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("displayValue") {
                self.displayValue = dict["displayValue"] as! String
            }
            if dict.keys.contains("fieldIdentifier") {
                self.fieldIdentifier = dict["fieldIdentifier"] as! String
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("level") {
                self.level = dict["level"] as! Int64
            }
            if dict.keys.contains("position") {
                self.position = dict["position"] as! Int64
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
            if dict.keys.contains("valueEn") {
                self.valueEn = dict["valueEn"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var fileds: [GetCustomFieldOptionResponseBody.Fileds]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.fileds != nil {
            var tmp : [Any] = []
            for k in self.fileds! {
                tmp.append(k.toMap())
            }
            map["fileds"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("fileds") {
            var tmp : [GetCustomFieldOptionResponseBody.Fileds] = []
            for v in dict["fileds"] as! [Any] {
                var model = GetCustomFieldOptionResponseBody.Fileds()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileds = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetCustomFieldOptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomFieldOptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCustomFieldOptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileBlobsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var filePath: String?

    public var from: Int64?

    public var organizationId: String?

    public var ref: String?

    public var to: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.from != nil {
            map["from"] = self.from!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.ref != nil {
            map["ref"] = self.ref!
        }
        if self.to != nil {
            map["to"] = self.to!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("filePath") {
            self.filePath = dict["filePath"] as! String
        }
        if dict.keys.contains("from") {
            self.from = dict["from"] as! Int64
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("ref") {
            self.ref = dict["ref"] as! String
        }
        if dict.keys.contains("to") {
            self.to = dict["to"] as! Int64
        }
    }
}

public class GetFileBlobsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var size: Int64?

        public var totalLines: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.size != nil {
                map["size"] = self.size!
            }
            if self.totalLines != nil {
                map["totalLines"] = self.totalLines!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("size") {
                self.size = dict["size"] as! Int64
            }
            if dict.keys.contains("totalLines") {
                self.totalLines = dict["totalLines"] as! Int32
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetFileBlobsResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetFileBlobsResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetFileBlobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileBlobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFileBlobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileLastCommitRequest : Tea.TeaModel {
    public var accessToken: String?

    public var filePath: String?

    public var organizationId: String?

    public var sha: String?

    public var showSignature: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.sha != nil {
            map["sha"] = self.sha!
        }
        if self.showSignature != nil {
            map["showSignature"] = self.showSignature!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("filePath") {
            self.filePath = dict["filePath"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("sha") {
            self.sha = dict["sha"] as! String
        }
        if dict.keys.contains("showSignature") {
            self.showSignature = dict["showSignature"] as! Bool
        }
    }
}

public class GetFileLastCommitResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Signature : Tea.TeaModel {
            public var gpgKeyId: String?

            public var verificationStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gpgKeyId != nil {
                    map["gpgKeyId"] = self.gpgKeyId!
                }
                if self.verificationStatus != nil {
                    map["verificationStatus"] = self.verificationStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("gpgKeyId") {
                    self.gpgKeyId = dict["gpgKeyId"] as! String
                }
                if dict.keys.contains("verificationStatus") {
                    self.verificationStatus = dict["verificationStatus"] as! String
                }
            }
        }
        public var authorDate: String?

        public var authorEmail: String?

        public var authorName: String?

        public var committedDate: String?

        public var committerEmail: String?

        public var committerName: String?

        public var createdAt: String?

        public var id: String?

        public var message: String?

        public var parentIds: [String]?

        public var shortId: String?

        public var signature: GetFileLastCommitResponseBody.Result.Signature?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.signature?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorDate != nil {
                map["authorDate"] = self.authorDate!
            }
            if self.authorEmail != nil {
                map["authorEmail"] = self.authorEmail!
            }
            if self.authorName != nil {
                map["authorName"] = self.authorName!
            }
            if self.committedDate != nil {
                map["committedDate"] = self.committedDate!
            }
            if self.committerEmail != nil {
                map["committerEmail"] = self.committerEmail!
            }
            if self.committerName != nil {
                map["committerName"] = self.committerName!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.parentIds != nil {
                map["parentIds"] = self.parentIds!
            }
            if self.shortId != nil {
                map["shortId"] = self.shortId!
            }
            if self.signature != nil {
                map["signature"] = self.signature?.toMap()
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("authorDate") {
                self.authorDate = dict["authorDate"] as! String
            }
            if dict.keys.contains("authorEmail") {
                self.authorEmail = dict["authorEmail"] as! String
            }
            if dict.keys.contains("authorName") {
                self.authorName = dict["authorName"] as! String
            }
            if dict.keys.contains("committedDate") {
                self.committedDate = dict["committedDate"] as! String
            }
            if dict.keys.contains("committerEmail") {
                self.committerEmail = dict["committerEmail"] as! String
            }
            if dict.keys.contains("committerName") {
                self.committerName = dict["committerName"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("message") {
                self.message = dict["message"] as! String
            }
            if dict.keys.contains("parentIds") {
                self.parentIds = dict["parentIds"] as! [String]
            }
            if dict.keys.contains("shortId") {
                self.shortId = dict["shortId"] as! String
            }
            if dict.keys.contains("signature") {
                var model = GetFileLastCommitResponseBody.Result.Signature()
                model.fromMap(dict["signature"] as! [String: Any])
                self.signature = model
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetFileLastCommitResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetFileLastCommitResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetFileLastCommitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileLastCommitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFileLastCommitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFlowTagGroupResponseBody : Tea.TeaModel {
    public class FlowTagGroup : Tea.TeaModel {
        public class FlowTagList : Tea.TeaModel {
            public var color: String?

            public var creatorAccountId: String?

            public var id: Int64?

            public var modiferAccountId: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.color != nil {
                    map["color"] = self.color!
                }
                if self.creatorAccountId != nil {
                    map["creatorAccountId"] = self.creatorAccountId!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.modiferAccountId != nil {
                    map["modiferAccountId"] = self.modiferAccountId!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("color") {
                    self.color = dict["color"] as! String
                }
                if dict.keys.contains("creatorAccountId") {
                    self.creatorAccountId = dict["creatorAccountId"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("modiferAccountId") {
                    self.modiferAccountId = dict["modiferAccountId"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public var creatorAccountId: String?

        public var flowTagList: [GetFlowTagGroupResponseBody.FlowTagGroup.FlowTagList]?

        public var id: Int64?

        public var modiferAccountId: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.flowTagList != nil {
                var tmp : [Any] = []
                for k in self.flowTagList! {
                    tmp.append(k.toMap())
                }
                map["flowTagList"] = tmp
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modiferAccountId != nil {
                map["modiferAccountId"] = self.modiferAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creatorAccountId") {
                self.creatorAccountId = dict["creatorAccountId"] as! String
            }
            if dict.keys.contains("flowTagList") {
                var tmp : [GetFlowTagGroupResponseBody.FlowTagGroup.FlowTagList] = []
                for v in dict["flowTagList"] as! [Any] {
                    var model = GetFlowTagGroupResponseBody.FlowTagGroup.FlowTagList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.flowTagList = tmp
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("modiferAccountId") {
                self.modiferAccountId = dict["modiferAccountId"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var flowTagGroup: GetFlowTagGroupResponseBody.FlowTagGroup?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.flowTagGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.flowTagGroup != nil {
            map["flowTagGroup"] = self.flowTagGroup?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("flowTagGroup") {
            var model = GetFlowTagGroupResponseBody.FlowTagGroup()
            model.fromMap(dict["flowTagGroup"] as! [String: Any])
            self.flowTagGroup = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetFlowTagGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFlowTagGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFlowTagGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGroupByPathRequest : Tea.TeaModel {
    public var identity: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identity != nil {
            map["identity"] = self.identity!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("identity") {
            self.identity = dict["identity"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class GetGroupByPathResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var avatarUrl: String?

        public var description_: String?

        public var id: Int64?

        public var name: String?

        public var nameWithNamespace: String?

        public var ownerId: String?

        public var parentId: String?

        public var path: String?

        public var pathWithNamespace: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("ownerId") {
                self.ownerId = dict["ownerId"] as! String
            }
            if dict.keys.contains("parentId") {
                self.parentId = dict["parentId"] as! String
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("pathWithNamespace") {
                self.pathWithNamespace = dict["pathWithNamespace"] as! String
            }
            if dict.keys.contains("visibilityLevel") {
                self.visibilityLevel = dict["visibilityLevel"] as! Int32
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetGroupByPathResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetGroupByPathResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetGroupByPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGroupByPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGroupByPathResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetGroupDetailRequest : Tea.TeaModel {
    public var accessToken: String?

    public var groupId: Int64?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.groupId != nil {
            map["groupId"] = self.groupId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("groupId") {
            self.groupId = dict["groupId"] as! Int64
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class GetGroupDetailResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var avatarUrl: String?

        public var description_: String?

        public var id: Int64?

        public var name: String?

        public var nameWithNamespace: String?

        public var ownerId: Int64?

        public var parentId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var type: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("ownerId") {
                self.ownerId = dict["ownerId"] as! Int64
            }
            if dict.keys.contains("parentId") {
                self.parentId = dict["parentId"] as! Int64
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("pathWithNamespace") {
                self.pathWithNamespace = dict["pathWithNamespace"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("visibilityLevel") {
                self.visibilityLevel = dict["visibilityLevel"] as! Int32
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetGroupDetailResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetGroupDetailResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetGroupDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGroupDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetGroupDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHostGroupResponseBody : Tea.TeaModel {
    public class HostGroup : Tea.TeaModel {
        public class HostInfos : Tea.TeaModel {
            public var aliyunRegionId: String?

            public var createTime: Int64?

            public var creatorAccountId: String?

            public var instanceName: String?

            public var ip: String?

            public var machineSn: String?

            public var modifierAccountId: String?

            public var objectType: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunRegionId != nil {
                    map["aliyunRegionId"] = self.aliyunRegionId!
                }
                if self.createTime != nil {
                    map["createTime"] = self.createTime!
                }
                if self.creatorAccountId != nil {
                    map["creatorAccountId"] = self.creatorAccountId!
                }
                if self.instanceName != nil {
                    map["instanceName"] = self.instanceName!
                }
                if self.ip != nil {
                    map["ip"] = self.ip!
                }
                if self.machineSn != nil {
                    map["machineSn"] = self.machineSn!
                }
                if self.modifierAccountId != nil {
                    map["modifierAccountId"] = self.modifierAccountId!
                }
                if self.objectType != nil {
                    map["objectType"] = self.objectType!
                }
                if self.updateTime != nil {
                    map["updateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliyunRegionId") {
                    self.aliyunRegionId = dict["aliyunRegionId"] as! String
                }
                if dict.keys.contains("createTime") {
                    self.createTime = dict["createTime"] as! Int64
                }
                if dict.keys.contains("creatorAccountId") {
                    self.creatorAccountId = dict["creatorAccountId"] as! String
                }
                if dict.keys.contains("instanceName") {
                    self.instanceName = dict["instanceName"] as! String
                }
                if dict.keys.contains("ip") {
                    self.ip = dict["ip"] as! String
                }
                if dict.keys.contains("machineSn") {
                    self.machineSn = dict["machineSn"] as! String
                }
                if dict.keys.contains("modifierAccountId") {
                    self.modifierAccountId = dict["modifierAccountId"] as! String
                }
                if dict.keys.contains("objectType") {
                    self.objectType = dict["objectType"] as! String
                }
                if dict.keys.contains("updateTime") {
                    self.updateTime = dict["updateTime"] as! Int64
                }
            }
        }
        public var aliyunRegion: String?

        public var createTime: Int64?

        public var creatorAccountId: String?

        public var description_: String?

        public var ecsLabelKey: String?

        public var ecsLabelValue: String?

        public var ecsType: String?

        public var hostInfos: [GetHostGroupResponseBody.HostGroup.HostInfos]?

        public var hostNum: Int64?

        public var id: Int64?

        public var modifierAccountId: String?

        public var name: String?

        public var serviceConnectionId: Int64?

        public var type: String?

        public var upateTIme: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunRegion != nil {
                map["aliyunRegion"] = self.aliyunRegion!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.ecsLabelKey != nil {
                map["ecsLabelKey"] = self.ecsLabelKey!
            }
            if self.ecsLabelValue != nil {
                map["ecsLabelValue"] = self.ecsLabelValue!
            }
            if self.ecsType != nil {
                map["ecsType"] = self.ecsType!
            }
            if self.hostInfos != nil {
                var tmp : [Any] = []
                for k in self.hostInfos! {
                    tmp.append(k.toMap())
                }
                map["hostInfos"] = tmp
            }
            if self.hostNum != nil {
                map["hostNum"] = self.hostNum!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.serviceConnectionId != nil {
                map["serviceConnectionId"] = self.serviceConnectionId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.upateTIme != nil {
                map["upateTIme"] = self.upateTIme!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("aliyunRegion") {
                self.aliyunRegion = dict["aliyunRegion"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("creatorAccountId") {
                self.creatorAccountId = dict["creatorAccountId"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("ecsLabelKey") {
                self.ecsLabelKey = dict["ecsLabelKey"] as! String
            }
            if dict.keys.contains("ecsLabelValue") {
                self.ecsLabelValue = dict["ecsLabelValue"] as! String
            }
            if dict.keys.contains("ecsType") {
                self.ecsType = dict["ecsType"] as! String
            }
            if dict.keys.contains("hostInfos") {
                var tmp : [GetHostGroupResponseBody.HostGroup.HostInfos] = []
                for v in dict["hostInfos"] as! [Any] {
                    var model = GetHostGroupResponseBody.HostGroup.HostInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hostInfos = tmp
            }
            if dict.keys.contains("hostNum") {
                self.hostNum = dict["hostNum"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("modifierAccountId") {
                self.modifierAccountId = dict["modifierAccountId"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("serviceConnectionId") {
                self.serviceConnectionId = dict["serviceConnectionId"] as! Int64
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("upateTIme") {
                self.upateTIme = dict["upateTIme"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var hostGroup: GetHostGroupResponseBody.HostGroup?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hostGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.hostGroup != nil {
            map["hostGroup"] = self.hostGroup?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("hostGroup") {
            var model = GetHostGroupResponseBody.HostGroup()
            model.fromMap(dict["hostGroup"] as! [String: Any])
            self.hostGroup = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetHostGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHostGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetHostGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class GetMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public class Reviewers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var hasCommented: Bool?

            public var hasReviewed: Bool?

            public var id: Int64?

            public var name: String?

            public var reviewOpinionStatus: String?

            public var reviewTime: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.hasCommented != nil {
                    map["hasCommented"] = self.hasCommented!
                }
                if self.hasReviewed != nil {
                    map["hasReviewed"] = self.hasReviewed!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.reviewOpinionStatus != nil {
                    map["reviewOpinionStatus"] = self.reviewOpinionStatus!
                }
                if self.reviewTime != nil {
                    map["reviewTime"] = self.reviewTime!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("hasCommented") {
                    self.hasCommented = dict["hasCommented"] as! Bool
                }
                if dict.keys.contains("hasReviewed") {
                    self.hasReviewed = dict["hasReviewed"] as! Bool
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("reviewOpinionStatus") {
                    self.reviewOpinionStatus = dict["reviewOpinionStatus"] as! String
                }
                if dict.keys.contains("reviewTime") {
                    self.reviewTime = dict["reviewTime"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public class Subscribers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public class TodoList : Tea.TeaModel {
            public class RequirementCheckItems : Tea.TeaModel {
                public var itemType: String?

                public var pass: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.itemType != nil {
                        map["itemType"] = self.itemType!
                    }
                    if self.pass != nil {
                        map["pass"] = self.pass!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("itemType") {
                        self.itemType = dict["itemType"] as! String
                    }
                    if dict.keys.contains("pass") {
                        self.pass = dict["pass"] as! Bool
                    }
                }
            }
            public var requirementCheckItems: [GetMergeRequestResponseBody.Result.TodoList.RequirementCheckItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requirementCheckItems != nil {
                    var tmp : [Any] = []
                    for k in self.requirementCheckItems! {
                        tmp.append(k.toMap())
                    }
                    map["requirementCheckItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("requirementCheckItems") {
                    var tmp : [GetMergeRequestResponseBody.Result.TodoList.RequirementCheckItems] = []
                    for v in dict["requirementCheckItems"] as! [Any] {
                        var model = GetMergeRequestResponseBody.Result.TodoList.RequirementCheckItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.requirementCheckItems = tmp
                }
            }
        }
        public var ahead: Int32?

        public var allRequirementsPass: Bool?

        public var author: GetMergeRequestResponseBody.Result.Author?

        public var behind: Int32?

        public var createFrom: String?

        public var createTime: String?

        public var description_: String?

        public var detailUrl: String?

        public var localId: Int64?

        public var mergedRevision: String?

        public var mrBizId: String?

        public var mrType: String?

        public var projectId: Int64?

        public var reviewers: [GetMergeRequestResponseBody.Result.Reviewers]?

        public var sourceBranch: String?

        public var sourceProjectId: Int64?

        public var status: String?

        public var subscribers: [GetMergeRequestResponseBody.Result.Subscribers]?

        public var supportMergeFastForwardOnly: Bool?

        public var targetBranch: String?

        public var targetProjectId: Int64?

        public var targetProjectNameWithNamespace: String?

        public var targetProjectPathWithNamespace: String?

        public var title: String?

        public var todoList: GetMergeRequestResponseBody.Result.TodoList?

        public var updateTime: String?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.todoList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ahead != nil {
                map["ahead"] = self.ahead!
            }
            if self.allRequirementsPass != nil {
                map["allRequirementsPass"] = self.allRequirementsPass!
            }
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.behind != nil {
                map["behind"] = self.behind!
            }
            if self.createFrom != nil {
                map["createFrom"] = self.createFrom!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.detailUrl != nil {
                map["detailUrl"] = self.detailUrl!
            }
            if self.localId != nil {
                map["localId"] = self.localId!
            }
            if self.mergedRevision != nil {
                map["mergedRevision"] = self.mergedRevision!
            }
            if self.mrBizId != nil {
                map["mrBizId"] = self.mrBizId!
            }
            if self.mrType != nil {
                map["mrType"] = self.mrType!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.reviewers != nil {
                var tmp : [Any] = []
                for k in self.reviewers! {
                    tmp.append(k.toMap())
                }
                map["reviewers"] = tmp
            }
            if self.sourceBranch != nil {
                map["sourceBranch"] = self.sourceBranch!
            }
            if self.sourceProjectId != nil {
                map["sourceProjectId"] = self.sourceProjectId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.subscribers != nil {
                var tmp : [Any] = []
                for k in self.subscribers! {
                    tmp.append(k.toMap())
                }
                map["subscribers"] = tmp
            }
            if self.supportMergeFastForwardOnly != nil {
                map["supportMergeFastForwardOnly"] = self.supportMergeFastForwardOnly!
            }
            if self.targetBranch != nil {
                map["targetBranch"] = self.targetBranch!
            }
            if self.targetProjectId != nil {
                map["targetProjectId"] = self.targetProjectId!
            }
            if self.targetProjectNameWithNamespace != nil {
                map["targetProjectNameWithNamespace"] = self.targetProjectNameWithNamespace!
            }
            if self.targetProjectPathWithNamespace != nil {
                map["targetProjectPathWithNamespace"] = self.targetProjectPathWithNamespace!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.todoList != nil {
                map["todoList"] = self.todoList?.toMap()
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ahead") {
                self.ahead = dict["ahead"] as! Int32
            }
            if dict.keys.contains("allRequirementsPass") {
                self.allRequirementsPass = dict["allRequirementsPass"] as! Bool
            }
            if dict.keys.contains("author") {
                var model = GetMergeRequestResponseBody.Result.Author()
                model.fromMap(dict["author"] as! [String: Any])
                self.author = model
            }
            if dict.keys.contains("behind") {
                self.behind = dict["behind"] as! Int32
            }
            if dict.keys.contains("createFrom") {
                self.createFrom = dict["createFrom"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("detailUrl") {
                self.detailUrl = dict["detailUrl"] as! String
            }
            if dict.keys.contains("localId") {
                self.localId = dict["localId"] as! Int64
            }
            if dict.keys.contains("mergedRevision") {
                self.mergedRevision = dict["mergedRevision"] as! String
            }
            if dict.keys.contains("mrBizId") {
                self.mrBizId = dict["mrBizId"] as! String
            }
            if dict.keys.contains("mrType") {
                self.mrType = dict["mrType"] as! String
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! Int64
            }
            if dict.keys.contains("reviewers") {
                var tmp : [GetMergeRequestResponseBody.Result.Reviewers] = []
                for v in dict["reviewers"] as! [Any] {
                    var model = GetMergeRequestResponseBody.Result.Reviewers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reviewers = tmp
            }
            if dict.keys.contains("sourceBranch") {
                self.sourceBranch = dict["sourceBranch"] as! String
            }
            if dict.keys.contains("sourceProjectId") {
                self.sourceProjectId = dict["sourceProjectId"] as! Int64
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("subscribers") {
                var tmp : [GetMergeRequestResponseBody.Result.Subscribers] = []
                for v in dict["subscribers"] as! [Any] {
                    var model = GetMergeRequestResponseBody.Result.Subscribers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.subscribers = tmp
            }
            if dict.keys.contains("supportMergeFastForwardOnly") {
                self.supportMergeFastForwardOnly = dict["supportMergeFastForwardOnly"] as! Bool
            }
            if dict.keys.contains("targetBranch") {
                self.targetBranch = dict["targetBranch"] as! String
            }
            if dict.keys.contains("targetProjectId") {
                self.targetProjectId = dict["targetProjectId"] as! Int64
            }
            if dict.keys.contains("targetProjectNameWithNamespace") {
                self.targetProjectNameWithNamespace = dict["targetProjectNameWithNamespace"] as! String
            }
            if dict.keys.contains("targetProjectPathWithNamespace") {
                self.targetProjectPathWithNamespace = dict["targetProjectPathWithNamespace"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("todoList") {
                var model = GetMergeRequestResponseBody.Result.TodoList()
                model.fromMap(dict["todoList"] as! [String: Any])
                self.todoList = model
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! String
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetMergeRequestResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMergeRequestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMergeRequestChangeTreeRequest : Tea.TeaModel {
    public var accessToken: String?

    public var fromPatchSetBizId: String?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public var toPatchSetBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.fromPatchSetBizId != nil {
            map["fromPatchSetBizId"] = self.fromPatchSetBizId!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        if self.toPatchSetBizId != nil {
            map["toPatchSetBizId"] = self.toPatchSetBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("fromPatchSetBizId") {
            self.fromPatchSetBizId = dict["fromPatchSetBizId"] as! String
        }
        if dict.keys.contains("localId") {
            self.localId = dict["localId"] as! Int64
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
        if dict.keys.contains("toPatchSetBizId") {
            self.toPatchSetBizId = dict["toPatchSetBizId"] as! String
        }
    }
}

public class GetMergeRequestChangeTreeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ChangedFilesInfos : Tea.TeaModel {
            public var addLines: Int64?

            public var binaryFile: Bool?

            public var delLines: Int64?

            public var deletedFile: Bool?

            public var newFile: Bool?

            public var newPath: String?

            public var oldPath: String?

            public var renamedFile: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addLines != nil {
                    map["addLines"] = self.addLines!
                }
                if self.binaryFile != nil {
                    map["binaryFile"] = self.binaryFile!
                }
                if self.delLines != nil {
                    map["delLines"] = self.delLines!
                }
                if self.deletedFile != nil {
                    map["deletedFile"] = self.deletedFile!
                }
                if self.newFile != nil {
                    map["newFile"] = self.newFile!
                }
                if self.newPath != nil {
                    map["newPath"] = self.newPath!
                }
                if self.oldPath != nil {
                    map["oldPath"] = self.oldPath!
                }
                if self.renamedFile != nil {
                    map["renamedFile"] = self.renamedFile!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("addLines") {
                    self.addLines = dict["addLines"] as! Int64
                }
                if dict.keys.contains("binaryFile") {
                    self.binaryFile = dict["binaryFile"] as! Bool
                }
                if dict.keys.contains("delLines") {
                    self.delLines = dict["delLines"] as! Int64
                }
                if dict.keys.contains("deletedFile") {
                    self.deletedFile = dict["deletedFile"] as! Bool
                }
                if dict.keys.contains("newFile") {
                    self.newFile = dict["newFile"] as! Bool
                }
                if dict.keys.contains("newPath") {
                    self.newPath = dict["newPath"] as! String
                }
                if dict.keys.contains("oldPath") {
                    self.oldPath = dict["oldPath"] as! String
                }
                if dict.keys.contains("renamedFile") {
                    self.renamedFile = dict["renamedFile"] as! Bool
                }
            }
        }
        public var changedFilesCount: Int64?

        public var changedFilesInfos: [GetMergeRequestChangeTreeResponseBody.Result.ChangedFilesInfos]?

        public var totalAddLines: Int64?

        public var totalDelLines: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changedFilesCount != nil {
                map["changedFilesCount"] = self.changedFilesCount!
            }
            if self.changedFilesInfos != nil {
                var tmp : [Any] = []
                for k in self.changedFilesInfos! {
                    tmp.append(k.toMap())
                }
                map["changedFilesInfos"] = tmp
            }
            if self.totalAddLines != nil {
                map["totalAddLines"] = self.totalAddLines!
            }
            if self.totalDelLines != nil {
                map["totalDelLines"] = self.totalDelLines!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("changedFilesCount") {
                self.changedFilesCount = dict["changedFilesCount"] as! Int64
            }
            if dict.keys.contains("changedFilesInfos") {
                var tmp : [GetMergeRequestChangeTreeResponseBody.Result.ChangedFilesInfos] = []
                for v in dict["changedFilesInfos"] as! [Any] {
                    var model = GetMergeRequestChangeTreeResponseBody.Result.ChangedFilesInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.changedFilesInfos = tmp
            }
            if dict.keys.contains("totalAddLines") {
                self.totalAddLines = dict["totalAddLines"] as! Int64
            }
            if dict.keys.contains("totalDelLines") {
                self.totalDelLines = dict["totalDelLines"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetMergeRequestChangeTreeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetMergeRequestChangeTreeResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetMergeRequestChangeTreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMergeRequestChangeTreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMergeRequestChangeTreeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOrganizationMemberResponseBody : Tea.TeaModel {
    public class Member : Tea.TeaModel {
        public class Identities : Tea.TeaModel {
            public var externUid: String?

            public var provider: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.externUid != nil {
                    map["externUid"] = self.externUid!
                }
                if self.provider != nil {
                    map["provider"] = self.provider!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("externUid") {
                    self.externUid = dict["externUid"] as! String
                }
                if dict.keys.contains("provider") {
                    self.provider = dict["provider"] as! String
                }
            }
        }
        public var accountId: String?

        public var birthday: Int64?

        public var deptLists: [String]?

        public var email: String?

        public var hiredDate: Int64?

        public var identities: GetOrganizationMemberResponseBody.Member.Identities?

        public var jobNumber: String?

        public var joinTime: Int64?

        public var lastVisitTime: Int64?

        public var mobile: String?

        public var organizationMemberName: String?

        public var organizationRoleId: String?

        public var organizationRoleName: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.identities?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            if self.birthday != nil {
                map["birthday"] = self.birthday!
            }
            if self.deptLists != nil {
                map["deptLists"] = self.deptLists!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.hiredDate != nil {
                map["hiredDate"] = self.hiredDate!
            }
            if self.identities != nil {
                map["identities"] = self.identities?.toMap()
            }
            if self.jobNumber != nil {
                map["jobNumber"] = self.jobNumber!
            }
            if self.joinTime != nil {
                map["joinTime"] = self.joinTime!
            }
            if self.lastVisitTime != nil {
                map["lastVisitTime"] = self.lastVisitTime!
            }
            if self.mobile != nil {
                map["mobile"] = self.mobile!
            }
            if self.organizationMemberName != nil {
                map["organizationMemberName"] = self.organizationMemberName!
            }
            if self.organizationRoleId != nil {
                map["organizationRoleId"] = self.organizationRoleId!
            }
            if self.organizationRoleName != nil {
                map["organizationRoleName"] = self.organizationRoleName!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
            if dict.keys.contains("birthday") {
                self.birthday = dict["birthday"] as! Int64
            }
            if dict.keys.contains("deptLists") {
                self.deptLists = dict["deptLists"] as! [String]
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("hiredDate") {
                self.hiredDate = dict["hiredDate"] as! Int64
            }
            if dict.keys.contains("identities") {
                var model = GetOrganizationMemberResponseBody.Member.Identities()
                model.fromMap(dict["identities"] as! [String: Any])
                self.identities = model
            }
            if dict.keys.contains("jobNumber") {
                self.jobNumber = dict["jobNumber"] as! String
            }
            if dict.keys.contains("joinTime") {
                self.joinTime = dict["joinTime"] as! Int64
            }
            if dict.keys.contains("lastVisitTime") {
                self.lastVisitTime = dict["lastVisitTime"] as! Int64
            }
            if dict.keys.contains("mobile") {
                self.mobile = dict["mobile"] as! String
            }
            if dict.keys.contains("organizationMemberName") {
                self.organizationMemberName = dict["organizationMemberName"] as! String
            }
            if dict.keys.contains("organizationRoleId") {
                self.organizationRoleId = dict["organizationRoleId"] as! String
            }
            if dict.keys.contains("organizationRoleName") {
                self.organizationRoleName = dict["organizationRoleName"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var member: GetOrganizationMemberResponseBody.Member?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.member?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.member != nil {
            map["member"] = self.member?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("member") {
            var model = GetOrganizationMemberResponseBody.Member()
            model.fromMap(dict["member"] as! [String: Any])
            self.member = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetOrganizationMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOrganizationMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOrganizationMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public class PipelineConfig : Tea.TeaModel {
            public class Sources : Tea.TeaModel {
                public class Data : Tea.TeaModel {
                    public var branch: String?

                    public var cloneDepth: Int64?

                    public var credentialId: Int64?

                    public var credentialLabel: String?

                    public var credentialType: String?

                    public var events: [String]?

                    public var isBranchMode: Bool?

                    public var isCloneDepth: Bool?

                    public var isSubmodule: Bool?

                    public var isTrigger: Bool?

                    public var label: String?

                    public var namespace: String?

                    public var repo: String?

                    public var serviceConnectionId: Int64?

                    public var triggerFilter: String?

                    public var webhook: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.branch != nil {
                            map["branch"] = self.branch!
                        }
                        if self.cloneDepth != nil {
                            map["cloneDepth"] = self.cloneDepth!
                        }
                        if self.credentialId != nil {
                            map["credentialId"] = self.credentialId!
                        }
                        if self.credentialLabel != nil {
                            map["credentialLabel"] = self.credentialLabel!
                        }
                        if self.credentialType != nil {
                            map["credentialType"] = self.credentialType!
                        }
                        if self.events != nil {
                            map["events"] = self.events!
                        }
                        if self.isBranchMode != nil {
                            map["isBranchMode"] = self.isBranchMode!
                        }
                        if self.isCloneDepth != nil {
                            map["isCloneDepth"] = self.isCloneDepth!
                        }
                        if self.isSubmodule != nil {
                            map["isSubmodule"] = self.isSubmodule!
                        }
                        if self.isTrigger != nil {
                            map["isTrigger"] = self.isTrigger!
                        }
                        if self.label != nil {
                            map["label"] = self.label!
                        }
                        if self.namespace != nil {
                            map["namespace"] = self.namespace!
                        }
                        if self.repo != nil {
                            map["repo"] = self.repo!
                        }
                        if self.serviceConnectionId != nil {
                            map["serviceConnectionId"] = self.serviceConnectionId!
                        }
                        if self.triggerFilter != nil {
                            map["triggerFilter"] = self.triggerFilter!
                        }
                        if self.webhook != nil {
                            map["webhook"] = self.webhook!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("branch") {
                            self.branch = dict["branch"] as! String
                        }
                        if dict.keys.contains("cloneDepth") {
                            self.cloneDepth = dict["cloneDepth"] as! Int64
                        }
                        if dict.keys.contains("credentialId") {
                            self.credentialId = dict["credentialId"] as! Int64
                        }
                        if dict.keys.contains("credentialLabel") {
                            self.credentialLabel = dict["credentialLabel"] as! String
                        }
                        if dict.keys.contains("credentialType") {
                            self.credentialType = dict["credentialType"] as! String
                        }
                        if dict.keys.contains("events") {
                            self.events = dict["events"] as! [String]
                        }
                        if dict.keys.contains("isBranchMode") {
                            self.isBranchMode = dict["isBranchMode"] as! Bool
                        }
                        if dict.keys.contains("isCloneDepth") {
                            self.isCloneDepth = dict["isCloneDepth"] as! Bool
                        }
                        if dict.keys.contains("isSubmodule") {
                            self.isSubmodule = dict["isSubmodule"] as! Bool
                        }
                        if dict.keys.contains("isTrigger") {
                            self.isTrigger = dict["isTrigger"] as! Bool
                        }
                        if dict.keys.contains("label") {
                            self.label = dict["label"] as! String
                        }
                        if dict.keys.contains("namespace") {
                            self.namespace = dict["namespace"] as! String
                        }
                        if dict.keys.contains("repo") {
                            self.repo = dict["repo"] as! String
                        }
                        if dict.keys.contains("serviceConnectionId") {
                            self.serviceConnectionId = dict["serviceConnectionId"] as! Int64
                        }
                        if dict.keys.contains("triggerFilter") {
                            self.triggerFilter = dict["triggerFilter"] as! String
                        }
                        if dict.keys.contains("webhook") {
                            self.webhook = dict["webhook"] as! String
                        }
                    }
                }
                public var data: GetPipelineResponseBody.Pipeline.PipelineConfig.Sources.Data?

                public var sign: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.data?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.data != nil {
                        map["data"] = self.data?.toMap()
                    }
                    if self.sign != nil {
                        map["sign"] = self.sign!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("data") {
                        var model = GetPipelineResponseBody.Pipeline.PipelineConfig.Sources.Data()
                        model.fromMap(dict["data"] as! [String: Any])
                        self.data = model
                    }
                    if dict.keys.contains("sign") {
                        self.sign = dict["sign"] as! String
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                }
            }
            public var flow: String?

            public var settings: String?

            public var sources: [GetPipelineResponseBody.Pipeline.PipelineConfig.Sources]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.flow != nil {
                    map["flow"] = self.flow!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                if self.sources != nil {
                    var tmp : [Any] = []
                    for k in self.sources! {
                        tmp.append(k.toMap())
                    }
                    map["sources"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("flow") {
                    self.flow = dict["flow"] as! String
                }
                if dict.keys.contains("settings") {
                    self.settings = dict["settings"] as! String
                }
                if dict.keys.contains("sources") {
                    var tmp : [GetPipelineResponseBody.Pipeline.PipelineConfig.Sources] = []
                    for v in dict["sources"] as! [Any] {
                        var model = GetPipelineResponseBody.Pipeline.PipelineConfig.Sources()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.sources = tmp
                }
            }
        }
        public class TagList : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public var createTime: Int64?

        public var creatorAccountId: String?

        public var envId: Int32?

        public var envName: String?

        public var groupId: Int64?

        public var modifierAccountId: String?

        public var name: String?

        public var pipelineConfig: GetPipelineResponseBody.Pipeline.PipelineConfig?

        public var tagList: [GetPipelineResponseBody.Pipeline.TagList]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pipelineConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.envId != nil {
                map["envId"] = self.envId!
            }
            if self.envName != nil {
                map["envName"] = self.envName!
            }
            if self.groupId != nil {
                map["groupId"] = self.groupId!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.pipelineConfig != nil {
                map["pipelineConfig"] = self.pipelineConfig?.toMap()
            }
            if self.tagList != nil {
                var tmp : [Any] = []
                for k in self.tagList! {
                    tmp.append(k.toMap())
                }
                map["tagList"] = tmp
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("creatorAccountId") {
                self.creatorAccountId = dict["creatorAccountId"] as! String
            }
            if dict.keys.contains("envId") {
                self.envId = dict["envId"] as! Int32
            }
            if dict.keys.contains("envName") {
                self.envName = dict["envName"] as! String
            }
            if dict.keys.contains("groupId") {
                self.groupId = dict["groupId"] as! Int64
            }
            if dict.keys.contains("modifierAccountId") {
                self.modifierAccountId = dict["modifierAccountId"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("pipelineConfig") {
                var model = GetPipelineResponseBody.Pipeline.PipelineConfig()
                model.fromMap(dict["pipelineConfig"] as! [String: Any])
                self.pipelineConfig = model
            }
            if dict.keys.contains("tagList") {
                var tmp : [GetPipelineResponseBody.Pipeline.TagList] = []
                for v in dict["tagList"] as! [Any] {
                    var model = GetPipelineResponseBody.Pipeline.TagList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagList = tmp
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var pipeline: GetPipelineResponseBody.Pipeline?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipeline != nil {
            map["pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("pipeline") {
            var model = GetPipelineResponseBody.Pipeline()
            model.fromMap(dict["pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPipelineArtifactUrlRequest : Tea.TeaModel {
    public var fileName: String?

    public var filePath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["fileName"] = self.fileName!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("fileName") {
            self.fileName = dict["fileName"] as! String
        }
        if dict.keys.contains("filePath") {
            self.filePath = dict["filePath"] as! String
        }
    }
}

public class GetPipelineArtifactUrlResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var fileUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.fileUrl != nil {
            map["fileUrl"] = self.fileUrl!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("fileUrl") {
            self.fileUrl = dict["fileUrl"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetPipelineArtifactUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineArtifactUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPipelineArtifactUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPipelineEmasArtifactUrlRequest : Tea.TeaModel {
    public var serviceConnectionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serviceConnectionId != nil {
            map["serviceConnectionId"] = self.serviceConnectionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("serviceConnectionId") {
            self.serviceConnectionId = dict["serviceConnectionId"] as! Int64
        }
    }
}

public class GetPipelineEmasArtifactUrlResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var fileUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.fileUrl != nil {
            map["fileUrl"] = self.fileUrl!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("fileUrl") {
            self.fileUrl = dict["fileUrl"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetPipelineEmasArtifactUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineEmasArtifactUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPipelineEmasArtifactUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPipelineGroupResponseBody : Tea.TeaModel {
    public class PipelineGroup : Tea.TeaModel {
        public var createTime: Int64?

        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelineGroup: GetPipelineGroupResponseBody.PipelineGroup?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipelineGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelineGroup != nil {
            map["pipelineGroup"] = self.pipelineGroup?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("pipelineGroup") {
            var model = GetPipelineGroupResponseBody.PipelineGroup()
            model.fromMap(dict["pipelineGroup"] as! [String: Any])
            self.pipelineGroup = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetPipelineGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPipelineGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPipelineRunResponseBody : Tea.TeaModel {
    public class PipelineRun : Tea.TeaModel {
        public class Sources : Tea.TeaModel {
            public class Data : Tea.TeaModel {
                public var branch: String?

                public var commint: String?

                public var repo: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.branch != nil {
                        map["branch"] = self.branch!
                    }
                    if self.commint != nil {
                        map["commint"] = self.commint!
                    }
                    if self.repo != nil {
                        map["repo"] = self.repo!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("branch") {
                        self.branch = dict["branch"] as! String
                    }
                    if dict.keys.contains("commint") {
                        self.commint = dict["commint"] as! String
                    }
                    if dict.keys.contains("repo") {
                        self.repo = dict["repo"] as! String
                    }
                }
            }
            public var data: GetPipelineRunResponseBody.PipelineRun.Sources.Data?

            public var sign: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.data?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["data"] = self.data?.toMap()
                }
                if self.sign != nil {
                    map["sign"] = self.sign!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("data") {
                    var model = GetPipelineRunResponseBody.PipelineRun.Sources.Data()
                    model.fromMap(dict["data"] as! [String: Any])
                    self.data = model
                }
                if dict.keys.contains("sign") {
                    self.sign = dict["sign"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class Stages : Tea.TeaModel {
            public class StageInfo : Tea.TeaModel {
                public class Jobs : Tea.TeaModel {
                    public class Actions : Tea.TeaModel {
                        public var disable: Bool?

                        public var params: [String: Any]?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.disable != nil {
                                map["disable"] = self.disable!
                            }
                            if self.params != nil {
                                map["params"] = self.params!
                            }
                            if self.type != nil {
                                map["type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("disable") {
                                self.disable = dict["disable"] as! Bool
                            }
                            if dict.keys.contains("params") {
                                self.params = dict["params"] as! [String: Any]
                            }
                            if dict.keys.contains("type") {
                                self.type = dict["type"] as! String
                            }
                        }
                    }
                    public var actions: [GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs.Actions]?

                    public var endTime: Int64?

                    public var id: Int64?

                    public var name: String?

                    public var params: String?

                    public var startTime: Int64?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.actions != nil {
                            var tmp : [Any] = []
                            for k in self.actions! {
                                tmp.append(k.toMap())
                            }
                            map["actions"] = tmp
                        }
                        if self.endTime != nil {
                            map["endTime"] = self.endTime!
                        }
                        if self.id != nil {
                            map["id"] = self.id!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.params != nil {
                            map["params"] = self.params!
                        }
                        if self.startTime != nil {
                            map["startTime"] = self.startTime!
                        }
                        if self.status != nil {
                            map["status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("actions") {
                            var tmp : [GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs.Actions] = []
                            for v in dict["actions"] as! [Any] {
                                var model = GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs.Actions()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.actions = tmp
                        }
                        if dict.keys.contains("endTime") {
                            self.endTime = dict["endTime"] as! Int64
                        }
                        if dict.keys.contains("id") {
                            self.id = dict["id"] as! Int64
                        }
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("params") {
                            self.params = dict["params"] as! String
                        }
                        if dict.keys.contains("startTime") {
                            self.startTime = dict["startTime"] as! Int64
                        }
                        if dict.keys.contains("status") {
                            self.status = dict["status"] as! String
                        }
                    }
                }
                public var endTime: Int64?

                public var jobs: [GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs]?

                public var name: String?

                public var startTime: Int64?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.endTime != nil {
                        map["endTime"] = self.endTime!
                    }
                    if self.jobs != nil {
                        var tmp : [Any] = []
                        for k in self.jobs! {
                            tmp.append(k.toMap())
                        }
                        map["jobs"] = tmp
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.startTime != nil {
                        map["startTime"] = self.startTime!
                    }
                    if self.status != nil {
                        map["status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("endTime") {
                        self.endTime = dict["endTime"] as! Int64
                    }
                    if dict.keys.contains("jobs") {
                        var tmp : [GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs] = []
                        for v in dict["jobs"] as! [Any] {
                            var model = GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo.Jobs()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.jobs = tmp
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("startTime") {
                        self.startTime = dict["startTime"] as! Int64
                    }
                    if dict.keys.contains("status") {
                        self.status = dict["status"] as! String
                    }
                }
            }
            public var name: String?

            public var stageInfo: GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.stageInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.stageInfo != nil {
                    map["stageInfo"] = self.stageInfo?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("stageInfo") {
                    var model = GetPipelineRunResponseBody.PipelineRun.Stages.StageInfo()
                    model.fromMap(dict["stageInfo"] as! [String: Any])
                    self.stageInfo = model
                }
            }
        }
        public var createTime: Int64?

        public var creatorAccountId: String?

        public var modifierAccountId: String?

        public var pipelineId: Int64?

        public var pipelineRunId: Int64?

        public var sources: [GetPipelineRunResponseBody.PipelineRun.Sources]?

        public var stageGroup: [[String]]?

        public var stages: [GetPipelineRunResponseBody.PipelineRun.Stages]?

        public var status: String?

        public var triggerMode: Int32?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineRunId != nil {
                map["pipelineRunId"] = self.pipelineRunId!
            }
            if self.sources != nil {
                var tmp : [Any] = []
                for k in self.sources! {
                    tmp.append(k.toMap())
                }
                map["sources"] = tmp
            }
            if self.stageGroup != nil {
                map["stageGroup"] = self.stageGroup!
            }
            if self.stages != nil {
                var tmp : [Any] = []
                for k in self.stages! {
                    tmp.append(k.toMap())
                }
                map["stages"] = tmp
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.triggerMode != nil {
                map["triggerMode"] = self.triggerMode!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("creatorAccountId") {
                self.creatorAccountId = dict["creatorAccountId"] as! String
            }
            if dict.keys.contains("modifierAccountId") {
                self.modifierAccountId = dict["modifierAccountId"] as! String
            }
            if dict.keys.contains("pipelineId") {
                self.pipelineId = dict["pipelineId"] as! Int64
            }
            if dict.keys.contains("pipelineRunId") {
                self.pipelineRunId = dict["pipelineRunId"] as! Int64
            }
            if dict.keys.contains("sources") {
                var tmp : [GetPipelineRunResponseBody.PipelineRun.Sources] = []
                for v in dict["sources"] as! [Any] {
                    var model = GetPipelineRunResponseBody.PipelineRun.Sources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sources = tmp
            }
            if dict.keys.contains("stageGroup") {
                self.stageGroup = dict["stageGroup"] as! [[String]]
            }
            if dict.keys.contains("stages") {
                var tmp : [GetPipelineRunResponseBody.PipelineRun.Stages] = []
                for v in dict["stages"] as! [Any] {
                    var model = GetPipelineRunResponseBody.PipelineRun.Stages()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.stages = tmp
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("triggerMode") {
                self.triggerMode = dict["triggerMode"] as! Int32
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelineRun: GetPipelineRunResponseBody.PipelineRun?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipelineRun?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelineRun != nil {
            map["pipelineRun"] = self.pipelineRun?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("pipelineRun") {
            var model = GetPipelineRunResponseBody.PipelineRun()
            model.fromMap(dict["pipelineRun"] as! [String: Any])
            self.pipelineRun = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetPipelineRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPipelineRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPipelineScanReportUrlRequest : Tea.TeaModel {
    public var reportPath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportPath != nil {
            map["reportPath"] = self.reportPath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("reportPath") {
            self.reportPath = dict["reportPath"] as! String
        }
    }
}

public class GetPipelineScanReportUrlResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var reportUrl: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.reportUrl != nil {
            map["reportUrl"] = self.reportUrl!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("reportUrl") {
            self.reportUrl = dict["reportUrl"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetPipelineScanReportUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPipelineScanReportUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPipelineScanReportUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProjectInfoResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public var category: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var customCode: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var icon: String?

        public var iconBig: String?

        public var iconGroup: String?

        public var iconSmall: String?

        public var id: String?

        public var identifier: String?

        public var identifierPath: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var name: String?

        public var organizationIdentifier: String?

        public var parentIdentifier: String?

        public var scope: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subType: String?

        public var typeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["category"] = self.category!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.customCode != nil {
                map["customCode"] = self.customCode!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.icon != nil {
                map["icon"] = self.icon!
            }
            if self.iconBig != nil {
                map["iconBig"] = self.iconBig!
            }
            if self.iconGroup != nil {
                map["iconGroup"] = self.iconGroup!
            }
            if self.iconSmall != nil {
                map["iconSmall"] = self.iconSmall!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.identifierPath != nil {
                map["identifierPath"] = self.identifierPath!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationIdentifier != nil {
                map["organizationIdentifier"] = self.organizationIdentifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subType != nil {
                map["subType"] = self.subType!
            }
            if self.typeIdentifier != nil {
                map["typeIdentifier"] = self.typeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("category") {
                self.category = dict["category"] as! String
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("customCode") {
                self.customCode = dict["customCode"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("icon") {
                self.icon = dict["icon"] as! String
            }
            if dict.keys.contains("iconBig") {
                self.iconBig = dict["iconBig"] as! String
            }
            if dict.keys.contains("iconGroup") {
                self.iconGroup = dict["iconGroup"] as! String
            }
            if dict.keys.contains("iconSmall") {
                self.iconSmall = dict["iconSmall"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("identifierPath") {
                self.identifierPath = dict["identifierPath"] as! String
            }
            if dict.keys.contains("logicalStatus") {
                self.logicalStatus = dict["logicalStatus"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("organizationIdentifier") {
                self.organizationIdentifier = dict["organizationIdentifier"] as! String
            }
            if dict.keys.contains("parentIdentifier") {
                self.parentIdentifier = dict["parentIdentifier"] as! String
            }
            if dict.keys.contains("scope") {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("statusIdentifier") {
                self.statusIdentifier = dict["statusIdentifier"] as! String
            }
            if dict.keys.contains("statusStageIdentifier") {
                self.statusStageIdentifier = dict["statusStageIdentifier"] as! String
            }
            if dict.keys.contains("subType") {
                self.subType = dict["subType"] as! String
            }
            if dict.keys.contains("typeIdentifier") {
                self.typeIdentifier = dict["typeIdentifier"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var project: GetProjectInfoResponseBody.Project?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.project != nil {
            map["project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("project") {
            var model = GetProjectInfoResponseBody.Project()
            model.fromMap(dict["project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetProjectInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProjectInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetProjectMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class GetProjectMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetProjectMemberResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetProjectMemberResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetProjectMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPushRuleRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class GetPushRuleResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class RuleInfos : Tea.TeaModel {
            public var checkerName: String?

            public var checkerType: String?

            public var extraMessage: String?

            public var fileRuleRegexes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkerName != nil {
                    map["checkerName"] = self.checkerName!
                }
                if self.checkerType != nil {
                    map["checkerType"] = self.checkerType!
                }
                if self.extraMessage != nil {
                    map["extraMessage"] = self.extraMessage!
                }
                if self.fileRuleRegexes != nil {
                    map["fileRuleRegexes"] = self.fileRuleRegexes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("checkerName") {
                    self.checkerName = dict["checkerName"] as! String
                }
                if dict.keys.contains("checkerType") {
                    self.checkerType = dict["checkerType"] as! String
                }
                if dict.keys.contains("extraMessage") {
                    self.extraMessage = dict["extraMessage"] as! String
                }
                if dict.keys.contains("fileRuleRegexes") {
                    self.fileRuleRegexes = dict["fileRuleRegexes"] as! [String]
                }
            }
        }
        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var ruleInfos: [GetPushRuleResponseBody.Result.RuleInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleInfos != nil {
                var tmp : [Any] = []
                for k in self.ruleInfos! {
                    tmp.append(k.toMap())
                }
                map["ruleInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("ruleInfos") {
                var tmp : [GetPushRuleResponseBody.Result.RuleInfos] = []
                for v in dict["ruleInfos"] as! [Any] {
                    var model = GetPushRuleResponseBody.Result.RuleInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleInfos = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetPushRuleResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetPushRuleResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetPushRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPushRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPushRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRepositoryRequest : Tea.TeaModel {
    public var accessToken: String?

    public var identity: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.identity != nil {
            map["identity"] = self.identity!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("identity") {
            self.identity = dict["identity"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class GetRepositoryResponseBody : Tea.TeaModel {
    public class Repository : Tea.TeaModel {
        public class Namespace : Tea.TeaModel {
            public var avatar: String?

            public var createdAt: String?

            public var description_: String?

            public var id: Int64?

            public var name: String?

            public var ownerId: Int64?

            public var path: String?

            public var updatedAt: String?

            public var visibilityLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.ownerId != nil {
                    map["ownerId"] = self.ownerId!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.updatedAt != nil {
                    map["updatedAt"] = self.updatedAt!
                }
                if self.visibilityLevel != nil {
                    map["visibilityLevel"] = self.visibilityLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatar") {
                    self.avatar = dict["avatar"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("ownerId") {
                    self.ownerId = dict["ownerId"] as! Int64
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("updatedAt") {
                    self.updatedAt = dict["updatedAt"] as! String
                }
                if dict.keys.contains("visibilityLevel") {
                    self.visibilityLevel = dict["visibilityLevel"] as! Int32
                }
            }
        }
        public var archive: Bool?

        public var avatarUrl: String?

        public var createdAt: String?

        public var creatorId: Int64?

        public var defaultBranch: String?

        public var demoProjectStatus: Bool?

        public var description_: String?

        public var httpUrlToRepository: String?

        public var id: Int64?

        public var lastActivityAt: String?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespace: GetRepositoryResponseBody.Repository.Namespace?

        public var path: String?

        public var pathWithNamespace: String?

        public var sshUrlToRepository: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.namespace?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archive != nil {
                map["archive"] = self.archive!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.defaultBranch != nil {
                map["defaultBranch"] = self.defaultBranch!
            }
            if self.demoProjectStatus != nil {
                map["demoProjectStatus"] = self.demoProjectStatus!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.httpUrlToRepository != nil {
                map["httpUrlToRepository"] = self.httpUrlToRepository!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespace != nil {
                map["namespace"] = self.namespace?.toMap()
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.sshUrlToRepository != nil {
                map["sshUrlToRepository"] = self.sshUrlToRepository!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("archive") {
                self.archive = dict["archive"] as! Bool
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("creatorId") {
                self.creatorId = dict["creatorId"] as! Int64
            }
            if dict.keys.contains("defaultBranch") {
                self.defaultBranch = dict["defaultBranch"] as! String
            }
            if dict.keys.contains("demoProjectStatus") {
                self.demoProjectStatus = dict["demoProjectStatus"] as! Bool
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("httpUrlToRepository") {
                self.httpUrlToRepository = dict["httpUrlToRepository"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("lastActivityAt") {
                self.lastActivityAt = dict["lastActivityAt"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("namespace") {
                var model = GetRepositoryResponseBody.Repository.Namespace()
                model.fromMap(dict["namespace"] as! [String: Any])
                self.namespace = model
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("pathWithNamespace") {
                self.pathWithNamespace = dict["pathWithNamespace"] as! String
            }
            if dict.keys.contains("sshUrlToRepository") {
                self.sshUrlToRepository = dict["sshUrlToRepository"] as! String
            }
            if dict.keys.contains("visibilityLevel") {
                self.visibilityLevel = dict["visibilityLevel"] as! Int32
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var repository: GetRepositoryResponseBody.Repository?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.repository?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.repository != nil {
            map["repository"] = self.repository?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("repository") {
            var model = GetRepositoryResponseBody.Repository()
            model.fromMap(dict["repository"] as! [String: Any])
            self.repository = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRepositoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRepositoryCommitRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var showSignature: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.showSignature != nil {
            map["showSignature"] = self.showSignature!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("showSignature") {
            self.showSignature = dict["showSignature"] as! Bool
        }
    }
}

public class GetRepositoryCommitResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
                if dict.keys.contains("websiteUrl") {
                    self.websiteUrl = dict["websiteUrl"] as! String
                }
            }
        }
        public class Committer : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
                if dict.keys.contains("websiteUrl") {
                    self.websiteUrl = dict["websiteUrl"] as! String
                }
            }
        }
        public class Signature : Tea.TeaModel {
            public var gpgKeyId: String?

            public var verificationStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gpgKeyId != nil {
                    map["gpgKeyId"] = self.gpgKeyId!
                }
                if self.verificationStatus != nil {
                    map["verificationStatus"] = self.verificationStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("gpgKeyId") {
                    self.gpgKeyId = dict["gpgKeyId"] as! String
                }
                if dict.keys.contains("verificationStatus") {
                    self.verificationStatus = dict["verificationStatus"] as! String
                }
            }
        }
        public var author: GetRepositoryCommitResponseBody.Result.Author?

        public var authorEmail: String?

        public var authorName: String?

        public var authoredDate: String?

        public var commentsCount: Int64?

        public var committedDate: String?

        public var committer: GetRepositoryCommitResponseBody.Result.Committer?

        public var committerEmail: String?

        public var committerName: String?

        public var createdAt: String?

        public var id: String?

        public var message: String?

        public var parentIds: [String]?

        public var shortId: String?

        public var signature: GetRepositoryCommitResponseBody.Result.Signature?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.committer?.validate()
            try self.signature?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.authorEmail != nil {
                map["authorEmail"] = self.authorEmail!
            }
            if self.authorName != nil {
                map["authorName"] = self.authorName!
            }
            if self.authoredDate != nil {
                map["authoredDate"] = self.authoredDate!
            }
            if self.commentsCount != nil {
                map["commentsCount"] = self.commentsCount!
            }
            if self.committedDate != nil {
                map["committedDate"] = self.committedDate!
            }
            if self.committer != nil {
                map["committer"] = self.committer?.toMap()
            }
            if self.committerEmail != nil {
                map["committerEmail"] = self.committerEmail!
            }
            if self.committerName != nil {
                map["committerName"] = self.committerName!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.parentIds != nil {
                map["parentIds"] = self.parentIds!
            }
            if self.shortId != nil {
                map["shortId"] = self.shortId!
            }
            if self.signature != nil {
                map["signature"] = self.signature?.toMap()
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("author") {
                var model = GetRepositoryCommitResponseBody.Result.Author()
                model.fromMap(dict["author"] as! [String: Any])
                self.author = model
            }
            if dict.keys.contains("authorEmail") {
                self.authorEmail = dict["authorEmail"] as! String
            }
            if dict.keys.contains("authorName") {
                self.authorName = dict["authorName"] as! String
            }
            if dict.keys.contains("authoredDate") {
                self.authoredDate = dict["authoredDate"] as! String
            }
            if dict.keys.contains("commentsCount") {
                self.commentsCount = dict["commentsCount"] as! Int64
            }
            if dict.keys.contains("committedDate") {
                self.committedDate = dict["committedDate"] as! String
            }
            if dict.keys.contains("committer") {
                var model = GetRepositoryCommitResponseBody.Result.Committer()
                model.fromMap(dict["committer"] as! [String: Any])
                self.committer = model
            }
            if dict.keys.contains("committerEmail") {
                self.committerEmail = dict["committerEmail"] as! String
            }
            if dict.keys.contains("committerName") {
                self.committerName = dict["committerName"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("message") {
                self.message = dict["message"] as! String
            }
            if dict.keys.contains("parentIds") {
                self.parentIds = dict["parentIds"] as! [String]
            }
            if dict.keys.contains("shortId") {
                self.shortId = dict["shortId"] as! String
            }
            if dict.keys.contains("signature") {
                var model = GetRepositoryCommitResponseBody.Result.Signature()
                model.fromMap(dict["signature"] as! [String: Any])
                self.signature = model
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetRepositoryCommitResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetRepositoryCommitResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetRepositoryCommitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRepositoryCommitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRepositoryCommitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRepositoryTagRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var tagName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.tagName != nil {
            map["tagName"] = self.tagName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("tagName") {
            self.tagName = dict["tagName"] as! String
        }
    }
}

public class GetRepositoryTagResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public class Signature : Tea.TeaModel {
                public var gpgKeyId: String?

                public var verificationStatus: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gpgKeyId != nil {
                        map["gpgKeyId"] = self.gpgKeyId!
                    }
                    if self.verificationStatus != nil {
                        map["verificationStatus"] = self.verificationStatus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("gpgKeyId") {
                        self.gpgKeyId = dict["gpgKeyId"] as! String
                    }
                    if dict.keys.contains("verificationStatus") {
                        self.verificationStatus = dict["verificationStatus"] as! String
                    }
                }
            }
            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var committedDate: String?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var signature: GetRepositoryTagResponseBody.Result.Commit.Signature?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.signature?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.signature != nil {
                    map["signature"] = self.signature?.toMap()
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("authorEmail") {
                    self.authorEmail = dict["authorEmail"] as! String
                }
                if dict.keys.contains("authorName") {
                    self.authorName = dict["authorName"] as! String
                }
                if dict.keys.contains("authoredDate") {
                    self.authoredDate = dict["authoredDate"] as! String
                }
                if dict.keys.contains("committedDate") {
                    self.committedDate = dict["committedDate"] as! String
                }
                if dict.keys.contains("committerEmail") {
                    self.committerEmail = dict["committerEmail"] as! String
                }
                if dict.keys.contains("committerName") {
                    self.committerName = dict["committerName"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("parentIds") {
                    self.parentIds = dict["parentIds"] as! [String]
                }
                if dict.keys.contains("shortId") {
                    self.shortId = dict["shortId"] as! String
                }
                if dict.keys.contains("signature") {
                    var model = GetRepositoryTagResponseBody.Result.Commit.Signature()
                    model.fromMap(dict["signature"] as! [String: Any])
                    self.signature = model
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public var commit: GetRepositoryTagResponseBody.Result.Commit?

        public var id: String?

        public var message: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("commit") {
                var model = GetRepositoryTagResponseBody.Result.Commit()
                model.fromMap(dict["commit"] as! [String: Any])
                self.commit = model
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("message") {
                self.message = dict["message"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetRepositoryTagResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetRepositoryTagResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetRepositoryTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRepositoryTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRepositoryTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSearchCodePreviewRequest : Tea.TeaModel {
    public var docId: String?

    public var isDsl: Bool?

    public var keyword: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.docId != nil {
            map["docId"] = self.docId!
        }
        if self.isDsl != nil {
            map["isDsl"] = self.isDsl!
        }
        if self.keyword != nil {
            map["keyword"] = self.keyword!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("docId") {
            self.docId = dict["docId"] as! String
        }
        if dict.keys.contains("isDsl") {
            self.isDsl = dict["isDsl"] as! Bool
        }
        if dict.keys.contains("keyword") {
            self.keyword = dict["keyword"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class GetSearchCodePreviewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class HighlightTextMap : Tea.TeaModel {
            public var clob: String?

            public var fileName: String?

            public var organizationId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clob != nil {
                    map["clob"] = self.clob!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("clob") {
                    self.clob = dict["clob"] as! String
                }
                if dict.keys.contains("fileName") {
                    self.fileName = dict["fileName"] as! String
                }
                if dict.keys.contains("organizationId") {
                    self.organizationId = dict["organizationId"] as! String
                }
            }
        }
        public class Source : Tea.TeaModel {
            public var branch: String?

            public var checkinDate: String?

            public var fileName: String?

            public var filePath: String?

            public var language: String?

            public var organizationId: String?

            public var repoPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.branch != nil {
                    map["branch"] = self.branch!
                }
                if self.checkinDate != nil {
                    map["checkinDate"] = self.checkinDate!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                if self.filePath != nil {
                    map["filePath"] = self.filePath!
                }
                if self.language != nil {
                    map["language"] = self.language!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.repoPath != nil {
                    map["repoPath"] = self.repoPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("branch") {
                    self.branch = dict["branch"] as! String
                }
                if dict.keys.contains("checkinDate") {
                    self.checkinDate = dict["checkinDate"] as! String
                }
                if dict.keys.contains("fileName") {
                    self.fileName = dict["fileName"] as! String
                }
                if dict.keys.contains("filePath") {
                    self.filePath = dict["filePath"] as! String
                }
                if dict.keys.contains("language") {
                    self.language = dict["language"] as! String
                }
                if dict.keys.contains("organizationId") {
                    self.organizationId = dict["organizationId"] as! String
                }
                if dict.keys.contains("repoPath") {
                    self.repoPath = dict["repoPath"] as! String
                }
            }
        }
        public var docId: String?

        public var highlightTextMap: GetSearchCodePreviewResponseBody.Result.HighlightTextMap?

        public var source: GetSearchCodePreviewResponseBody.Result.Source?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.highlightTextMap?.validate()
            try self.source?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.docId != nil {
                map["docId"] = self.docId!
            }
            if self.highlightTextMap != nil {
                map["highlightTextMap"] = self.highlightTextMap?.toMap()
            }
            if self.source != nil {
                map["source"] = self.source?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("docId") {
                self.docId = dict["docId"] as! String
            }
            if dict.keys.contains("highlightTextMap") {
                var model = GetSearchCodePreviewResponseBody.Result.HighlightTextMap()
                model.fromMap(dict["highlightTextMap"] as! [String: Any])
                self.highlightTextMap = model
            }
            if dict.keys.contains("source") {
                var model = GetSearchCodePreviewResponseBody.Result.Source()
                model.fromMap(dict["source"] as! [String: Any])
                self.source = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetSearchCodePreviewResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetSearchCodePreviewResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetSearchCodePreviewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSearchCodePreviewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSearchCodePreviewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSprintInfoResponseBody : Tea.TeaModel {
    public class Sprint : Tea.TeaModel {
        public var creator: String?

        public var description_: String?

        public var endDate: Int64?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var owners: [String]?

        public var scope: String?

        public var spaceIdentifier: String?

        public var startDate: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endDate != nil {
                map["endDate"] = self.endDate!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.owners != nil {
                map["owners"] = self.owners!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.startDate != nil {
                map["startDate"] = self.startDate!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("endDate") {
                self.endDate = dict["endDate"] as! Int64
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("owners") {
                self.owners = dict["owners"] as! [String]
            }
            if dict.keys.contains("scope") {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("startDate") {
                self.startDate = dict["startDate"] as! Int64
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sprint: GetSprintInfoResponseBody.Sprint?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sprint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.sprint != nil {
            map["sprint"] = self.sprint?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("sprint") {
            var model = GetSprintInfoResponseBody.Sprint()
            model.fromMap(dict["sprint"] as! [String: Any])
            self.sprint = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetSprintInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSprintInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSprintInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTestResultListRequest : Tea.TeaModel {
    public var conditions: String?

    public var directoryIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditions != nil {
            map["conditions"] = self.conditions!
        }
        if self.directoryIdentifier != nil {
            map["directoryIdentifier"] = self.directoryIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("conditions") {
            self.conditions = dict["conditions"] as! String
        }
        if dict.keys.contains("directoryIdentifier") {
            self.directoryIdentifier = dict["directoryIdentifier"] as! String
        }
    }
}

public class GetTestResultListResponseBody : Tea.TeaModel {
    public class TestResult : Tea.TeaModel {
        public class AssignedTo : Tea.TeaModel {
            public var assignedToIdenttifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assignedToIdenttifier != nil {
                    map["assignedToIdenttifier"] = self.assignedToIdenttifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("assignedToIdenttifier") {
                    self.assignedToIdenttifier = dict["assignedToIdenttifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class CustomFields : Tea.TeaModel {
            public var fieldClassName: String?

            public var fieldFormat: String?

            public var fieldIdentifier: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldClassName != nil {
                    map["fieldClassName"] = self.fieldClassName!
                }
                if self.fieldFormat != nil {
                    map["fieldFormat"] = self.fieldFormat!
                }
                if self.fieldIdentifier != nil {
                    map["fieldIdentifier"] = self.fieldIdentifier!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fieldClassName") {
                    self.fieldClassName = dict["fieldClassName"] as! String
                }
                if dict.keys.contains("fieldFormat") {
                    self.fieldFormat = dict["fieldFormat"] as! String
                }
                if dict.keys.contains("fieldIdentifier") {
                    self.fieldIdentifier = dict["fieldIdentifier"] as! String
                }
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public class TestResultExecutor : Tea.TeaModel {
            public var executorIdentifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.executorIdentifier != nil {
                    map["executorIdentifier"] = self.executorIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("executorIdentifier") {
                    self.executorIdentifier = dict["executorIdentifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public var assignedTo: GetTestResultListResponseBody.TestResult.AssignedTo?

        public var bugCount: Int64?

        public var categoryIdentifier: String?

        public var customFields: [GetTestResultListResponseBody.TestResult.CustomFields]?

        public var gmtCreate: Int64?

        public var spaceIdentifier: String?

        public var subject: String?

        public var testResultExecutor: GetTestResultListResponseBody.TestResult.TestResultExecutor?

        public var testResultGmtCreate: Int64?

        public var testResultIdentifier: String?

        public var testResultStatus: String?

        public var testcaseIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.assignedTo?.validate()
            try self.testResultExecutor?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo?.toMap()
            }
            if self.bugCount != nil {
                map["bugCount"] = self.bugCount!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.customFields != nil {
                var tmp : [Any] = []
                for k in self.customFields! {
                    tmp.append(k.toMap())
                }
                map["customFields"] = tmp
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.testResultExecutor != nil {
                map["testResultExecutor"] = self.testResultExecutor?.toMap()
            }
            if self.testResultGmtCreate != nil {
                map["testResultGmtCreate"] = self.testResultGmtCreate!
            }
            if self.testResultIdentifier != nil {
                map["testResultIdentifier"] = self.testResultIdentifier!
            }
            if self.testResultStatus != nil {
                map["testResultStatus"] = self.testResultStatus!
            }
            if self.testcaseIdentifier != nil {
                map["testcaseIdentifier"] = self.testcaseIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedTo") {
                var model = GetTestResultListResponseBody.TestResult.AssignedTo()
                model.fromMap(dict["assignedTo"] as! [String: Any])
                self.assignedTo = model
            }
            if dict.keys.contains("bugCount") {
                self.bugCount = dict["bugCount"] as! Int64
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("customFields") {
                var tmp : [GetTestResultListResponseBody.TestResult.CustomFields] = []
                for v in dict["customFields"] as! [Any] {
                    var model = GetTestResultListResponseBody.TestResult.CustomFields()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customFields = tmp
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("testResultExecutor") {
                var model = GetTestResultListResponseBody.TestResult.TestResultExecutor()
                model.fromMap(dict["testResultExecutor"] as! [String: Any])
                self.testResultExecutor = model
            }
            if dict.keys.contains("testResultGmtCreate") {
                self.testResultGmtCreate = dict["testResultGmtCreate"] as! Int64
            }
            if dict.keys.contains("testResultIdentifier") {
                self.testResultIdentifier = dict["testResultIdentifier"] as! String
            }
            if dict.keys.contains("testResultStatus") {
                self.testResultStatus = dict["testResultStatus"] as! String
            }
            if dict.keys.contains("testcaseIdentifier") {
                self.testcaseIdentifier = dict["testcaseIdentifier"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var testResult: [GetTestResultListResponseBody.TestResult]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.testResult != nil {
            var tmp : [Any] = []
            for k in self.testResult! {
                tmp.append(k.toMap())
            }
            map["testResult"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("testResult") {
            var tmp : [GetTestResultListResponseBody.TestResult] = []
            for v in dict["testResult"] as! [Any] {
                var model = GetTestResultListResponseBody.TestResult()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.testResult = tmp
        }
    }
}

public class GetTestResultListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTestResultListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTestResultListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTestcaseListRequest : Tea.TeaModel {
    public var conditions: String?

    public var directoryIdentifier: String?

    public var maxResult: String?

    public var nextToken: String?

    public var spaceIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditions != nil {
            map["conditions"] = self.conditions!
        }
        if self.directoryIdentifier != nil {
            map["directoryIdentifier"] = self.directoryIdentifier!
        }
        if self.maxResult != nil {
            map["maxResult"] = self.maxResult!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("conditions") {
            self.conditions = dict["conditions"] as! String
        }
        if dict.keys.contains("directoryIdentifier") {
            self.directoryIdentifier = dict["directoryIdentifier"] as! String
        }
        if dict.keys.contains("maxResult") {
            self.maxResult = dict["maxResult"] as! String
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("spaceIdentifier") {
            self.spaceIdentifier = dict["spaceIdentifier"] as! String
        }
    }
}

public class GetTestcaseListResponseBody : Tea.TeaModel {
    public class Testcase : Tea.TeaModel {
        public class AssignedTo : Tea.TeaModel {
            public var assignedToIdenttifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assignedToIdenttifier != nil {
                    map["assignedToIdenttifier"] = self.assignedToIdenttifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("assignedToIdenttifier") {
                    self.assignedToIdenttifier = dict["assignedToIdenttifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class CustomFields : Tea.TeaModel {
            public var fieldClassName: String?

            public var fieldFormat: String?

            public var fieldIdentifier: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldClassName != nil {
                    map["fieldClassName"] = self.fieldClassName!
                }
                if self.fieldFormat != nil {
                    map["fieldFormat"] = self.fieldFormat!
                }
                if self.fieldIdentifier != nil {
                    map["fieldIdentifier"] = self.fieldIdentifier!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fieldClassName") {
                    self.fieldClassName = dict["fieldClassName"] as! String
                }
                if dict.keys.contains("fieldFormat") {
                    self.fieldFormat = dict["fieldFormat"] as! String
                }
                if dict.keys.contains("fieldIdentifier") {
                    self.fieldIdentifier = dict["fieldIdentifier"] as! String
                }
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public class Space : Tea.TeaModel {
            public var spaceIdentifier: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.spaceIdentifier != nil {
                    map["spaceIdentifier"] = self.spaceIdentifier!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("spaceIdentifier") {
                    self.spaceIdentifier = dict["spaceIdentifier"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var name: String?

            public var tagIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.tagIdentifier != nil {
                    map["tagIdentifier"] = self.tagIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("tagIdentifier") {
                    self.tagIdentifier = dict["tagIdentifier"] as! String
                }
            }
        }
        public var assignedTo: GetTestcaseListResponseBody.Testcase.AssignedTo?

        public var categoryIdentifier: String?

        public var customFields: [GetTestcaseListResponseBody.Testcase.CustomFields]?

        public var gmtCreate: Int64?

        public var identifier: String?

        public var space: GetTestcaseListResponseBody.Testcase.Space?

        public var subject: String?

        public var tags: [GetTestcaseListResponseBody.Testcase.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.assignedTo?.validate()
            try self.space?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo?.toMap()
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.customFields != nil {
                var tmp : [Any] = []
                for k in self.customFields! {
                    tmp.append(k.toMap())
                }
                map["customFields"] = tmp
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.space != nil {
                map["space"] = self.space?.toMap()
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedTo") {
                var model = GetTestcaseListResponseBody.Testcase.AssignedTo()
                model.fromMap(dict["assignedTo"] as! [String: Any])
                self.assignedTo = model
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("customFields") {
                var tmp : [GetTestcaseListResponseBody.Testcase.CustomFields] = []
                for v in dict["customFields"] as! [Any] {
                    var model = GetTestcaseListResponseBody.Testcase.CustomFields()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customFields = tmp
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("space") {
                var model = GetTestcaseListResponseBody.Testcase.Space()
                model.fromMap(dict["space"] as! [String: Any])
                self.space = model
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("tags") {
                var tmp : [GetTestcaseListResponseBody.Testcase.Tags] = []
                for v in dict["tags"] as! [Any] {
                    var model = GetTestcaseListResponseBody.Testcase.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var testcase: [GetTestcaseListResponseBody.Testcase]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.testcase != nil {
            var tmp : [Any] = []
            for k in self.testcase! {
                tmp.append(k.toMap())
            }
            map["testcase"] = tmp
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("testcase") {
            var tmp : [GetTestcaseListResponseBody.Testcase] = []
            for v in dict["testcase"] as! [Any] {
                var model = GetTestcaseListResponseBody.Testcase()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.testcase = tmp
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class GetTestcaseListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTestcaseListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTestcaseListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserInfoRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class GetUserInfoResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var name: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("username") {
                self.username = dict["username"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: GetUserInfoResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = GetUserInfoResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetUserInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUserInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVMDeployOrderResponseBody : Tea.TeaModel {
    public class DeployOrder : Tea.TeaModel {
        public class Actions : Tea.TeaModel {
            public var disable: Bool?

            public var params: Any?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disable != nil {
                    map["disable"] = self.disable!
                }
                if self.params != nil {
                    map["params"] = self.params!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("disable") {
                    self.disable = dict["disable"] as! Bool
                }
                if dict.keys.contains("params") {
                    self.params = dict["params"] as! Any
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class DeployMachineInfo : Tea.TeaModel {
            public class DeployMachines : Tea.TeaModel {
                public class Actions : Tea.TeaModel {
                    public var disable: Bool?

                    public var params: Any?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.disable != nil {
                            map["disable"] = self.disable!
                        }
                        if self.params != nil {
                            map["params"] = self.params!
                        }
                        if self.type != nil {
                            map["type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("disable") {
                            self.disable = dict["disable"] as! Bool
                        }
                        if dict.keys.contains("params") {
                            self.params = dict["params"] as! Any
                        }
                        if dict.keys.contains("type") {
                            self.type = dict["type"] as! String
                        }
                    }
                }
                public var actions: [GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines.Actions]?

                public var batchNum: Int32?

                public var clientStatus: String?

                public var createTime: Int64?

                public var ip: String?

                public var machineSn: String?

                public var status: String?

                public var updateTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.actions != nil {
                        var tmp : [Any] = []
                        for k in self.actions! {
                            tmp.append(k.toMap())
                        }
                        map["actions"] = tmp
                    }
                    if self.batchNum != nil {
                        map["batchNum"] = self.batchNum!
                    }
                    if self.clientStatus != nil {
                        map["clientStatus"] = self.clientStatus!
                    }
                    if self.createTime != nil {
                        map["createTime"] = self.createTime!
                    }
                    if self.ip != nil {
                        map["ip"] = self.ip!
                    }
                    if self.machineSn != nil {
                        map["machineSn"] = self.machineSn!
                    }
                    if self.status != nil {
                        map["status"] = self.status!
                    }
                    if self.updateTime != nil {
                        map["updateTime"] = self.updateTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("actions") {
                        var tmp : [GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines.Actions] = []
                        for v in dict["actions"] as! [Any] {
                            var model = GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines.Actions()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.actions = tmp
                    }
                    if dict.keys.contains("batchNum") {
                        self.batchNum = dict["batchNum"] as! Int32
                    }
                    if dict.keys.contains("clientStatus") {
                        self.clientStatus = dict["clientStatus"] as! String
                    }
                    if dict.keys.contains("createTime") {
                        self.createTime = dict["createTime"] as! Int64
                    }
                    if dict.keys.contains("ip") {
                        self.ip = dict["ip"] as! String
                    }
                    if dict.keys.contains("machineSn") {
                        self.machineSn = dict["machineSn"] as! String
                    }
                    if dict.keys.contains("status") {
                        self.status = dict["status"] as! String
                    }
                    if dict.keys.contains("updateTime") {
                        self.updateTime = dict["updateTime"] as! Int64
                    }
                }
            }
            public var batchNum: Int32?

            public var deployMachines: [GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines]?

            public var hostGroupId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchNum != nil {
                    map["batchNum"] = self.batchNum!
                }
                if self.deployMachines != nil {
                    var tmp : [Any] = []
                    for k in self.deployMachines! {
                        tmp.append(k.toMap())
                    }
                    map["deployMachines"] = tmp
                }
                if self.hostGroupId != nil {
                    map["hostGroupId"] = self.hostGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("batchNum") {
                    self.batchNum = dict["batchNum"] as! Int32
                }
                if dict.keys.contains("deployMachines") {
                    var tmp : [GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines] = []
                    for v in dict["deployMachines"] as! [Any] {
                        var model = GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo.DeployMachines()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.deployMachines = tmp
                }
                if dict.keys.contains("hostGroupId") {
                    self.hostGroupId = dict["hostGroupId"] as! Int64
                }
            }
        }
        public var actions: [GetVMDeployOrderResponseBody.DeployOrder.Actions]?

        public var createTime: Int64?

        public var creator: String?

        public var currentBatch: Int32?

        public var deployMachineInfo: GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo?

        public var deployOrderId: String?

        public var exceptionCode: String?

        public var status: String?

        public var totalBatch: Int32?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.deployMachineInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actions != nil {
                var tmp : [Any] = []
                for k in self.actions! {
                    tmp.append(k.toMap())
                }
                map["actions"] = tmp
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.currentBatch != nil {
                map["currentBatch"] = self.currentBatch!
            }
            if self.deployMachineInfo != nil {
                map["deployMachineInfo"] = self.deployMachineInfo?.toMap()
            }
            if self.deployOrderId != nil {
                map["deployOrderId"] = self.deployOrderId!
            }
            if self.exceptionCode != nil {
                map["exceptionCode"] = self.exceptionCode!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.totalBatch != nil {
                map["totalBatch"] = self.totalBatch!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("actions") {
                var tmp : [GetVMDeployOrderResponseBody.DeployOrder.Actions] = []
                for v in dict["actions"] as! [Any] {
                    var model = GetVMDeployOrderResponseBody.DeployOrder.Actions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.actions = tmp
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("currentBatch") {
                self.currentBatch = dict["currentBatch"] as! Int32
            }
            if dict.keys.contains("deployMachineInfo") {
                var model = GetVMDeployOrderResponseBody.DeployOrder.DeployMachineInfo()
                model.fromMap(dict["deployMachineInfo"] as! [String: Any])
                self.deployMachineInfo = model
            }
            if dict.keys.contains("deployOrderId") {
                self.deployOrderId = dict["deployOrderId"] as! String
            }
            if dict.keys.contains("exceptionCode") {
                self.exceptionCode = dict["exceptionCode"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("totalBatch") {
                self.totalBatch = dict["totalBatch"] as! Int32
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! Int64
            }
        }
    }
    public var deployOrder: GetVMDeployOrderResponseBody.DeployOrder?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployOrder?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployOrder != nil {
            map["deployOrder"] = self.deployOrder?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("deployOrder") {
            var model = GetVMDeployOrderResponseBody.DeployOrder()
            model.fromMap(dict["deployOrder"] as! [String: Any])
            self.deployOrder = model
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetVMDeployOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVMDeployOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVMDeployOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVariableGroupResponseBody : Tea.TeaModel {
    public class VariableGroup : Tea.TeaModel {
        public class RelatedPipelines : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class Variables : Tea.TeaModel {
            public var isEncrypted: Bool?

            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isEncrypted != nil {
                    map["isEncrypted"] = self.isEncrypted!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("isEncrypted") {
                    self.isEncrypted = dict["isEncrypted"] as! Bool
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public var ccreatorAccountId: String?

        public var createTime: Int64?

        public var description_: String?

        public var id: Int64?

        public var modifierAccountId: String?

        public var name: String?

        public var relatedPipelines: [GetVariableGroupResponseBody.VariableGroup.RelatedPipelines]?

        public var updateTime: Int64?

        public var variables: [GetVariableGroupResponseBody.VariableGroup.Variables]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ccreatorAccountId != nil {
                map["ccreatorAccountId"] = self.ccreatorAccountId!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.relatedPipelines != nil {
                var tmp : [Any] = []
                for k in self.relatedPipelines! {
                    tmp.append(k.toMap())
                }
                map["relatedPipelines"] = tmp
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.variables != nil {
                var tmp : [Any] = []
                for k in self.variables! {
                    tmp.append(k.toMap())
                }
                map["variables"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ccreatorAccountId") {
                self.ccreatorAccountId = dict["ccreatorAccountId"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("modifierAccountId") {
                self.modifierAccountId = dict["modifierAccountId"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("relatedPipelines") {
                var tmp : [GetVariableGroupResponseBody.VariableGroup.RelatedPipelines] = []
                for v in dict["relatedPipelines"] as! [Any] {
                    var model = GetVariableGroupResponseBody.VariableGroup.RelatedPipelines()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.relatedPipelines = tmp
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! Int64
            }
            if dict.keys.contains("variables") {
                var tmp : [GetVariableGroupResponseBody.VariableGroup.Variables] = []
                for v in dict["variables"] as! [Any] {
                    var model = GetVariableGroupResponseBody.VariableGroup.Variables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.variables = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var variableGroup: GetVariableGroupResponseBody.VariableGroup?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.variableGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.variableGroup != nil {
            map["variableGroup"] = self.variableGroup?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("variableGroup") {
            var model = GetVariableGroupResponseBody.VariableGroup()
            model.fromMap(dict["variableGroup"] as! [String: Any])
            self.variableGroup = model
        }
    }
}

public class GetVariableGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVariableGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVariableGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkItemActivityResponseBody : Tea.TeaModel {
    public class Activities : Tea.TeaModel {
        public class NewValue : Tea.TeaModel {
            public var displayValue: String?

            public var plainValue: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayValue != nil {
                    map["displayValue"] = self.displayValue!
                }
                if self.plainValue != nil {
                    map["plainValue"] = self.plainValue!
                }
                if self.resourceType != nil {
                    map["resourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("displayValue") {
                    self.displayValue = dict["displayValue"] as! String
                }
                if dict.keys.contains("plainValue") {
                    self.plainValue = dict["plainValue"] as! String
                }
                if dict.keys.contains("resourceType") {
                    self.resourceType = dict["resourceType"] as! String
                }
            }
        }
        public class OldValue : Tea.TeaModel {
            public var displayValue: String?

            public var plainValue: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayValue != nil {
                    map["displayValue"] = self.displayValue!
                }
                if self.plainValue != nil {
                    map["plainValue"] = self.plainValue!
                }
                if self.resourceType != nil {
                    map["resourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("displayValue") {
                    self.displayValue = dict["displayValue"] as! String
                }
                if dict.keys.contains("plainValue") {
                    self.plainValue = dict["plainValue"] as! String
                }
                if dict.keys.contains("resourceType") {
                    self.resourceType = dict["resourceType"] as! String
                }
            }
        }
        public class Property : Tea.TeaModel {
            public var displayName: String?

            public var propertyIdentifier: String?

            public var propertyName: String?

            public var propertyType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.propertyIdentifier != nil {
                    map["propertyIdentifier"] = self.propertyIdentifier!
                }
                if self.propertyName != nil {
                    map["propertyName"] = self.propertyName!
                }
                if self.propertyType != nil {
                    map["propertyType"] = self.propertyType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("displayName") {
                    self.displayName = dict["displayName"] as! String
                }
                if dict.keys.contains("propertyIdentifier") {
                    self.propertyIdentifier = dict["propertyIdentifier"] as! String
                }
                if dict.keys.contains("propertyName") {
                    self.propertyName = dict["propertyName"] as! String
                }
                if dict.keys.contains("propertyType") {
                    self.propertyType = dict["propertyType"] as! String
                }
            }
        }
        public var actionType: String?

        public var eventId: Int64?

        public var eventTime: Int64?

        public var eventType: String?

        public var newValue: [GetWorkItemActivityResponseBody.Activities.NewValue]?

        public var oldValue: [GetWorkItemActivityResponseBody.Activities.OldValue]?

        public var operator_: String?

        public var parentEventId: Int64?

        public var property: GetWorkItemActivityResponseBody.Activities.Property?

        public var resourceIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.property?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionType != nil {
                map["actionType"] = self.actionType!
            }
            if self.eventId != nil {
                map["eventId"] = self.eventId!
            }
            if self.eventTime != nil {
                map["eventTime"] = self.eventTime!
            }
            if self.eventType != nil {
                map["eventType"] = self.eventType!
            }
            if self.newValue != nil {
                var tmp : [Any] = []
                for k in self.newValue! {
                    tmp.append(k.toMap())
                }
                map["newValue"] = tmp
            }
            if self.oldValue != nil {
                var tmp : [Any] = []
                for k in self.oldValue! {
                    tmp.append(k.toMap())
                }
                map["oldValue"] = tmp
            }
            if self.operator_ != nil {
                map["operator"] = self.operator_!
            }
            if self.parentEventId != nil {
                map["parentEventId"] = self.parentEventId!
            }
            if self.property != nil {
                map["property"] = self.property?.toMap()
            }
            if self.resourceIdentifier != nil {
                map["resourceIdentifier"] = self.resourceIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("actionType") {
                self.actionType = dict["actionType"] as! String
            }
            if dict.keys.contains("eventId") {
                self.eventId = dict["eventId"] as! Int64
            }
            if dict.keys.contains("eventTime") {
                self.eventTime = dict["eventTime"] as! Int64
            }
            if dict.keys.contains("eventType") {
                self.eventType = dict["eventType"] as! String
            }
            if dict.keys.contains("newValue") {
                var tmp : [GetWorkItemActivityResponseBody.Activities.NewValue] = []
                for v in dict["newValue"] as! [Any] {
                    var model = GetWorkItemActivityResponseBody.Activities.NewValue()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.newValue = tmp
            }
            if dict.keys.contains("oldValue") {
                var tmp : [GetWorkItemActivityResponseBody.Activities.OldValue] = []
                for v in dict["oldValue"] as! [Any] {
                    var model = GetWorkItemActivityResponseBody.Activities.OldValue()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.oldValue = tmp
            }
            if dict.keys.contains("operator") {
                self.operator_ = dict["operator"] as! String
            }
            if dict.keys.contains("parentEventId") {
                self.parentEventId = dict["parentEventId"] as! Int64
            }
            if dict.keys.contains("property") {
                var model = GetWorkItemActivityResponseBody.Activities.Property()
                model.fromMap(dict["property"] as! [String: Any])
                self.property = model
            }
            if dict.keys.contains("resourceIdentifier") {
                self.resourceIdentifier = dict["resourceIdentifier"] as! String
            }
        }
    }
    public var activities: [GetWorkItemActivityResponseBody.Activities]?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activities != nil {
            var tmp : [Any] = []
            for k in self.activities! {
                tmp.append(k.toMap())
            }
            map["activities"] = tmp
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("activities") {
            var tmp : [GetWorkItemActivityResponseBody.Activities] = []
            for v in dict["activities"] as! [Any] {
                var model = GetWorkItemActivityResponseBody.Activities()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.activities = tmp
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetWorkItemActivityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkItemActivityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkItemActivityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkItemInfoResponseBody : Tea.TeaModel {
    public class Workitem : Tea.TeaModel {
        public class CustomFields : Tea.TeaModel {
            public class ValueList : Tea.TeaModel {
                public var displayValue: String?

                public var identifier: String?

                public var level: Int64?

                public var value: String?

                public var valueEn: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.displayValue != nil {
                        map["displayValue"] = self.displayValue!
                    }
                    if self.identifier != nil {
                        map["identifier"] = self.identifier!
                    }
                    if self.level != nil {
                        map["level"] = self.level!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    if self.valueEn != nil {
                        map["valueEn"] = self.valueEn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("displayValue") {
                        self.displayValue = dict["displayValue"] as! String
                    }
                    if dict.keys.contains("identifier") {
                        self.identifier = dict["identifier"] as! String
                    }
                    if dict.keys.contains("level") {
                        self.level = dict["level"] as! Int64
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                    if dict.keys.contains("valueEn") {
                        self.valueEn = dict["valueEn"] as! String
                    }
                }
            }
            public var fieldClassName: String?

            public var fieldFormat: String?

            public var fieldIdentifier: String?

            public var level: Int64?

            public var objectValue: String?

            public var position: Int64?

            public var value: String?

            public var valueList: [GetWorkItemInfoResponseBody.Workitem.CustomFields.ValueList]?

            public var workitemIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldClassName != nil {
                    map["fieldClassName"] = self.fieldClassName!
                }
                if self.fieldFormat != nil {
                    map["fieldFormat"] = self.fieldFormat!
                }
                if self.fieldIdentifier != nil {
                    map["fieldIdentifier"] = self.fieldIdentifier!
                }
                if self.level != nil {
                    map["level"] = self.level!
                }
                if self.objectValue != nil {
                    map["objectValue"] = self.objectValue!
                }
                if self.position != nil {
                    map["position"] = self.position!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                if self.valueList != nil {
                    var tmp : [Any] = []
                    for k in self.valueList! {
                        tmp.append(k.toMap())
                    }
                    map["valueList"] = tmp
                }
                if self.workitemIdentifier != nil {
                    map["workitemIdentifier"] = self.workitemIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fieldClassName") {
                    self.fieldClassName = dict["fieldClassName"] as! String
                }
                if dict.keys.contains("fieldFormat") {
                    self.fieldFormat = dict["fieldFormat"] as! String
                }
                if dict.keys.contains("fieldIdentifier") {
                    self.fieldIdentifier = dict["fieldIdentifier"] as! String
                }
                if dict.keys.contains("level") {
                    self.level = dict["level"] as! Int64
                }
                if dict.keys.contains("objectValue") {
                    self.objectValue = dict["objectValue"] as! String
                }
                if dict.keys.contains("position") {
                    self.position = dict["position"] as! Int64
                }
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
                if dict.keys.contains("valueList") {
                    var tmp : [GetWorkItemInfoResponseBody.Workitem.CustomFields.ValueList] = []
                    for v in dict["valueList"] as! [Any] {
                        var model = GetWorkItemInfoResponseBody.Workitem.CustomFields.ValueList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.valueList = tmp
                }
                if dict.keys.contains("workitemIdentifier") {
                    self.workitemIdentifier = dict["workitemIdentifier"] as! String
                }
            }
        }
        public class TagDetails : Tea.TeaModel {
            public var color: String?

            public var identifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.color != nil {
                    map["color"] = self.color!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("color") {
                    self.color = dict["color"] as! String
                }
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var customFields: [GetWorkItemInfoResponseBody.Workitem.CustomFields]?

        public var document: String?

        public var documentFormat: String?

        public var finishTime: Int64?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var parentIdentifier: String?

        public var participant: [String]?

        public var serialNumber: String?

        public var spaceIdentifier: String?

        public var spaceName: String?

        public var spaceType: String?

        public var sprint: [String]?

        public var status: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subject: String?

        public var tag: [String]?

        public var tagDetails: [GetWorkItemInfoResponseBody.Workitem.TagDetails]?

        public var tracker: [String]?

        public var updateStatusAt: Int64?

        public var verifier: [String]?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.customFields != nil {
                var tmp : [Any] = []
                for k in self.customFields! {
                    tmp.append(k.toMap())
                }
                map["customFields"] = tmp
            }
            if self.document != nil {
                map["document"] = self.document!
            }
            if self.documentFormat != nil {
                map["documentFormat"] = self.documentFormat!
            }
            if self.finishTime != nil {
                map["finishTime"] = self.finishTime!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.participant != nil {
                map["participant"] = self.participant!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceName != nil {
                map["spaceName"] = self.spaceName!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.sprint != nil {
                map["sprint"] = self.sprint!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.tag != nil {
                map["tag"] = self.tag!
            }
            if self.tagDetails != nil {
                var tmp : [Any] = []
                for k in self.tagDetails! {
                    tmp.append(k.toMap())
                }
                map["tagDetails"] = tmp
            }
            if self.tracker != nil {
                map["tracker"] = self.tracker!
            }
            if self.updateStatusAt != nil {
                map["updateStatusAt"] = self.updateStatusAt!
            }
            if self.verifier != nil {
                map["verifier"] = self.verifier!
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedTo") {
                self.assignedTo = dict["assignedTo"] as! String
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("customFields") {
                var tmp : [GetWorkItemInfoResponseBody.Workitem.CustomFields] = []
                for v in dict["customFields"] as! [Any] {
                    var model = GetWorkItemInfoResponseBody.Workitem.CustomFields()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customFields = tmp
            }
            if dict.keys.contains("document") {
                self.document = dict["document"] as! String
            }
            if dict.keys.contains("documentFormat") {
                self.documentFormat = dict["documentFormat"] as! String
            }
            if dict.keys.contains("finishTime") {
                self.finishTime = dict["finishTime"] as! Int64
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("logicalStatus") {
                self.logicalStatus = dict["logicalStatus"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("parentIdentifier") {
                self.parentIdentifier = dict["parentIdentifier"] as! String
            }
            if dict.keys.contains("participant") {
                self.participant = dict["participant"] as! [String]
            }
            if dict.keys.contains("serialNumber") {
                self.serialNumber = dict["serialNumber"] as! String
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("spaceName") {
                self.spaceName = dict["spaceName"] as! String
            }
            if dict.keys.contains("spaceType") {
                self.spaceType = dict["spaceType"] as! String
            }
            if dict.keys.contains("sprint") {
                self.sprint = dict["sprint"] as! [String]
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("statusIdentifier") {
                self.statusIdentifier = dict["statusIdentifier"] as! String
            }
            if dict.keys.contains("statusStageIdentifier") {
                self.statusStageIdentifier = dict["statusStageIdentifier"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("tag") {
                self.tag = dict["tag"] as! [String]
            }
            if dict.keys.contains("tagDetails") {
                var tmp : [GetWorkItemInfoResponseBody.Workitem.TagDetails] = []
                for v in dict["tagDetails"] as! [Any] {
                    var model = GetWorkItemInfoResponseBody.Workitem.TagDetails()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagDetails = tmp
            }
            if dict.keys.contains("tracker") {
                self.tracker = dict["tracker"] as! [String]
            }
            if dict.keys.contains("updateStatusAt") {
                self.updateStatusAt = dict["updateStatusAt"] as! Int64
            }
            if dict.keys.contains("verifier") {
                self.verifier = dict["verifier"] as! [String]
            }
            if dict.keys.contains("workitemTypeIdentifier") {
                self.workitemTypeIdentifier = dict["workitemTypeIdentifier"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workitem: GetWorkItemInfoResponseBody.Workitem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitem != nil {
            map["workitem"] = self.workitem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("workitem") {
            var model = GetWorkItemInfoResponseBody.Workitem()
            model.fromMap(dict["workitem"] as! [String: Any])
            self.workitem = model
        }
    }
}

public class GetWorkItemInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkItemInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkItemInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkItemWorkFlowInfoRequest : Tea.TeaModel {
    public var configurationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configurationId != nil {
            map["configurationId"] = self.configurationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("configurationId") {
            self.configurationId = dict["configurationId"] as! String
        }
    }
}

public class GetWorkItemWorkFlowInfoResponseBody : Tea.TeaModel {
    public class Workflow : Tea.TeaModel {
        public class Statuses : Tea.TeaModel {
            public var creator: String?

            public var description_: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var identifier: String?

            public var modifier: String?

            public var name: String?

            public var resourceType: String?

            public var source: String?

            public var workflowStageIdentifier: String?

            public var workflowStageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creator != nil {
                    map["creator"] = self.creator!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["gmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["gmtModified"] = self.gmtModified!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.modifier != nil {
                    map["modifier"] = self.modifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.resourceType != nil {
                    map["resourceType"] = self.resourceType!
                }
                if self.source != nil {
                    map["source"] = self.source!
                }
                if self.workflowStageIdentifier != nil {
                    map["workflowStageIdentifier"] = self.workflowStageIdentifier!
                }
                if self.workflowStageName != nil {
                    map["workflowStageName"] = self.workflowStageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("creator") {
                    self.creator = dict["creator"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("gmtCreate") {
                    self.gmtCreate = dict["gmtCreate"] as! Int64
                }
                if dict.keys.contains("gmtModified") {
                    self.gmtModified = dict["gmtModified"] as! Int64
                }
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
                if dict.keys.contains("modifier") {
                    self.modifier = dict["modifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("resourceType") {
                    self.resourceType = dict["resourceType"] as! String
                }
                if dict.keys.contains("source") {
                    self.source = dict["source"] as! String
                }
                if dict.keys.contains("workflowStageIdentifier") {
                    self.workflowStageIdentifier = dict["workflowStageIdentifier"] as! String
                }
                if dict.keys.contains("workflowStageName") {
                    self.workflowStageName = dict["workflowStageName"] as! String
                }
            }
        }
        public class WorkflowActions : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public var nextWorkflowStatusIdentifier: String?

            public var workflowIdentifier: String?

            public var workflowStatusIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.nextWorkflowStatusIdentifier != nil {
                    map["nextWorkflowStatusIdentifier"] = self.nextWorkflowStatusIdentifier!
                }
                if self.workflowIdentifier != nil {
                    map["workflowIdentifier"] = self.workflowIdentifier!
                }
                if self.workflowStatusIdentifier != nil {
                    map["workflowStatusIdentifier"] = self.workflowStatusIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("nextWorkflowStatusIdentifier") {
                    self.nextWorkflowStatusIdentifier = dict["nextWorkflowStatusIdentifier"] as! String
                }
                if dict.keys.contains("workflowIdentifier") {
                    self.workflowIdentifier = dict["workflowIdentifier"] as! String
                }
                if dict.keys.contains("workflowStatusIdentifier") {
                    self.workflowStatusIdentifier = dict["workflowStatusIdentifier"] as! String
                }
            }
        }
        public var creator: String?

        public var defaultStatusIdentifier: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var ownerSpaceIdentifier: String?

        public var ownerSpaceType: String?

        public var resourceType: String?

        public var source: String?

        public var statusOrder: String?

        public var statuses: [GetWorkItemWorkFlowInfoResponseBody.Workflow.Statuses]?

        public var workflowActions: [GetWorkItemWorkFlowInfoResponseBody.Workflow.WorkflowActions]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.defaultStatusIdentifier != nil {
                map["defaultStatusIdentifier"] = self.defaultStatusIdentifier!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerSpaceIdentifier != nil {
                map["ownerSpaceIdentifier"] = self.ownerSpaceIdentifier!
            }
            if self.ownerSpaceType != nil {
                map["ownerSpaceType"] = self.ownerSpaceType!
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.statusOrder != nil {
                map["statusOrder"] = self.statusOrder!
            }
            if self.statuses != nil {
                var tmp : [Any] = []
                for k in self.statuses! {
                    tmp.append(k.toMap())
                }
                map["statuses"] = tmp
            }
            if self.workflowActions != nil {
                var tmp : [Any] = []
                for k in self.workflowActions! {
                    tmp.append(k.toMap())
                }
                map["workflowActions"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("defaultStatusIdentifier") {
                self.defaultStatusIdentifier = dict["defaultStatusIdentifier"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("ownerSpaceIdentifier") {
                self.ownerSpaceIdentifier = dict["ownerSpaceIdentifier"] as! String
            }
            if dict.keys.contains("ownerSpaceType") {
                self.ownerSpaceType = dict["ownerSpaceType"] as! String
            }
            if dict.keys.contains("resourceType") {
                self.resourceType = dict["resourceType"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("statusOrder") {
                self.statusOrder = dict["statusOrder"] as! String
            }
            if dict.keys.contains("statuses") {
                var tmp : [GetWorkItemWorkFlowInfoResponseBody.Workflow.Statuses] = []
                for v in dict["statuses"] as! [Any] {
                    var model = GetWorkItemWorkFlowInfoResponseBody.Workflow.Statuses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.statuses = tmp
            }
            if dict.keys.contains("workflowActions") {
                var tmp : [GetWorkItemWorkFlowInfoResponseBody.Workflow.WorkflowActions] = []
                for v in dict["workflowActions"] as! [Any] {
                    var model = GetWorkItemWorkFlowInfoResponseBody.Workflow.WorkflowActions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.workflowActions = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workflow: GetWorkItemWorkFlowInfoResponseBody.Workflow?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workflow != nil {
            map["workflow"] = self.workflow?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("workflow") {
            var model = GetWorkItemWorkFlowInfoResponseBody.Workflow()
            model.fromMap(dict["workflow"] as! [String: Any])
            self.workflow = model
        }
    }
}

public class GetWorkItemWorkFlowInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkItemWorkFlowInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkItemWorkFlowInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkitemAttachmentCreatemetaRequest : Tea.TeaModel {
    public var fileName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["fileName"] = self.fileName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("fileName") {
            self.fileName = dict["fileName"] as! String
        }
    }
}

public class GetWorkitemAttachmentCreatemetaResponseBody : Tea.TeaModel {
    public class UploadInfo : Tea.TeaModel {
        public var accessid: String?

        public var dir: String?

        public var host: String?

        public var policy: String?

        public var signature: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessid != nil {
                map["accessid"] = self.accessid!
            }
            if self.dir != nil {
                map["dir"] = self.dir!
            }
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.policy != nil {
                map["policy"] = self.policy!
            }
            if self.signature != nil {
                map["signature"] = self.signature!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessid") {
                self.accessid = dict["accessid"] as! String
            }
            if dict.keys.contains("dir") {
                self.dir = dict["dir"] as! String
            }
            if dict.keys.contains("host") {
                self.host = dict["host"] as! String
            }
            if dict.keys.contains("policy") {
                self.policy = dict["policy"] as! String
            }
            if dict.keys.contains("signature") {
                self.signature = dict["signature"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: String?

    public var uploadInfo: GetWorkitemAttachmentCreatemetaResponseBody.UploadInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.uploadInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.uploadInfo != nil {
            map["uploadInfo"] = self.uploadInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
        if dict.keys.contains("uploadInfo") {
            var model = GetWorkitemAttachmentCreatemetaResponseBody.UploadInfo()
            model.fromMap(dict["uploadInfo"] as! [String: Any])
            self.uploadInfo = model
        }
    }
}

public class GetWorkitemAttachmentCreatemetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkitemAttachmentCreatemetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkitemAttachmentCreatemetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkitemCommentListResponseBody : Tea.TeaModel {
    public class CommentList : Tea.TeaModel {
        public class User : Tea.TeaModel {
            public var account: String?

            public var avatar: String?

            public var identifier: String?

            public var nickName: String?

            public var realName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["account"] = self.account!
                }
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.nickName != nil {
                    map["nickName"] = self.nickName!
                }
                if self.realName != nil {
                    map["realName"] = self.realName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("account") {
                    self.account = dict["account"] as! String
                }
                if dict.keys.contains("avatar") {
                    self.avatar = dict["avatar"] as! String
                }
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
                if dict.keys.contains("nickName") {
                    self.nickName = dict["nickName"] as! String
                }
                if dict.keys.contains("realName") {
                    self.realName = dict["realName"] as! String
                }
            }
        }
        public var content: String?

        public var createTime: Int64?

        public var formatType: String?

        public var id: Int64?

        public var isTop: Bool?

        public var modifiedTime: Int64?

        public var parentId: Int64?

        public var targetIdentifier: String?

        public var targetType: String?

        public var topTime: Int64?

        public var user: GetWorkitemCommentListResponseBody.CommentList.User?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.user?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.formatType != nil {
                map["formatType"] = self.formatType!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isTop != nil {
                map["isTop"] = self.isTop!
            }
            if self.modifiedTime != nil {
                map["modifiedTime"] = self.modifiedTime!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.targetIdentifier != nil {
                map["targetIdentifier"] = self.targetIdentifier!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.topTime != nil {
                map["topTime"] = self.topTime!
            }
            if self.user != nil {
                map["user"] = self.user?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("formatType") {
                self.formatType = dict["formatType"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("isTop") {
                self.isTop = dict["isTop"] as! Bool
            }
            if dict.keys.contains("modifiedTime") {
                self.modifiedTime = dict["modifiedTime"] as! Int64
            }
            if dict.keys.contains("parentId") {
                self.parentId = dict["parentId"] as! Int64
            }
            if dict.keys.contains("targetIdentifier") {
                self.targetIdentifier = dict["targetIdentifier"] as! String
            }
            if dict.keys.contains("targetType") {
                self.targetType = dict["targetType"] as! String
            }
            if dict.keys.contains("topTime") {
                self.topTime = dict["topTime"] as! Int64
            }
            if dict.keys.contains("user") {
                var model = GetWorkitemCommentListResponseBody.CommentList.User()
                model.fromMap(dict["user"] as! [String: Any])
                self.user = model
            }
        }
    }
    public var commentList: [GetWorkitemCommentListResponseBody.CommentList]?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commentList != nil {
            var tmp : [Any] = []
            for k in self.commentList! {
                tmp.append(k.toMap())
            }
            map["commentList"] = tmp
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commentList") {
            var tmp : [GetWorkitemCommentListResponseBody.CommentList] = []
            for v in dict["commentList"] as! [Any] {
                var model = GetWorkitemCommentListResponseBody.CommentList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.commentList = tmp
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
    }
}

public class GetWorkitemCommentListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkitemCommentListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkitemCommentListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkitemFileResponseBody : Tea.TeaModel {
    public class WorkitemFile : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public var size: Int32?

        public var suffix: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.size != nil {
                map["size"] = self.size!
            }
            if self.suffix != nil {
                map["suffix"] = self.suffix!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("size") {
                self.size = dict["size"] as! Int32
            }
            if dict.keys.contains("suffix") {
                self.suffix = dict["suffix"] as! String
            }
            if dict.keys.contains("url") {
                self.url = dict["url"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public var workitemFile: GetWorkitemFileResponseBody.WorkitemFile?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitemFile?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitemFile != nil {
            map["workitemFile"] = self.workitemFile?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
        if dict.keys.contains("workitemFile") {
            var model = GetWorkitemFileResponseBody.WorkitemFile()
            model.fromMap(dict["workitemFile"] as! [String: Any])
            self.workitemFile = model
        }
    }
}

public class GetWorkitemFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkitemFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkitemFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkitemRelationsRequest : Tea.TeaModel {
    public var relationType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relationType != nil {
            map["relationType"] = self.relationType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("relationType") {
            self.relationType = dict["relationType"] as! String
        }
    }
}

public class GetWorkitemRelationsResponseBody : Tea.TeaModel {
    public class RelationList : Tea.TeaModel {
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var identifier: String?

        public var spaceIdentifier: String?

        public var subject: String?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedTo") {
                self.assignedTo = dict["assignedTo"] as! String
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("workitemTypeIdentifier") {
                self.workitemTypeIdentifier = dict["workitemTypeIdentifier"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var relationList: [GetWorkitemRelationsResponseBody.RelationList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.relationList != nil {
            var tmp : [Any] = []
            for k in self.relationList! {
                tmp.append(k.toMap())
            }
            map["relationList"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("relationList") {
            var tmp : [GetWorkitemRelationsResponseBody.RelationList] = []
            for v in dict["relationList"] as! [Any] {
                var model = GetWorkitemRelationsResponseBody.RelationList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.relationList = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class GetWorkitemRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkitemRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkitemRelationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkitemTimeTypeListResponseBody : Tea.TeaModel {
    public class TimeType : Tea.TeaModel {
        public var description_: String?

        public var displayName: String?

        public var identifier: String?

        public var name: String?

        public var position: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.position != nil {
                map["position"] = self.position!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("displayName") {
                self.displayName = dict["displayName"] as! String
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("position") {
                self.position = dict["position"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public var timeType: [GetWorkitemTimeTypeListResponseBody.TimeType]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.timeType != nil {
            var tmp : [Any] = []
            for k in self.timeType! {
                tmp.append(k.toMap())
            }
            map["timeType"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
        if dict.keys.contains("timeType") {
            var tmp : [GetWorkitemTimeTypeListResponseBody.TimeType] = []
            for v in dict["timeType"] as! [Any] {
                var model = GetWorkitemTimeTypeListResponseBody.TimeType()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.timeType = tmp
        }
    }
}

public class GetWorkitemTimeTypeListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkitemTimeTypeListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkitemTimeTypeListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWorkspaceResponseBody : Tea.TeaModel {
    public class Workspace : Tea.TeaModel {
        public var codeUrl: String?

        public var codeVersion: String?

        public var createTime: String?

        public var id: String?

        public var name: String?

        public var spec: String?

        public var status: String?

        public var template: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.codeUrl != nil {
                map["codeUrl"] = self.codeUrl!
            }
            if self.codeVersion != nil {
                map["codeVersion"] = self.codeVersion!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.spec != nil {
                map["spec"] = self.spec!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.template != nil {
                map["template"] = self.template!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("codeUrl") {
                self.codeUrl = dict["codeUrl"] as! String
            }
            if dict.keys.contains("codeVersion") {
                self.codeVersion = dict["codeVersion"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("spec") {
                self.spec = dict["spec"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("template") {
                self.template = dict["template"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workspace: GetWorkspaceResponseBody.Workspace?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workspace?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workspace != nil {
            map["workspace"] = self.workspace?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("workspace") {
            var model = GetWorkspaceResponseBody.Workspace()
            model.fromMap(dict["workspace"] as! [String: Any])
            self.workspace = model
        }
    }
}

public class GetWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinPipelineGroupRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var pipelineIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["groupId"] = self.groupId!
        }
        if self.pipelineIds != nil {
            map["pipelineIds"] = self.pipelineIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("groupId") {
            self.groupId = dict["groupId"] as! Int64
        }
        if dict.keys.contains("pipelineIds") {
            self.pipelineIds = dict["pipelineIds"] as! String
        }
    }
}

public class JoinPipelineGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class JoinPipelineGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinPipelineGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = JoinPipelineGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LinkMergeRequestLabelRequest : Tea.TeaModel {
    public var accessToken: String?

    public var labelIds: [String]?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.labelIds != nil {
            map["labelIds"] = self.labelIds!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("labelIds") {
            self.labelIds = dict["labelIds"] as! [String]
        }
        if dict.keys.contains("localId") {
            self.localId = dict["localId"] as! Int64
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class LinkMergeRequestLabelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: LinkMergeRequestLabelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = LinkMergeRequestLabelResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class LinkMergeRequestLabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LinkMergeRequestLabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = LinkMergeRequestLabelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAllReleaseWorkflowsRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ListAllReleaseWorkflowsResponse : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public class ReleaseStages : Tea.TeaModel {
            public class VariableGroups : Tea.TeaModel {
                public var name: String?

                public var displayName: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.displayName != nil {
                        map["displayName"] = self.displayName!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("displayName") {
                        self.displayName = dict["displayName"] as! String
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                }
            }
            public var appName: String?

            public var name: String?

            public var sn: String?

            public var releaseWorkflowSn: String?

            public var order: String?

            public var variableGroups: [ListAllReleaseWorkflowsResponse.Body.ReleaseStages.VariableGroups]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["appName"] = self.appName!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sn != nil {
                    map["sn"] = self.sn!
                }
                if self.releaseWorkflowSn != nil {
                    map["releaseWorkflowSn"] = self.releaseWorkflowSn!
                }
                if self.order != nil {
                    map["order"] = self.order!
                }
                if self.variableGroups != nil {
                    var tmp : [Any] = []
                    for k in self.variableGroups! {
                        tmp.append(k.toMap())
                    }
                    map["variableGroups"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("appName") {
                    self.appName = dict["appName"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("sn") {
                    self.sn = dict["sn"] as! String
                }
                if dict.keys.contains("releaseWorkflowSn") {
                    self.releaseWorkflowSn = dict["releaseWorkflowSn"] as! String
                }
                if dict.keys.contains("order") {
                    self.order = dict["order"] as! String
                }
                if dict.keys.contains("variableGroups") {
                    var tmp : [ListAllReleaseWorkflowsResponse.Body.ReleaseStages.VariableGroups] = []
                    for v in dict["variableGroups"] as! [Any] {
                        var model = ListAllReleaseWorkflowsResponse.Body.ReleaseStages.VariableGroups()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.variableGroups = tmp
                }
            }
        }
        public var appName: String?

        public var sn: String?

        public var name: String?

        public var order: String?

        public var releaseStages: [ListAllReleaseWorkflowsResponse.Body.ReleaseStages]?

        public var note: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["appName"] = self.appName!
            }
            if self.sn != nil {
                map["sn"] = self.sn!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.order != nil {
                map["order"] = self.order!
            }
            if self.releaseStages != nil {
                var tmp : [Any] = []
                for k in self.releaseStages! {
                    tmp.append(k.toMap())
                }
                map["releaseStages"] = tmp
            }
            if self.note != nil {
                map["note"] = self.note!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("appName") {
                self.appName = dict["appName"] as! String
            }
            if dict.keys.contains("sn") {
                self.sn = dict["sn"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("order") {
                self.order = dict["order"] as! String
            }
            if dict.keys.contains("releaseStages") {
                var tmp : [ListAllReleaseWorkflowsResponse.Body.ReleaseStages] = []
                for v in dict["releaseStages"] as! [Any] {
                    var model = ListAllReleaseWorkflowsResponse.Body.ReleaseStages()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.releaseStages = tmp
            }
            if dict.keys.contains("note") {
                self.note = dict["note"] as! String
            }
        }
    }
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: [ListAllReleaseWorkflowsResponse.Body]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var tmp : [ListAllReleaseWorkflowsResponse.Body] = []
            for v in dict["body"] as! [Any] {
                var model = ListAllReleaseWorkflowsResponse.Body()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.body = tmp
        }
    }
}

public class ListAppReleaseStageExecutionIntegratedMetadataRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ListAppReleaseStageExecutionIntegratedMetadataResponse : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public class ChangeRequests : Tea.TeaModel {
            public var sn: String?

            public var name: String?

            public var branchName: String?

            public var commitId: String?

            public var ownerAccountId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sn != nil {
                    map["sn"] = self.sn!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.branchName != nil {
                    map["branchName"] = self.branchName!
                }
                if self.commitId != nil {
                    map["commitId"] = self.commitId!
                }
                if self.ownerAccountId != nil {
                    map["ownerAccountId"] = self.ownerAccountId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("sn") {
                    self.sn = dict["sn"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("branchName") {
                    self.branchName = dict["branchName"] as! String
                }
                if dict.keys.contains("commitId") {
                    self.commitId = dict["commitId"] as! String
                }
                if dict.keys.contains("ownerAccountId") {
                    self.ownerAccountId = dict["ownerAccountId"] as! String
                }
            }
        }
        public var releaseBranch: String?

        public var releaseRevision: String?

        public var repoUrl: String?

        public var repoType: String?

        public var changeRequests: [ListAppReleaseStageExecutionIntegratedMetadataResponse.Body.ChangeRequests]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.releaseBranch != nil {
                map["releaseBranch"] = self.releaseBranch!
            }
            if self.releaseRevision != nil {
                map["releaseRevision"] = self.releaseRevision!
            }
            if self.repoUrl != nil {
                map["repoUrl"] = self.repoUrl!
            }
            if self.repoType != nil {
                map["repoType"] = self.repoType!
            }
            if self.changeRequests != nil {
                var tmp : [Any] = []
                for k in self.changeRequests! {
                    tmp.append(k.toMap())
                }
                map["changeRequests"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("releaseBranch") {
                self.releaseBranch = dict["releaseBranch"] as! String
            }
            if dict.keys.contains("releaseRevision") {
                self.releaseRevision = dict["releaseRevision"] as! String
            }
            if dict.keys.contains("repoUrl") {
                self.repoUrl = dict["repoUrl"] as! String
            }
            if dict.keys.contains("repoType") {
                self.repoType = dict["repoType"] as! String
            }
            if dict.keys.contains("changeRequests") {
                var tmp : [ListAppReleaseStageExecutionIntegratedMetadataResponse.Body.ChangeRequests] = []
                for v in dict["changeRequests"] as! [Any] {
                    var model = ListAppReleaseStageExecutionIntegratedMetadataResponse.Body.ChangeRequests()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.changeRequests = tmp
            }
        }
    }
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: [ListAppReleaseStageExecutionIntegratedMetadataResponse.Body]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var tmp : [ListAppReleaseStageExecutionIntegratedMetadataResponse.Body] = []
            for v in dict["body"] as! [Any] {
                var model = ListAppReleaseStageExecutionIntegratedMetadataResponse.Body()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.body = tmp
        }
    }
}

public class ListAppReleaseStageExecutionsRequest : Tea.TeaModel {
    public var nextToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int32?

    public var pagination: String?

    public var perPage: Int32?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pagination != nil {
            map["pagination"] = self.pagination!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orderBy") {
            self.orderBy = dict["orderBy"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("pagination") {
            self.pagination = dict["pagination"] as! String
        }
        if dict.keys.contains("perPage") {
            self.perPage = dict["perPage"] as! Int32
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
    }
}

public class ListAppReleaseStageExecutionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var endTime: String?

        public var number: String?

        public var startTime: String?

        public var state: String?

        public var triggerMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.number != nil {
                map["number"] = self.number!
            }
            if self.startTime != nil {
                map["startTime"] = self.startTime!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.triggerMode != nil {
                map["triggerMode"] = self.triggerMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("endTime") {
                self.endTime = dict["endTime"] as! String
            }
            if dict.keys.contains("number") {
                self.number = dict["number"] as! String
            }
            if dict.keys.contains("startTime") {
                self.startTime = dict["startTime"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("triggerMode") {
                self.triggerMode = dict["triggerMode"] as! String
            }
        }
    }
    public var current: Int64?

    public var data: [ListAppReleaseStageExecutionsResponseBody.Data]?

    public var nextToken: String?

    public var pages: Int64?

    public var perPage: Int64?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["current"] = self.current!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pages != nil {
            map["pages"] = self.pages!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("current") {
            self.current = dict["current"] as! Int64
        }
        if dict.keys.contains("data") {
            var tmp : [ListAppReleaseStageExecutionsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListAppReleaseStageExecutionsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("pages") {
            self.pages = dict["pages"] as! Int64
        }
        if dict.keys.contains("perPage") {
            self.perPage = dict["perPage"] as! Int64
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListAppReleaseStageExecutionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppReleaseStageExecutionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAppReleaseStageExecutionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationMembersRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ListApplicationMembersResponseBody : Tea.TeaModel {
    public class Records : Tea.TeaModel {
        public class RoleList : Tea.TeaModel {
            public var displayName: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("displayName") {
                    self.displayName = dict["displayName"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public var avatar: String?

        public var description_: String?

        public var displayName: String?

        public var id: String?

        public var roleList: [ListApplicationMembersResponseBody.Records.RoleList]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatar != nil {
                map["avatar"] = self.avatar!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.roleList != nil {
                var tmp : [Any] = []
                for k in self.roleList! {
                    tmp.append(k.toMap())
                }
                map["roleList"] = tmp
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("avatar") {
                self.avatar = dict["avatar"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("displayName") {
                self.displayName = dict["displayName"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("roleList") {
                var tmp : [ListApplicationMembersResponseBody.Records.RoleList] = []
                for v in dict["roleList"] as! [Any] {
                    var model = ListApplicationMembersResponseBody.Records.RoleList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.roleList = tmp
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var current: Int64?

    public var pageSize: Int64?

    public var pages: Int64?

    public var records: [ListApplicationMembersResponseBody.Records]?

    public var requestId: String?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["current"] = self.current!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.pages != nil {
            map["pages"] = self.pages!
        }
        if self.records != nil {
            var tmp : [Any] = []
            for k in self.records! {
                tmp.append(k.toMap())
            }
            map["records"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("current") {
            self.current = dict["current"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("pages") {
            self.pages = dict["pages"] as! Int64
        }
        if dict.keys.contains("records") {
            var tmp : [ListApplicationMembersResponseBody.Records] = []
            for v in dict["records"] as! [Any] {
                var model = ListApplicationMembersResponseBody.Records()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.records = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListApplicationMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApplicationMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationsRequest : Tea.TeaModel {
    public var nextToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var pagination: String?

    public var perPage: Int32?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.pagination != nil {
            map["pagination"] = self.pagination!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orderBy") {
            self.orderBy = dict["orderBy"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("pagination") {
            self.pagination = dict["pagination"] as! String
        }
        if dict.keys.contains("perPage") {
            self.perPage = dict["perPage"] as! Int32
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
    }
}

public class ListApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var creatorAccountId: String?

        public var description_: String?

        public var gmtCreate: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creatorAccountId") {
                self.creatorAccountId = dict["creatorAccountId"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var data: [ListApplicationsResponseBody.Data]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            var tmp : [ListApplicationsResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListApplicationsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListChangeRequestWorkflowExecutionsRequest : Tea.TeaModel {
    public var orderBy: String?

    public var organizationId: String?

    public var page: Int64?

    public var perPage: Int64?

    public var releaseStageSn: String?

    public var releaseWorkflowSn: String?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.releaseStageSn != nil {
            map["releaseStageSn"] = self.releaseStageSn!
        }
        if self.releaseWorkflowSn != nil {
            map["releaseWorkflowSn"] = self.releaseWorkflowSn!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("orderBy") {
            self.orderBy = dict["orderBy"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("perPage") {
            self.perPage = dict["perPage"] as! Int64
        }
        if dict.keys.contains("releaseStageSn") {
            self.releaseStageSn = dict["releaseStageSn"] as! String
        }
        if dict.keys.contains("releaseWorkflowSn") {
            self.releaseWorkflowSn = dict["releaseWorkflowSn"] as! String
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
    }
}

public class ListChangeRequestWorkflowExecutionsResponseBody : Tea.TeaModel {
    public var current: Int64?

    public var pageSize: Int64?

    public var pages: Int64?

    public var records: [Any]?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["current"] = self.current!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.pages != nil {
            map["pages"] = self.pages!
        }
        if self.records != nil {
            map["records"] = self.records!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("current") {
            self.current = dict["current"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("pages") {
            self.pages = dict["pages"] as! Int64
        }
        if dict.keys.contains("records") {
            self.records = dict["records"] as! [Any]
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListChangeRequestWorkflowExecutionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListChangeRequestWorkflowExecutionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListChangeRequestWorkflowExecutionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListChangeRequestsRequest : Tea.TeaModel {
    public var appNameList: [String]?

    public var displayNameKeyword: String?

    public var nextToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var ownerIdList: [String]?

    public var page: Int32?

    public var pagination: String?

    public var perPage: Int32?

    public var sort: String?

    public var stateList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appNameList != nil {
            map["appNameList"] = self.appNameList!
        }
        if self.displayNameKeyword != nil {
            map["displayNameKeyword"] = self.displayNameKeyword!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.ownerIdList != nil {
            map["ownerIdList"] = self.ownerIdList!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pagination != nil {
            map["pagination"] = self.pagination!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.stateList != nil {
            map["stateList"] = self.stateList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("appNameList") {
            self.appNameList = dict["appNameList"] as! [String]
        }
        if dict.keys.contains("displayNameKeyword") {
            self.displayNameKeyword = dict["displayNameKeyword"] as! String
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orderBy") {
            self.orderBy = dict["orderBy"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("ownerIdList") {
            self.ownerIdList = dict["ownerIdList"] as! [String]
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("pagination") {
            self.pagination = dict["pagination"] as! String
        }
        if dict.keys.contains("perPage") {
            self.perPage = dict["perPage"] as! Int32
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
        if dict.keys.contains("stateList") {
            self.stateList = dict["stateList"] as! [String]
        }
    }
}

public class ListChangeRequestsShrinkRequest : Tea.TeaModel {
    public var appNameListShrink: String?

    public var displayNameKeyword: String?

    public var nextToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var ownerIdListShrink: String?

    public var page: Int32?

    public var pagination: String?

    public var perPage: Int32?

    public var sort: String?

    public var stateListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appNameListShrink != nil {
            map["appNameList"] = self.appNameListShrink!
        }
        if self.displayNameKeyword != nil {
            map["displayNameKeyword"] = self.displayNameKeyword!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.ownerIdListShrink != nil {
            map["ownerIdList"] = self.ownerIdListShrink!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pagination != nil {
            map["pagination"] = self.pagination!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.stateListShrink != nil {
            map["stateList"] = self.stateListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("appNameList") {
            self.appNameListShrink = dict["appNameList"] as! String
        }
        if dict.keys.contains("displayNameKeyword") {
            self.displayNameKeyword = dict["displayNameKeyword"] as! String
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orderBy") {
            self.orderBy = dict["orderBy"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("ownerIdList") {
            self.ownerIdListShrink = dict["ownerIdList"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("pagination") {
            self.pagination = dict["pagination"] as! String
        }
        if dict.keys.contains("perPage") {
            self.perPage = dict["perPage"] as! Int32
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
        if dict.keys.contains("stateList") {
            self.stateListShrink = dict["stateList"] as! String
        }
    }
}

public class ListChangeRequestsResponseBody : Tea.TeaModel {
    public var current: Int64?

    public var data: [Any]?

    public var nextToken: String?

    public var pages: Int64?

    public var perPage: Int64?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["current"] = self.current!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pages != nil {
            map["pages"] = self.pages!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("current") {
            self.current = dict["current"] as! Int64
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! [Any]
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("pages") {
            self.pages = dict["pages"] as! Int64
        }
        if dict.keys.contains("perPage") {
            self.perPage = dict["perPage"] as! Int64
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListChangeRequestsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListChangeRequestsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListChangeRequestsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCheckRunsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var ref: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.ref != nil {
            map["ref"] = self.ref!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("ref") {
            self.ref = dict["ref"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class ListCheckRunsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var annotationLevel: String?

            public var endColumn: Int64?

            public var endLine: Int64?

            public var id: Int64?

            public var message: String?

            public var path: String?

            public var rawDetails: String?

            public var startColumn: Int64?

            public var startLine: Int64?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotationLevel != nil {
                    map["annotationLevel"] = self.annotationLevel!
                }
                if self.endColumn != nil {
                    map["endColumn"] = self.endColumn!
                }
                if self.endLine != nil {
                    map["endLine"] = self.endLine!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.rawDetails != nil {
                    map["rawDetails"] = self.rawDetails!
                }
                if self.startColumn != nil {
                    map["startColumn"] = self.startColumn!
                }
                if self.startLine != nil {
                    map["startLine"] = self.startLine!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("annotationLevel") {
                    self.annotationLevel = dict["annotationLevel"] as! String
                }
                if dict.keys.contains("endColumn") {
                    self.endColumn = dict["endColumn"] as! Int64
                }
                if dict.keys.contains("endLine") {
                    self.endLine = dict["endLine"] as! Int64
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("rawDetails") {
                    self.rawDetails = dict["rawDetails"] as! String
                }
                if dict.keys.contains("startColumn") {
                    self.startColumn = dict["startColumn"] as! Int64
                }
                if dict.keys.contains("startLine") {
                    self.startLine = dict["startLine"] as! Int64
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class CheckSuite : Tea.TeaModel {
            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class Images : Tea.TeaModel {
                public var alt: String?

                public var caption: String?

                public var imageUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alt != nil {
                        map["alt"] = self.alt!
                    }
                    if self.caption != nil {
                        map["caption"] = self.caption!
                    }
                    if self.imageUrl != nil {
                        map["imageUrl"] = self.imageUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("alt") {
                        self.alt = dict["alt"] as! String
                    }
                    if dict.keys.contains("caption") {
                        self.caption = dict["caption"] as! String
                    }
                    if dict.keys.contains("imageUrl") {
                        self.imageUrl = dict["imageUrl"] as! String
                    }
                }
            }
            public var images: [ListCheckRunsResponseBody.Result.Output.Images]?

            public var summary: String?

            public var text: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.images != nil {
                    var tmp : [Any] = []
                    for k in self.images! {
                        tmp.append(k.toMap())
                    }
                    map["images"] = tmp
                }
                if self.summary != nil {
                    map["summary"] = self.summary!
                }
                if self.text != nil {
                    map["text"] = self.text!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("images") {
                    var tmp : [ListCheckRunsResponseBody.Result.Output.Images] = []
                    for v in dict["images"] as! [Any] {
                        var model = ListCheckRunsResponseBody.Result.Output.Images()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.images = tmp
                }
                if dict.keys.contains("summary") {
                    self.summary = dict["summary"] as! String
                }
                if dict.keys.contains("text") {
                    self.text = dict["text"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class Writer : Tea.TeaModel {
            public var id: String?

            public var logoUrl: String?

            public var name: String?

            public var slug: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.logoUrl != nil {
                    map["logoUrl"] = self.logoUrl!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.slug != nil {
                    map["slug"] = self.slug!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("logoUrl") {
                    self.logoUrl = dict["logoUrl"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("slug") {
                    self.slug = dict["slug"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var annotations: [ListCheckRunsResponseBody.Result.Annotations]?

        public var checkSuite: ListCheckRunsResponseBody.Result.CheckSuite?

        public var completedAt: String?

        public var conclusion: String?

        public var createdAt: String?

        public var detailsUrl: String?

        public var externalId: String?

        public var headSha: String?

        public var id: Int64?

        public var name: String?

        public var output: ListCheckRunsResponseBody.Result.Output?

        public var startedAt: String?

        public var status: String?

        public var updatedAt: String?

        public var writer: ListCheckRunsResponseBody.Result.Writer?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkSuite?.validate()
            try self.output?.validate()
            try self.writer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["annotations"] = tmp
            }
            if self.checkSuite != nil {
                map["checkSuite"] = self.checkSuite?.toMap()
            }
            if self.completedAt != nil {
                map["completedAt"] = self.completedAt!
            }
            if self.conclusion != nil {
                map["conclusion"] = self.conclusion!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.detailsUrl != nil {
                map["detailsUrl"] = self.detailsUrl!
            }
            if self.externalId != nil {
                map["externalId"] = self.externalId!
            }
            if self.headSha != nil {
                map["headSha"] = self.headSha!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.output != nil {
                map["output"] = self.output?.toMap()
            }
            if self.startedAt != nil {
                map["startedAt"] = self.startedAt!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.writer != nil {
                map["writer"] = self.writer?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("annotations") {
                var tmp : [ListCheckRunsResponseBody.Result.Annotations] = []
                for v in dict["annotations"] as! [Any] {
                    var model = ListCheckRunsResponseBody.Result.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("checkSuite") {
                var model = ListCheckRunsResponseBody.Result.CheckSuite()
                model.fromMap(dict["checkSuite"] as! [String: Any])
                self.checkSuite = model
            }
            if dict.keys.contains("completedAt") {
                self.completedAt = dict["completedAt"] as! String
            }
            if dict.keys.contains("conclusion") {
                self.conclusion = dict["conclusion"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("detailsUrl") {
                self.detailsUrl = dict["detailsUrl"] as! String
            }
            if dict.keys.contains("externalId") {
                self.externalId = dict["externalId"] as! String
            }
            if dict.keys.contains("headSha") {
                self.headSha = dict["headSha"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("output") {
                var model = ListCheckRunsResponseBody.Result.Output()
                model.fromMap(dict["output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("startedAt") {
                self.startedAt = dict["startedAt"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("writer") {
                var model = ListCheckRunsResponseBody.Result.Writer()
                model.fromMap(dict["writer"] as! [String: Any])
                self.writer = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListCheckRunsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListCheckRunsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListCheckRunsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListCheckRunsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCheckRunsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCheckRunsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCommitStatusesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var repositoryIdentity: String?

    public var sha: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        if self.sha != nil {
            map["sha"] = self.sha!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
        if dict.keys.contains("sha") {
            self.sha = dict["sha"] as! String
        }
    }
}

public class ListCommitStatusesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Creator : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var login: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.login != nil {
                    map["login"] = self.login!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliyunPk") {
                    self.aliyunPk = dict["aliyunPk"] as! String
                }
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("login") {
                    self.login = dict["login"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var context: String?

        public var creator: ListCommitStatusesResponseBody.Result.Creator?

        public var description_: String?

        public var id: Int64?

        public var sha: String?

        public var state: String?

        public var targetUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.creator?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.context != nil {
                map["context"] = self.context!
            }
            if self.creator != nil {
                map["creator"] = self.creator?.toMap()
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.sha != nil {
                map["sha"] = self.sha!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.targetUrl != nil {
                map["targetUrl"] = self.targetUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("context") {
                self.context = dict["context"] as! String
            }
            if dict.keys.contains("creator") {
                var model = ListCommitStatusesResponseBody.Result.Creator()
                model.fromMap(dict["creator"] as! [String: Any])
                self.creator = model
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("sha") {
                self.sha = dict["sha"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("targetUrl") {
                self.targetUrl = dict["targetUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListCommitStatusesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListCommitStatusesResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListCommitStatusesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListCommitStatusesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCommitStatusesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCommitStatusesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowTagGroupsResponseBody : Tea.TeaModel {
    public class FlowTagGroups : Tea.TeaModel {
        public var creatorAccountId: String?

        public var id: Int64?

        public var modiferAccountId: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modiferAccountId != nil {
                map["modiferAccountId"] = self.modiferAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creatorAccountId") {
                self.creatorAccountId = dict["creatorAccountId"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("modiferAccountId") {
                self.modiferAccountId = dict["modiferAccountId"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var flowTagGroups: [ListFlowTagGroupsResponseBody.FlowTagGroups]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.flowTagGroups != nil {
            var tmp : [Any] = []
            for k in self.flowTagGroups! {
                tmp.append(k.toMap())
            }
            map["flowTagGroups"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("flowTagGroups") {
            var tmp : [ListFlowTagGroupsResponseBody.FlowTagGroups] = []
            for v in dict["flowTagGroups"] as! [Any] {
                var model = ListFlowTagGroupsResponseBody.FlowTagGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.flowTagGroups = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListFlowTagGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowTagGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFlowTagGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGroupMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ListGroupMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var memberType: String?

        public var name: String?

        public var sourceId: Int64?

        public var state: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.memberType != nil {
                map["memberType"] = self.memberType!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("memberType") {
                self.memberType = dict["memberType"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceId") {
                self.sourceId = dict["sourceId"] as! Int64
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("username") {
                self.username = dict["username"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListGroupMemberResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListGroupMemberResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListGroupMemberResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListGroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGroupMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGroupRepositoriesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var search: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("search") {
            self.search = dict["search"] as! String
        }
    }
}

public class ListGroupRepositoriesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var archived: Bool?

        public var commitCount: Int64?

        public var createdAt: String?

        public var creatorId: Int64?

        public var description_: String?

        public var httpUrl: String?

        public var id: Int64?

        public var importUrl: String?

        public var isStared: Bool?

        public var issuesEnabled: Bool?

        public var lastActivityAt: String?

        public var mergeRequestsEnabled: Bool?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespaceId: Bool?

        public var path: String?

        public var pathWithNamespace: String?

        public var privateFlag: Bool?

        public var snippetsEnabled: Bool?

        public var sshUrl: String?

        public var starCount: Int32?

        public var updatedAt: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public var wikiEnabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archived != nil {
                map["archived"] = self.archived!
            }
            if self.commitCount != nil {
                map["commitCount"] = self.commitCount!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.httpUrl != nil {
                map["httpUrl"] = self.httpUrl!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.importUrl != nil {
                map["importUrl"] = self.importUrl!
            }
            if self.isStared != nil {
                map["isStared"] = self.isStared!
            }
            if self.issuesEnabled != nil {
                map["issuesEnabled"] = self.issuesEnabled!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.mergeRequestsEnabled != nil {
                map["mergeRequestsEnabled"] = self.mergeRequestsEnabled!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespaceId != nil {
                map["namespaceId"] = self.namespaceId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.privateFlag != nil {
                map["privateFlag"] = self.privateFlag!
            }
            if self.snippetsEnabled != nil {
                map["snippetsEnabled"] = self.snippetsEnabled!
            }
            if self.sshUrl != nil {
                map["sshUrl"] = self.sshUrl!
            }
            if self.starCount != nil {
                map["starCount"] = self.starCount!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            if self.wikiEnabled != nil {
                map["wikiEnabled"] = self.wikiEnabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("archived") {
                self.archived = dict["archived"] as! Bool
            }
            if dict.keys.contains("commitCount") {
                self.commitCount = dict["commitCount"] as! Int64
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("creatorId") {
                self.creatorId = dict["creatorId"] as! Int64
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("httpUrl") {
                self.httpUrl = dict["httpUrl"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("importUrl") {
                self.importUrl = dict["importUrl"] as! String
            }
            if dict.keys.contains("isStared") {
                self.isStared = dict["isStared"] as! Bool
            }
            if dict.keys.contains("issuesEnabled") {
                self.issuesEnabled = dict["issuesEnabled"] as! Bool
            }
            if dict.keys.contains("lastActivityAt") {
                self.lastActivityAt = dict["lastActivityAt"] as! String
            }
            if dict.keys.contains("mergeRequestsEnabled") {
                self.mergeRequestsEnabled = dict["mergeRequestsEnabled"] as! Bool
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("namespaceId") {
                self.namespaceId = dict["namespaceId"] as! Bool
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("pathWithNamespace") {
                self.pathWithNamespace = dict["pathWithNamespace"] as! String
            }
            if dict.keys.contains("privateFlag") {
                self.privateFlag = dict["privateFlag"] as! Bool
            }
            if dict.keys.contains("snippetsEnabled") {
                self.snippetsEnabled = dict["snippetsEnabled"] as! Bool
            }
            if dict.keys.contains("sshUrl") {
                self.sshUrl = dict["sshUrl"] as! String
            }
            if dict.keys.contains("starCount") {
                self.starCount = dict["starCount"] as! Int32
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("visibilityLevel") {
                self.visibilityLevel = dict["visibilityLevel"] as! Int32
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
            if dict.keys.contains("wikiEnabled") {
                self.wikiEnabled = dict["wikiEnabled"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListGroupRepositoriesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListGroupRepositoriesResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListGroupRepositoriesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListGroupRepositoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGroupRepositoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGroupRepositoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHostGroupsRequest : Tea.TeaModel {
    public var createEndTime: Int64?

    public var createStartTime: Int64?

    public var creatorAccountIds: String?

    public var ids: String?

    public var maxResults: Int64?

    public var name: String?

    public var nextToken: String?

    public var pageOrder: String?

    public var pageSort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createEndTime != nil {
            map["createEndTime"] = self.createEndTime!
        }
        if self.createStartTime != nil {
            map["createStartTime"] = self.createStartTime!
        }
        if self.creatorAccountIds != nil {
            map["creatorAccountIds"] = self.creatorAccountIds!
        }
        if self.ids != nil {
            map["ids"] = self.ids!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pageOrder != nil {
            map["pageOrder"] = self.pageOrder!
        }
        if self.pageSort != nil {
            map["pageSort"] = self.pageSort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("createEndTime") {
            self.createEndTime = dict["createEndTime"] as! Int64
        }
        if dict.keys.contains("createStartTime") {
            self.createStartTime = dict["createStartTime"] as! Int64
        }
        if dict.keys.contains("creatorAccountIds") {
            self.creatorAccountIds = dict["creatorAccountIds"] as! String
        }
        if dict.keys.contains("ids") {
            self.ids = dict["ids"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("pageOrder") {
            self.pageOrder = dict["pageOrder"] as! String
        }
        if dict.keys.contains("pageSort") {
            self.pageSort = dict["pageSort"] as! String
        }
    }
}

public class ListHostGroupsResponseBody : Tea.TeaModel {
    public class HostGroups : Tea.TeaModel {
        public var aliyunRegion: String?

        public var createTime: Int64?

        public var creatorAccountId: String?

        public var description_: String?

        public var ecsLabelKey: String?

        public var ecsLabelValue: String?

        public var ecsType: String?

        public var hostNum: Int64?

        public var id: Int64?

        public var modifierAccountId: String?

        public var name: String?

        public var serviceConnectionId: Int64?

        public var type: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunRegion != nil {
                map["aliyunRegion"] = self.aliyunRegion!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.ecsLabelKey != nil {
                map["ecsLabelKey"] = self.ecsLabelKey!
            }
            if self.ecsLabelValue != nil {
                map["ecsLabelValue"] = self.ecsLabelValue!
            }
            if self.ecsType != nil {
                map["ecsType"] = self.ecsType!
            }
            if self.hostNum != nil {
                map["hostNum"] = self.hostNum!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.serviceConnectionId != nil {
                map["serviceConnectionId"] = self.serviceConnectionId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("aliyunRegion") {
                self.aliyunRegion = dict["aliyunRegion"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("creatorAccountId") {
                self.creatorAccountId = dict["creatorAccountId"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("ecsLabelKey") {
                self.ecsLabelKey = dict["ecsLabelKey"] as! String
            }
            if dict.keys.contains("ecsLabelValue") {
                self.ecsLabelValue = dict["ecsLabelValue"] as! String
            }
            if dict.keys.contains("ecsType") {
                self.ecsType = dict["ecsType"] as! String
            }
            if dict.keys.contains("hostNum") {
                self.hostNum = dict["hostNum"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("modifierAccountId") {
                self.modifierAccountId = dict["modifierAccountId"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("serviceConnectionId") {
                self.serviceConnectionId = dict["serviceConnectionId"] as! Int64
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var hostGroups: [ListHostGroupsResponseBody.HostGroups]?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.hostGroups != nil {
            var tmp : [Any] = []
            for k in self.hostGroups! {
                tmp.append(k.toMap())
            }
            map["hostGroups"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("hostGroups") {
            var tmp : [ListHostGroupsResponseBody.HostGroups] = []
            for v in dict["hostGroups"] as! [Any] {
                var model = ListHostGroupsResponseBody.HostGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hostGroups = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListHostGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHostGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListHostGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListJoinedOrganizationsResponseBody : Tea.TeaModel {
    public class Organizations : Tea.TeaModel {
        public var id: String?

        public var isOrgAdmin: Bool?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isOrgAdmin != nil {
                map["isOrgAdmin"] = self.isOrgAdmin!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isOrgAdmin") {
                self.isOrgAdmin = dict["isOrgAdmin"] as! Bool
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var organizations: [ListJoinedOrganizationsResponseBody.Organizations]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.organizations != nil {
            var tmp : [Any] = []
            for k in self.organizations! {
                tmp.append(k.toMap())
            }
            map["organizations"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("organizations") {
            var tmp : [ListJoinedOrganizationsResponseBody.Organizations] = []
            for v in dict["organizations"] as! [Any] {
                var model = ListJoinedOrganizationsResponseBody.Organizations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.organizations = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListJoinedOrganizationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListJoinedOrganizationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListJoinedOrganizationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMergeRequestCommentsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var commentType: String?

    public var filePath: String?

    public var patchSetBizIds: [String]?

    public var resolved: Bool?

    public var state: String?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.commentType != nil {
            map["commentType"] = self.commentType!
        }
        if self.filePath != nil {
            map["filePath"] = self.filePath!
        }
        if self.patchSetBizIds != nil {
            map["patchSetBizIds"] = self.patchSetBizIds!
        }
        if self.resolved != nil {
            map["resolved"] = self.resolved!
        }
        if self.state != nil {
            map["state"] = self.state!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("commentType") {
            self.commentType = dict["commentType"] as! String
        }
        if dict.keys.contains("filePath") {
            self.filePath = dict["filePath"] as! String
        }
        if dict.keys.contains("patchSetBizIds") {
            self.patchSetBizIds = dict["patchSetBizIds"] as! [String]
        }
        if dict.keys.contains("resolved") {
            self.resolved = dict["resolved"] as! Bool
        }
        if dict.keys.contains("state") {
            self.state = dict["state"] as! String
        }
        if dict.keys.contains("localId") {
            self.localId = dict["localId"] as! Int64
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class ListMergeRequestCommentsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliyunPk") {
                    self.aliyunPk = dict["aliyunPk"] as! String
                }
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public class ChildComments : Tea.TeaModel {
            public class Author : Tea.TeaModel {
                public var aliyunPk: String?

                public var avatarUrl: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var state: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aliyunPk != nil {
                        map["aliyunPk"] = self.aliyunPk!
                    }
                    if self.avatarUrl != nil {
                        map["avatarUrl"] = self.avatarUrl!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("aliyunPk") {
                        self.aliyunPk = dict["aliyunPk"] as! String
                    }
                    if dict.keys.contains("avatarUrl") {
                        self.avatarUrl = dict["avatarUrl"] as! String
                    }
                    if dict.keys.contains("email") {
                        self.email = dict["email"] as! String
                    }
                    if dict.keys.contains("id") {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("state") {
                        self.state = dict["state"] as! String
                    }
                    if dict.keys.contains("username") {
                        self.username = dict["username"] as! String
                    }
                }
            }
            public class FinalChildComments : Tea.TeaModel {
                public class Author : Tea.TeaModel {
                    public var aliyunPk: String?

                    public var avatarUrl: String?

                    public var email: String?

                    public var id: Int64?

                    public var name: String?

                    public var state: String?

                    public var username: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.aliyunPk != nil {
                            map["aliyunPk"] = self.aliyunPk!
                        }
                        if self.avatarUrl != nil {
                            map["avatarUrl"] = self.avatarUrl!
                        }
                        if self.email != nil {
                            map["email"] = self.email!
                        }
                        if self.id != nil {
                            map["id"] = self.id!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.state != nil {
                            map["state"] = self.state!
                        }
                        if self.username != nil {
                            map["username"] = self.username!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("aliyunPk") {
                            self.aliyunPk = dict["aliyunPk"] as! String
                        }
                        if dict.keys.contains("avatarUrl") {
                            self.avatarUrl = dict["avatarUrl"] as! String
                        }
                        if dict.keys.contains("email") {
                            self.email = dict["email"] as! String
                        }
                        if dict.keys.contains("id") {
                            self.id = dict["id"] as! Int64
                        }
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("state") {
                            self.state = dict["state"] as! String
                        }
                        if dict.keys.contains("username") {
                            self.username = dict["username"] as! String
                        }
                    }
                }
                public class RelatedPatchSet : Tea.TeaModel {
                    public var commitId: String?

                    public var createdAt: String?

                    public var patchSetBizId: String?

                    public var patchSetName: String?

                    public var patchSetNo: String?

                    public var relatedMergeItemType: String?

                    public var shortId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.commitId != nil {
                            map["commitId"] = self.commitId!
                        }
                        if self.createdAt != nil {
                            map["createdAt"] = self.createdAt!
                        }
                        if self.patchSetBizId != nil {
                            map["patchSetBizId"] = self.patchSetBizId!
                        }
                        if self.patchSetName != nil {
                            map["patchSetName"] = self.patchSetName!
                        }
                        if self.patchSetNo != nil {
                            map["patchSetNo"] = self.patchSetNo!
                        }
                        if self.relatedMergeItemType != nil {
                            map["relatedMergeItemType"] = self.relatedMergeItemType!
                        }
                        if self.shortId != nil {
                            map["shortId"] = self.shortId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("commitId") {
                            self.commitId = dict["commitId"] as! String
                        }
                        if dict.keys.contains("createdAt") {
                            self.createdAt = dict["createdAt"] as! String
                        }
                        if dict.keys.contains("patchSetBizId") {
                            self.patchSetBizId = dict["patchSetBizId"] as! String
                        }
                        if dict.keys.contains("patchSetName") {
                            self.patchSetName = dict["patchSetName"] as! String
                        }
                        if dict.keys.contains("patchSetNo") {
                            self.patchSetNo = dict["patchSetNo"] as! String
                        }
                        if dict.keys.contains("relatedMergeItemType") {
                            self.relatedMergeItemType = dict["relatedMergeItemType"] as! String
                        }
                        if dict.keys.contains("shortId") {
                            self.shortId = dict["shortId"] as! String
                        }
                    }
                }
                public var author: ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments.Author?

                public var commentBizId: String?

                public var commentTime: String?

                public var commentType: String?

                public var content: String?

                public var deleted: Bool?

                public var filePath: String?

                public var lastEditTime: String?

                public var lineNumber: String?

                public var parentCommentBizId: String?

                public var relatedPatchSet: ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments.RelatedPatchSet?

                public var resolved: Bool?

                public var rootCommentBizId: String?

                public var state: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.author?.validate()
                    try self.relatedPatchSet?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.author != nil {
                        map["author"] = self.author?.toMap()
                    }
                    if self.commentBizId != nil {
                        map["commentBizId"] = self.commentBizId!
                    }
                    if self.commentTime != nil {
                        map["commentTime"] = self.commentTime!
                    }
                    if self.commentType != nil {
                        map["commentType"] = self.commentType!
                    }
                    if self.content != nil {
                        map["content"] = self.content!
                    }
                    if self.deleted != nil {
                        map["deleted"] = self.deleted!
                    }
                    if self.filePath != nil {
                        map["filePath"] = self.filePath!
                    }
                    if self.lastEditTime != nil {
                        map["lastEditTime"] = self.lastEditTime!
                    }
                    if self.lineNumber != nil {
                        map["lineNumber"] = self.lineNumber!
                    }
                    if self.parentCommentBizId != nil {
                        map["parentCommentBizId"] = self.parentCommentBizId!
                    }
                    if self.relatedPatchSet != nil {
                        map["relatedPatchSet"] = self.relatedPatchSet?.toMap()
                    }
                    if self.resolved != nil {
                        map["resolved"] = self.resolved!
                    }
                    if self.rootCommentBizId != nil {
                        map["rootCommentBizId"] = self.rootCommentBizId!
                    }
                    if self.state != nil {
                        map["state"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("author") {
                        var model = ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments.Author()
                        model.fromMap(dict["author"] as! [String: Any])
                        self.author = model
                    }
                    if dict.keys.contains("commentBizId") {
                        self.commentBizId = dict["commentBizId"] as! String
                    }
                    if dict.keys.contains("commentTime") {
                        self.commentTime = dict["commentTime"] as! String
                    }
                    if dict.keys.contains("commentType") {
                        self.commentType = dict["commentType"] as! String
                    }
                    if dict.keys.contains("content") {
                        self.content = dict["content"] as! String
                    }
                    if dict.keys.contains("deleted") {
                        self.deleted = dict["deleted"] as! Bool
                    }
                    if dict.keys.contains("filePath") {
                        self.filePath = dict["filePath"] as! String
                    }
                    if dict.keys.contains("lastEditTime") {
                        self.lastEditTime = dict["lastEditTime"] as! String
                    }
                    if dict.keys.contains("lineNumber") {
                        self.lineNumber = dict["lineNumber"] as! String
                    }
                    if dict.keys.contains("parentCommentBizId") {
                        self.parentCommentBizId = dict["parentCommentBizId"] as! String
                    }
                    if dict.keys.contains("relatedPatchSet") {
                        var model = ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments.RelatedPatchSet()
                        model.fromMap(dict["relatedPatchSet"] as! [String: Any])
                        self.relatedPatchSet = model
                    }
                    if dict.keys.contains("resolved") {
                        self.resolved = dict["resolved"] as! Bool
                    }
                    if dict.keys.contains("rootCommentBizId") {
                        self.rootCommentBizId = dict["rootCommentBizId"] as! String
                    }
                    if dict.keys.contains("state") {
                        self.state = dict["state"] as! String
                    }
                }
            }
            public class RelatedPatchSet : Tea.TeaModel {
                public var commitId: String?

                public var createdAt: String?

                public var patchSetBizId: String?

                public var patchSetName: String?

                public var patchSetNo: String?

                public var relatedMergeItemType: String?

                public var shortId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commitId != nil {
                        map["commitId"] = self.commitId!
                    }
                    if self.createdAt != nil {
                        map["createdAt"] = self.createdAt!
                    }
                    if self.patchSetBizId != nil {
                        map["patchSetBizId"] = self.patchSetBizId!
                    }
                    if self.patchSetName != nil {
                        map["patchSetName"] = self.patchSetName!
                    }
                    if self.patchSetNo != nil {
                        map["patchSetNo"] = self.patchSetNo!
                    }
                    if self.relatedMergeItemType != nil {
                        map["relatedMergeItemType"] = self.relatedMergeItemType!
                    }
                    if self.shortId != nil {
                        map["shortId"] = self.shortId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("commitId") {
                        self.commitId = dict["commitId"] as! String
                    }
                    if dict.keys.contains("createdAt") {
                        self.createdAt = dict["createdAt"] as! String
                    }
                    if dict.keys.contains("patchSetBizId") {
                        self.patchSetBizId = dict["patchSetBizId"] as! String
                    }
                    if dict.keys.contains("patchSetName") {
                        self.patchSetName = dict["patchSetName"] as! String
                    }
                    if dict.keys.contains("patchSetNo") {
                        self.patchSetNo = dict["patchSetNo"] as! String
                    }
                    if dict.keys.contains("relatedMergeItemType") {
                        self.relatedMergeItemType = dict["relatedMergeItemType"] as! String
                    }
                    if dict.keys.contains("shortId") {
                        self.shortId = dict["shortId"] as! String
                    }
                }
            }
            public var author: ListMergeRequestCommentsResponseBody.Result.ChildComments.Author?

            public var commentBizId: String?

            public var commentTime: String?

            public var commentType: String?

            public var content: String?

            public var deleted: Bool?

            public var filePath: String?

            public var finalChildComments: [ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments]?

            public var lastEditTime: String?

            public var lineNumber: String?

            public var parentCommentBizId: String?

            public var relatedPatchSet: ListMergeRequestCommentsResponseBody.Result.ChildComments.RelatedPatchSet?

            public var resolved: Bool?

            public var rootCommentBizId: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.author?.validate()
                try self.relatedPatchSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.author != nil {
                    map["author"] = self.author?.toMap()
                }
                if self.commentBizId != nil {
                    map["commentBizId"] = self.commentBizId!
                }
                if self.commentTime != nil {
                    map["commentTime"] = self.commentTime!
                }
                if self.commentType != nil {
                    map["commentType"] = self.commentType!
                }
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.deleted != nil {
                    map["deleted"] = self.deleted!
                }
                if self.filePath != nil {
                    map["filePath"] = self.filePath!
                }
                if self.finalChildComments != nil {
                    var tmp : [Any] = []
                    for k in self.finalChildComments! {
                        tmp.append(k.toMap())
                    }
                    map["finalChildComments"] = tmp
                }
                if self.lastEditTime != nil {
                    map["lastEditTime"] = self.lastEditTime!
                }
                if self.lineNumber != nil {
                    map["lineNumber"] = self.lineNumber!
                }
                if self.parentCommentBizId != nil {
                    map["parentCommentBizId"] = self.parentCommentBizId!
                }
                if self.relatedPatchSet != nil {
                    map["relatedPatchSet"] = self.relatedPatchSet?.toMap()
                }
                if self.resolved != nil {
                    map["resolved"] = self.resolved!
                }
                if self.rootCommentBizId != nil {
                    map["rootCommentBizId"] = self.rootCommentBizId!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("author") {
                    var model = ListMergeRequestCommentsResponseBody.Result.ChildComments.Author()
                    model.fromMap(dict["author"] as! [String: Any])
                    self.author = model
                }
                if dict.keys.contains("commentBizId") {
                    self.commentBizId = dict["commentBizId"] as! String
                }
                if dict.keys.contains("commentTime") {
                    self.commentTime = dict["commentTime"] as! String
                }
                if dict.keys.contains("commentType") {
                    self.commentType = dict["commentType"] as! String
                }
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("deleted") {
                    self.deleted = dict["deleted"] as! Bool
                }
                if dict.keys.contains("filePath") {
                    self.filePath = dict["filePath"] as! String
                }
                if dict.keys.contains("finalChildComments") {
                    var tmp : [ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments] = []
                    for v in dict["finalChildComments"] as! [Any] {
                        var model = ListMergeRequestCommentsResponseBody.Result.ChildComments.FinalChildComments()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.finalChildComments = tmp
                }
                if dict.keys.contains("lastEditTime") {
                    self.lastEditTime = dict["lastEditTime"] as! String
                }
                if dict.keys.contains("lineNumber") {
                    self.lineNumber = dict["lineNumber"] as! String
                }
                if dict.keys.contains("parentCommentBizId") {
                    self.parentCommentBizId = dict["parentCommentBizId"] as! String
                }
                if dict.keys.contains("relatedPatchSet") {
                    var model = ListMergeRequestCommentsResponseBody.Result.ChildComments.RelatedPatchSet()
                    model.fromMap(dict["relatedPatchSet"] as! [String: Any])
                    self.relatedPatchSet = model
                }
                if dict.keys.contains("resolved") {
                    self.resolved = dict["resolved"] as! Bool
                }
                if dict.keys.contains("rootCommentBizId") {
                    self.rootCommentBizId = dict["rootCommentBizId"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
            }
        }
        public class RelatedPatchSet : Tea.TeaModel {
            public var commitId: String?

            public var createdAt: String?

            public var patchSetBizId: String?

            public var patchSetName: String?

            public var patchSetNo: String?

            public var relatedMergeItemType: String?

            public var shortId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commitId != nil {
                    map["commitId"] = self.commitId!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.patchSetBizId != nil {
                    map["patchSetBizId"] = self.patchSetBizId!
                }
                if self.patchSetName != nil {
                    map["patchSetName"] = self.patchSetName!
                }
                if self.patchSetNo != nil {
                    map["patchSetNo"] = self.patchSetNo!
                }
                if self.relatedMergeItemType != nil {
                    map["relatedMergeItemType"] = self.relatedMergeItemType!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("commitId") {
                    self.commitId = dict["commitId"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("patchSetBizId") {
                    self.patchSetBizId = dict["patchSetBizId"] as! String
                }
                if dict.keys.contains("patchSetName") {
                    self.patchSetName = dict["patchSetName"] as! String
                }
                if dict.keys.contains("patchSetNo") {
                    self.patchSetNo = dict["patchSetNo"] as! String
                }
                if dict.keys.contains("relatedMergeItemType") {
                    self.relatedMergeItemType = dict["relatedMergeItemType"] as! String
                }
                if dict.keys.contains("shortId") {
                    self.shortId = dict["shortId"] as! String
                }
            }
        }
        public var author: ListMergeRequestCommentsResponseBody.Result.Author?

        public var childComments: [ListMergeRequestCommentsResponseBody.Result.ChildComments]?

        public var commentBizId: String?

        public var commentTime: String?

        public var commentType: String?

        public var content: String?

        public var deleted: Bool?

        public var filePath: String?

        public var lastEditTime: String?

        public var lineNumber: String?

        public var parentCommentBizId: String?

        public var relatedPatchSet: ListMergeRequestCommentsResponseBody.Result.RelatedPatchSet?

        public var resolved: Bool?

        public var rootCommentBizId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.relatedPatchSet?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.childComments != nil {
                var tmp : [Any] = []
                for k in self.childComments! {
                    tmp.append(k.toMap())
                }
                map["childComments"] = tmp
            }
            if self.commentBizId != nil {
                map["commentBizId"] = self.commentBizId!
            }
            if self.commentTime != nil {
                map["commentTime"] = self.commentTime!
            }
            if self.commentType != nil {
                map["commentType"] = self.commentType!
            }
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.deleted != nil {
                map["deleted"] = self.deleted!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            if self.lastEditTime != nil {
                map["lastEditTime"] = self.lastEditTime!
            }
            if self.lineNumber != nil {
                map["lineNumber"] = self.lineNumber!
            }
            if self.parentCommentBizId != nil {
                map["parentCommentBizId"] = self.parentCommentBizId!
            }
            if self.relatedPatchSet != nil {
                map["relatedPatchSet"] = self.relatedPatchSet?.toMap()
            }
            if self.resolved != nil {
                map["resolved"] = self.resolved!
            }
            if self.rootCommentBizId != nil {
                map["rootCommentBizId"] = self.rootCommentBizId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("author") {
                var model = ListMergeRequestCommentsResponseBody.Result.Author()
                model.fromMap(dict["author"] as! [String: Any])
                self.author = model
            }
            if dict.keys.contains("childComments") {
                var tmp : [ListMergeRequestCommentsResponseBody.Result.ChildComments] = []
                for v in dict["childComments"] as! [Any] {
                    var model = ListMergeRequestCommentsResponseBody.Result.ChildComments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.childComments = tmp
            }
            if dict.keys.contains("commentBizId") {
                self.commentBizId = dict["commentBizId"] as! String
            }
            if dict.keys.contains("commentTime") {
                self.commentTime = dict["commentTime"] as! String
            }
            if dict.keys.contains("commentType") {
                self.commentType = dict["commentType"] as! String
            }
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("deleted") {
                self.deleted = dict["deleted"] as! Bool
            }
            if dict.keys.contains("filePath") {
                self.filePath = dict["filePath"] as! String
            }
            if dict.keys.contains("lastEditTime") {
                self.lastEditTime = dict["lastEditTime"] as! String
            }
            if dict.keys.contains("lineNumber") {
                self.lineNumber = dict["lineNumber"] as! String
            }
            if dict.keys.contains("parentCommentBizId") {
                self.parentCommentBizId = dict["parentCommentBizId"] as! String
            }
            if dict.keys.contains("relatedPatchSet") {
                var model = ListMergeRequestCommentsResponseBody.Result.RelatedPatchSet()
                model.fromMap(dict["relatedPatchSet"] as! [String: Any])
                self.relatedPatchSet = model
            }
            if dict.keys.contains("resolved") {
                self.resolved = dict["resolved"] as! Bool
            }
            if dict.keys.contains("rootCommentBizId") {
                self.rootCommentBizId = dict["rootCommentBizId"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListMergeRequestCommentsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListMergeRequestCommentsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListMergeRequestCommentsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListMergeRequestCommentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMergeRequestCommentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMergeRequestCommentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMergeRequestFilesReadsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var fromPatchSetBizId: String?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public var toPatchSetBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.fromPatchSetBizId != nil {
            map["fromPatchSetBizId"] = self.fromPatchSetBizId!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        if self.toPatchSetBizId != nil {
            map["toPatchSetBizId"] = self.toPatchSetBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("fromPatchSetBizId") {
            self.fromPatchSetBizId = dict["fromPatchSetBizId"] as! String
        }
        if dict.keys.contains("localId") {
            self.localId = dict["localId"] as! Int64
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
        if dict.keys.contains("toPatchSetBizId") {
            self.toPatchSetBizId = dict["toPatchSetBizId"] as! String
        }
    }
}

public class ListMergeRequestFilesReadsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ReadUsers : Tea.TeaModel {
            public var aliyunPk: String?

            public var avatarUrl: String?

            public var email: String?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunPk != nil {
                    map["aliyunPk"] = self.aliyunPk!
                }
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliyunPk") {
                    self.aliyunPk = dict["aliyunPk"] as! String
                }
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public var deletedFile: String?

        public var newFile: Bool?

        public var newFilePath: String?

        public var oldFilePath: String?

        public var readUsers: [ListMergeRequestFilesReadsResponseBody.Result.ReadUsers]?

        public var renamedFile: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deletedFile != nil {
                map["deletedFile"] = self.deletedFile!
            }
            if self.newFile != nil {
                map["newFile"] = self.newFile!
            }
            if self.newFilePath != nil {
                map["newFilePath"] = self.newFilePath!
            }
            if self.oldFilePath != nil {
                map["oldFilePath"] = self.oldFilePath!
            }
            if self.readUsers != nil {
                var tmp : [Any] = []
                for k in self.readUsers! {
                    tmp.append(k.toMap())
                }
                map["readUsers"] = tmp
            }
            if self.renamedFile != nil {
                map["renamedFile"] = self.renamedFile!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("deletedFile") {
                self.deletedFile = dict["deletedFile"] as! String
            }
            if dict.keys.contains("newFile") {
                self.newFile = dict["newFile"] as! Bool
            }
            if dict.keys.contains("newFilePath") {
                self.newFilePath = dict["newFilePath"] as! String
            }
            if dict.keys.contains("oldFilePath") {
                self.oldFilePath = dict["oldFilePath"] as! String
            }
            if dict.keys.contains("readUsers") {
                var tmp : [ListMergeRequestFilesReadsResponseBody.Result.ReadUsers] = []
                for v in dict["readUsers"] as! [Any] {
                    var model = ListMergeRequestFilesReadsResponseBody.Result.ReadUsers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.readUsers = tmp
            }
            if dict.keys.contains("renamedFile") {
                self.renamedFile = dict["renamedFile"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListMergeRequestFilesReadsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListMergeRequestFilesReadsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListMergeRequestFilesReadsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListMergeRequestFilesReadsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMergeRequestFilesReadsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMergeRequestFilesReadsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMergeRequestLabelsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("localId") {
            self.localId = dict["localId"] as! Int64
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class ListMergeRequestLabelsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var color: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.color != nil {
                map["color"] = self.color!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("color") {
                self.color = dict["color"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListMergeRequestLabelsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListMergeRequestLabelsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListMergeRequestLabelsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListMergeRequestLabelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMergeRequestLabelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMergeRequestLabelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMergeRequestPatchSetsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var localId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.localId != nil {
            map["localId"] = self.localId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("localId") {
            self.localId = dict["localId"] as! Int64
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class ListMergeRequestPatchSetsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var commitId: String?

        public var createdAt: String?

        public var patchSetBizId: String?

        public var patchSetName: String?

        public var patchSetNo: Int64?

        public var relatedMergeItemType: String?

        public var shortCommitId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commitId != nil {
                map["commitId"] = self.commitId!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.patchSetBizId != nil {
                map["patchSetBizId"] = self.patchSetBizId!
            }
            if self.patchSetName != nil {
                map["patchSetName"] = self.patchSetName!
            }
            if self.patchSetNo != nil {
                map["patchSetNo"] = self.patchSetNo!
            }
            if self.relatedMergeItemType != nil {
                map["relatedMergeItemType"] = self.relatedMergeItemType!
            }
            if self.shortCommitId != nil {
                map["shortCommitId"] = self.shortCommitId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("commitId") {
                self.commitId = dict["commitId"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("patchSetBizId") {
                self.patchSetBizId = dict["patchSetBizId"] as! String
            }
            if dict.keys.contains("patchSetName") {
                self.patchSetName = dict["patchSetName"] as! String
            }
            if dict.keys.contains("patchSetNo") {
                self.patchSetNo = dict["patchSetNo"] as! Int64
            }
            if dict.keys.contains("relatedMergeItemType") {
                self.relatedMergeItemType = dict["relatedMergeItemType"] as! String
            }
            if dict.keys.contains("shortCommitId") {
                self.shortCommitId = dict["shortCommitId"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListMergeRequestPatchSetsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListMergeRequestPatchSetsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListMergeRequestPatchSetsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListMergeRequestPatchSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMergeRequestPatchSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMergeRequestPatchSetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMergeRequestsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var authorIds: String?

    public var createdAfter: String?

    public var createdBefore: String?

    public var filter: String?

    public var groupIds: String?

    public var labelIds: String?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var projectIds: String?

    public var reviewerIds: String?

    public var search: String?

    public var sort: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.authorIds != nil {
            map["authorIds"] = self.authorIds!
        }
        if self.createdAfter != nil {
            map["createdAfter"] = self.createdAfter!
        }
        if self.createdBefore != nil {
            map["createdBefore"] = self.createdBefore!
        }
        if self.filter != nil {
            map["filter"] = self.filter!
        }
        if self.groupIds != nil {
            map["groupIds"] = self.groupIds!
        }
        if self.labelIds != nil {
            map["labelIds"] = self.labelIds!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.projectIds != nil {
            map["projectIds"] = self.projectIds!
        }
        if self.reviewerIds != nil {
            map["reviewerIds"] = self.reviewerIds!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.state != nil {
            map["state"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("authorIds") {
            self.authorIds = dict["authorIds"] as! String
        }
        if dict.keys.contains("createdAfter") {
            self.createdAfter = dict["createdAfter"] as! String
        }
        if dict.keys.contains("createdBefore") {
            self.createdBefore = dict["createdBefore"] as! String
        }
        if dict.keys.contains("filter") {
            self.filter = dict["filter"] as! String
        }
        if dict.keys.contains("groupIds") {
            self.groupIds = dict["groupIds"] as! String
        }
        if dict.keys.contains("labelIds") {
            self.labelIds = dict["labelIds"] as! String
        }
        if dict.keys.contains("orderBy") {
            self.orderBy = dict["orderBy"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("projectIds") {
            self.projectIds = dict["projectIds"] as! String
        }
        if dict.keys.contains("reviewerIds") {
            self.reviewerIds = dict["reviewerIds"] as! String
        }
        if dict.keys.contains("search") {
            self.search = dict["search"] as! String
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
        if dict.keys.contains("state") {
            self.state = dict["state"] as! String
        }
    }
}

public class ListMergeRequestsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public class Labels : Tea.TeaModel {
            public var color: String?

            public var description_: String?

            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.color != nil {
                    map["color"] = self.color!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("color") {
                    self.color = dict["color"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class Reviewers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var hasCommented: Bool?

            public var hasReviewed: Bool?

            public var id: Int64?

            public var name: String?

            public var reviewOpinionStatus: String?

            public var reviewTime: String?

            public var state: String?

            public var status: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.hasCommented != nil {
                    map["hasCommented"] = self.hasCommented!
                }
                if self.hasReviewed != nil {
                    map["hasReviewed"] = self.hasReviewed!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.reviewOpinionStatus != nil {
                    map["reviewOpinionStatus"] = self.reviewOpinionStatus!
                }
                if self.reviewTime != nil {
                    map["reviewTime"] = self.reviewTime!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.status != nil {
                    map["status"] = self.status!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("hasCommented") {
                    self.hasCommented = dict["hasCommented"] as! Bool
                }
                if dict.keys.contains("hasReviewed") {
                    self.hasReviewed = dict["hasReviewed"] as! Bool
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("reviewOpinionStatus") {
                    self.reviewOpinionStatus = dict["reviewOpinionStatus"] as! String
                }
                if dict.keys.contains("reviewTime") {
                    self.reviewTime = dict["reviewTime"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("status") {
                    self.status = dict["status"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public class Subscribers : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public var author: ListMergeRequestsResponseBody.Result.Author?

        public var createdAt: String?

        public var creationMethod: String?

        public var description_: String?

        public var detailUrl: String?

        public var id: Int64?

        public var iid: Int64?

        public var labels: [ListMergeRequestsResponseBody.Result.Labels]?

        public var localId: Int64?

        public var mergedRevision: String?

        public var mrBizId: String?

        public var nameWithNamespace: String?

        public var newMergeRequestIdentifier: Bool?

        public var newVersionState: String?

        public var projectId: Int64?

        public var reviewers: [ListMergeRequestsResponseBody.Result.Reviewers]?

        public var sourceBranch: String?

        public var sourceProjectId: Int64?

        public var sourceType: String?

        public var sshUrl: String?

        public var state: String?

        public var subscribers: [ListMergeRequestsResponseBody.Result.Subscribers]?

        public var supportMergeFFOnly: Bool?

        public var targetBranch: String?

        public var targetProjectId: Int64?

        public var targetType: String?

        public var title: String?

        public var updatedAt: String?

        public var webUrl: String?

        public var workInProgress: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creationMethod != nil {
                map["creationMethod"] = self.creationMethod!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.detailUrl != nil {
                map["detailUrl"] = self.detailUrl!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.iid != nil {
                map["iid"] = self.iid!
            }
            if self.labels != nil {
                var tmp : [Any] = []
                for k in self.labels! {
                    tmp.append(k.toMap())
                }
                map["labels"] = tmp
            }
            if self.localId != nil {
                map["localId"] = self.localId!
            }
            if self.mergedRevision != nil {
                map["mergedRevision"] = self.mergedRevision!
            }
            if self.mrBizId != nil {
                map["mrBizId"] = self.mrBizId!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.newMergeRequestIdentifier != nil {
                map["newMergeRequestIdentifier"] = self.newMergeRequestIdentifier!
            }
            if self.newVersionState != nil {
                map["newVersionState"] = self.newVersionState!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.reviewers != nil {
                var tmp : [Any] = []
                for k in self.reviewers! {
                    tmp.append(k.toMap())
                }
                map["reviewers"] = tmp
            }
            if self.sourceBranch != nil {
                map["sourceBranch"] = self.sourceBranch!
            }
            if self.sourceProjectId != nil {
                map["sourceProjectId"] = self.sourceProjectId!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.sshUrl != nil {
                map["sshUrl"] = self.sshUrl!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.subscribers != nil {
                var tmp : [Any] = []
                for k in self.subscribers! {
                    tmp.append(k.toMap())
                }
                map["subscribers"] = tmp
            }
            if self.supportMergeFFOnly != nil {
                map["supportMergeFFOnly"] = self.supportMergeFFOnly!
            }
            if self.targetBranch != nil {
                map["targetBranch"] = self.targetBranch!
            }
            if self.targetProjectId != nil {
                map["targetProjectId"] = self.targetProjectId!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            if self.workInProgress != nil {
                map["workInProgress"] = self.workInProgress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("author") {
                var model = ListMergeRequestsResponseBody.Result.Author()
                model.fromMap(dict["author"] as! [String: Any])
                self.author = model
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("creationMethod") {
                self.creationMethod = dict["creationMethod"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("detailUrl") {
                self.detailUrl = dict["detailUrl"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("iid") {
                self.iid = dict["iid"] as! Int64
            }
            if dict.keys.contains("labels") {
                var tmp : [ListMergeRequestsResponseBody.Result.Labels] = []
                for v in dict["labels"] as! [Any] {
                    var model = ListMergeRequestsResponseBody.Result.Labels()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.labels = tmp
            }
            if dict.keys.contains("localId") {
                self.localId = dict["localId"] as! Int64
            }
            if dict.keys.contains("mergedRevision") {
                self.mergedRevision = dict["mergedRevision"] as! String
            }
            if dict.keys.contains("mrBizId") {
                self.mrBizId = dict["mrBizId"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("newMergeRequestIdentifier") {
                self.newMergeRequestIdentifier = dict["newMergeRequestIdentifier"] as! Bool
            }
            if dict.keys.contains("newVersionState") {
                self.newVersionState = dict["newVersionState"] as! String
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! Int64
            }
            if dict.keys.contains("reviewers") {
                var tmp : [ListMergeRequestsResponseBody.Result.Reviewers] = []
                for v in dict["reviewers"] as! [Any] {
                    var model = ListMergeRequestsResponseBody.Result.Reviewers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reviewers = tmp
            }
            if dict.keys.contains("sourceBranch") {
                self.sourceBranch = dict["sourceBranch"] as! String
            }
            if dict.keys.contains("sourceProjectId") {
                self.sourceProjectId = dict["sourceProjectId"] as! Int64
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("sshUrl") {
                self.sshUrl = dict["sshUrl"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("subscribers") {
                var tmp : [ListMergeRequestsResponseBody.Result.Subscribers] = []
                for v in dict["subscribers"] as! [Any] {
                    var model = ListMergeRequestsResponseBody.Result.Subscribers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.subscribers = tmp
            }
            if dict.keys.contains("supportMergeFFOnly") {
                self.supportMergeFFOnly = dict["supportMergeFFOnly"] as! Bool
            }
            if dict.keys.contains("targetBranch") {
                self.targetBranch = dict["targetBranch"] as! String
            }
            if dict.keys.contains("targetProjectId") {
                self.targetProjectId = dict["targetProjectId"] as! Int64
            }
            if dict.keys.contains("targetType") {
                self.targetType = dict["targetType"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
            if dict.keys.contains("workInProgress") {
                self.workInProgress = dict["workInProgress"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListMergeRequestsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListMergeRequestsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListMergeRequestsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListMergeRequestsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMergeRequestsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMergeRequestsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListOrganizationMembersRequest : Tea.TeaModel {
    public var containsExternInfo: Bool?

    public var externUid: String?

    public var joinTimeFrom: Int64?

    public var joinTimeTo: Int64?

    public var maxResults: Int64?

    public var nextToken: String?

    public var organizationMemberName: String?

    public var provider: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containsExternInfo != nil {
            map["containsExternInfo"] = self.containsExternInfo!
        }
        if self.externUid != nil {
            map["externUid"] = self.externUid!
        }
        if self.joinTimeFrom != nil {
            map["joinTimeFrom"] = self.joinTimeFrom!
        }
        if self.joinTimeTo != nil {
            map["joinTimeTo"] = self.joinTimeTo!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.organizationMemberName != nil {
            map["organizationMemberName"] = self.organizationMemberName!
        }
        if self.provider != nil {
            map["provider"] = self.provider!
        }
        if self.state != nil {
            map["state"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("containsExternInfo") {
            self.containsExternInfo = dict["containsExternInfo"] as! Bool
        }
        if dict.keys.contains("externUid") {
            self.externUid = dict["externUid"] as! String
        }
        if dict.keys.contains("joinTimeFrom") {
            self.joinTimeFrom = dict["joinTimeFrom"] as! Int64
        }
        if dict.keys.contains("joinTimeTo") {
            self.joinTimeTo = dict["joinTimeTo"] as! Int64
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("organizationMemberName") {
            self.organizationMemberName = dict["organizationMemberName"] as! String
        }
        if dict.keys.contains("provider") {
            self.provider = dict["provider"] as! String
        }
        if dict.keys.contains("state") {
            self.state = dict["state"] as! String
        }
    }
}

public class ListOrganizationMembersResponseBody : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public class Identities : Tea.TeaModel {
            public var externUid: String?

            public var provider: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.externUid != nil {
                    map["externUid"] = self.externUid!
                }
                if self.provider != nil {
                    map["provider"] = self.provider!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("externUid") {
                    self.externUid = dict["externUid"] as! String
                }
                if dict.keys.contains("provider") {
                    self.provider = dict["provider"] as! String
                }
            }
        }
        public var accountId: String?

        public var birthday: Int64?

        public var deptLists: [String]?

        public var email: String?

        public var hiredDate: Int64?

        public var identities: ListOrganizationMembersResponseBody.Members.Identities?

        public var jobNumber: String?

        public var joinTime: Int64?

        public var lastVisitTime: Int64?

        public var mobile: String?

        public var organizationMemberName: String?

        public var organizationRoleId: String?

        public var organizationRoleName: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.identities?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            if self.birthday != nil {
                map["birthday"] = self.birthday!
            }
            if self.deptLists != nil {
                map["deptLists"] = self.deptLists!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.hiredDate != nil {
                map["hiredDate"] = self.hiredDate!
            }
            if self.identities != nil {
                map["identities"] = self.identities?.toMap()
            }
            if self.jobNumber != nil {
                map["jobNumber"] = self.jobNumber!
            }
            if self.joinTime != nil {
                map["joinTime"] = self.joinTime!
            }
            if self.lastVisitTime != nil {
                map["lastVisitTime"] = self.lastVisitTime!
            }
            if self.mobile != nil {
                map["mobile"] = self.mobile!
            }
            if self.organizationMemberName != nil {
                map["organizationMemberName"] = self.organizationMemberName!
            }
            if self.organizationRoleId != nil {
                map["organizationRoleId"] = self.organizationRoleId!
            }
            if self.organizationRoleName != nil {
                map["organizationRoleName"] = self.organizationRoleName!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
            if dict.keys.contains("birthday") {
                self.birthday = dict["birthday"] as! Int64
            }
            if dict.keys.contains("deptLists") {
                self.deptLists = dict["deptLists"] as! [String]
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("hiredDate") {
                self.hiredDate = dict["hiredDate"] as! Int64
            }
            if dict.keys.contains("identities") {
                var model = ListOrganizationMembersResponseBody.Members.Identities()
                model.fromMap(dict["identities"] as! [String: Any])
                self.identities = model
            }
            if dict.keys.contains("jobNumber") {
                self.jobNumber = dict["jobNumber"] as! String
            }
            if dict.keys.contains("joinTime") {
                self.joinTime = dict["joinTime"] as! Int64
            }
            if dict.keys.contains("lastVisitTime") {
                self.lastVisitTime = dict["lastVisitTime"] as! Int64
            }
            if dict.keys.contains("mobile") {
                self.mobile = dict["mobile"] as! String
            }
            if dict.keys.contains("organizationMemberName") {
                self.organizationMemberName = dict["organizationMemberName"] as! String
            }
            if dict.keys.contains("organizationRoleId") {
                self.organizationRoleId = dict["organizationRoleId"] as! String
            }
            if dict.keys.contains("organizationRoleName") {
                self.organizationRoleName = dict["organizationRoleName"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var members: [ListOrganizationMembersResponseBody.Members]?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["members"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("members") {
            var tmp : [ListOrganizationMembersResponseBody.Members] = []
            for v in dict["members"] as! [Any] {
                var model = ListOrganizationMembersResponseBody.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListOrganizationMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOrganizationMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListOrganizationMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListOrganizationsRequest : Tea.TeaModel {
    public var accessLevel: Int32?

    public var accessToken: String?

    public var minAccessLevel: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessLevel != nil {
            map["accessLevel"] = self.accessLevel!
        }
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.minAccessLevel != nil {
            map["minAccessLevel"] = self.minAccessLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessLevel") {
            self.accessLevel = dict["accessLevel"] as! Int32
        }
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("minAccessLevel") {
            self.minAccessLevel = dict["minAccessLevel"] as! Int32
        }
    }
}

public class ListOrganizationsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var id: Int64?

        public var namespaceId: String?

        public var organizationAlias: String?

        public var organizationId: String?

        public var organizationName: String?

        public var organizationRole: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.namespaceId != nil {
                map["namespaceId"] = self.namespaceId!
            }
            if self.organizationAlias != nil {
                map["organizationAlias"] = self.organizationAlias!
            }
            if self.organizationId != nil {
                map["organizationId"] = self.organizationId!
            }
            if self.organizationName != nil {
                map["organizationName"] = self.organizationName!
            }
            if self.organizationRole != nil {
                map["organizationRole"] = self.organizationRole!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("namespaceId") {
                self.namespaceId = dict["namespaceId"] as! String
            }
            if dict.keys.contains("organizationAlias") {
                self.organizationAlias = dict["organizationAlias"] as! String
            }
            if dict.keys.contains("organizationId") {
                self.organizationId = dict["organizationId"] as! String
            }
            if dict.keys.contains("organizationName") {
                self.organizationName = dict["organizationName"] as! String
            }
            if dict.keys.contains("organizationRole") {
                self.organizationRole = dict["organizationRole"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListOrganizationsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListOrganizationsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListOrganizationsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListOrganizationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOrganizationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListOrganizationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelineGroupPipelinesRequest : Tea.TeaModel {
    public var createEndTime: Int64?

    public var createStartTime: Int64?

    public var executeEndTime: Int64?

    public var executeStartTime: Int64?

    public var maxResults: Int64?

    public var nextToken: String?

    public var pipelineName: String?

    public var resultStatusList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createEndTime != nil {
            map["createEndTime"] = self.createEndTime!
        }
        if self.createStartTime != nil {
            map["createStartTime"] = self.createStartTime!
        }
        if self.executeEndTime != nil {
            map["executeEndTime"] = self.executeEndTime!
        }
        if self.executeStartTime != nil {
            map["executeStartTime"] = self.executeStartTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelineName != nil {
            map["pipelineName"] = self.pipelineName!
        }
        if self.resultStatusList != nil {
            map["resultStatusList"] = self.resultStatusList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("createEndTime") {
            self.createEndTime = dict["createEndTime"] as! Int64
        }
        if dict.keys.contains("createStartTime") {
            self.createStartTime = dict["createStartTime"] as! Int64
        }
        if dict.keys.contains("executeEndTime") {
            self.executeEndTime = dict["executeEndTime"] as! Int64
        }
        if dict.keys.contains("executeStartTime") {
            self.executeStartTime = dict["executeStartTime"] as! Int64
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("pipelineName") {
            self.pipelineName = dict["pipelineName"] as! String
        }
        if dict.keys.contains("resultStatusList") {
            self.resultStatusList = dict["resultStatusList"] as! String
        }
    }
}

public class ListPipelineGroupPipelinesResponseBody : Tea.TeaModel {
    public class Pipelines : Tea.TeaModel {
        public var createTime: Int64?

        public var pipelineId: Int64?

        public var pipelineName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineName != nil {
                map["pipelineName"] = self.pipelineName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("pipelineId") {
                self.pipelineId = dict["pipelineId"] as! Int64
            }
            if dict.keys.contains("pipelineName") {
                self.pipelineName = dict["pipelineName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nextToken: String?

    public var pipelines: [ListPipelineGroupPipelinesResponseBody.Pipelines]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelines != nil {
            var tmp : [Any] = []
            for k in self.pipelines! {
                tmp.append(k.toMap())
            }
            map["pipelines"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("pipelines") {
            var tmp : [ListPipelineGroupPipelinesResponseBody.Pipelines] = []
            for v in dict["pipelines"] as! [Any] {
                var model = ListPipelineGroupPipelinesResponseBody.Pipelines()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.pipelines = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class ListPipelineGroupPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineGroupPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelineGroupPipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelineGroupsRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
    }
}

public class ListPipelineGroupsResponseBody : Tea.TeaModel {
    public class PipelineGroups : Tea.TeaModel {
        public var createTime: Int64?

        public var id: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nextToken: String?

    public var pipelineGroups: [ListPipelineGroupsResponseBody.PipelineGroups]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelineGroups != nil {
            var tmp : [Any] = []
            for k in self.pipelineGroups! {
                tmp.append(k.toMap())
            }
            map["pipelineGroups"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("pipelineGroups") {
            var tmp : [ListPipelineGroupsResponseBody.PipelineGroups] = []
            for v in dict["pipelineGroups"] as! [Any] {
                var model = ListPipelineGroupsResponseBody.PipelineGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.pipelineGroups = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class ListPipelineGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelineGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelineJobHistorysRequest : Tea.TeaModel {
    public var category: String?

    public var identifier: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("category") {
            self.category = dict["category"] as! String
        }
        if dict.keys.contains("identifier") {
            self.identifier = dict["identifier"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
    }
}

public class ListPipelineJobHistorysResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public var executeNumber: Int32?

        public var identifier: String?

        public var jobId: Int64?

        public var jobName: String?

        public var operatorAccountId: String?

        public var pipelineId: Int64?

        public var pipelineRunId: Int64?

        public var sources: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.executeNumber != nil {
                map["executeNumber"] = self.executeNumber!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.jobId != nil {
                map["jobId"] = self.jobId!
            }
            if self.jobName != nil {
                map["jobName"] = self.jobName!
            }
            if self.operatorAccountId != nil {
                map["operatorAccountId"] = self.operatorAccountId!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineRunId != nil {
                map["pipelineRunId"] = self.pipelineRunId!
            }
            if self.sources != nil {
                map["sources"] = self.sources!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("executeNumber") {
                self.executeNumber = dict["executeNumber"] as! Int32
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("jobId") {
                self.jobId = dict["jobId"] as! Int64
            }
            if dict.keys.contains("jobName") {
                self.jobName = dict["jobName"] as! String
            }
            if dict.keys.contains("operatorAccountId") {
                self.operatorAccountId = dict["operatorAccountId"] as! String
            }
            if dict.keys.contains("pipelineId") {
                self.pipelineId = dict["pipelineId"] as! Int64
            }
            if dict.keys.contains("pipelineRunId") {
                self.pipelineRunId = dict["pipelineRunId"] as! Int64
            }
            if dict.keys.contains("sources") {
                self.sources = dict["sources"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var jobs: [ListPipelineJobHistorysResponseBody.Jobs]?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["jobs"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("jobs") {
            var tmp : [ListPipelineJobHistorysResponseBody.Jobs] = []
            for v in dict["jobs"] as! [Any] {
                var model = ListPipelineJobHistorysResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class ListPipelineJobHistorysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineJobHistorysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelineJobHistorysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelineJobsRequest : Tea.TeaModel {
    public var category: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("category") {
            self.category = dict["category"] as! String
        }
    }
}

public class ListPipelineJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public var identifier: String?

        public var jobName: String?

        public var lastJobId: Int64?

        public var lastJobParams: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.jobName != nil {
                map["jobName"] = self.jobName!
            }
            if self.lastJobId != nil {
                map["lastJobId"] = self.lastJobId!
            }
            if self.lastJobParams != nil {
                map["lastJobParams"] = self.lastJobParams!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("jobName") {
                self.jobName = dict["jobName"] as! String
            }
            if dict.keys.contains("lastJobId") {
                self.lastJobId = dict["lastJobId"] as! Int64
            }
            if dict.keys.contains("lastJobParams") {
                self.lastJobParams = dict["lastJobParams"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var jobs: [ListPipelineJobsResponseBody.Jobs]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["jobs"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("jobs") {
            var tmp : [ListPipelineJobsResponseBody.Jobs] = []
            for v in dict["jobs"] as! [Any] {
                var model = ListPipelineJobsResponseBody.Jobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.jobs = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListPipelineJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelineJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelineRelationsRequest : Tea.TeaModel {
    public var relObjectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.relObjectType != nil {
            map["relObjectType"] = self.relObjectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("relObjectType") {
            self.relObjectType = dict["relObjectType"] as! String
        }
    }
}

public class ListPipelineRelationsResponseBody : Tea.TeaModel {
    public class PipelineRelations : Tea.TeaModel {
        public var refObjectId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.refObjectId != nil {
                map["refObjectId"] = self.refObjectId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("refObjectId") {
                self.refObjectId = dict["refObjectId"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelineRelations: [ListPipelineRelationsResponseBody.PipelineRelations]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelineRelations != nil {
            var tmp : [Any] = []
            for k in self.pipelineRelations! {
                tmp.append(k.toMap())
            }
            map["pipelineRelations"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("pipelineRelations") {
            var tmp : [ListPipelineRelationsResponseBody.PipelineRelations] = []
            for v in dict["pipelineRelations"] as! [Any] {
                var model = ListPipelineRelationsResponseBody.PipelineRelations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.pipelineRelations = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListPipelineRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelineRelationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelineRunsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var maxResults: Int64?

    public var nextToken: String?

    public var startTime: Int64?

    public var status: String?

    public var triggerMode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.triggerMode != nil {
            map["triggerMode"] = self.triggerMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("triggerMode") {
            self.triggerMode = dict["triggerMode"] as! Int32
        }
    }
}

public class ListPipelineRunsResponseBody : Tea.TeaModel {
    public class PipelineRuns : Tea.TeaModel {
        public var creatorAccountId: String?

        public var endTime: Int64?

        public var pipelineId: Int64?

        public var pipelineRunId: Int64?

        public var startTime: Int64?

        public var status: String?

        public var triggerMode: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineRunId != nil {
                map["pipelineRunId"] = self.pipelineRunId!
            }
            if self.startTime != nil {
                map["startTime"] = self.startTime!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.triggerMode != nil {
                map["triggerMode"] = self.triggerMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creatorAccountId") {
                self.creatorAccountId = dict["creatorAccountId"] as! String
            }
            if dict.keys.contains("endTime") {
                self.endTime = dict["endTime"] as! Int64
            }
            if dict.keys.contains("pipelineId") {
                self.pipelineId = dict["pipelineId"] as! Int64
            }
            if dict.keys.contains("pipelineRunId") {
                self.pipelineRunId = dict["pipelineRunId"] as! Int64
            }
            if dict.keys.contains("startTime") {
                self.startTime = dict["startTime"] as! Int64
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("triggerMode") {
                self.triggerMode = dict["triggerMode"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nextToken: String?

    public var pipelineRuns: [ListPipelineRunsResponseBody.PipelineRuns]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelineRuns != nil {
            var tmp : [Any] = []
            for k in self.pipelineRuns! {
                tmp.append(k.toMap())
            }
            map["pipelineRuns"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("pipelineRuns") {
            var tmp : [ListPipelineRunsResponseBody.PipelineRuns] = []
            for v in dict["pipelineRuns"] as! [Any] {
                var model = ListPipelineRunsResponseBody.PipelineRuns()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.pipelineRuns = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListPipelineRunsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineRunsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelineRunsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelinesRequest : Tea.TeaModel {
    public var createEndTime: Int64?

    public var createStartTime: Int64?

    public var creatorAccountIds: String?

    public var executeAccountIds: String?

    public var executeEndTime: Int64?

    public var executeStartTime: Int64?

    public var maxResults: Int64?

    public var nextToken: String?

    public var pipelineName: String?

    public var statusList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createEndTime != nil {
            map["createEndTime"] = self.createEndTime!
        }
        if self.createStartTime != nil {
            map["createStartTime"] = self.createStartTime!
        }
        if self.creatorAccountIds != nil {
            map["creatorAccountIds"] = self.creatorAccountIds!
        }
        if self.executeAccountIds != nil {
            map["executeAccountIds"] = self.executeAccountIds!
        }
        if self.executeEndTime != nil {
            map["executeEndTime"] = self.executeEndTime!
        }
        if self.executeStartTime != nil {
            map["executeStartTime"] = self.executeStartTime!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelineName != nil {
            map["pipelineName"] = self.pipelineName!
        }
        if self.statusList != nil {
            map["statusList"] = self.statusList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("createEndTime") {
            self.createEndTime = dict["createEndTime"] as! Int64
        }
        if dict.keys.contains("createStartTime") {
            self.createStartTime = dict["createStartTime"] as! Int64
        }
        if dict.keys.contains("creatorAccountIds") {
            self.creatorAccountIds = dict["creatorAccountIds"] as! String
        }
        if dict.keys.contains("executeAccountIds") {
            self.executeAccountIds = dict["executeAccountIds"] as! String
        }
        if dict.keys.contains("executeEndTime") {
            self.executeEndTime = dict["executeEndTime"] as! Int64
        }
        if dict.keys.contains("executeStartTime") {
            self.executeStartTime = dict["executeStartTime"] as! Int64
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("pipelineName") {
            self.pipelineName = dict["pipelineName"] as! String
        }
        if dict.keys.contains("statusList") {
            self.statusList = dict["statusList"] as! String
        }
    }
}

public class ListPipelinesResponseBody : Tea.TeaModel {
    public class Pipelines : Tea.TeaModel {
        public var createTime: Int64?

        public var creatorAccountId: String?

        public var groupId: Int64?

        public var pipelineId: Int64?

        public var pipelineName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.groupId != nil {
                map["groupId"] = self.groupId!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineName != nil {
                map["pipelineName"] = self.pipelineName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("creatorAccountId") {
                self.creatorAccountId = dict["creatorAccountId"] as! String
            }
            if dict.keys.contains("groupId") {
                self.groupId = dict["groupId"] as! Int64
            }
            if dict.keys.contains("pipelineId") {
                self.pipelineId = dict["pipelineId"] as! Int64
            }
            if dict.keys.contains("pipelineName") {
                self.pipelineName = dict["pipelineName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nextToken: String?

    public var pipelines: [ListPipelinesResponseBody.Pipelines]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pipelines != nil {
            var tmp : [Any] = []
            for k in self.pipelines! {
                tmp.append(k.toMap())
            }
            map["pipelines"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("pipelines") {
            var tmp : [ListPipelinesResponseBody.Pipelines] = []
            for v in dict["pipelines"] as! [Any] {
                var model = ListPipelinesResponseBody.Pipelines()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.pipelines = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectLabelsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int32?

    public var pageSize: Int64?

    public var repositoryIdentity: String?

    public var search: String?

    public var sort: String?

    public var withCounts: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.withCounts != nil {
            map["withCounts"] = self.withCounts!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("orderBy") {
            self.orderBy = dict["orderBy"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
        if dict.keys.contains("search") {
            self.search = dict["search"] as! String
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
        if dict.keys.contains("withCounts") {
            self.withCounts = dict["withCounts"] as! Bool
        }
    }
}

public class ListProjectLabelsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var color: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public var openMergeRequestsCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.color != nil {
                map["color"] = self.color!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.openMergeRequestsCount != nil {
                map["openMergeRequestsCount"] = self.openMergeRequestsCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("color") {
                self.color = dict["color"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("openMergeRequestsCount") {
                self.openMergeRequestsCount = dict["openMergeRequestsCount"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListProjectLabelsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListProjectLabelsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListProjectLabelsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListProjectLabelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectLabelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectLabelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectMembersRequest : Tea.TeaModel {
    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.targetType != nil {
            map["targetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("targetType") {
            self.targetType = dict["targetType"] as! String
        }
    }
}

public class ListProjectMembersResponseBody : Tea.TeaModel {
    public class Members : Tea.TeaModel {
        public class Division : Tea.TeaModel {
            public var identifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
            }
        }
        public class OrganizationUserInfo : Tea.TeaModel {
            public var organizationIdentifier: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.organizationIdentifier != nil {
                    map["organizationIdentifier"] = self.organizationIdentifier!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("organizationIdentifier") {
                    self.organizationIdentifier = dict["organizationIdentifier"] as! String
                }
            }
        }
        public var account: String?

        public var avatar: String?

        public var dingTalkId: String?

        public var displayName: String?

        public var displayNickName: String?

        public var displayRealName: String?

        public var division: ListProjectMembersResponseBody.Members.Division?

        public var email: String?

        public var gender: String?

        public var identifier: String?

        public var mobile: String?

        public var nameEn: String?

        public var nickName: String?

        public var nickNamePinyin: String?

        public var organizationUserInfo: ListProjectMembersResponseBody.Members.OrganizationUserInfo?

        public var realName: String?

        public var realNamePinyin: String?

        public var roleName: String?

        public var stamp: String?

        public var tbRoleId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.division?.validate()
            try self.organizationUserInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                map["account"] = self.account!
            }
            if self.avatar != nil {
                map["avatar"] = self.avatar!
            }
            if self.dingTalkId != nil {
                map["dingTalkId"] = self.dingTalkId!
            }
            if self.displayName != nil {
                map["displayName"] = self.displayName!
            }
            if self.displayNickName != nil {
                map["displayNickName"] = self.displayNickName!
            }
            if self.displayRealName != nil {
                map["displayRealName"] = self.displayRealName!
            }
            if self.division != nil {
                map["division"] = self.division?.toMap()
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.gender != nil {
                map["gender"] = self.gender!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.mobile != nil {
                map["mobile"] = self.mobile!
            }
            if self.nameEn != nil {
                map["nameEn"] = self.nameEn!
            }
            if self.nickName != nil {
                map["nickName"] = self.nickName!
            }
            if self.nickNamePinyin != nil {
                map["nickNamePinyin"] = self.nickNamePinyin!
            }
            if self.organizationUserInfo != nil {
                map["organizationUserInfo"] = self.organizationUserInfo?.toMap()
            }
            if self.realName != nil {
                map["realName"] = self.realName!
            }
            if self.realNamePinyin != nil {
                map["realNamePinyin"] = self.realNamePinyin!
            }
            if self.roleName != nil {
                map["roleName"] = self.roleName!
            }
            if self.stamp != nil {
                map["stamp"] = self.stamp!
            }
            if self.tbRoleId != nil {
                map["tbRoleId"] = self.tbRoleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("account") {
                self.account = dict["account"] as! String
            }
            if dict.keys.contains("avatar") {
                self.avatar = dict["avatar"] as! String
            }
            if dict.keys.contains("dingTalkId") {
                self.dingTalkId = dict["dingTalkId"] as! String
            }
            if dict.keys.contains("displayName") {
                self.displayName = dict["displayName"] as! String
            }
            if dict.keys.contains("displayNickName") {
                self.displayNickName = dict["displayNickName"] as! String
            }
            if dict.keys.contains("displayRealName") {
                self.displayRealName = dict["displayRealName"] as! String
            }
            if dict.keys.contains("division") {
                var model = ListProjectMembersResponseBody.Members.Division()
                model.fromMap(dict["division"] as! [String: Any])
                self.division = model
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("gender") {
                self.gender = dict["gender"] as! String
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("mobile") {
                self.mobile = dict["mobile"] as! String
            }
            if dict.keys.contains("nameEn") {
                self.nameEn = dict["nameEn"] as! String
            }
            if dict.keys.contains("nickName") {
                self.nickName = dict["nickName"] as! String
            }
            if dict.keys.contains("nickNamePinyin") {
                self.nickNamePinyin = dict["nickNamePinyin"] as! String
            }
            if dict.keys.contains("organizationUserInfo") {
                var model = ListProjectMembersResponseBody.Members.OrganizationUserInfo()
                model.fromMap(dict["organizationUserInfo"] as! [String: Any])
                self.organizationUserInfo = model
            }
            if dict.keys.contains("realName") {
                self.realName = dict["realName"] as! String
            }
            if dict.keys.contains("realNamePinyin") {
                self.realNamePinyin = dict["realNamePinyin"] as! String
            }
            if dict.keys.contains("roleName") {
                self.roleName = dict["roleName"] as! String
            }
            if dict.keys.contains("stamp") {
                self.stamp = dict["stamp"] as! String
            }
            if dict.keys.contains("tbRoleId") {
                self.tbRoleId = dict["tbRoleId"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var members: [ListProjectMembersResponseBody.Members]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.members != nil {
            var tmp : [Any] = []
            for k in self.members! {
                tmp.append(k.toMap())
            }
            map["members"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("members") {
            var tmp : [ListProjectMembersResponseBody.Members] = []
            for v in dict["members"] as! [Any] {
                var model = ListProjectMembersResponseBody.Members()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.members = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListProjectMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectTemplatesRequest : Tea.TeaModel {
    public var category: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("category") {
            self.category = dict["category"] as! String
        }
    }
}

public class ListProjectTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public var copyFrom: String?

        public var creator: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var icon: String?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var nameEn: String?

        public var resourceCategory: String?

        public var resourceType: String?

        public var spaceIdentifier: String?

        public var spaceType: String?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.copyFrom != nil {
                map["copyFrom"] = self.copyFrom!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.icon != nil {
                map["icon"] = self.icon!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameEn != nil {
                map["nameEn"] = self.nameEn!
            }
            if self.resourceCategory != nil {
                map["resourceCategory"] = self.resourceCategory!
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("copyFrom") {
                self.copyFrom = dict["copyFrom"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("icon") {
                self.icon = dict["icon"] as! String
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameEn") {
                self.nameEn = dict["nameEn"] as! String
            }
            if dict.keys.contains("resourceCategory") {
                self.resourceCategory = dict["resourceCategory"] as! String
            }
            if dict.keys.contains("resourceType") {
                self.resourceType = dict["resourceType"] as! String
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("spaceType") {
                self.spaceType = dict["spaceType"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! Int64
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var templates: [ListProjectTemplatesResponseBody.Templates]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.templates != nil {
            var tmp : [Any] = []
            for k in self.templates! {
                tmp.append(k.toMap())
            }
            map["templates"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("templates") {
            var tmp : [ListProjectTemplatesResponseBody.Templates] = []
            for v in dict["templates"] as! [Any] {
                var model = ListProjectTemplatesResponseBody.Templates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templates = tmp
        }
    }
}

public class ListProjectTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectWorkitemTypesRequest : Tea.TeaModel {
    public var category: String?

    public var spaceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("category") {
            self.category = dict["category"] as! String
        }
        if dict.keys.contains("spaceType") {
            self.spaceType = dict["spaceType"] as! String
        }
    }
}

public class ListProjectWorkitemTypesResponseBody : Tea.TeaModel {
    public class WorkitemTypes : Tea.TeaModel {
        public var addUser: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var defaultType: Bool?

        public var description_: String?

        public var enable: Bool?

        public var gmtAdd: Int64?

        public var gmtCreate: Int64?

        public var identifier: String?

        public var name: String?

        public var nameEn: String?

        public var systemDefault: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addUser != nil {
                map["addUser"] = self.addUser!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.defaultType != nil {
                map["defaultType"] = self.defaultType!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.gmtAdd != nil {
                map["gmtAdd"] = self.gmtAdd!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameEn != nil {
                map["nameEn"] = self.nameEn!
            }
            if self.systemDefault != nil {
                map["systemDefault"] = self.systemDefault!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("addUser") {
                self.addUser = dict["addUser"] as! String
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("defaultType") {
                self.defaultType = dict["defaultType"] as! Bool
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("enable") {
                self.enable = dict["enable"] as! Bool
            }
            if dict.keys.contains("gmtAdd") {
                self.gmtAdd = dict["gmtAdd"] as! Int64
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameEn") {
                self.nameEn = dict["nameEn"] as! String
            }
            if dict.keys.contains("systemDefault") {
                self.systemDefault = dict["systemDefault"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workitemTypes: [ListProjectWorkitemTypesResponseBody.WorkitemTypes]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitemTypes != nil {
            var tmp : [Any] = []
            for k in self.workitemTypes! {
                tmp.append(k.toMap())
            }
            map["workitemTypes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("workitemTypes") {
            var tmp : [ListProjectWorkitemTypesResponseBody.WorkitemTypes] = []
            for v in dict["workitemTypes"] as! [Any] {
                var model = ListProjectWorkitemTypesResponseBody.WorkitemTypes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workitemTypes = tmp
        }
    }
}

public class ListProjectWorkitemTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectWorkitemTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectWorkitemTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProjectsRequest : Tea.TeaModel {
    public var category: String?

    public var conditions: String?

    public var extraConditions: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var scope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.conditions != nil {
            map["conditions"] = self.conditions!
        }
        if self.extraConditions != nil {
            map["extraConditions"] = self.extraConditions!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("category") {
            self.category = dict["category"] as! String
        }
        if dict.keys.contains("conditions") {
            self.conditions = dict["conditions"] as! String
        }
        if dict.keys.contains("extraConditions") {
            self.extraConditions = dict["extraConditions"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("scope") {
            self.scope = dict["scope"] as! String
        }
    }
}

public class ListProjectsResponseBody : Tea.TeaModel {
    public class Projects : Tea.TeaModel {
        public var categoryIdentifier: String?

        public var creator: String?

        public var customCode: String?

        public var deleteTime: Int64?

        public var description_: String?

        public var gmtCreate: Int64?

        public var icon: String?

        public var identifier: String?

        public var logicalStatus: String?

        public var name: String?

        public var scope: String?

        public var statusStageIdentifier: String?

        public var typeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.customCode != nil {
                map["customCode"] = self.customCode!
            }
            if self.deleteTime != nil {
                map["deleteTime"] = self.deleteTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.icon != nil {
                map["icon"] = self.icon!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.typeIdentifier != nil {
                map["typeIdentifier"] = self.typeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("customCode") {
                self.customCode = dict["customCode"] as! String
            }
            if dict.keys.contains("deleteTime") {
                self.deleteTime = dict["deleteTime"] as! Int64
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("icon") {
                self.icon = dict["icon"] as! String
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("logicalStatus") {
                self.logicalStatus = dict["logicalStatus"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("scope") {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("statusStageIdentifier") {
                self.statusStageIdentifier = dict["statusStageIdentifier"] as! String
            }
            if dict.keys.contains("typeIdentifier") {
                self.typeIdentifier = dict["typeIdentifier"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var projects: [ListProjectsResponseBody.Projects]?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.projects != nil {
            var tmp : [Any] = []
            for k in self.projects! {
                tmp.append(k.toMap())
            }
            map["projects"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("projects") {
            var tmp : [ListProjectsResponseBody.Projects] = []
            for v in dict["projects"] as! [Any] {
                var model = ListProjectsResponseBody.Projects()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.projects = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProjectsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListProtectedBranchesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ListProtectedBranchesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AllowMergeUsers : Tea.TeaModel {
            public var avatar: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatar") {
                    self.avatar = dict["avatar"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public class AllowPushUsers : Tea.TeaModel {
            public var avatar: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatar") {
                    self.avatar = dict["avatar"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public class MergeRequestSetting : Tea.TeaModel {
            public class DefaultAssignees : Tea.TeaModel {
                public var avatar: String?

                public var email: String?

                public var id: Int64?

                public var name: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avatar != nil {
                        map["avatar"] = self.avatar!
                    }
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.username != nil {
                        map["username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("avatar") {
                        self.avatar = dict["avatar"] as! String
                    }
                    if dict.keys.contains("email") {
                        self.email = dict["email"] as! String
                    }
                    if dict.keys.contains("id") {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("username") {
                        self.username = dict["username"] as! String
                    }
                }
            }
            public var allowMergeRequestRoles: [Int32]?

            public var defaultAssignees: [ListProtectedBranchesResponseBody.Result.MergeRequestSetting.DefaultAssignees]?

            public var isAllowSelfApproval: Bool?

            public var isRequireDiscussionProcessed: Bool?

            public var isRequired: Bool?

            public var isResetApprovalWhenNewPush: Bool?

            public var minimumApproval: Int32?

            public var mrMode: String?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowMergeRequestRoles != nil {
                    map["allowMergeRequestRoles"] = self.allowMergeRequestRoles!
                }
                if self.defaultAssignees != nil {
                    var tmp : [Any] = []
                    for k in self.defaultAssignees! {
                        tmp.append(k.toMap())
                    }
                    map["defaultAssignees"] = tmp
                }
                if self.isAllowSelfApproval != nil {
                    map["isAllowSelfApproval"] = self.isAllowSelfApproval!
                }
                if self.isRequireDiscussionProcessed != nil {
                    map["isRequireDiscussionProcessed"] = self.isRequireDiscussionProcessed!
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.isResetApprovalWhenNewPush != nil {
                    map["isResetApprovalWhenNewPush"] = self.isResetApprovalWhenNewPush!
                }
                if self.minimumApproval != nil {
                    map["minimumApproval"] = self.minimumApproval!
                }
                if self.mrMode != nil {
                    map["mrMode"] = self.mrMode!
                }
                if self.whiteList != nil {
                    map["whiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("allowMergeRequestRoles") {
                    self.allowMergeRequestRoles = dict["allowMergeRequestRoles"] as! [Int32]
                }
                if dict.keys.contains("defaultAssignees") {
                    var tmp : [ListProtectedBranchesResponseBody.Result.MergeRequestSetting.DefaultAssignees] = []
                    for v in dict["defaultAssignees"] as! [Any] {
                        var model = ListProtectedBranchesResponseBody.Result.MergeRequestSetting.DefaultAssignees()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.defaultAssignees = tmp
                }
                if dict.keys.contains("isAllowSelfApproval") {
                    self.isAllowSelfApproval = dict["isAllowSelfApproval"] as! Bool
                }
                if dict.keys.contains("isRequireDiscussionProcessed") {
                    self.isRequireDiscussionProcessed = dict["isRequireDiscussionProcessed"] as! Bool
                }
                if dict.keys.contains("isRequired") {
                    self.isRequired = dict["isRequired"] as! Bool
                }
                if dict.keys.contains("isResetApprovalWhenNewPush") {
                    self.isResetApprovalWhenNewPush = dict["isResetApprovalWhenNewPush"] as! Bool
                }
                if dict.keys.contains("minimumApproval") {
                    self.minimumApproval = dict["minimumApproval"] as! Int32
                }
                if dict.keys.contains("mrMode") {
                    self.mrMode = dict["mrMode"] as! String
                }
                if dict.keys.contains("whiteList") {
                    self.whiteList = dict["whiteList"] as! String
                }
            }
        }
        public class TestSettingDTO : Tea.TeaModel {
            public class CheckConfig : Tea.TeaModel {
                public class CheckItems : Tea.TeaModel {
                    public var isRequired: Bool?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isRequired != nil {
                            map["isRequired"] = self.isRequired!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("isRequired") {
                            self.isRequired = dict["isRequired"] as! Bool
                        }
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                    }
                }
                public var checkItems: [ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkItems != nil {
                        var tmp : [Any] = []
                        for k in self.checkItems! {
                            tmp.append(k.toMap())
                        }
                        map["checkItems"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("checkItems") {
                        var tmp : [ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems] = []
                        for v in dict["checkItems"] as! [Any] {
                            var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.checkItems = tmp
                    }
                }
            }
            public class CheckTaskQualityConfig : Tea.TeaModel {
                public var bizNo: String?

                public var enabled: Bool?

                public var message: String?

                public var taskName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizNo != nil {
                        map["bizNo"] = self.bizNo!
                    }
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    if self.taskName != nil {
                        map["taskName"] = self.taskName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("bizNo") {
                        self.bizNo = dict["bizNo"] as! String
                    }
                    if dict.keys.contains("enabled") {
                        self.enabled = dict["enabled"] as! Bool
                    }
                    if dict.keys.contains("message") {
                        self.message = dict["message"] as! String
                    }
                    if dict.keys.contains("taskName") {
                        self.taskName = dict["taskName"] as! String
                    }
                }
            }
            public class CodeGuidelinesDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("enabled") {
                        self.enabled = dict["enabled"] as! Bool
                    }
                    if dict.keys.contains("message") {
                        self.message = dict["message"] as! String
                    }
                }
            }
            public class SensitiveInfoDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("enabled") {
                        self.enabled = dict["enabled"] as! Bool
                    }
                    if dict.keys.contains("message") {
                        self.message = dict["message"] as! String
                    }
                }
            }
            public var checkConfig: ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig?

            public var checkTaskQualityConfig: ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig?

            public var codeGuidelinesDetection: ListProtectedBranchesResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection?

            public var isRequired: Bool?

            public var sensitiveInfoDetection: ListProtectedBranchesResponseBody.Result.TestSettingDTO.SensitiveInfoDetection?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.checkConfig?.validate()
                try self.checkTaskQualityConfig?.validate()
                try self.codeGuidelinesDetection?.validate()
                try self.sensitiveInfoDetection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkConfig != nil {
                    map["checkConfig"] = self.checkConfig?.toMap()
                }
                if self.checkTaskQualityConfig != nil {
                    map["checkTaskQualityConfig"] = self.checkTaskQualityConfig?.toMap()
                }
                if self.codeGuidelinesDetection != nil {
                    map["codeGuidelinesDetection"] = self.codeGuidelinesDetection?.toMap()
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.sensitiveInfoDetection != nil {
                    map["sensitiveInfoDetection"] = self.sensitiveInfoDetection?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("checkConfig") {
                    var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig()
                    model.fromMap(dict["checkConfig"] as! [String: Any])
                    self.checkConfig = model
                }
                if dict.keys.contains("checkTaskQualityConfig") {
                    var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig()
                    model.fromMap(dict["checkTaskQualityConfig"] as! [String: Any])
                    self.checkTaskQualityConfig = model
                }
                if dict.keys.contains("codeGuidelinesDetection") {
                    var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection()
                    model.fromMap(dict["codeGuidelinesDetection"] as! [String: Any])
                    self.codeGuidelinesDetection = model
                }
                if dict.keys.contains("isRequired") {
                    self.isRequired = dict["isRequired"] as! Bool
                }
                if dict.keys.contains("sensitiveInfoDetection") {
                    var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO.SensitiveInfoDetection()
                    model.fromMap(dict["sensitiveInfoDetection"] as! [String: Any])
                    self.sensitiveInfoDetection = model
                }
            }
        }
        public var allowMergeRoles: [Int32]?

        public var allowMergeUserIds: [Int64]?

        public var allowMergeUsers: [ListProtectedBranchesResponseBody.Result.AllowMergeUsers]?

        public var allowPushRoles: [Int32]?

        public var allowPushUserIds: [Int64]?

        public var allowPushUsers: [ListProtectedBranchesResponseBody.Result.AllowPushUsers]?

        public var branch: String?

        public var createdAt: String?

        public var id: Int64?

        public var matches: [String]?

        public var mergeRequestSetting: ListProtectedBranchesResponseBody.Result.MergeRequestSetting?

        public var testSettingDTO: ListProtectedBranchesResponseBody.Result.TestSettingDTO?

        public var updatedAt: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mergeRequestSetting?.validate()
            try self.testSettingDTO?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowMergeRoles != nil {
                map["allowMergeRoles"] = self.allowMergeRoles!
            }
            if self.allowMergeUserIds != nil {
                map["allowMergeUserIds"] = self.allowMergeUserIds!
            }
            if self.allowMergeUsers != nil {
                var tmp : [Any] = []
                for k in self.allowMergeUsers! {
                    tmp.append(k.toMap())
                }
                map["allowMergeUsers"] = tmp
            }
            if self.allowPushRoles != nil {
                map["allowPushRoles"] = self.allowPushRoles!
            }
            if self.allowPushUserIds != nil {
                map["allowPushUserIds"] = self.allowPushUserIds!
            }
            if self.allowPushUsers != nil {
                var tmp : [Any] = []
                for k in self.allowPushUsers! {
                    tmp.append(k.toMap())
                }
                map["allowPushUsers"] = tmp
            }
            if self.branch != nil {
                map["branch"] = self.branch!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.matches != nil {
                map["matches"] = self.matches!
            }
            if self.mergeRequestSetting != nil {
                map["mergeRequestSetting"] = self.mergeRequestSetting?.toMap()
            }
            if self.testSettingDTO != nil {
                map["testSettingDTO"] = self.testSettingDTO?.toMap()
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("allowMergeRoles") {
                self.allowMergeRoles = dict["allowMergeRoles"] as! [Int32]
            }
            if dict.keys.contains("allowMergeUserIds") {
                self.allowMergeUserIds = dict["allowMergeUserIds"] as! [Int64]
            }
            if dict.keys.contains("allowMergeUsers") {
                var tmp : [ListProtectedBranchesResponseBody.Result.AllowMergeUsers] = []
                for v in dict["allowMergeUsers"] as! [Any] {
                    var model = ListProtectedBranchesResponseBody.Result.AllowMergeUsers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.allowMergeUsers = tmp
            }
            if dict.keys.contains("allowPushRoles") {
                self.allowPushRoles = dict["allowPushRoles"] as! [Int32]
            }
            if dict.keys.contains("allowPushUserIds") {
                self.allowPushUserIds = dict["allowPushUserIds"] as! [Int64]
            }
            if dict.keys.contains("allowPushUsers") {
                var tmp : [ListProtectedBranchesResponseBody.Result.AllowPushUsers] = []
                for v in dict["allowPushUsers"] as! [Any] {
                    var model = ListProtectedBranchesResponseBody.Result.AllowPushUsers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.allowPushUsers = tmp
            }
            if dict.keys.contains("branch") {
                self.branch = dict["branch"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("matches") {
                self.matches = dict["matches"] as! [String]
            }
            if dict.keys.contains("mergeRequestSetting") {
                var model = ListProtectedBranchesResponseBody.Result.MergeRequestSetting()
                model.fromMap(dict["mergeRequestSetting"] as! [String: Any])
                self.mergeRequestSetting = model
            }
            if dict.keys.contains("testSettingDTO") {
                var model = ListProtectedBranchesResponseBody.Result.TestSettingDTO()
                model.fromMap(dict["testSettingDTO"] as! [String: Any])
                self.testSettingDTO = model
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListProtectedBranchesResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListProtectedBranchesResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListProtectedBranchesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListProtectedBranchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListProtectedBranchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListProtectedBranchesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPushRulesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ListPushRulesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class RuleInfos : Tea.TeaModel {
            public var checkerName: String?

            public var checkerType: String?

            public var extraMessage: String?

            public var fileRuleRegexes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkerName != nil {
                    map["checkerName"] = self.checkerName!
                }
                if self.checkerType != nil {
                    map["checkerType"] = self.checkerType!
                }
                if self.extraMessage != nil {
                    map["extraMessage"] = self.extraMessage!
                }
                if self.fileRuleRegexes != nil {
                    map["fileRuleRegexes"] = self.fileRuleRegexes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("checkerName") {
                    self.checkerName = dict["checkerName"] as! String
                }
                if dict.keys.contains("checkerType") {
                    self.checkerType = dict["checkerType"] as! String
                }
                if dict.keys.contains("extraMessage") {
                    self.extraMessage = dict["extraMessage"] as! String
                }
                if dict.keys.contains("fileRuleRegexes") {
                    self.fileRuleRegexes = dict["fileRuleRegexes"] as! [String]
                }
            }
        }
        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var ruleInfos: [ListPushRulesResponseBody.Result.RuleInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleInfos != nil {
                var tmp : [Any] = []
                for k in self.ruleInfos! {
                    tmp.append(k.toMap())
                }
                map["ruleInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("ruleInfos") {
                var tmp : [ListPushRulesResponseBody.Result.RuleInfos] = []
                for v in dict["ruleInfos"] as! [Any] {
                    var model = ListPushRulesResponseBody.Result.RuleInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleInfos = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListPushRulesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListPushRulesResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListPushRulesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListPushRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPushRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPushRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRepositoriesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var archived: Bool?

    public var minAccessLevel: Int32?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int64?

    public var perPage: Int64?

    public var search: String?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.archived != nil {
            map["archived"] = self.archived!
        }
        if self.minAccessLevel != nil {
            map["minAccessLevel"] = self.minAccessLevel!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.perPage != nil {
            map["perPage"] = self.perPage!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("archived") {
            self.archived = dict["archived"] as! Bool
        }
        if dict.keys.contains("minAccessLevel") {
            self.minAccessLevel = dict["minAccessLevel"] as! Int32
        }
        if dict.keys.contains("orderBy") {
            self.orderBy = dict["orderBy"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("perPage") {
            self.perPage = dict["perPage"] as! Int64
        }
        if dict.keys.contains("search") {
            self.search = dict["search"] as! String
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
    }
}

public class ListRepositoriesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var id: Int64?

        public var accessLevel: Int32?

        public var archive: Bool?

        public var avatarUrl: String?

        public var createdAt: String?

        public var description_: String?

        public var importStatus: String?

        public var lastActivityAt: String?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespaceId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var star: Bool?

        public var starCount: Int64?

        public var updatedAt: String?

        public var visibilityLevel: String?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.archive != nil {
                map["archive"] = self.archive!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.importStatus != nil {
                map["importStatus"] = self.importStatus!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespaceId != nil {
                map["namespaceId"] = self.namespaceId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.star != nil {
                map["star"] = self.star!
            }
            if self.starCount != nil {
                map["starCount"] = self.starCount!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("archive") {
                self.archive = dict["archive"] as! Bool
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("importStatus") {
                self.importStatus = dict["importStatus"] as! String
            }
            if dict.keys.contains("lastActivityAt") {
                self.lastActivityAt = dict["lastActivityAt"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("namespaceId") {
                self.namespaceId = dict["namespaceId"] as! Int64
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("pathWithNamespace") {
                self.pathWithNamespace = dict["pathWithNamespace"] as! String
            }
            if dict.keys.contains("star") {
                self.star = dict["star"] as! Bool
            }
            if dict.keys.contains("starCount") {
                self.starCount = dict["starCount"] as! Int64
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("visibilityLevel") {
                self.visibilityLevel = dict["visibilityLevel"] as! String
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoriesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! Int32
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListRepositoriesResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListRepositoriesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListRepositoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRepositoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRepositoryBranchesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var search: String?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("search") {
            self.search = dict["search"] as! String
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
    }
}

public class ListRepositoryBranchesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var committedDate: String?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("authorEmail") {
                    self.authorEmail = dict["authorEmail"] as! String
                }
                if dict.keys.contains("authorName") {
                    self.authorName = dict["authorName"] as! String
                }
                if dict.keys.contains("authoredDate") {
                    self.authoredDate = dict["authoredDate"] as! String
                }
                if dict.keys.contains("committedDate") {
                    self.committedDate = dict["committedDate"] as! String
                }
                if dict.keys.contains("committerEmail") {
                    self.committerEmail = dict["committerEmail"] as! String
                }
                if dict.keys.contains("committerName") {
                    self.committerName = dict["committerName"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("parentIds") {
                    self.parentIds = dict["parentIds"] as! [String]
                }
                if dict.keys.contains("shortId") {
                    self.shortId = dict["shortId"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public var commit: ListRepositoryBranchesResponseBody.Result.Commit?

        public var name: String?

        public var protected: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.protected != nil {
                map["protected"] = self.protected!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("commit") {
                var model = ListRepositoryBranchesResponseBody.Result.Commit()
                model.fromMap(dict["commit"] as! [String: Any])
                self.commit = model
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("protected") {
                self.protected = dict["protected"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryBranchesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListRepositoryBranchesResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListRepositoryBranchesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListRepositoryBranchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryBranchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRepositoryBranchesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRepositoryCommitDiffRequest : Tea.TeaModel {
    public var accessToken: String?

    public var contextLine: Int32?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.contextLine != nil {
            map["contextLine"] = self.contextLine!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("contextLine") {
            self.contextLine = dict["contextLine"] as! Int32
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ListRepositoryCommitDiffResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var aMode: String?

        public var bMode: String?

        public var deletedFile: Bool?

        public var diff: String?

        public var isBinary: Bool?

        public var isNewLfs: Bool?

        public var isOldLfs: Bool?

        public var newFile: Bool?

        public var newId: String?

        public var newPath: String?

        public var oldId: String?

        public var oldPath: String?

        public var renamedFile: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aMode != nil {
                map["aMode"] = self.aMode!
            }
            if self.bMode != nil {
                map["bMode"] = self.bMode!
            }
            if self.deletedFile != nil {
                map["deletedFile"] = self.deletedFile!
            }
            if self.diff != nil {
                map["diff"] = self.diff!
            }
            if self.isBinary != nil {
                map["isBinary"] = self.isBinary!
            }
            if self.isNewLfs != nil {
                map["isNewLfs"] = self.isNewLfs!
            }
            if self.isOldLfs != nil {
                map["isOldLfs"] = self.isOldLfs!
            }
            if self.newFile != nil {
                map["newFile"] = self.newFile!
            }
            if self.newId != nil {
                map["newId"] = self.newId!
            }
            if self.newPath != nil {
                map["newPath"] = self.newPath!
            }
            if self.oldId != nil {
                map["oldId"] = self.oldId!
            }
            if self.oldPath != nil {
                map["oldPath"] = self.oldPath!
            }
            if self.renamedFile != nil {
                map["renamedFile"] = self.renamedFile!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("aMode") {
                self.aMode = dict["aMode"] as! String
            }
            if dict.keys.contains("bMode") {
                self.bMode = dict["bMode"] as! String
            }
            if dict.keys.contains("deletedFile") {
                self.deletedFile = dict["deletedFile"] as! Bool
            }
            if dict.keys.contains("diff") {
                self.diff = dict["diff"] as! String
            }
            if dict.keys.contains("isBinary") {
                self.isBinary = dict["isBinary"] as! Bool
            }
            if dict.keys.contains("isNewLfs") {
                self.isNewLfs = dict["isNewLfs"] as! Bool
            }
            if dict.keys.contains("isOldLfs") {
                self.isOldLfs = dict["isOldLfs"] as! Bool
            }
            if dict.keys.contains("newFile") {
                self.newFile = dict["newFile"] as! Bool
            }
            if dict.keys.contains("newId") {
                self.newId = dict["newId"] as! String
            }
            if dict.keys.contains("newPath") {
                self.newPath = dict["newPath"] as! String
            }
            if dict.keys.contains("oldId") {
                self.oldId = dict["oldId"] as! String
            }
            if dict.keys.contains("oldPath") {
                self.oldPath = dict["oldPath"] as! String
            }
            if dict.keys.contains("renamedFile") {
                self.renamedFile = dict["renamedFile"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryCommitDiffResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListRepositoryCommitDiffResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListRepositoryCommitDiffResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListRepositoryCommitDiffResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryCommitDiffResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRepositoryCommitDiffResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRepositoryCommitsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var end: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var path: String?

    public var refName: String?

    public var search: String?

    public var showCommentsCount: Bool?

    public var showSignature: Bool?

    public var start: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.end != nil {
            map["end"] = self.end!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.refName != nil {
            map["refName"] = self.refName!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.showCommentsCount != nil {
            map["showCommentsCount"] = self.showCommentsCount!
        }
        if self.showSignature != nil {
            map["showSignature"] = self.showSignature!
        }
        if self.start != nil {
            map["start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("end") {
            self.end = dict["end"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("path") {
            self.path = dict["path"] as! String
        }
        if dict.keys.contains("refName") {
            self.refName = dict["refName"] as! String
        }
        if dict.keys.contains("search") {
            self.search = dict["search"] as! String
        }
        if dict.keys.contains("showCommentsCount") {
            self.showCommentsCount = dict["showCommentsCount"] as! Bool
        }
        if dict.keys.contains("showSignature") {
            self.showSignature = dict["showSignature"] as! Bool
        }
        if dict.keys.contains("start") {
            self.start = dict["start"] as! String
        }
    }
}

public class ListRepositoryCommitsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Author : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
                if dict.keys.contains("websiteUrl") {
                    self.websiteUrl = dict["websiteUrl"] as! String
                }
            }
        }
        public class Committer : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public var websiteUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                if self.websiteUrl != nil {
                    map["websiteUrl"] = self.websiteUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
                if dict.keys.contains("websiteUrl") {
                    self.websiteUrl = dict["websiteUrl"] as! String
                }
            }
        }
        public class Signature : Tea.TeaModel {
            public var gpgKeyId: String?

            public var verificationStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gpgKeyId != nil {
                    map["gpgKeyId"] = self.gpgKeyId!
                }
                if self.verificationStatus != nil {
                    map["verificationStatus"] = self.verificationStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("gpgKeyId") {
                    self.gpgKeyId = dict["gpgKeyId"] as! String
                }
                if dict.keys.contains("verificationStatus") {
                    self.verificationStatus = dict["verificationStatus"] as! String
                }
            }
        }
        public var author: ListRepositoryCommitsResponseBody.Result.Author?

        public var authorEmail: String?

        public var authorName: String?

        public var authoredDate: String?

        public var commentsCount: Int64?

        public var committedDate: String?

        public var committer: ListRepositoryCommitsResponseBody.Result.Committer?

        public var committerEmail: String?

        public var committerName: String?

        public var createdAt: String?

        public var id: String?

        public var message: String?

        public var parentIds: [String]?

        public var shortId: String?

        public var signature: ListRepositoryCommitsResponseBody.Result.Signature?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.author?.validate()
            try self.committer?.validate()
            try self.signature?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.author != nil {
                map["author"] = self.author?.toMap()
            }
            if self.authorEmail != nil {
                map["authorEmail"] = self.authorEmail!
            }
            if self.authorName != nil {
                map["authorName"] = self.authorName!
            }
            if self.authoredDate != nil {
                map["authoredDate"] = self.authoredDate!
            }
            if self.commentsCount != nil {
                map["commentsCount"] = self.commentsCount!
            }
            if self.committedDate != nil {
                map["committedDate"] = self.committedDate!
            }
            if self.committer != nil {
                map["committer"] = self.committer?.toMap()
            }
            if self.committerEmail != nil {
                map["committerEmail"] = self.committerEmail!
            }
            if self.committerName != nil {
                map["committerName"] = self.committerName!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.parentIds != nil {
                map["parentIds"] = self.parentIds!
            }
            if self.shortId != nil {
                map["shortId"] = self.shortId!
            }
            if self.signature != nil {
                map["signature"] = self.signature?.toMap()
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("author") {
                var model = ListRepositoryCommitsResponseBody.Result.Author()
                model.fromMap(dict["author"] as! [String: Any])
                self.author = model
            }
            if dict.keys.contains("authorEmail") {
                self.authorEmail = dict["authorEmail"] as! String
            }
            if dict.keys.contains("authorName") {
                self.authorName = dict["authorName"] as! String
            }
            if dict.keys.contains("authoredDate") {
                self.authoredDate = dict["authoredDate"] as! String
            }
            if dict.keys.contains("commentsCount") {
                self.commentsCount = dict["commentsCount"] as! Int64
            }
            if dict.keys.contains("committedDate") {
                self.committedDate = dict["committedDate"] as! String
            }
            if dict.keys.contains("committer") {
                var model = ListRepositoryCommitsResponseBody.Result.Committer()
                model.fromMap(dict["committer"] as! [String: Any])
                self.committer = model
            }
            if dict.keys.contains("committerEmail") {
                self.committerEmail = dict["committerEmail"] as! String
            }
            if dict.keys.contains("committerName") {
                self.committerName = dict["committerName"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("message") {
                self.message = dict["message"] as! String
            }
            if dict.keys.contains("parentIds") {
                self.parentIds = dict["parentIds"] as! [String]
            }
            if dict.keys.contains("shortId") {
                self.shortId = dict["shortId"] as! String
            }
            if dict.keys.contains("signature") {
                var model = ListRepositoryCommitsResponseBody.Result.Signature()
                model.fromMap(dict["signature"] as! [String: Any])
                self.signature = model
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryCommitsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListRepositoryCommitsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListRepositoryCommitsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListRepositoryCommitsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryCommitsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRepositoryCommitsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRepositoryGroupsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var includePersonal: Bool?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var parentId: Int64?

    public var search: String?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.includePersonal != nil {
            map["includePersonal"] = self.includePersonal!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.parentId != nil {
            map["parentId"] = self.parentId!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("includePersonal") {
            self.includePersonal = dict["includePersonal"] as! Bool
        }
        if dict.keys.contains("orderBy") {
            self.orderBy = dict["orderBy"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("parentId") {
            self.parentId = dict["parentId"] as! Int64
        }
        if dict.keys.contains("search") {
            self.search = dict["search"] as! String
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
    }
}

public class ListRepositoryGroupsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var createdAt: String?

        public var description_: String?

        public var groupCount: Int64?

        public var id: Int64?

        public var name: String?

        public var nameWithNamespace: String?

        public var ownerId: Int64?

        public var parentId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var projectCount: Int64?

        public var type: String?

        public var updatedAt: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.groupCount != nil {
                map["groupCount"] = self.groupCount!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.projectCount != nil {
                map["projectCount"] = self.projectCount!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("groupCount") {
                self.groupCount = dict["groupCount"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("ownerId") {
                self.ownerId = dict["ownerId"] as! Int64
            }
            if dict.keys.contains("parentId") {
                self.parentId = dict["parentId"] as! Int64
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("pathWithNamespace") {
                self.pathWithNamespace = dict["pathWithNamespace"] as! String
            }
            if dict.keys.contains("projectCount") {
                self.projectCount = dict["projectCount"] as! Int64
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("visibilityLevel") {
                self.visibilityLevel = dict["visibilityLevel"] as! Int32
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryGroupsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListRepositoryGroupsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListRepositoryGroupsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListRepositoryGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRepositoryGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRepositoryMemberWithInheritedRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ListRepositoryMemberWithInheritedResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Inherited : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public var nameWithNamespace: String?

            public var path: String?

            public var pathWithNamespace: String?

            public var type: String?

            public var visibilityLevel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.nameWithNamespace != nil {
                    map["nameWithNamespace"] = self.nameWithNamespace!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.pathWithNamespace != nil {
                    map["pathWithNamespace"] = self.pathWithNamespace!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.visibilityLevel != nil {
                    map["visibilityLevel"] = self.visibilityLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("nameWithNamespace") {
                    self.nameWithNamespace = dict["nameWithNamespace"] as! String
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("pathWithNamespace") {
                    self.pathWithNamespace = dict["pathWithNamespace"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("visibilityLevel") {
                    self.visibilityLevel = dict["visibilityLevel"] as! String
                }
            }
        }
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var inherited: ListRepositoryMemberWithInheritedResponseBody.Result.Inherited?

        public var name: String?

        public var state: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inherited?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.inherited != nil {
                map["inherited"] = self.inherited?.toMap()
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("inherited") {
                var model = ListRepositoryMemberWithInheritedResponseBody.Result.Inherited()
                model.fromMap(dict["inherited"] as! [String: Any])
                self.inherited = model
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("username") {
                self.username = dict["username"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryMemberWithInheritedResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListRepositoryMemberWithInheritedResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListRepositoryMemberWithInheritedResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListRepositoryMemberWithInheritedResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryMemberWithInheritedResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRepositoryMemberWithInheritedResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRepositoryTagsRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var search: String?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.search != nil {
            map["search"] = self.search!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("search") {
            self.search = dict["search"] as! String
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
    }
}

public class ListRepositoryTagsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Commit : Tea.TeaModel {
            public class Signature : Tea.TeaModel {
                public var gpgKeyId: String?

                public var verificationStatus: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gpgKeyId != nil {
                        map["gpgKeyId"] = self.gpgKeyId!
                    }
                    if self.verificationStatus != nil {
                        map["verificationStatus"] = self.verificationStatus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("gpgKeyId") {
                        self.gpgKeyId = dict["gpgKeyId"] as! String
                    }
                    if dict.keys.contains("verificationStatus") {
                        self.verificationStatus = dict["verificationStatus"] as! String
                    }
                }
            }
            public var authorEmail: String?

            public var authorName: String?

            public var authoredDate: String?

            public var committedDate: String?

            public var committerEmail: String?

            public var committerName: String?

            public var createdAt: String?

            public var id: String?

            public var message: String?

            public var parentIds: [String]?

            public var shortId: String?

            public var signature: ListRepositoryTagsResponseBody.Result.Commit.Signature?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.signature?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorEmail != nil {
                    map["authorEmail"] = self.authorEmail!
                }
                if self.authorName != nil {
                    map["authorName"] = self.authorName!
                }
                if self.authoredDate != nil {
                    map["authoredDate"] = self.authoredDate!
                }
                if self.committedDate != nil {
                    map["committedDate"] = self.committedDate!
                }
                if self.committerEmail != nil {
                    map["committerEmail"] = self.committerEmail!
                }
                if self.committerName != nil {
                    map["committerName"] = self.committerName!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.parentIds != nil {
                    map["parentIds"] = self.parentIds!
                }
                if self.shortId != nil {
                    map["shortId"] = self.shortId!
                }
                if self.signature != nil {
                    map["signature"] = self.signature?.toMap()
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("authorEmail") {
                    self.authorEmail = dict["authorEmail"] as! String
                }
                if dict.keys.contains("authorName") {
                    self.authorName = dict["authorName"] as! String
                }
                if dict.keys.contains("authoredDate") {
                    self.authoredDate = dict["authoredDate"] as! String
                }
                if dict.keys.contains("committedDate") {
                    self.committedDate = dict["committedDate"] as! String
                }
                if dict.keys.contains("committerEmail") {
                    self.committerEmail = dict["committerEmail"] as! String
                }
                if dict.keys.contains("committerName") {
                    self.committerName = dict["committerName"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("parentIds") {
                    self.parentIds = dict["parentIds"] as! [String]
                }
                if dict.keys.contains("shortId") {
                    self.shortId = dict["shortId"] as! String
                }
                if dict.keys.contains("signature") {
                    var model = ListRepositoryTagsResponseBody.Result.Commit.Signature()
                    model.fromMap(dict["signature"] as! [String: Any])
                    self.signature = model
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public var commit: ListRepositoryTagsResponseBody.Result.Commit?

        public var id: String?

        public var message: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.commit?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commit != nil {
                map["commit"] = self.commit?.toMap()
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("commit") {
                var model = ListRepositoryTagsResponseBody.Result.Commit()
                model.fromMap(dict["commit"] as! [String: Any])
                self.commit = model
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("message") {
                self.message = dict["message"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryTagsResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListRepositoryTagsResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListRepositoryTagsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListRepositoryTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRepositoryTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRepositoryTreeRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var path: String?

    public var refName: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.refName != nil {
            map["refName"] = self.refName!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("path") {
            self.path = dict["path"] as! String
        }
        if dict.keys.contains("refName") {
            self.refName = dict["refName"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class ListRepositoryTreeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var id: String?

        public var isLFS: Bool?

        public var mode: String?

        public var name: String?

        public var path: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isLFS != nil {
                map["isLFS"] = self.isLFS!
            }
            if self.mode != nil {
                map["mode"] = self.mode!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isLFS") {
                self.isLFS = dict["isLFS"] as! Bool
            }
            if dict.keys.contains("mode") {
                self.mode = dict["mode"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryTreeResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListRepositoryTreeResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListRepositoryTreeResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListRepositoryTreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryTreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRepositoryTreeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRepositoryWebhookRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
    }
}

public class ListRepositoryWebhookResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var description_: String?

        public var enableSslVerification: Bool?

        public var id: Int64?

        public var lastTestResult: String?

        public var mergeRequestsEvents: Bool?

        public var noteEvents: Bool?

        public var projectId: Int64?

        public var pushEvents: Bool?

        public var secretToken: String?

        public var tagPushEvents: Bool?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.enableSslVerification != nil {
                map["enableSslVerification"] = self.enableSslVerification!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastTestResult != nil {
                map["lastTestResult"] = self.lastTestResult!
            }
            if self.mergeRequestsEvents != nil {
                map["mergeRequestsEvents"] = self.mergeRequestsEvents!
            }
            if self.noteEvents != nil {
                map["noteEvents"] = self.noteEvents!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.pushEvents != nil {
                map["pushEvents"] = self.pushEvents!
            }
            if self.secretToken != nil {
                map["secretToken"] = self.secretToken!
            }
            if self.tagPushEvents != nil {
                map["tagPushEvents"] = self.tagPushEvents!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("enableSslVerification") {
                self.enableSslVerification = dict["enableSslVerification"] as! Bool
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("lastTestResult") {
                self.lastTestResult = dict["lastTestResult"] as! String
            }
            if dict.keys.contains("mergeRequestsEvents") {
                self.mergeRequestsEvents = dict["mergeRequestsEvents"] as! Bool
            }
            if dict.keys.contains("noteEvents") {
                self.noteEvents = dict["noteEvents"] as! Bool
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! Int64
            }
            if dict.keys.contains("pushEvents") {
                self.pushEvents = dict["pushEvents"] as! Bool
            }
            if dict.keys.contains("secretToken") {
                self.secretToken = dict["secretToken"] as! String
            }
            if dict.keys.contains("tagPushEvents") {
                self.tagPushEvents = dict["tagPushEvents"] as! Bool
            }
            if dict.keys.contains("url") {
                self.url = dict["url"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListRepositoryWebhookResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListRepositoryWebhookResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListRepositoryWebhookResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListRepositoryWebhookResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRepositoryWebhookResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRepositoryWebhookResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListResourceMembersResponseBody : Tea.TeaModel {
    public class ResourceMembers : Tea.TeaModel {
        public var accountId: String?

        public var roleName: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            if self.roleName != nil {
                map["roleName"] = self.roleName!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
            if dict.keys.contains("roleName") {
                self.roleName = dict["roleName"] as! String
            }
            if dict.keys.contains("username") {
                self.username = dict["username"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var resourceMembers: [ListResourceMembersResponseBody.ResourceMembers]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resourceMembers != nil {
            var tmp : [Any] = []
            for k in self.resourceMembers! {
                tmp.append(k.toMap())
            }
            map["resourceMembers"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resourceMembers") {
            var tmp : [ListResourceMembersResponseBody.ResourceMembers] = []
            for v in dict["resourceMembers"] as! [Any] {
                var model = ListResourceMembersResponseBody.ResourceMembers()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceMembers = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListResourceMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourceMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListResourceMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSearchCommitRequest : Tea.TeaModel {
    public class RepoPath : Tea.TeaModel {
        public var matchType: String?

        public var operatorType: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchType != nil {
                map["matchType"] = self.matchType!
            }
            if self.operatorType != nil {
                map["operatorType"] = self.operatorType!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("matchType") {
                self.matchType = dict["matchType"] as! String
            }
            if dict.keys.contains("operatorType") {
                self.operatorType = dict["operatorType"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var keyword: String?

    public var order: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var repoPath: ListSearchCommitRequest.RepoPath?

    public var scope: String?

    public var sort: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.repoPath?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["keyword"] = self.keyword!
        }
        if self.order != nil {
            map["order"] = self.order!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.repoPath != nil {
            map["repoPath"] = self.repoPath?.toMap()
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("keyword") {
            self.keyword = dict["keyword"] as! String
        }
        if dict.keys.contains("order") {
            self.order = dict["order"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("repoPath") {
            var model = ListSearchCommitRequest.RepoPath()
            model.fromMap(dict["repoPath"] as! [String: Any])
            self.repoPath = model
        }
        if dict.keys.contains("scope") {
            self.scope = dict["scope"] as! String
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ListSearchCommitResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class HighlightTextMap : Tea.TeaModel {
            public var commitId: String?

            public var commitMessage: String?

            public var organizationId: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commitId != nil {
                    map["commitId"] = self.commitId!
                }
                if self.commitMessage != nil {
                    map["commitMessage"] = self.commitMessage!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("commitId") {
                    self.commitId = dict["commitId"] as! String
                }
                if dict.keys.contains("commitMessage") {
                    self.commitMessage = dict["commitMessage"] as! String
                }
                if dict.keys.contains("organizationId") {
                    self.organizationId = dict["organizationId"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class Source : Tea.TeaModel {
            public class Author : Tea.TeaModel {
                public var email: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.email != nil {
                        map["email"] = self.email!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("email") {
                        self.email = dict["email"] as! String
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                }
            }
            public var author: ListSearchCommitResponseBody.Result.Source.Author?

            public var authorTime: String?

            public var commitId: String?

            public var commitMessage: String?

            public var organizationId: String?

            public var repoPath: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.author?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.author != nil {
                    map["author"] = self.author?.toMap()
                }
                if self.authorTime != nil {
                    map["authorTime"] = self.authorTime!
                }
                if self.commitId != nil {
                    map["commitId"] = self.commitId!
                }
                if self.commitMessage != nil {
                    map["commitMessage"] = self.commitMessage!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.repoPath != nil {
                    map["repoPath"] = self.repoPath!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("author") {
                    var model = ListSearchCommitResponseBody.Result.Source.Author()
                    model.fromMap(dict["author"] as! [String: Any])
                    self.author = model
                }
                if dict.keys.contains("authorTime") {
                    self.authorTime = dict["authorTime"] as! String
                }
                if dict.keys.contains("commitId") {
                    self.commitId = dict["commitId"] as! String
                }
                if dict.keys.contains("commitMessage") {
                    self.commitMessage = dict["commitMessage"] as! String
                }
                if dict.keys.contains("organizationId") {
                    self.organizationId = dict["organizationId"] as! String
                }
                if dict.keys.contains("repoPath") {
                    self.repoPath = dict["repoPath"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public var docId: String?

        public var highlightTextMap: ListSearchCommitResponseBody.Result.HighlightTextMap?

        public var source: ListSearchCommitResponseBody.Result.Source?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.highlightTextMap?.validate()
            try self.source?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.docId != nil {
                map["docId"] = self.docId!
            }
            if self.highlightTextMap != nil {
                map["highlightTextMap"] = self.highlightTextMap?.toMap()
            }
            if self.source != nil {
                map["source"] = self.source?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("docId") {
                self.docId = dict["docId"] as! String
            }
            if dict.keys.contains("highlightTextMap") {
                var model = ListSearchCommitResponseBody.Result.HighlightTextMap()
                model.fromMap(dict["highlightTextMap"] as! [String: Any])
                self.highlightTextMap = model
            }
            if dict.keys.contains("source") {
                var model = ListSearchCommitResponseBody.Result.Source()
                model.fromMap(dict["source"] as! [String: Any])
                self.source = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListSearchCommitResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListSearchCommitResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListSearchCommitResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListSearchCommitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSearchCommitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSearchCommitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSearchRepositoryRequest : Tea.TeaModel {
    public class RepoPath : Tea.TeaModel {
        public var matchType: String?

        public var operatorType: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchType != nil {
                map["matchType"] = self.matchType!
            }
            if self.operatorType != nil {
                map["operatorType"] = self.operatorType!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("matchType") {
                self.matchType = dict["matchType"] as! String
            }
            if dict.keys.contains("operatorType") {
                self.operatorType = dict["operatorType"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var aliyunPk: String?

    public var keyword: String?

    public var order: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var repoPath: ListSearchRepositoryRequest.RepoPath?

    public var scope: String?

    public var sort: String?

    public var visibilityLevel: Int32?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.repoPath?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunPk != nil {
            map["aliyunPk"] = self.aliyunPk!
        }
        if self.keyword != nil {
            map["keyword"] = self.keyword!
        }
        if self.order != nil {
            map["order"] = self.order!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.repoPath != nil {
            map["repoPath"] = self.repoPath?.toMap()
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.visibilityLevel != nil {
            map["visibilityLevel"] = self.visibilityLevel!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("aliyunPk") {
            self.aliyunPk = dict["aliyunPk"] as! String
        }
        if dict.keys.contains("keyword") {
            self.keyword = dict["keyword"] as! String
        }
        if dict.keys.contains("order") {
            self.order = dict["order"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("repoPath") {
            var model = ListSearchRepositoryRequest.RepoPath()
            model.fromMap(dict["repoPath"] as! [String: Any])
            self.repoPath = model
        }
        if dict.keys.contains("scope") {
            self.scope = dict["scope"] as! String
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
        if dict.keys.contains("visibilityLevel") {
            self.visibilityLevel = dict["visibilityLevel"] as! Int32
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ListSearchRepositoryResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class HighlightTextMap : Tea.TeaModel {
            public var creatorUserId: String?

            public var description_: String?

            public var organizationId: String?

            public var readMe: String?

            public var repoNameWithNamespace: String?

            public var repoPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creatorUserId != nil {
                    map["creatorUserId"] = self.creatorUserId!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.readMe != nil {
                    map["readMe"] = self.readMe!
                }
                if self.repoNameWithNamespace != nil {
                    map["repoNameWithNamespace"] = self.repoNameWithNamespace!
                }
                if self.repoPath != nil {
                    map["repoPath"] = self.repoPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("creatorUserId") {
                    self.creatorUserId = dict["creatorUserId"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("organizationId") {
                    self.organizationId = dict["organizationId"] as! String
                }
                if dict.keys.contains("readMe") {
                    self.readMe = dict["readMe"] as! String
                }
                if dict.keys.contains("repoNameWithNamespace") {
                    self.repoNameWithNamespace = dict["repoNameWithNamespace"] as! String
                }
                if dict.keys.contains("repoPath") {
                    self.repoPath = dict["repoPath"] as! String
                }
            }
        }
        public class Source : Tea.TeaModel {
            public var createTime: String?

            public var description_: String?

            public var lastActivityTime: String?

            public var organizationId: String?

            public var readMe: String?

            public var repoName: String?

            public var repoPath: String?

            public var visibilityLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["createTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.lastActivityTime != nil {
                    map["lastActivityTime"] = self.lastActivityTime!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.readMe != nil {
                    map["readMe"] = self.readMe!
                }
                if self.repoName != nil {
                    map["repoName"] = self.repoName!
                }
                if self.repoPath != nil {
                    map["repoPath"] = self.repoPath!
                }
                if self.visibilityLevel != nil {
                    map["visibilityLevel"] = self.visibilityLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("createTime") {
                    self.createTime = dict["createTime"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("lastActivityTime") {
                    self.lastActivityTime = dict["lastActivityTime"] as! String
                }
                if dict.keys.contains("organizationId") {
                    self.organizationId = dict["organizationId"] as! String
                }
                if dict.keys.contains("readMe") {
                    self.readMe = dict["readMe"] as! String
                }
                if dict.keys.contains("repoName") {
                    self.repoName = dict["repoName"] as! String
                }
                if dict.keys.contains("repoPath") {
                    self.repoPath = dict["repoPath"] as! String
                }
                if dict.keys.contains("visibilityLevel") {
                    self.visibilityLevel = dict["visibilityLevel"] as! Int32
                }
            }
        }
        public var docId: String?

        public var highlightTextMap: ListSearchRepositoryResponseBody.Result.HighlightTextMap?

        public var source: ListSearchRepositoryResponseBody.Result.Source?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.highlightTextMap?.validate()
            try self.source?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.docId != nil {
                map["docId"] = self.docId!
            }
            if self.highlightTextMap != nil {
                map["highlightTextMap"] = self.highlightTextMap?.toMap()
            }
            if self.source != nil {
                map["source"] = self.source?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("docId") {
                self.docId = dict["docId"] as! String
            }
            if dict.keys.contains("highlightTextMap") {
                var model = ListSearchRepositoryResponseBody.Result.HighlightTextMap()
                model.fromMap(dict["highlightTextMap"] as! [String: Any])
                self.highlightTextMap = model
            }
            if dict.keys.contains("source") {
                var model = ListSearchRepositoryResponseBody.Result.Source()
                model.fromMap(dict["source"] as! [String: Any])
                self.source = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListSearchRepositoryResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListSearchRepositoryResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListSearchRepositoryResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListSearchRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSearchRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSearchRepositoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSearchSourceCodeRequest : Tea.TeaModel {
    public class FilePath : Tea.TeaModel {
        public var matchType: String?

        public var operatorType: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchType != nil {
                map["matchType"] = self.matchType!
            }
            if self.operatorType != nil {
                map["operatorType"] = self.operatorType!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("matchType") {
                self.matchType = dict["matchType"] as! String
            }
            if dict.keys.contains("operatorType") {
                self.operatorType = dict["operatorType"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public class RepoPath : Tea.TeaModel {
        public var matchType: String?

        public var operatorType: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchType != nil {
                map["matchType"] = self.matchType!
            }
            if self.operatorType != nil {
                map["operatorType"] = self.operatorType!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("matchType") {
                self.matchType = dict["matchType"] as! String
            }
            if dict.keys.contains("operatorType") {
                self.operatorType = dict["operatorType"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var filePath: ListSearchSourceCodeRequest.FilePath?

    public var isCodeBlock: Bool?

    public var keyword: String?

    public var language: String?

    public var order: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var repoPath: ListSearchSourceCodeRequest.RepoPath?

    public var scope: String?

    public var sort: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filePath?.validate()
        try self.repoPath?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["filePath"] = self.filePath?.toMap()
        }
        if self.isCodeBlock != nil {
            map["isCodeBlock"] = self.isCodeBlock!
        }
        if self.keyword != nil {
            map["keyword"] = self.keyword!
        }
        if self.language != nil {
            map["language"] = self.language!
        }
        if self.order != nil {
            map["order"] = self.order!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.repoPath != nil {
            map["repoPath"] = self.repoPath?.toMap()
        }
        if self.scope != nil {
            map["scope"] = self.scope!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("filePath") {
            var model = ListSearchSourceCodeRequest.FilePath()
            model.fromMap(dict["filePath"] as! [String: Any])
            self.filePath = model
        }
        if dict.keys.contains("isCodeBlock") {
            self.isCodeBlock = dict["isCodeBlock"] as! Bool
        }
        if dict.keys.contains("keyword") {
            self.keyword = dict["keyword"] as! String
        }
        if dict.keys.contains("language") {
            self.language = dict["language"] as! String
        }
        if dict.keys.contains("order") {
            self.order = dict["order"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("repoPath") {
            var model = ListSearchSourceCodeRequest.RepoPath()
            model.fromMap(dict["repoPath"] as! [String: Any])
            self.repoPath = model
        }
        if dict.keys.contains("scope") {
            self.scope = dict["scope"] as! String
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ListSearchSourceCodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class HighlightTextMap : Tea.TeaModel {
            public var clob: String?

            public var fileName: String?

            public var language: String?

            public var organizationId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clob != nil {
                    map["clob"] = self.clob!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                if self.language != nil {
                    map["language"] = self.language!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("clob") {
                    self.clob = dict["clob"] as! String
                }
                if dict.keys.contains("fileName") {
                    self.fileName = dict["fileName"] as! String
                }
                if dict.keys.contains("language") {
                    self.language = dict["language"] as! String
                }
                if dict.keys.contains("organizationId") {
                    self.organizationId = dict["organizationId"] as! String
                }
            }
        }
        public class Source : Tea.TeaModel {
            public var branch: String?

            public var checkinDate: String?

            public var fileName: String?

            public var filePath: String?

            public var language: String?

            public var organizationId: String?

            public var repoPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.branch != nil {
                    map["branch"] = self.branch!
                }
                if self.checkinDate != nil {
                    map["checkinDate"] = self.checkinDate!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                if self.filePath != nil {
                    map["filePath"] = self.filePath!
                }
                if self.language != nil {
                    map["language"] = self.language!
                }
                if self.organizationId != nil {
                    map["organizationId"] = self.organizationId!
                }
                if self.repoPath != nil {
                    map["repoPath"] = self.repoPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("branch") {
                    self.branch = dict["branch"] as! String
                }
                if dict.keys.contains("checkinDate") {
                    self.checkinDate = dict["checkinDate"] as! String
                }
                if dict.keys.contains("fileName") {
                    self.fileName = dict["fileName"] as! String
                }
                if dict.keys.contains("filePath") {
                    self.filePath = dict["filePath"] as! String
                }
                if dict.keys.contains("language") {
                    self.language = dict["language"] as! String
                }
                if dict.keys.contains("organizationId") {
                    self.organizationId = dict["organizationId"] as! String
                }
                if dict.keys.contains("repoPath") {
                    self.repoPath = dict["repoPath"] as! String
                }
            }
        }
        public var docId: String?

        public var highlightTextMap: ListSearchSourceCodeResponseBody.Result.HighlightTextMap?

        public var source: ListSearchSourceCodeResponseBody.Result.Source?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.highlightTextMap?.validate()
            try self.source?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.docId != nil {
                map["docId"] = self.docId!
            }
            if self.highlightTextMap != nil {
                map["highlightTextMap"] = self.highlightTextMap?.toMap()
            }
            if self.source != nil {
                map["source"] = self.source?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("docId") {
                self.docId = dict["docId"] as! String
            }
            if dict.keys.contains("highlightTextMap") {
                var model = ListSearchSourceCodeResponseBody.Result.HighlightTextMap()
                model.fromMap(dict["highlightTextMap"] as! [String: Any])
                self.highlightTextMap = model
            }
            if dict.keys.contains("source") {
                var model = ListSearchSourceCodeResponseBody.Result.Source()
                model.fromMap(dict["source"] as! [String: Any])
                self.source = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListSearchSourceCodeResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListSearchSourceCodeResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListSearchSourceCodeResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListSearchSourceCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSearchSourceCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSearchSourceCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServiceAuthsRequest : Tea.TeaModel {
    public var serviceAuthType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serviceAuthType != nil {
            map["serviceAuthType"] = self.serviceAuthType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("serviceAuthType") {
            self.serviceAuthType = dict["serviceAuthType"] as! String
        }
    }
}

public class ListServiceAuthsResponseBody : Tea.TeaModel {
    public class ServiceAuths : Tea.TeaModel {
        public var id: Int64?

        public var ownerName: String?

        public var ownerStaffId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ownerName != nil {
                map["ownerName"] = self.ownerName!
            }
            if self.ownerStaffId != nil {
                map["ownerStaffId"] = self.ownerStaffId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("ownerName") {
                self.ownerName = dict["ownerName"] as! String
            }
            if dict.keys.contains("ownerStaffId") {
                self.ownerStaffId = dict["ownerStaffId"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var serviceAuths: [ListServiceAuthsResponseBody.ServiceAuths]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.serviceAuths != nil {
            var tmp : [Any] = []
            for k in self.serviceAuths! {
                tmp.append(k.toMap())
            }
            map["serviceAuths"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("serviceAuths") {
            var tmp : [ListServiceAuthsResponseBody.ServiceAuths] = []
            for v in dict["serviceAuths"] as! [Any] {
                var model = ListServiceAuthsResponseBody.ServiceAuths()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceAuths = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListServiceAuthsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceAuthsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListServiceAuthsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServiceConnectionsRequest : Tea.TeaModel {
    public var sericeConnectionType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sericeConnectionType != nil {
            map["sericeConnectionType"] = self.sericeConnectionType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("sericeConnectionType") {
            self.sericeConnectionType = dict["sericeConnectionType"] as! String
        }
    }
}

public class ListServiceConnectionsResponseBody : Tea.TeaModel {
    public class ServiceConnections : Tea.TeaModel {
        public var createTime: Int64?

        public var id: Int64?

        public var name: String?

        public var ownerAccountId: Int64?

        public var type: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerAccountId != nil {
                map["ownerAccountId"] = self.ownerAccountId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.uuid != nil {
                map["uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("ownerAccountId") {
                self.ownerAccountId = dict["ownerAccountId"] as! Int64
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("uuid") {
                self.uuid = dict["uuid"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var serviceConnections: [ListServiceConnectionsResponseBody.ServiceConnections]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.serviceConnections != nil {
            var tmp : [Any] = []
            for k in self.serviceConnections! {
                tmp.append(k.toMap())
            }
            map["serviceConnections"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("serviceConnections") {
            var tmp : [ListServiceConnectionsResponseBody.ServiceConnections] = []
            for v in dict["serviceConnections"] as! [Any] {
                var model = ListServiceConnectionsResponseBody.ServiceConnections()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceConnections = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListServiceConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListServiceConnectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServiceCredentialsRequest : Tea.TeaModel {
    public var serviceCredentialType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serviceCredentialType != nil {
            map["serviceCredentialType"] = self.serviceCredentialType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("serviceCredentialType") {
            self.serviceCredentialType = dict["serviceCredentialType"] as! String
        }
    }
}

public class ListServiceCredentialsResponseBody : Tea.TeaModel {
    public class ServiceCredentials : Tea.TeaModel {
        public var id: Int64?

        public var ownerName: String?

        public var ownerStaffId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ownerName != nil {
                map["ownerName"] = self.ownerName!
            }
            if self.ownerStaffId != nil {
                map["ownerStaffId"] = self.ownerStaffId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("ownerName") {
                self.ownerName = dict["ownerName"] as! String
            }
            if dict.keys.contains("ownerStaffId") {
                self.ownerStaffId = dict["ownerStaffId"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var serviceCredentials: [ListServiceCredentialsResponseBody.ServiceCredentials]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.serviceCredentials != nil {
            var tmp : [Any] = []
            for k in self.serviceCredentials! {
                tmp.append(k.toMap())
            }
            map["serviceCredentials"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("serviceCredentials") {
            var tmp : [ListServiceCredentialsResponseBody.ServiceCredentials] = []
            for v in dict["serviceCredentials"] as! [Any] {
                var model = ListServiceCredentialsResponseBody.ServiceCredentials()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceCredentials = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListServiceCredentialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceCredentialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListServiceCredentialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSprintsRequest : Tea.TeaModel {
    public var maxResults: Int64?

    public var nextToken: String?

    public var spaceIdentifier: String?

    public var spaceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("spaceIdentifier") {
            self.spaceIdentifier = dict["spaceIdentifier"] as! String
        }
        if dict.keys.contains("spaceType") {
            self.spaceType = dict["spaceType"] as! String
        }
    }
}

public class ListSprintsResponseBody : Tea.TeaModel {
    public class Sprints : Tea.TeaModel {
        public var creator: String?

        public var description_: String?

        public var endDate: Int64?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var scope: String?

        public var spaceIdentifier: String?

        public var startDate: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endDate != nil {
                map["endDate"] = self.endDate!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.startDate != nil {
                map["startDate"] = self.startDate!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("endDate") {
                self.endDate = dict["endDate"] as! Int64
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("scope") {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("startDate") {
                self.startDate = dict["startDate"] as! Int64
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var sprints: [ListSprintsResponseBody.Sprints]?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.sprints != nil {
            var tmp : [Any] = []
            for k in self.sprints! {
                tmp.append(k.toMap())
            }
            map["sprints"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("sprints") {
            var tmp : [ListSprintsResponseBody.Sprints] = []
            for v in dict["sprints"] as! [Any] {
                var model = ListSprintsResponseBody.Sprints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sprints = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
    }
}

public class ListSprintsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSprintsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSprintsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTestCaseFieldsRequest : Tea.TeaModel {
    public var spaceIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("spaceIdentifier") {
            self.spaceIdentifier = dict["spaceIdentifier"] as! String
        }
    }
}

public class ListTestCaseFieldsResponseBody : Tea.TeaModel {
    public class Fields : Tea.TeaModel {
        public class Options : Tea.TeaModel {
            public var displayValue: String?

            public var fieldIdentifier: String?

            public var identifier: String?

            public var level: Int64?

            public var position: Int64?

            public var value: String?

            public var valueEn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayValue != nil {
                    map["displayValue"] = self.displayValue!
                }
                if self.fieldIdentifier != nil {
                    map["fieldIdentifier"] = self.fieldIdentifier!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.level != nil {
                    map["level"] = self.level!
                }
                if self.position != nil {
                    map["position"] = self.position!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                if self.valueEn != nil {
                    map["valueEn"] = self.valueEn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("displayValue") {
                    self.displayValue = dict["displayValue"] as! String
                }
                if dict.keys.contains("fieldIdentifier") {
                    self.fieldIdentifier = dict["fieldIdentifier"] as! String
                }
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
                if dict.keys.contains("level") {
                    self.level = dict["level"] as! Int64
                }
                if dict.keys.contains("position") {
                    self.position = dict["position"] as! Int64
                }
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
                if dict.keys.contains("valueEn") {
                    self.valueEn = dict["valueEn"] as! String
                }
            }
        }
        public var className: String?

        public var creator: String?

        public var defaultValue: String?

        public var description_: String?

        public var format: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var isRequired: Bool?

        public var isShowWhenCreate: Bool?

        public var isSystemRequired: Bool?

        public var linkWithService: String?

        public var modifier: String?

        public var name: String?

        public var options: [ListTestCaseFieldsResponseBody.Fields.Options]?

        public var resourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.className != nil {
                map["className"] = self.className!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.defaultValue != nil {
                map["defaultValue"] = self.defaultValue!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.format != nil {
                map["format"] = self.format!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.isShowWhenCreate != nil {
                map["isShowWhenCreate"] = self.isShowWhenCreate!
            }
            if self.isSystemRequired != nil {
                map["isSystemRequired"] = self.isSystemRequired!
            }
            if self.linkWithService != nil {
                map["linkWithService"] = self.linkWithService!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.options != nil {
                var tmp : [Any] = []
                for k in self.options! {
                    tmp.append(k.toMap())
                }
                map["options"] = tmp
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("className") {
                self.className = dict["className"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("defaultValue") {
                self.defaultValue = dict["defaultValue"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("format") {
                self.format = dict["format"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("isRequired") {
                self.isRequired = dict["isRequired"] as! Bool
            }
            if dict.keys.contains("isShowWhenCreate") {
                self.isShowWhenCreate = dict["isShowWhenCreate"] as! Bool
            }
            if dict.keys.contains("isSystemRequired") {
                self.isSystemRequired = dict["isSystemRequired"] as! Bool
            }
            if dict.keys.contains("linkWithService") {
                self.linkWithService = dict["linkWithService"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("options") {
                var tmp : [ListTestCaseFieldsResponseBody.Fields.Options] = []
                for v in dict["options"] as! [Any] {
                    var model = ListTestCaseFieldsResponseBody.Fields.Options()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.options = tmp
            }
            if dict.keys.contains("resourceType") {
                self.resourceType = dict["resourceType"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var fields: [ListTestCaseFieldsResponseBody.Fields]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.fields != nil {
            var tmp : [Any] = []
            for k in self.fields! {
                tmp.append(k.toMap())
            }
            map["fields"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("fields") {
            var tmp : [ListTestCaseFieldsResponseBody.Fields] = []
            for v in dict["fields"] as! [Any] {
                var model = ListTestCaseFieldsResponseBody.Fields()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fields = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListTestCaseFieldsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTestCaseFieldsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTestCaseFieldsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserDrawRecordByPkRequest : Tea.TeaModel {
    public var aliyunPk: String?

    public var drawGroup: String?

    public var drawPoolName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunPk != nil {
            map["aliyunPk"] = self.aliyunPk!
        }
        if self.drawGroup != nil {
            map["drawGroup"] = self.drawGroup!
        }
        if self.drawPoolName != nil {
            map["drawPoolName"] = self.drawPoolName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("aliyunPk") {
            self.aliyunPk = dict["aliyunPk"] as! String
        }
        if dict.keys.contains("drawGroup") {
            self.drawGroup = dict["drawGroup"] as! String
        }
        if dict.keys.contains("drawPoolName") {
            self.drawPoolName = dict["drawPoolName"] as! String
        }
    }
}

public class ListUserDrawRecordByPkResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var aliyunPk: String?

        public var drawGroup: String?

        public var drawPoolName: String?

        public var drawResult: String?

        public var gmtCreate: String?

        public var taskGroupId: String?

        public var uccId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunPk != nil {
                map["aliyunPk"] = self.aliyunPk!
            }
            if self.drawGroup != nil {
                map["drawGroup"] = self.drawGroup!
            }
            if self.drawPoolName != nil {
                map["drawPoolName"] = self.drawPoolName!
            }
            if self.drawResult != nil {
                map["drawResult"] = self.drawResult!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.taskGroupId != nil {
                map["taskGroupId"] = self.taskGroupId!
            }
            if self.uccId != nil {
                map["uccId"] = self.uccId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("aliyunPk") {
                self.aliyunPk = dict["aliyunPk"] as! String
            }
            if dict.keys.contains("drawGroup") {
                self.drawGroup = dict["drawGroup"] as! String
            }
            if dict.keys.contains("drawPoolName") {
                self.drawPoolName = dict["drawPoolName"] as! String
            }
            if dict.keys.contains("drawResult") {
                self.drawResult = dict["drawResult"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("taskGroupId") {
                self.taskGroupId = dict["taskGroupId"] as! String
            }
            if dict.keys.contains("uccId") {
                self.uccId = dict["uccId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListUserDrawRecordByPkResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["data"] = tmp
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! String
        }
        if dict.keys.contains("data") {
            var tmp : [ListUserDrawRecordByPkResponseBody.Data] = []
            for v in dict["data"] as! [Any] {
                var model = ListUserDrawRecordByPkResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListUserDrawRecordByPkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserDrawRecordByPkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUserDrawRecordByPkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserKeysRequest : Tea.TeaModel {
    public var accessToken: String?

    public var orderBy: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var sort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("orderBy") {
            self.orderBy = dict["orderBy"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
    }
}

public class ListUserKeysResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var expireTime: String?

        public var fingerPrint: String?

        public var id: Int64?

        public var keyScope: String?

        public var lastUsedTime: String?

        public var publicKey: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.expireTime != nil {
                map["expireTime"] = self.expireTime!
            }
            if self.fingerPrint != nil {
                map["fingerPrint"] = self.fingerPrint!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.keyScope != nil {
                map["keyScope"] = self.keyScope!
            }
            if self.lastUsedTime != nil {
                map["lastUsedTime"] = self.lastUsedTime!
            }
            if self.publicKey != nil {
                map["publicKey"] = self.publicKey!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("expireTime") {
                self.expireTime = dict["expireTime"] as! String
            }
            if dict.keys.contains("fingerPrint") {
                self.fingerPrint = dict["fingerPrint"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("keyScope") {
                self.keyScope = dict["keyScope"] as! String
            }
            if dict.keys.contains("lastUsedTime") {
                self.lastUsedTime = dict["lastUsedTime"] as! String
            }
            if dict.keys.contains("publicKey") {
                self.publicKey = dict["publicKey"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListUserKeysResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListUserKeysResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListUserKeysResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListUserKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUserKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserResourcesRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public var page: Int64?

    public var pageSize: Int64?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.userIds != nil {
            map["userIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int64
        }
        if dict.keys.contains("userIds") {
            self.userIds = dict["userIds"] as! String
        }
    }
}

public class ListUserResourcesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class GroupInfos : Tea.TeaModel {
            public class GroupInfo : Tea.TeaModel {
                public var createdAt: String?

                public var description_: String?

                public var id: Int64?

                public var name: String?

                public var nameWithNamespace: String?

                public var ownerId: Int64?

                public var parentId: Int64?

                public var path: String?

                public var pathWithNamespace: String?

                public var updatedAt: String?

                public var visibilityLevel: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.createdAt != nil {
                        map["createdAt"] = self.createdAt!
                    }
                    if self.description_ != nil {
                        map["description"] = self.description_!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.nameWithNamespace != nil {
                        map["nameWithNamespace"] = self.nameWithNamespace!
                    }
                    if self.ownerId != nil {
                        map["ownerId"] = self.ownerId!
                    }
                    if self.parentId != nil {
                        map["parentId"] = self.parentId!
                    }
                    if self.path != nil {
                        map["path"] = self.path!
                    }
                    if self.pathWithNamespace != nil {
                        map["pathWithNamespace"] = self.pathWithNamespace!
                    }
                    if self.updatedAt != nil {
                        map["updatedAt"] = self.updatedAt!
                    }
                    if self.visibilityLevel != nil {
                        map["visibilityLevel"] = self.visibilityLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("createdAt") {
                        self.createdAt = dict["createdAt"] as! String
                    }
                    if dict.keys.contains("description") {
                        self.description_ = dict["description"] as! String
                    }
                    if dict.keys.contains("id") {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("nameWithNamespace") {
                        self.nameWithNamespace = dict["nameWithNamespace"] as! String
                    }
                    if dict.keys.contains("ownerId") {
                        self.ownerId = dict["ownerId"] as! Int64
                    }
                    if dict.keys.contains("parentId") {
                        self.parentId = dict["parentId"] as! Int64
                    }
                    if dict.keys.contains("path") {
                        self.path = dict["path"] as! String
                    }
                    if dict.keys.contains("pathWithNamespace") {
                        self.pathWithNamespace = dict["pathWithNamespace"] as! String
                    }
                    if dict.keys.contains("updatedAt") {
                        self.updatedAt = dict["updatedAt"] as! String
                    }
                    if dict.keys.contains("visibilityLevel") {
                        self.visibilityLevel = dict["visibilityLevel"] as! Int32
                    }
                }
            }
            public class GroupRole : Tea.TeaModel {
                public var accessLevel: Int32?

                public var cnRoleName: String?

                public var enRoleName: String?

                public var sourceId: Int64?

                public var sourceType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessLevel != nil {
                        map["accessLevel"] = self.accessLevel!
                    }
                    if self.cnRoleName != nil {
                        map["cnRoleName"] = self.cnRoleName!
                    }
                    if self.enRoleName != nil {
                        map["enRoleName"] = self.enRoleName!
                    }
                    if self.sourceId != nil {
                        map["sourceId"] = self.sourceId!
                    }
                    if self.sourceType != nil {
                        map["sourceType"] = self.sourceType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("accessLevel") {
                        self.accessLevel = dict["accessLevel"] as! Int32
                    }
                    if dict.keys.contains("cnRoleName") {
                        self.cnRoleName = dict["cnRoleName"] as! String
                    }
                    if dict.keys.contains("enRoleName") {
                        self.enRoleName = dict["enRoleName"] as! String
                    }
                    if dict.keys.contains("sourceId") {
                        self.sourceId = dict["sourceId"] as! Int64
                    }
                    if dict.keys.contains("sourceType") {
                        self.sourceType = dict["sourceType"] as! String
                    }
                }
            }
            public var groupInfo: ListUserResourcesResponseBody.Result.GroupInfos.GroupInfo?

            public var groupRole: ListUserResourcesResponseBody.Result.GroupInfos.GroupRole?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.groupInfo?.validate()
                try self.groupRole?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupInfo != nil {
                    map["groupInfo"] = self.groupInfo?.toMap()
                }
                if self.groupRole != nil {
                    map["groupRole"] = self.groupRole?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("groupInfo") {
                    var model = ListUserResourcesResponseBody.Result.GroupInfos.GroupInfo()
                    model.fromMap(dict["groupInfo"] as! [String: Any])
                    self.groupInfo = model
                }
                if dict.keys.contains("groupRole") {
                    var model = ListUserResourcesResponseBody.Result.GroupInfos.GroupRole()
                    model.fromMap(dict["groupRole"] as! [String: Any])
                    self.groupRole = model
                }
            }
        }
        public class RepositoryInfos : Tea.TeaModel {
            public class RepositoryInfo : Tea.TeaModel {
                public var accessLevel: Int32?

                public var archived: Bool?

                public var createdAt: String?

                public var creatorId: Int64?

                public var description_: String?

                public var encrypted: Bool?

                public var id: Int64?

                public var lastActivityAt: String?

                public var name: String?

                public var nameWithNamespace: String?

                public var namespaceId: Int64?

                public var path: String?

                public var pathWithNamespace: String?

                public var updatedAt: String?

                public var visibilityLevel: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessLevel != nil {
                        map["accessLevel"] = self.accessLevel!
                    }
                    if self.archived != nil {
                        map["archived"] = self.archived!
                    }
                    if self.createdAt != nil {
                        map["createdAt"] = self.createdAt!
                    }
                    if self.creatorId != nil {
                        map["creatorId"] = self.creatorId!
                    }
                    if self.description_ != nil {
                        map["description"] = self.description_!
                    }
                    if self.encrypted != nil {
                        map["encrypted"] = self.encrypted!
                    }
                    if self.id != nil {
                        map["id"] = self.id!
                    }
                    if self.lastActivityAt != nil {
                        map["lastActivityAt"] = self.lastActivityAt!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.nameWithNamespace != nil {
                        map["nameWithNamespace"] = self.nameWithNamespace!
                    }
                    if self.namespaceId != nil {
                        map["namespaceId"] = self.namespaceId!
                    }
                    if self.path != nil {
                        map["path"] = self.path!
                    }
                    if self.pathWithNamespace != nil {
                        map["pathWithNamespace"] = self.pathWithNamespace!
                    }
                    if self.updatedAt != nil {
                        map["updatedAt"] = self.updatedAt!
                    }
                    if self.visibilityLevel != nil {
                        map["visibilityLevel"] = self.visibilityLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("accessLevel") {
                        self.accessLevel = dict["accessLevel"] as! Int32
                    }
                    if dict.keys.contains("archived") {
                        self.archived = dict["archived"] as! Bool
                    }
                    if dict.keys.contains("createdAt") {
                        self.createdAt = dict["createdAt"] as! String
                    }
                    if dict.keys.contains("creatorId") {
                        self.creatorId = dict["creatorId"] as! Int64
                    }
                    if dict.keys.contains("description") {
                        self.description_ = dict["description"] as! String
                    }
                    if dict.keys.contains("encrypted") {
                        self.encrypted = dict["encrypted"] as! Bool
                    }
                    if dict.keys.contains("id") {
                        self.id = dict["id"] as! Int64
                    }
                    if dict.keys.contains("lastActivityAt") {
                        self.lastActivityAt = dict["lastActivityAt"] as! String
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("nameWithNamespace") {
                        self.nameWithNamespace = dict["nameWithNamespace"] as! String
                    }
                    if dict.keys.contains("namespaceId") {
                        self.namespaceId = dict["namespaceId"] as! Int64
                    }
                    if dict.keys.contains("path") {
                        self.path = dict["path"] as! String
                    }
                    if dict.keys.contains("pathWithNamespace") {
                        self.pathWithNamespace = dict["pathWithNamespace"] as! String
                    }
                    if dict.keys.contains("updatedAt") {
                        self.updatedAt = dict["updatedAt"] as! String
                    }
                    if dict.keys.contains("visibilityLevel") {
                        self.visibilityLevel = dict["visibilityLevel"] as! Int32
                    }
                }
            }
            public class RepositoryRole : Tea.TeaModel {
                public var accessLevel: Int32?

                public var cnRoleName: String?

                public var enRoleName: String?

                public var sourceId: Int64?

                public var sourceType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessLevel != nil {
                        map["accessLevel"] = self.accessLevel!
                    }
                    if self.cnRoleName != nil {
                        map["cnRoleName"] = self.cnRoleName!
                    }
                    if self.enRoleName != nil {
                        map["enRoleName"] = self.enRoleName!
                    }
                    if self.sourceId != nil {
                        map["sourceId"] = self.sourceId!
                    }
                    if self.sourceType != nil {
                        map["sourceType"] = self.sourceType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("accessLevel") {
                        self.accessLevel = dict["accessLevel"] as! Int32
                    }
                    if dict.keys.contains("cnRoleName") {
                        self.cnRoleName = dict["cnRoleName"] as! String
                    }
                    if dict.keys.contains("enRoleName") {
                        self.enRoleName = dict["enRoleName"] as! String
                    }
                    if dict.keys.contains("sourceId") {
                        self.sourceId = dict["sourceId"] as! Int64
                    }
                    if dict.keys.contains("sourceType") {
                        self.sourceType = dict["sourceType"] as! String
                    }
                }
            }
            public var repositoryInfo: ListUserResourcesResponseBody.Result.RepositoryInfos.RepositoryInfo?

            public var repositoryRole: ListUserResourcesResponseBody.Result.RepositoryInfos.RepositoryRole?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.repositoryInfo?.validate()
                try self.repositoryRole?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.repositoryInfo != nil {
                    map["repositoryInfo"] = self.repositoryInfo?.toMap()
                }
                if self.repositoryRole != nil {
                    map["repositoryRole"] = self.repositoryRole?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("repositoryInfo") {
                    var model = ListUserResourcesResponseBody.Result.RepositoryInfos.RepositoryInfo()
                    model.fromMap(dict["repositoryInfo"] as! [String: Any])
                    self.repositoryInfo = model
                }
                if dict.keys.contains("repositoryRole") {
                    var model = ListUserResourcesResponseBody.Result.RepositoryInfos.RepositoryRole()
                    model.fromMap(dict["repositoryRole"] as! [String: Any])
                    self.repositoryRole = model
                }
            }
        }
        public class UserInfo : Tea.TeaModel {
            public var avatarUrl: String?

            public var email: String?

            public var id: Int64?

            public var name: String?

            public var state: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["avatarUrl"] = self.avatarUrl!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.username != nil {
                    map["username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatarUrl") {
                    self.avatarUrl = dict["avatarUrl"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! String
                }
                if dict.keys.contains("username") {
                    self.username = dict["username"] as! String
                }
            }
        }
        public var groupInfos: [ListUserResourcesResponseBody.Result.GroupInfos]?

        public var repositoryInfos: [ListUserResourcesResponseBody.Result.RepositoryInfos]?

        public var userInfo: ListUserResourcesResponseBody.Result.UserInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.userInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupInfos != nil {
                var tmp : [Any] = []
                for k in self.groupInfos! {
                    tmp.append(k.toMap())
                }
                map["groupInfos"] = tmp
            }
            if self.repositoryInfos != nil {
                var tmp : [Any] = []
                for k in self.repositoryInfos! {
                    tmp.append(k.toMap())
                }
                map["repositoryInfos"] = tmp
            }
            if self.userInfo != nil {
                map["userInfo"] = self.userInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("groupInfos") {
                var tmp : [ListUserResourcesResponseBody.Result.GroupInfos] = []
                for v in dict["groupInfos"] as! [Any] {
                    var model = ListUserResourcesResponseBody.Result.GroupInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.groupInfos = tmp
            }
            if dict.keys.contains("repositoryInfos") {
                var tmp : [ListUserResourcesResponseBody.Result.RepositoryInfos] = []
                for v in dict["repositoryInfos"] as! [Any] {
                    var model = ListUserResourcesResponseBody.Result.RepositoryInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.repositoryInfos = tmp
            }
            if dict.keys.contains("userInfo") {
                var model = ListUserResourcesResponseBody.Result.UserInfo()
                model.fromMap(dict["userInfo"] as! [String: Any])
                self.userInfo = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: [ListUserResourcesResponseBody.Result]?

    public var success: Bool?

    public var total: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["result"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.total != nil {
            map["total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var tmp : [ListUserResourcesResponseBody.Result] = []
            for v in dict["result"] as! [Any] {
                var model = ListUserResourcesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("total") {
            self.total = dict["total"] as! Int64
        }
    }
}

public class ListUserResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUserResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVariableGroupsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var pageOrder: String?

    public var pageSort: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.pageOrder != nil {
            map["pageOrder"] = self.pageOrder!
        }
        if self.pageSort != nil {
            map["pageSort"] = self.pageSort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("pageOrder") {
            self.pageOrder = dict["pageOrder"] as! String
        }
        if dict.keys.contains("pageSort") {
            self.pageSort = dict["pageSort"] as! String
        }
    }
}

public class ListVariableGroupsResponseBody : Tea.TeaModel {
    public class VariableGroups : Tea.TeaModel {
        public class RelatedPipelines : Tea.TeaModel {
            public var id: Int64?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class Variables : Tea.TeaModel {
            public var isEncrypted: Bool?

            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isEncrypted != nil {
                    map["isEncrypted"] = self.isEncrypted!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("isEncrypted") {
                    self.isEncrypted = dict["isEncrypted"] as! Bool
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public var createTime: Int64?

        public var creatorAccountId: String?

        public var description_: String?

        public var id: Int64?

        public var modifierAccountId: String?

        public var name: String?

        public var relatedPipelines: [ListVariableGroupsResponseBody.VariableGroups.RelatedPipelines]?

        public var updateTime: Int64?

        public var variables: [ListVariableGroupsResponseBody.VariableGroups.Variables]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.creatorAccountId != nil {
                map["creatorAccountId"] = self.creatorAccountId!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.modifierAccountId != nil {
                map["modifierAccountId"] = self.modifierAccountId!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.relatedPipelines != nil {
                var tmp : [Any] = []
                for k in self.relatedPipelines! {
                    tmp.append(k.toMap())
                }
                map["relatedPipelines"] = tmp
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            if self.variables != nil {
                var tmp : [Any] = []
                for k in self.variables! {
                    tmp.append(k.toMap())
                }
                map["variables"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("creatorAccountId") {
                self.creatorAccountId = dict["creatorAccountId"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("modifierAccountId") {
                self.modifierAccountId = dict["modifierAccountId"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("relatedPipelines") {
                var tmp : [ListVariableGroupsResponseBody.VariableGroups.RelatedPipelines] = []
                for v in dict["relatedPipelines"] as! [Any] {
                    var model = ListVariableGroupsResponseBody.VariableGroups.RelatedPipelines()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.relatedPipelines = tmp
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! Int64
            }
            if dict.keys.contains("variables") {
                var tmp : [ListVariableGroupsResponseBody.VariableGroups.Variables] = []
                for v in dict["variables"] as! [Any] {
                    var model = ListVariableGroupsResponseBody.VariableGroups.Variables()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.variables = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var variableGroups: [ListVariableGroupsResponseBody.VariableGroups]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.variableGroups != nil {
            var tmp : [Any] = []
            for k in self.variableGroups! {
                tmp.append(k.toMap())
            }
            map["variableGroups"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("variableGroups") {
            var tmp : [ListVariableGroupsResponseBody.VariableGroups] = []
            for v in dict["variableGroups"] as! [Any] {
                var model = ListVariableGroupsResponseBody.VariableGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.variableGroups = tmp
        }
    }
}

public class ListVariableGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVariableGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVariableGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkItemAllFieldsRequest : Tea.TeaModel {
    public var spaceIdentifier: String?

    public var spaceType: String?

    public var workitemTypeIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        if self.workitemTypeIdentifier != nil {
            map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("spaceIdentifier") {
            self.spaceIdentifier = dict["spaceIdentifier"] as! String
        }
        if dict.keys.contains("spaceType") {
            self.spaceType = dict["spaceType"] as! String
        }
        if dict.keys.contains("workitemTypeIdentifier") {
            self.workitemTypeIdentifier = dict["workitemTypeIdentifier"] as! String
        }
    }
}

public class ListWorkItemAllFieldsResponseBody : Tea.TeaModel {
    public class Fields : Tea.TeaModel {
        public class Options : Tea.TeaModel {
            public var displayValue: String?

            public var fieldIdentifier: String?

            public var identifier: String?

            public var level: Int64?

            public var position: Int64?

            public var value: String?

            public var valueEn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayValue != nil {
                    map["displayValue"] = self.displayValue!
                }
                if self.fieldIdentifier != nil {
                    map["fieldIdentifier"] = self.fieldIdentifier!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.level != nil {
                    map["level"] = self.level!
                }
                if self.position != nil {
                    map["position"] = self.position!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                if self.valueEn != nil {
                    map["valueEn"] = self.valueEn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("displayValue") {
                    self.displayValue = dict["displayValue"] as! String
                }
                if dict.keys.contains("fieldIdentifier") {
                    self.fieldIdentifier = dict["fieldIdentifier"] as! String
                }
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
                if dict.keys.contains("level") {
                    self.level = dict["level"] as! Int64
                }
                if dict.keys.contains("position") {
                    self.position = dict["position"] as! Int64
                }
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
                if dict.keys.contains("valueEn") {
                    self.valueEn = dict["valueEn"] as! String
                }
            }
        }
        public var className: String?

        public var creator: String?

        public var defaultValue: String?

        public var description_: String?

        public var format: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var isRequired: Bool?

        public var isShowWhenCreate: Bool?

        public var isSystemRequired: Bool?

        public var linkWithService: String?

        public var modifier: String?

        public var name: String?

        public var options: [ListWorkItemAllFieldsResponseBody.Fields.Options]?

        public var resourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.className != nil {
                map["className"] = self.className!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.defaultValue != nil {
                map["defaultValue"] = self.defaultValue!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.format != nil {
                map["format"] = self.format!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.isShowWhenCreate != nil {
                map["isShowWhenCreate"] = self.isShowWhenCreate!
            }
            if self.isSystemRequired != nil {
                map["isSystemRequired"] = self.isSystemRequired!
            }
            if self.linkWithService != nil {
                map["linkWithService"] = self.linkWithService!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.options != nil {
                var tmp : [Any] = []
                for k in self.options! {
                    tmp.append(k.toMap())
                }
                map["options"] = tmp
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("className") {
                self.className = dict["className"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("defaultValue") {
                self.defaultValue = dict["defaultValue"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("format") {
                self.format = dict["format"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("isRequired") {
                self.isRequired = dict["isRequired"] as! Bool
            }
            if dict.keys.contains("isShowWhenCreate") {
                self.isShowWhenCreate = dict["isShowWhenCreate"] as! Bool
            }
            if dict.keys.contains("isSystemRequired") {
                self.isSystemRequired = dict["isSystemRequired"] as! Bool
            }
            if dict.keys.contains("linkWithService") {
                self.linkWithService = dict["linkWithService"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("options") {
                var tmp : [ListWorkItemAllFieldsResponseBody.Fields.Options] = []
                for v in dict["options"] as! [Any] {
                    var model = ListWorkItemAllFieldsResponseBody.Fields.Options()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.options = tmp
            }
            if dict.keys.contains("resourceType") {
                self.resourceType = dict["resourceType"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var fields: [ListWorkItemAllFieldsResponseBody.Fields]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.fields != nil {
            var tmp : [Any] = []
            for k in self.fields! {
                tmp.append(k.toMap())
            }
            map["fields"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("fields") {
            var tmp : [ListWorkItemAllFieldsResponseBody.Fields] = []
            for v in dict["fields"] as! [Any] {
                var model = ListWorkItemAllFieldsResponseBody.Fields()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fields = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListWorkItemAllFieldsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkItemAllFieldsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkItemAllFieldsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkItemWorkFlowStatusRequest : Tea.TeaModel {
    public var spaceIdentifier: String?

    public var spaceType: String?

    public var workitemCategoryIdentifier: String?

    public var workitemTypeIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        if self.workitemCategoryIdentifier != nil {
            map["workitemCategoryIdentifier"] = self.workitemCategoryIdentifier!
        }
        if self.workitemTypeIdentifier != nil {
            map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("spaceIdentifier") {
            self.spaceIdentifier = dict["spaceIdentifier"] as! String
        }
        if dict.keys.contains("spaceType") {
            self.spaceType = dict["spaceType"] as! String
        }
        if dict.keys.contains("workitemCategoryIdentifier") {
            self.workitemCategoryIdentifier = dict["workitemCategoryIdentifier"] as! String
        }
        if dict.keys.contains("workitemTypeIdentifier") {
            self.workitemTypeIdentifier = dict["workitemTypeIdentifier"] as! String
        }
    }
}

public class ListWorkItemWorkFlowStatusResponseBody : Tea.TeaModel {
    public class Statuses : Tea.TeaModel {
        public var creator: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var modifier: String?

        public var name: String?

        public var resourceType: String?

        public var source: String?

        public var workflowStageIdentifier: String?

        public var workflowStageName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.workflowStageIdentifier != nil {
                map["workflowStageIdentifier"] = self.workflowStageIdentifier!
            }
            if self.workflowStageName != nil {
                map["workflowStageName"] = self.workflowStageName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("resourceType") {
                self.resourceType = dict["resourceType"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("workflowStageIdentifier") {
                self.workflowStageIdentifier = dict["workflowStageIdentifier"] as! String
            }
            if dict.keys.contains("workflowStageName") {
                self.workflowStageName = dict["workflowStageName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var statuses: [ListWorkItemWorkFlowStatusResponseBody.Statuses]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.statuses != nil {
            var tmp : [Any] = []
            for k in self.statuses! {
                tmp.append(k.toMap())
            }
            map["statuses"] = tmp
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("statuses") {
            var tmp : [ListWorkItemWorkFlowStatusResponseBody.Statuses] = []
            for v in dict["statuses"] as! [Any] {
                var model = ListWorkItemWorkFlowStatusResponseBody.Statuses()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statuses = tmp
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListWorkItemWorkFlowStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkItemWorkFlowStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkItemWorkFlowStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkitemAttachmentsResponseBody : Tea.TeaModel {
    public class Attachments : Tea.TeaModel {
        public var creator: String?

        public var fileIdentifier: String?

        public var fileName: String?

        public var fileSuffix: String?

        public var gmtCreate: Int64?

        public var size: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.fileIdentifier != nil {
                map["fileIdentifier"] = self.fileIdentifier!
            }
            if self.fileName != nil {
                map["fileName"] = self.fileName!
            }
            if self.fileSuffix != nil {
                map["fileSuffix"] = self.fileSuffix!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.size != nil {
                map["size"] = self.size!
            }
            if self.url != nil {
                map["url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("fileIdentifier") {
                self.fileIdentifier = dict["fileIdentifier"] as! String
            }
            if dict.keys.contains("fileName") {
                self.fileName = dict["fileName"] as! String
            }
            if dict.keys.contains("fileSuffix") {
                self.fileSuffix = dict["fileSuffix"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("size") {
                self.size = dict["size"] as! String
            }
            if dict.keys.contains("url") {
                self.url = dict["url"] as! String
            }
        }
    }
    public var attachments: [ListWorkitemAttachmentsResponseBody.Attachments]?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachments != nil {
            var tmp : [Any] = []
            for k in self.attachments! {
                tmp.append(k.toMap())
            }
            map["attachments"] = tmp
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("attachments") {
            var tmp : [ListWorkitemAttachmentsResponseBody.Attachments] = []
            for v in dict["attachments"] as! [Any] {
                var model = ListWorkitemAttachmentsResponseBody.Attachments()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.attachments = tmp
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ListWorkitemAttachmentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkitemAttachmentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkitemAttachmentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkitemEstimateResponseBody : Tea.TeaModel {
    public class WorkitemTimeEstimate : Tea.TeaModel {
        public class RecordUser : Tea.TeaModel {
            public var identifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtEnd: Int64?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var identifier: String?

        public var recordUser: ListWorkitemEstimateResponseBody.WorkitemTimeEstimate.RecordUser?

        public var spentTime: Double?

        public var type: String?

        public var workitemIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordUser?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtEnd != nil {
                map["gmtEnd"] = self.gmtEnd!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.recordUser != nil {
                map["recordUser"] = self.recordUser?.toMap()
            }
            if self.spentTime != nil {
                map["spentTime"] = self.spentTime!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.workitemIdentifier != nil {
                map["workitemIdentifier"] = self.workitemIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtEnd") {
                self.gmtEnd = dict["gmtEnd"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("gmtStart") {
                self.gmtStart = dict["gmtStart"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("recordUser") {
                var model = ListWorkitemEstimateResponseBody.WorkitemTimeEstimate.RecordUser()
                model.fromMap(dict["recordUser"] as! [String: Any])
                self.recordUser = model
            }
            if dict.keys.contains("spentTime") {
                self.spentTime = dict["spentTime"] as! Double
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("workitemIdentifier") {
                self.workitemIdentifier = dict["workitemIdentifier"] as! String
            }
        }
    }
    public var code: Int64?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var workitemTimeEstimate: [ListWorkitemEstimateResponseBody.WorkitemTimeEstimate]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitemTimeEstimate != nil {
            var tmp : [Any] = []
            for k in self.workitemTimeEstimate! {
                tmp.append(k.toMap())
            }
            map["workitemTimeEstimate"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! Int64
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("workitemTimeEstimate") {
            var tmp : [ListWorkitemEstimateResponseBody.WorkitemTimeEstimate] = []
            for v in dict["workitemTimeEstimate"] as! [Any] {
                var model = ListWorkitemEstimateResponseBody.WorkitemTimeEstimate()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workitemTimeEstimate = tmp
        }
    }
}

public class ListWorkitemEstimateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkitemEstimateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkitemEstimateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkitemTimeResponseBody : Tea.TeaModel {
    public class WorkitemTime : Tea.TeaModel {
        public var actualTime: Double?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtEnd: Int64?

        public var gmtModified: Int64?

        public var gmtStart: Int64?

        public var identifier: String?

        public var recordUser: String?

        public var type: String?

        public var workitemIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualTime != nil {
                map["actualTime"] = self.actualTime!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtEnd != nil {
                map["gmtEnd"] = self.gmtEnd!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.gmtStart != nil {
                map["gmtStart"] = self.gmtStart!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.recordUser != nil {
                map["recordUser"] = self.recordUser!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.workitemIdentifier != nil {
                map["workitemIdentifier"] = self.workitemIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("actualTime") {
                self.actualTime = dict["actualTime"] as! Double
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtEnd") {
                self.gmtEnd = dict["gmtEnd"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("gmtStart") {
                self.gmtStart = dict["gmtStart"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("recordUser") {
                self.recordUser = dict["recordUser"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("workitemIdentifier") {
                self.workitemIdentifier = dict["workitemIdentifier"] as! String
            }
        }
    }
    public var code: Int64?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var workitemTime: [ListWorkitemTimeResponseBody.WorkitemTime]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitemTime != nil {
            var tmp : [Any] = []
            for k in self.workitemTime! {
                tmp.append(k.toMap())
            }
            map["workitemTime"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("code") {
            self.code = dict["code"] as! Int64
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("workitemTime") {
            var tmp : [ListWorkitemTimeResponseBody.WorkitemTime] = []
            for v in dict["workitemTime"] as! [Any] {
                var model = ListWorkitemTimeResponseBody.WorkitemTime()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workitemTime = tmp
        }
    }
}

public class ListWorkitemTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkitemTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkitemTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkitemsRequest : Tea.TeaModel {
    public var category: String?

    public var conditions: String?

    public var extraConditions: String?

    public var groupCondition: String?

    public var maxResults: String?

    public var nextToken: String?

    public var orderBy: String?

    public var searchType: String?

    public var spaceIdentifier: String?

    public var spaceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["category"] = self.category!
        }
        if self.conditions != nil {
            map["conditions"] = self.conditions!
        }
        if self.extraConditions != nil {
            map["extraConditions"] = self.extraConditions!
        }
        if self.groupCondition != nil {
            map["groupCondition"] = self.groupCondition!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.orderBy != nil {
            map["orderBy"] = self.orderBy!
        }
        if self.searchType != nil {
            map["searchType"] = self.searchType!
        }
        if self.spaceIdentifier != nil {
            map["spaceIdentifier"] = self.spaceIdentifier!
        }
        if self.spaceType != nil {
            map["spaceType"] = self.spaceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("category") {
            self.category = dict["category"] as! String
        }
        if dict.keys.contains("conditions") {
            self.conditions = dict["conditions"] as! String
        }
        if dict.keys.contains("extraConditions") {
            self.extraConditions = dict["extraConditions"] as! String
        }
        if dict.keys.contains("groupCondition") {
            self.groupCondition = dict["groupCondition"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! String
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("orderBy") {
            self.orderBy = dict["orderBy"] as! String
        }
        if dict.keys.contains("searchType") {
            self.searchType = dict["searchType"] as! String
        }
        if dict.keys.contains("spaceIdentifier") {
            self.spaceIdentifier = dict["spaceIdentifier"] as! String
        }
        if dict.keys.contains("spaceType") {
            self.spaceType = dict["spaceType"] as! String
        }
    }
}

public class ListWorkitemsResponseBody : Tea.TeaModel {
    public class Workitems : Tea.TeaModel {
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var document: String?

        public var finishTime: Int64?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var parentIdentifier: String?

        public var serialNumber: String?

        public var spaceIdentifier: String?

        public var spaceName: String?

        public var spaceType: String?

        public var sprintIdentifier: String?

        public var status: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subject: String?

        public var updateStatusAt: Int64?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.document != nil {
                map["document"] = self.document!
            }
            if self.finishTime != nil {
                map["finishTime"] = self.finishTime!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceName != nil {
                map["spaceName"] = self.spaceName!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.sprintIdentifier != nil {
                map["sprintIdentifier"] = self.sprintIdentifier!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.updateStatusAt != nil {
                map["updateStatusAt"] = self.updateStatusAt!
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedTo") {
                self.assignedTo = dict["assignedTo"] as! String
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("document") {
                self.document = dict["document"] as! String
            }
            if dict.keys.contains("finishTime") {
                self.finishTime = dict["finishTime"] as! Int64
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("logicalStatus") {
                self.logicalStatus = dict["logicalStatus"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("parentIdentifier") {
                self.parentIdentifier = dict["parentIdentifier"] as! String
            }
            if dict.keys.contains("serialNumber") {
                self.serialNumber = dict["serialNumber"] as! String
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("spaceName") {
                self.spaceName = dict["spaceName"] as! String
            }
            if dict.keys.contains("spaceType") {
                self.spaceType = dict["spaceType"] as! String
            }
            if dict.keys.contains("sprintIdentifier") {
                self.sprintIdentifier = dict["sprintIdentifier"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("statusIdentifier") {
                self.statusIdentifier = dict["statusIdentifier"] as! String
            }
            if dict.keys.contains("statusStageIdentifier") {
                self.statusStageIdentifier = dict["statusStageIdentifier"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("updateStatusAt") {
                self.updateStatusAt = dict["updateStatusAt"] as! Int64
            }
            if dict.keys.contains("workitemTypeIdentifier") {
                self.workitemTypeIdentifier = dict["workitemTypeIdentifier"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public var workitems: [ListWorkitemsResponseBody.Workitems]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.workitems != nil {
            var tmp : [Any] = []
            for k in self.workitems! {
                tmp.append(k.toMap())
            }
            map["workitems"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int64
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int64
        }
        if dict.keys.contains("workitems") {
            var tmp : [ListWorkitemsResponseBody.Workitems] = []
            for v in dict["workitems"] as! [Any] {
                var model = ListWorkitemsResponseBody.Workitems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workitems = tmp
        }
    }
}

public class ListWorkitemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkitemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkitemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWorkspacesRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var statusList: [String]?

    public var workspaceTemplateList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.statusList != nil {
            map["statusList"] = self.statusList!
        }
        if self.workspaceTemplateList != nil {
            map["workspaceTemplateList"] = self.workspaceTemplateList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("statusList") {
            self.statusList = dict["statusList"] as! [String]
        }
        if dict.keys.contains("workspaceTemplateList") {
            self.workspaceTemplateList = dict["workspaceTemplateList"] as! [String]
        }
    }
}

public class ListWorkspacesShrinkRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var statusListShrink: String?

    public var workspaceTemplateListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.statusListShrink != nil {
            map["statusList"] = self.statusListShrink!
        }
        if self.workspaceTemplateListShrink != nil {
            map["workspaceTemplateList"] = self.workspaceTemplateListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("statusList") {
            self.statusListShrink = dict["statusList"] as! String
        }
        if dict.keys.contains("workspaceTemplateList") {
            self.workspaceTemplateListShrink = dict["workspaceTemplateList"] as! String
        }
    }
}

public class ListWorkspacesResponseBody : Tea.TeaModel {
    public class Workspaces : Tea.TeaModel {
        public var codeUrl: String?

        public var codeVersion: String?

        public var createTime: String?

        public var id: String?

        public var name: String?

        public var spec: String?

        public var status: String?

        public var template: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.codeUrl != nil {
                map["codeUrl"] = self.codeUrl!
            }
            if self.codeVersion != nil {
                map["codeVersion"] = self.codeVersion!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.spec != nil {
                map["spec"] = self.spec!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.template != nil {
                map["template"] = self.template!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("codeUrl") {
                self.codeUrl = dict["codeUrl"] as! String
            }
            if dict.keys.contains("codeVersion") {
                self.codeVersion = dict["codeVersion"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("spec") {
                self.spec = dict["spec"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("template") {
                self.template = dict["template"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public var workspaces: [ListWorkspacesResponseBody.Workspaces]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.maxResults != nil {
            map["maxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        if self.workspaces != nil {
            var tmp : [Any] = []
            for k in self.workspaces! {
                tmp.append(k.toMap())
            }
            map["workspaces"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("maxResults") {
            self.maxResults = dict["maxResults"] as! Int32
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int32
        }
        if dict.keys.contains("workspaces") {
            var tmp : [ListWorkspacesResponseBody.Workspaces] = []
            for v in dict["workspaces"] as! [Any] {
                var model = ListWorkspacesResponseBody.Workspaces()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.workspaces = tmp
        }
    }
}

public class ListWorkspacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWorkspacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWorkspacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LogPipelineJobRunResponseBody : Tea.TeaModel {
    public class Log : Tea.TeaModel {
        public var content: String?

        public var more: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.more != nil {
                map["more"] = self.more!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("more") {
                self.more = dict["more"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var log: LogPipelineJobRunResponseBody.Log?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.log?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.log != nil {
            map["log"] = self.log?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("log") {
            var model = LogPipelineJobRunResponseBody.Log()
            model.fromMap(dict["log"] as! [String: Any])
            self.log = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class LogPipelineJobRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LogPipelineJobRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = LogPipelineJobRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LogVMDeployMachineResponseBody : Tea.TeaModel {
    public class DeployMachineLog : Tea.TeaModel {
        public var aliyunRegion: String?

        public var deployBeginTime: Int64?

        public var deployEndTime: Int64?

        public var deployLog: String?

        public var deployLogPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunRegion != nil {
                map["aliyunRegion"] = self.aliyunRegion!
            }
            if self.deployBeginTime != nil {
                map["deployBeginTime"] = self.deployBeginTime!
            }
            if self.deployEndTime != nil {
                map["deployEndTime"] = self.deployEndTime!
            }
            if self.deployLog != nil {
                map["deployLog"] = self.deployLog!
            }
            if self.deployLogPath != nil {
                map["deployLogPath"] = self.deployLogPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("aliyunRegion") {
                self.aliyunRegion = dict["aliyunRegion"] as! String
            }
            if dict.keys.contains("deployBeginTime") {
                self.deployBeginTime = dict["deployBeginTime"] as! Int64
            }
            if dict.keys.contains("deployEndTime") {
                self.deployEndTime = dict["deployEndTime"] as! Int64
            }
            if dict.keys.contains("deployLog") {
                self.deployLog = dict["deployLog"] as! String
            }
            if dict.keys.contains("deployLogPath") {
                self.deployLogPath = dict["deployLogPath"] as! String
            }
        }
    }
    public var deployMachineLog: LogVMDeployMachineResponseBody.DeployMachineLog?

    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployMachineLog?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployMachineLog != nil {
            map["deployMachineLog"] = self.deployMachineLog?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("deployMachineLog") {
            var model = LogVMDeployMachineResponseBody.DeployMachineLog()
            model.fromMap(dict["deployMachineLog"] as! [String: Any])
            self.deployMachineLog = model
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class LogVMDeployMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LogVMDeployMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = LogVMDeployMachineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MergeMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var mergeMessage: String?

    public var mergeType: String?

    public var removeSourceBranch: Bool?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.mergeMessage != nil {
            map["mergeMessage"] = self.mergeMessage!
        }
        if self.mergeType != nil {
            map["mergeType"] = self.mergeType!
        }
        if self.removeSourceBranch != nil {
            map["removeSourceBranch"] = self.removeSourceBranch!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("mergeMessage") {
            self.mergeMessage = dict["mergeMessage"] as! String
        }
        if dict.keys.contains("mergeType") {
            self.mergeType = dict["mergeType"] as! String
        }
        if dict.keys.contains("removeSourceBranch") {
            self.removeSourceBranch = dict["removeSourceBranch"] as! Bool
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class MergeMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var bizId: String?

        public var localId: Int64?

        public var mergedRevision: String?

        public var projectId: Int64?

        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizId != nil {
                map["bizId"] = self.bizId!
            }
            if self.localId != nil {
                map["localId"] = self.localId!
            }
            if self.mergedRevision != nil {
                map["mergedRevision"] = self.mergedRevision!
            }
            if self.projectId != nil {
                map["projectId"] = self.projectId!
            }
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("bizId") {
                self.bizId = dict["bizId"] as! String
            }
            if dict.keys.contains("localId") {
                self.localId = dict["localId"] as! Int64
            }
            if dict.keys.contains("mergedRevision") {
                self.mergedRevision = dict["mergedRevision"] as! String
            }
            if dict.keys.contains("projectId") {
                self.projectId = dict["projectId"] as! Int64
            }
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: MergeMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = MergeMergeRequestResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class MergeMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MergeMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MergeMergeRequestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PassPipelineValidateResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class PassPipelineValidateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PassPipelineValidateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PassPipelineValidateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefusePipelineValidateResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class RefusePipelineValidateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefusePipelineValidateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RefusePipelineValidateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseWorkspaceResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ReleaseWorkspaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseWorkspaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseWorkspaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReopenMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ReopenMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: ReopenMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = ReopenMergeRequestResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ReopenMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReopenMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReopenMergeRequestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetSshKeyResponseBody : Tea.TeaModel {
    public class SshKey : Tea.TeaModel {
        public var id: Int64?

        public var publicKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.publicKey != nil {
                map["publicKey"] = self.publicKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("publicKey") {
                self.publicKey = dict["publicKey"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var sshKey: ResetSshKeyResponseBody.SshKey?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sshKey?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.sshKey != nil {
            map["sshKey"] = self.sshKey?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("sshKey") {
            var model = ResetSshKeyResponseBody.SshKey()
            model.fromMap(dict["sshKey"] as! [String: Any])
            self.sshKey = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ResetSshKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetSshKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetSshKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeVMDeployOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ResumeVMDeployOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeVMDeployOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeVMDeployOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryPipelineJobRunResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class RetryPipelineJobRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryPipelineJobRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RetryPipelineJobRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryVMDeployMachineResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class RetryVMDeployMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryVMDeployMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RetryVMDeployMachineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReviewMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var draftCommentIds: [String]?

    public var reviewComment: String?

    public var reviewOpinion: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.draftCommentIds != nil {
            map["draftCommentIds"] = self.draftCommentIds!
        }
        if self.reviewComment != nil {
            map["reviewComment"] = self.reviewComment!
        }
        if self.reviewOpinion != nil {
            map["reviewOpinion"] = self.reviewOpinion!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("draftCommentIds") {
            self.draftCommentIds = dict["draftCommentIds"] as! [String]
        }
        if dict.keys.contains("reviewComment") {
            self.reviewComment = dict["reviewComment"] as! String
        }
        if dict.keys.contains("reviewOpinion") {
            self.reviewOpinion = dict["reviewOpinion"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class ReviewMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: ReviewMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = ReviewMergeRequestResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class ReviewMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReviewMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReviewMergeRequestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SkipPipelineJobRunResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class SkipPipelineJobRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SkipPipelineJobRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SkipPipelineJobRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SkipVMDeployMachineResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class SkipVMDeployMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SkipVMDeployMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SkipVMDeployMachineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartPipelineRunRequest : Tea.TeaModel {
    public var params: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.params != nil {
            map["params"] = self.params!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("params") {
            self.params = dict["params"] as! String
        }
    }
}

public class StartPipelineRunResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var pipelineRunId: Int64?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.pipelineRunId != nil {
            map["pipelineRunId"] = self.pipelineRunId!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("pipelineRunId") {
            self.pipelineRunId = dict["pipelineRunId"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class StartPipelineRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartPipelineRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartPipelineRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopPipelineJobRunResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class StopPipelineJobRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopPipelineJobRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopPipelineJobRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopPipelineRunResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class StopPipelineRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopPipelineRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopPipelineRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopVMDeployOrderResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class StopVMDeployOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopVMDeployOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopVMDeployOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TransferRepositoryRequest : Tea.TeaModel {
    public var accessToken: String?

    public var groupId: String?

    public var organizationId: String?

    public var repositoryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.groupId != nil {
            map["groupId"] = self.groupId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryId != nil {
            map["repositoryId"] = self.repositoryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("groupId") {
            self.groupId = dict["groupId"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryId") {
            self.repositoryId = dict["repositoryId"] as! String
        }
    }
}

public class TransferRepositoryResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var archived: Bool?

        public var createdAt: String?

        public var creatorId: Int64?

        public var demoProject: Bool?

        public var description_: String?

        public var encrypted: Bool?

        public var id: Int64?

        public var lastActivityAt: String?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespaceId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var starCount: Int64?

        public var starred: Bool?

        public var updatedAt: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.archived != nil {
                map["archived"] = self.archived!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.demoProject != nil {
                map["demoProject"] = self.demoProject!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.encrypted != nil {
                map["encrypted"] = self.encrypted!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespaceId != nil {
                map["namespaceId"] = self.namespaceId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.starCount != nil {
                map["starCount"] = self.starCount!
            }
            if self.starred != nil {
                map["starred"] = self.starred!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("archived") {
                self.archived = dict["archived"] as! Bool
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("creatorId") {
                self.creatorId = dict["creatorId"] as! Int64
            }
            if dict.keys.contains("demoProject") {
                self.demoProject = dict["demoProject"] as! Bool
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("encrypted") {
                self.encrypted = dict["encrypted"] as! Bool
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("lastActivityAt") {
                self.lastActivityAt = dict["lastActivityAt"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("namespaceId") {
                self.namespaceId = dict["namespaceId"] as! Int64
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("pathWithNamespace") {
                self.pathWithNamespace = dict["pathWithNamespace"] as! String
            }
            if dict.keys.contains("starCount") {
                self.starCount = dict["starCount"] as! Int64
            }
            if dict.keys.contains("starred") {
                self.starred = dict["starred"] as! Bool
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("visibilityLevel") {
                self.visibilityLevel = dict["visibilityLevel"] as! Int32
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: TransferRepositoryResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = TransferRepositoryResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class TransferRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransferRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TransferRepositoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TriggerRepositoryMirrorSyncRequest : Tea.TeaModel {
    public var accessToken: String?

    public var account: String?

    public var organizationId: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.account != nil {
            map["account"] = self.account!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.token != nil {
            map["token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("account") {
            self.account = dict["account"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("token") {
            self.token = dict["token"] as! String
        }
    }
}

public class TriggerRepositoryMirrorSyncResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: TriggerRepositoryMirrorSyncResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = TriggerRepositoryMirrorSyncResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class TriggerRepositoryMirrorSyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TriggerRepositoryMirrorSyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TriggerRepositoryMirrorSyncResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAppMemberRequest : Tea.TeaModel {
    public class Player : Tea.TeaModel {
        public var id: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var player: UpdateAppMemberRequest.Player?

    public var roleNames: [String]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.player?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.player != nil {
            map["player"] = self.player?.toMap()
        }
        if self.roleNames != nil {
            map["roleNames"] = self.roleNames!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("player") {
            var model = UpdateAppMemberRequest.Player()
            model.fromMap(dict["player"] as! [String: Any])
            self.player = model
        }
        if dict.keys.contains("roleNames") {
            self.roleNames = dict["roleNames"] as! [String]
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class UpdateAppMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class UpdateApplicationRequest : Tea.TeaModel {
    public var ownerAccountId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccountId != nil {
            map["ownerAccountId"] = self.ownerAccountId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ownerAccountId") {
            self.ownerAccountId = dict["ownerAccountId"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class UpdateApplicationResponseBody : Tea.TeaModel {
    public var creatorAccountId: String?

    public var description_: String?

    public var gmtCreate: String?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creatorAccountId != nil {
            map["creatorAccountId"] = self.creatorAccountId!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.gmtCreate != nil {
            map["gmtCreate"] = self.gmtCreate!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("creatorAccountId") {
            self.creatorAccountId = dict["creatorAccountId"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("gmtCreate") {
            self.gmtCreate = dict["gmtCreate"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCheckRunRequest : Tea.TeaModel {
    public class Annotations : Tea.TeaModel {
        public var annotationLevel: String?

        public var endColumn: Int64?

        public var endLine: Int64?

        public var message: String?

        public var path: String?

        public var rawDetails: String?

        public var startColumn: Int64?

        public var startLine: Int64?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotationLevel != nil {
                map["annotationLevel"] = self.annotationLevel!
            }
            if self.endColumn != nil {
                map["endColumn"] = self.endColumn!
            }
            if self.endLine != nil {
                map["endLine"] = self.endLine!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.rawDetails != nil {
                map["rawDetails"] = self.rawDetails!
            }
            if self.startColumn != nil {
                map["startColumn"] = self.startColumn!
            }
            if self.startLine != nil {
                map["startLine"] = self.startLine!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("annotationLevel") {
                self.annotationLevel = dict["annotationLevel"] as! String
            }
            if dict.keys.contains("endColumn") {
                self.endColumn = dict["endColumn"] as! Int64
            }
            if dict.keys.contains("endLine") {
                self.endLine = dict["endLine"] as! Int64
            }
            if dict.keys.contains("message") {
                self.message = dict["message"] as! String
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("rawDetails") {
                self.rawDetails = dict["rawDetails"] as! String
            }
            if dict.keys.contains("startColumn") {
                self.startColumn = dict["startColumn"] as! Int64
            }
            if dict.keys.contains("startLine") {
                self.startLine = dict["startLine"] as! Int64
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public class Output : Tea.TeaModel {
        public class Images : Tea.TeaModel {
            public var alt: String?

            public var caption: String?

            public var imageUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alt != nil {
                    map["alt"] = self.alt!
                }
                if self.caption != nil {
                    map["caption"] = self.caption!
                }
                if self.imageUrl != nil {
                    map["imageUrl"] = self.imageUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("alt") {
                    self.alt = dict["alt"] as! String
                }
                if dict.keys.contains("caption") {
                    self.caption = dict["caption"] as! String
                }
                if dict.keys.contains("imageUrl") {
                    self.imageUrl = dict["imageUrl"] as! String
                }
            }
        }
        public var images: [UpdateCheckRunRequest.Output.Images]?

        public var summary: String?

        public var text: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.images != nil {
                var tmp : [Any] = []
                for k in self.images! {
                    tmp.append(k.toMap())
                }
                map["images"] = tmp
            }
            if self.summary != nil {
                map["summary"] = self.summary!
            }
            if self.text != nil {
                map["text"] = self.text!
            }
            if self.title != nil {
                map["title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("images") {
                var tmp : [UpdateCheckRunRequest.Output.Images] = []
                for v in dict["images"] as! [Any] {
                    var model = UpdateCheckRunRequest.Output.Images()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.images = tmp
            }
            if dict.keys.contains("summary") {
                self.summary = dict["summary"] as! String
            }
            if dict.keys.contains("text") {
                self.text = dict["text"] as! String
            }
            if dict.keys.contains("title") {
                self.title = dict["title"] as! String
            }
        }
    }
    public var accessToken: String?

    public var annotations: [UpdateCheckRunRequest.Annotations]?

    public var completedAt: String?

    public var conclusion: String?

    public var detailsUrl: String?

    public var externalId: String?

    public var name: String?

    public var output: UpdateCheckRunRequest.Output?

    public var startedAt: String?

    public var status: String?

    public var checkRunId: Int64?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.output?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.annotations != nil {
            var tmp : [Any] = []
            for k in self.annotations! {
                tmp.append(k.toMap())
            }
            map["annotations"] = tmp
        }
        if self.completedAt != nil {
            map["completedAt"] = self.completedAt!
        }
        if self.conclusion != nil {
            map["conclusion"] = self.conclusion!
        }
        if self.detailsUrl != nil {
            map["detailsUrl"] = self.detailsUrl!
        }
        if self.externalId != nil {
            map["externalId"] = self.externalId!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.output != nil {
            map["output"] = self.output?.toMap()
        }
        if self.startedAt != nil {
            map["startedAt"] = self.startedAt!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.checkRunId != nil {
            map["checkRunId"] = self.checkRunId!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("annotations") {
            var tmp : [UpdateCheckRunRequest.Annotations] = []
            for v in dict["annotations"] as! [Any] {
                var model = UpdateCheckRunRequest.Annotations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.annotations = tmp
        }
        if dict.keys.contains("completedAt") {
            self.completedAt = dict["completedAt"] as! String
        }
        if dict.keys.contains("conclusion") {
            self.conclusion = dict["conclusion"] as! String
        }
        if dict.keys.contains("detailsUrl") {
            self.detailsUrl = dict["detailsUrl"] as! String
        }
        if dict.keys.contains("externalId") {
            self.externalId = dict["externalId"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("output") {
            var model = UpdateCheckRunRequest.Output()
            model.fromMap(dict["output"] as! [String: Any])
            self.output = model
        }
        if dict.keys.contains("startedAt") {
            self.startedAt = dict["startedAt"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("checkRunId") {
            self.checkRunId = dict["checkRunId"] as! Int64
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class UpdateCheckRunResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Annotations : Tea.TeaModel {
            public var annotationLevel: String?

            public var endColumn: Int64?

            public var endLine: Int64?

            public var id: Int64?

            public var message: String?

            public var path: String?

            public var rawDetails: String?

            public var startColumn: Int64?

            public var startLine: Int64?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.annotationLevel != nil {
                    map["annotationLevel"] = self.annotationLevel!
                }
                if self.endColumn != nil {
                    map["endColumn"] = self.endColumn!
                }
                if self.endLine != nil {
                    map["endLine"] = self.endLine!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.rawDetails != nil {
                    map["rawDetails"] = self.rawDetails!
                }
                if self.startColumn != nil {
                    map["startColumn"] = self.startColumn!
                }
                if self.startLine != nil {
                    map["startLine"] = self.startLine!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("annotationLevel") {
                    self.annotationLevel = dict["annotationLevel"] as! String
                }
                if dict.keys.contains("endColumn") {
                    self.endColumn = dict["endColumn"] as! Int64
                }
                if dict.keys.contains("endLine") {
                    self.endLine = dict["endLine"] as! Int64
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("rawDetails") {
                    self.rawDetails = dict["rawDetails"] as! String
                }
                if dict.keys.contains("startColumn") {
                    self.startColumn = dict["startColumn"] as! Int64
                }
                if dict.keys.contains("startLine") {
                    self.startLine = dict["startLine"] as! Int64
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class CheckSuite : Tea.TeaModel {
            public var id: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
            }
        }
        public class Output : Tea.TeaModel {
            public class Images : Tea.TeaModel {
                public var alt: String?

                public var caption: String?

                public var imageUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alt != nil {
                        map["alt"] = self.alt!
                    }
                    if self.caption != nil {
                        map["caption"] = self.caption!
                    }
                    if self.imageUrl != nil {
                        map["imageUrl"] = self.imageUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("alt") {
                        self.alt = dict["alt"] as! String
                    }
                    if dict.keys.contains("caption") {
                        self.caption = dict["caption"] as! String
                    }
                    if dict.keys.contains("imageUrl") {
                        self.imageUrl = dict["imageUrl"] as! String
                    }
                }
            }
            public var images: [UpdateCheckRunResponseBody.Result.Output.Images]?

            public var summary: String?

            public var text: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.images != nil {
                    var tmp : [Any] = []
                    for k in self.images! {
                        tmp.append(k.toMap())
                    }
                    map["images"] = tmp
                }
                if self.summary != nil {
                    map["summary"] = self.summary!
                }
                if self.text != nil {
                    map["text"] = self.text!
                }
                if self.title != nil {
                    map["title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("images") {
                    var tmp : [UpdateCheckRunResponseBody.Result.Output.Images] = []
                    for v in dict["images"] as! [Any] {
                        var model = UpdateCheckRunResponseBody.Result.Output.Images()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.images = tmp
                }
                if dict.keys.contains("summary") {
                    self.summary = dict["summary"] as! String
                }
                if dict.keys.contains("text") {
                    self.text = dict["text"] as! String
                }
                if dict.keys.contains("title") {
                    self.title = dict["title"] as! String
                }
            }
        }
        public class Writer : Tea.TeaModel {
            public var id: String?

            public var logoUrl: String?

            public var name: String?

            public var slug: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.logoUrl != nil {
                    map["logoUrl"] = self.logoUrl!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.slug != nil {
                    map["slug"] = self.slug!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! String
                }
                if dict.keys.contains("logoUrl") {
                    self.logoUrl = dict["logoUrl"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("slug") {
                    self.slug = dict["slug"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var annotations: [UpdateCheckRunResponseBody.Result.Annotations]?

        public var checkSuite: UpdateCheckRunResponseBody.Result.CheckSuite?

        public var completedAt: String?

        public var conclusion: String?

        public var createdAt: String?

        public var detailsUrl: String?

        public var externalId: String?

        public var headSha: String?

        public var id: Int64?

        public var name: String?

        public var output: UpdateCheckRunResponseBody.Result.Output?

        public var startedAt: String?

        public var status: String?

        public var updatedAt: String?

        public var writer: UpdateCheckRunResponseBody.Result.Writer?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkSuite?.validate()
            try self.output?.validate()
            try self.writer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.annotations != nil {
                var tmp : [Any] = []
                for k in self.annotations! {
                    tmp.append(k.toMap())
                }
                map["annotations"] = tmp
            }
            if self.checkSuite != nil {
                map["checkSuite"] = self.checkSuite?.toMap()
            }
            if self.completedAt != nil {
                map["completedAt"] = self.completedAt!
            }
            if self.conclusion != nil {
                map["conclusion"] = self.conclusion!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.detailsUrl != nil {
                map["detailsUrl"] = self.detailsUrl!
            }
            if self.externalId != nil {
                map["externalId"] = self.externalId!
            }
            if self.headSha != nil {
                map["headSha"] = self.headSha!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.output != nil {
                map["output"] = self.output?.toMap()
            }
            if self.startedAt != nil {
                map["startedAt"] = self.startedAt!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.writer != nil {
                map["writer"] = self.writer?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("annotations") {
                var tmp : [UpdateCheckRunResponseBody.Result.Annotations] = []
                for v in dict["annotations"] as! [Any] {
                    var model = UpdateCheckRunResponseBody.Result.Annotations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.annotations = tmp
            }
            if dict.keys.contains("checkSuite") {
                var model = UpdateCheckRunResponseBody.Result.CheckSuite()
                model.fromMap(dict["checkSuite"] as! [String: Any])
                self.checkSuite = model
            }
            if dict.keys.contains("completedAt") {
                self.completedAt = dict["completedAt"] as! String
            }
            if dict.keys.contains("conclusion") {
                self.conclusion = dict["conclusion"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("detailsUrl") {
                self.detailsUrl = dict["detailsUrl"] as! String
            }
            if dict.keys.contains("externalId") {
                self.externalId = dict["externalId"] as! String
            }
            if dict.keys.contains("headSha") {
                self.headSha = dict["headSha"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("output") {
                var model = UpdateCheckRunResponseBody.Result.Output()
                model.fromMap(dict["output"] as! [String: Any])
                self.output = model
            }
            if dict.keys.contains("startedAt") {
                self.startedAt = dict["startedAt"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("writer") {
                var model = UpdateCheckRunResponseBody.Result.Writer()
                model.fromMap(dict["writer"] as! [String: Any])
                self.writer = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateCheckRunResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdateCheckRunResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateCheckRunResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCheckRunResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCheckRunResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFileRequest : Tea.TeaModel {
    public var accessToken: String?

    public var branchName: String?

    public var commitMessage: String?

    public var content: String?

    public var encoding: String?

    public var newPath: String?

    public var oldPath: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.branchName != nil {
            map["branchName"] = self.branchName!
        }
        if self.commitMessage != nil {
            map["commitMessage"] = self.commitMessage!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.encoding != nil {
            map["encoding"] = self.encoding!
        }
        if self.newPath != nil {
            map["newPath"] = self.newPath!
        }
        if self.oldPath != nil {
            map["oldPath"] = self.oldPath!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("branchName") {
            self.branchName = dict["branchName"] as! String
        }
        if dict.keys.contains("commitMessage") {
            self.commitMessage = dict["commitMessage"] as! String
        }
        if dict.keys.contains("content") {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("encoding") {
            self.encoding = dict["encoding"] as! String
        }
        if dict.keys.contains("newPath") {
            self.newPath = dict["newPath"] as! String
        }
        if dict.keys.contains("oldPath") {
            self.oldPath = dict["oldPath"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class UpdateFileResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var branchName: String?

        public var filePath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["branchName"] = self.branchName!
            }
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("branchName") {
                self.branchName = dict["branchName"] as! String
            }
            if dict.keys.contains("filePath") {
                self.filePath = dict["filePath"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateFileResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdateFileResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFlowTagRequest : Tea.TeaModel {
    public var color: String?

    public var flowTagGroupId: Int64?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.color != nil {
            map["color"] = self.color!
        }
        if self.flowTagGroupId != nil {
            map["flowTagGroupId"] = self.flowTagGroupId!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("color") {
            self.color = dict["color"] as! String
        }
        if dict.keys.contains("flowTagGroupId") {
            self.flowTagGroupId = dict["flowTagGroupId"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
    }
}

public class UpdateFlowTagResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateFlowTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFlowTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateFlowTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFlowTagGroupRequest : Tea.TeaModel {
    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
    }
}

public class UpdateFlowTagGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateFlowTagGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFlowTagGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateFlowTagGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGroupRequest : Tea.TeaModel {
    public var accessToken: String?

    public var avatarUrl: String?

    public var description_: String?

    public var name: String?

    public var path: String?

    public var pathWithNamespace: String?

    public var visibilityLevel: Int32?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.avatarUrl != nil {
            map["avatarUrl"] = self.avatarUrl!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.pathWithNamespace != nil {
            map["pathWithNamespace"] = self.pathWithNamespace!
        }
        if self.visibilityLevel != nil {
            map["visibilityLevel"] = self.visibilityLevel!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("avatarUrl") {
            self.avatarUrl = dict["avatarUrl"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("path") {
            self.path = dict["path"] as! String
        }
        if dict.keys.contains("pathWithNamespace") {
            self.pathWithNamespace = dict["pathWithNamespace"] as! String
        }
        if dict.keys.contains("visibilityLevel") {
            self.visibilityLevel = dict["visibilityLevel"] as! Int32
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class UpdateGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var avatarUrl: String?

        public var description_: String?

        public var id: Int64?

        public var name: String?

        public var nameWithNamespace: String?

        public var ownerId: Int64?

        public var parentId: Int64?

        public var path: String?

        public var pathWithNamespace: String?

        public var type: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("ownerId") {
                self.ownerId = dict["ownerId"] as! Int64
            }
            if dict.keys.contains("parentId") {
                self.parentId = dict["parentId"] as! Int64
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("pathWithNamespace") {
                self.pathWithNamespace = dict["pathWithNamespace"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("visibilityLevel") {
                self.visibilityLevel = dict["visibilityLevel"] as! Int32
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateGroupResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdateGroupResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGroupMemberRequest : Tea.TeaModel {
    public var accessToken: String?

    public var aliyunPk: String?

    public var accessLevel: Int32?

    public var memberType: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.aliyunPk != nil {
            map["aliyunPk"] = self.aliyunPk!
        }
        if self.accessLevel != nil {
            map["accessLevel"] = self.accessLevel!
        }
        if self.memberType != nil {
            map["memberType"] = self.memberType!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("aliyunPk") {
            self.aliyunPk = dict["aliyunPk"] as! String
        }
        if dict.keys.contains("accessLevel") {
            self.accessLevel = dict["accessLevel"] as! Int32
        }
        if dict.keys.contains("memberType") {
            self.memberType = dict["memberType"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class UpdateGroupMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var id: Int64?

        public var memberType: String?

        public var name: String?

        public var sourceId: Int64?

        public var state: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.memberType != nil {
                map["memberType"] = self.memberType!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("memberType") {
                self.memberType = dict["memberType"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceId") {
                self.sourceId = dict["sourceId"] as! Int64
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("username") {
                self.username = dict["username"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateGroupMemberResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdateGroupMemberResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateGroupMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGroupMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGroupMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateHostGroupRequest : Tea.TeaModel {
    public var aliyunRegion: String?

    public var ecsLabelKey: String?

    public var ecsLabelValue: String?

    public var ecsType: String?

    public var envId: String?

    public var machineInfos: String?

    public var name: String?

    public var serviceConnectionId: Int64?

    public var tagIds: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunRegion != nil {
            map["aliyunRegion"] = self.aliyunRegion!
        }
        if self.ecsLabelKey != nil {
            map["ecsLabelKey"] = self.ecsLabelKey!
        }
        if self.ecsLabelValue != nil {
            map["ecsLabelValue"] = self.ecsLabelValue!
        }
        if self.ecsType != nil {
            map["ecsType"] = self.ecsType!
        }
        if self.envId != nil {
            map["envId"] = self.envId!
        }
        if self.machineInfos != nil {
            map["machineInfos"] = self.machineInfos!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.serviceConnectionId != nil {
            map["serviceConnectionId"] = self.serviceConnectionId!
        }
        if self.tagIds != nil {
            map["tagIds"] = self.tagIds!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("aliyunRegion") {
            self.aliyunRegion = dict["aliyunRegion"] as! String
        }
        if dict.keys.contains("ecsLabelKey") {
            self.ecsLabelKey = dict["ecsLabelKey"] as! String
        }
        if dict.keys.contains("ecsLabelValue") {
            self.ecsLabelValue = dict["ecsLabelValue"] as! String
        }
        if dict.keys.contains("ecsType") {
            self.ecsType = dict["ecsType"] as! String
        }
        if dict.keys.contains("envId") {
            self.envId = dict["envId"] as! String
        }
        if dict.keys.contains("machineInfos") {
            self.machineInfos = dict["machineInfos"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("serviceConnectionId") {
            self.serviceConnectionId = dict["serviceConnectionId"] as! Int64
        }
        if dict.keys.contains("tagIds") {
            self.tagIds = dict["tagIds"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class UpdateHostGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateHostGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHostGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateHostGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMergeRequestRequest : Tea.TeaModel {
    public var accessToken: String?

    public var description_: String?

    public var title: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.title != nil {
            map["title"] = self.title!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("title") {
            self.title = dict["title"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class UpdateMergeRequestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateMergeRequestResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdateMergeRequestResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateMergeRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMergeRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMergeRequestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMergeRequestPersonnelRequest : Tea.TeaModel {
    public var accessToken: String?

    public var newUserIdList: [String]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.newUserIdList != nil {
            map["newUserIdList"] = self.newUserIdList!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("newUserIdList") {
            self.newUserIdList = dict["newUserIdList"] as! [String]
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class UpdateMergeRequestPersonnelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateMergeRequestPersonnelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdateMergeRequestPersonnelResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateMergeRequestPersonnelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMergeRequestPersonnelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMergeRequestPersonnelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateOrganizationMemberRequest : Tea.TeaModel {
    public var organizationMemberName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationMemberName != nil {
            map["organizationMemberName"] = self.organizationMemberName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("organizationMemberName") {
            self.organizationMemberName = dict["organizationMemberName"] as! String
        }
    }
}

public class UpdateOrganizationMemberResponseBody : Tea.TeaModel {
    public class Member : Tea.TeaModel {
        public var accountId: String?

        public var organizationMemberName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            if self.organizationMemberName != nil {
                map["organizationMemberName"] = self.organizationMemberName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
            if dict.keys.contains("organizationMemberName") {
                self.organizationMemberName = dict["organizationMemberName"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var member: UpdateOrganizationMemberResponseBody.Member?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.member?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.member != nil {
            map["member"] = self.member?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("member") {
            var model = UpdateOrganizationMemberResponseBody.Member()
            model.fromMap(dict["member"] as! [String: Any])
            self.member = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateOrganizationMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateOrganizationMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateOrganizationMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePipelineRequest : Tea.TeaModel {
    public var content: String?

    public var name: String?

    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.pipelineId != nil {
            map["pipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("content") {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("pipelineId") {
            self.pipelineId = dict["pipelineId"] as! String
        }
    }
}

public class UpdatePipelineResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePipelineBaseInfoRequest : Tea.TeaModel {
    public var envId: Int64?

    public var pipelineName: String?

    public var tagList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.envId != nil {
            map["envId"] = self.envId!
        }
        if self.pipelineName != nil {
            map["pipelineName"] = self.pipelineName!
        }
        if self.tagList != nil {
            map["tagList"] = self.tagList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("envId") {
            self.envId = dict["envId"] as! Int64
        }
        if dict.keys.contains("pipelineName") {
            self.pipelineName = dict["pipelineName"] as! String
        }
        if dict.keys.contains("tagList") {
            self.tagList = dict["tagList"] as! String
        }
    }
}

public class UpdatePipelineBaseInfoResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdatePipelineBaseInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineBaseInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePipelineBaseInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePipelineGroupRequest : Tea.TeaModel {
    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
    }
}

public class UpdatePipelineGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdatePipelineGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePipelineGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProjectFieldRequest : Tea.TeaModel {
    public class UpdateBasicFieldRequestList : Tea.TeaModel {
        public var propertyKey: String?

        public var propertyValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.propertyKey != nil {
                map["propertyKey"] = self.propertyKey!
            }
            if self.propertyValue != nil {
                map["propertyValue"] = self.propertyValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("propertyKey") {
                self.propertyKey = dict["propertyKey"] as! String
            }
            if dict.keys.contains("propertyValue") {
                self.propertyValue = dict["propertyValue"] as! String
            }
        }
    }
    public class UpdateForOpenApiList : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldIdentifier") {
                self.fieldIdentifier = dict["fieldIdentifier"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var statusIdentifier: String?

    public var updateBasicFieldRequestList: [UpdateProjectFieldRequest.UpdateBasicFieldRequestList]?

    public var updateForOpenApiList: [UpdateProjectFieldRequest.UpdateForOpenApiList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.statusIdentifier != nil {
            map["statusIdentifier"] = self.statusIdentifier!
        }
        if self.updateBasicFieldRequestList != nil {
            var tmp : [Any] = []
            for k in self.updateBasicFieldRequestList! {
                tmp.append(k.toMap())
            }
            map["updateBasicFieldRequestList"] = tmp
        }
        if self.updateForOpenApiList != nil {
            var tmp : [Any] = []
            for k in self.updateForOpenApiList! {
                tmp.append(k.toMap())
            }
            map["updateForOpenApiList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("statusIdentifier") {
            self.statusIdentifier = dict["statusIdentifier"] as! String
        }
        if dict.keys.contains("updateBasicFieldRequestList") {
            var tmp : [UpdateProjectFieldRequest.UpdateBasicFieldRequestList] = []
            for v in dict["updateBasicFieldRequestList"] as! [Any] {
                var model = UpdateProjectFieldRequest.UpdateBasicFieldRequestList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.updateBasicFieldRequestList = tmp
        }
        if dict.keys.contains("updateForOpenApiList") {
            var tmp : [UpdateProjectFieldRequest.UpdateForOpenApiList] = []
            for v in dict["updateForOpenApiList"] as! [Any] {
                var model = UpdateProjectFieldRequest.UpdateForOpenApiList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.updateForOpenApiList = tmp
        }
    }
}

public class UpdateProjectFieldResponseBody : Tea.TeaModel {
    public class Project : Tea.TeaModel {
        public class FieldList : Tea.TeaModel {
            public var displayName: String?

            public var identifier: String?

            public var value: String?

            public var valueType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                if self.valueType != nil {
                    map["valueType"] = self.valueType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("displayName") {
                    self.displayName = dict["displayName"] as! String
                }
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
                if dict.keys.contains("valueType") {
                    self.valueType = dict["valueType"] as! String
                }
            }
        }
        public var category: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var customCode: String?

        public var description_: String?

        public var fieldList: [UpdateProjectFieldResponseBody.Project.FieldList]?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var icon: String?

        public var iconBig: String?

        public var iconGroup: String?

        public var iconSmall: String?

        public var id: String?

        public var identifier: String?

        public var identifierPath: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var name: String?

        public var organizationIdentifier: String?

        public var parentIdentifier: String?

        public var scope: String?

        public var statusIdentifier: String?

        public var statusName: String?

        public var statusStageIdentifier: String?

        public var subType: String?

        public var typeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["category"] = self.category!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.customCode != nil {
                map["customCode"] = self.customCode!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.fieldList != nil {
                var tmp : [Any] = []
                for k in self.fieldList! {
                    tmp.append(k.toMap())
                }
                map["fieldList"] = tmp
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.icon != nil {
                map["icon"] = self.icon!
            }
            if self.iconBig != nil {
                map["iconBig"] = self.iconBig!
            }
            if self.iconGroup != nil {
                map["iconGroup"] = self.iconGroup!
            }
            if self.iconSmall != nil {
                map["iconSmall"] = self.iconSmall!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.identifierPath != nil {
                map["identifierPath"] = self.identifierPath!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.organizationIdentifier != nil {
                map["organizationIdentifier"] = self.organizationIdentifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.scope != nil {
                map["scope"] = self.scope!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusName != nil {
                map["statusName"] = self.statusName!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subType != nil {
                map["subType"] = self.subType!
            }
            if self.typeIdentifier != nil {
                map["typeIdentifier"] = self.typeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("category") {
                self.category = dict["category"] as! String
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("customCode") {
                self.customCode = dict["customCode"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("fieldList") {
                var tmp : [UpdateProjectFieldResponseBody.Project.FieldList] = []
                for v in dict["fieldList"] as! [Any] {
                    var model = UpdateProjectFieldResponseBody.Project.FieldList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fieldList = tmp
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("icon") {
                self.icon = dict["icon"] as! String
            }
            if dict.keys.contains("iconBig") {
                self.iconBig = dict["iconBig"] as! String
            }
            if dict.keys.contains("iconGroup") {
                self.iconGroup = dict["iconGroup"] as! String
            }
            if dict.keys.contains("iconSmall") {
                self.iconSmall = dict["iconSmall"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("identifierPath") {
                self.identifierPath = dict["identifierPath"] as! String
            }
            if dict.keys.contains("logicalStatus") {
                self.logicalStatus = dict["logicalStatus"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("organizationIdentifier") {
                self.organizationIdentifier = dict["organizationIdentifier"] as! String
            }
            if dict.keys.contains("parentIdentifier") {
                self.parentIdentifier = dict["parentIdentifier"] as! String
            }
            if dict.keys.contains("scope") {
                self.scope = dict["scope"] as! String
            }
            if dict.keys.contains("statusIdentifier") {
                self.statusIdentifier = dict["statusIdentifier"] as! String
            }
            if dict.keys.contains("statusName") {
                self.statusName = dict["statusName"] as! String
            }
            if dict.keys.contains("statusStageIdentifier") {
                self.statusStageIdentifier = dict["statusStageIdentifier"] as! String
            }
            if dict.keys.contains("subType") {
                self.subType = dict["subType"] as! String
            }
            if dict.keys.contains("typeIdentifier") {
                self.typeIdentifier = dict["typeIdentifier"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var project: UpdateProjectFieldResponseBody.Project?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.project?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.project != nil {
            map["project"] = self.project?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("project") {
            var model = UpdateProjectFieldResponseBody.Project()
            model.fromMap(dict["project"] as! [String: Any])
            self.project = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateProjectFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProjectFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateProjectFieldResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProjectLabelRequest : Tea.TeaModel {
    public var accessToken: String?

    public var color: String?

    public var description_: String?

    public var name: String?

    public var organizationId: String?

    public var repositoryIdentity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.color != nil {
            map["color"] = self.color!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.repositoryIdentity != nil {
            map["repositoryIdentity"] = self.repositoryIdentity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("color") {
            self.color = dict["color"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("repositoryIdentity") {
            self.repositoryIdentity = dict["repositoryIdentity"] as! String
        }
    }
}

public class UpdateProjectLabelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var color: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.color != nil {
                map["color"] = self.color!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("color") {
                self.color = dict["color"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateProjectLabelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdateProjectLabelResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateProjectLabelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProjectLabelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateProjectLabelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProjectMemberRequest : Tea.TeaModel {
    public var roleIdentifier: String?

    public var targetIdentifier: String?

    public var targetType: String?

    public var userIdentifier: String?

    public var userType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roleIdentifier != nil {
            map["roleIdentifier"] = self.roleIdentifier!
        }
        if self.targetIdentifier != nil {
            map["targetIdentifier"] = self.targetIdentifier!
        }
        if self.targetType != nil {
            map["targetType"] = self.targetType!
        }
        if self.userIdentifier != nil {
            map["userIdentifier"] = self.userIdentifier!
        }
        if self.userType != nil {
            map["userType"] = self.userType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("roleIdentifier") {
            self.roleIdentifier = dict["roleIdentifier"] as! String
        }
        if dict.keys.contains("targetIdentifier") {
            self.targetIdentifier = dict["targetIdentifier"] as! String
        }
        if dict.keys.contains("targetType") {
            self.targetType = dict["targetType"] as! String
        }
        if dict.keys.contains("userIdentifier") {
            self.userIdentifier = dict["userIdentifier"] as! String
        }
        if dict.keys.contains("userType") {
            self.userType = dict["userType"] as! String
        }
    }
}

public class UpdateProjectMemberResponseBody : Tea.TeaModel {
    public class Member : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: String?

        public var roleIdentifier: String?

        public var targetIdentifier: String?

        public var targetType: String?

        public var userIdentifier: String?

        public var userType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.roleIdentifier != nil {
                map["roleIdentifier"] = self.roleIdentifier!
            }
            if self.targetIdentifier != nil {
                map["targetIdentifier"] = self.targetIdentifier!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.userIdentifier != nil {
                map["userIdentifier"] = self.userIdentifier!
            }
            if self.userType != nil {
                map["userType"] = self.userType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("roleIdentifier") {
                self.roleIdentifier = dict["roleIdentifier"] as! String
            }
            if dict.keys.contains("targetIdentifier") {
                self.targetIdentifier = dict["targetIdentifier"] as! String
            }
            if dict.keys.contains("targetType") {
                self.targetType = dict["targetType"] as! String
            }
            if dict.keys.contains("userIdentifier") {
                self.userIdentifier = dict["userIdentifier"] as! String
            }
            if dict.keys.contains("userType") {
                self.userType = dict["userType"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var member: UpdateProjectMemberResponseBody.Member?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.member?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.member != nil {
            map["member"] = self.member?.toMap()
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("member") {
            var model = UpdateProjectMemberResponseBody.Member()
            model.fromMap(dict["member"] as! [String: Any])
            self.member = model
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateProjectMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProjectMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateProjectMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateProtectedBranchesRequest : Tea.TeaModel {
    public class MergeRequestSetting : Tea.TeaModel {
        public var allowMergeRequestRoles: [Int32]?

        public var defaultAssignees: [String]?

        public var isAllowSelfApproval: Bool?

        public var isRequireDiscussionProcessed: Bool?

        public var isRequired: Bool?

        public var isResetApprovalWhenNewPush: Bool?

        public var minimumApproval: Int32?

        public var mrMode: String?

        public var whiteList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowMergeRequestRoles != nil {
                map["allowMergeRequestRoles"] = self.allowMergeRequestRoles!
            }
            if self.defaultAssignees != nil {
                map["defaultAssignees"] = self.defaultAssignees!
            }
            if self.isAllowSelfApproval != nil {
                map["isAllowSelfApproval"] = self.isAllowSelfApproval!
            }
            if self.isRequireDiscussionProcessed != nil {
                map["isRequireDiscussionProcessed"] = self.isRequireDiscussionProcessed!
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.isResetApprovalWhenNewPush != nil {
                map["isResetApprovalWhenNewPush"] = self.isResetApprovalWhenNewPush!
            }
            if self.minimumApproval != nil {
                map["minimumApproval"] = self.minimumApproval!
            }
            if self.mrMode != nil {
                map["mrMode"] = self.mrMode!
            }
            if self.whiteList != nil {
                map["whiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("allowMergeRequestRoles") {
                self.allowMergeRequestRoles = dict["allowMergeRequestRoles"] as! [Int32]
            }
            if dict.keys.contains("defaultAssignees") {
                self.defaultAssignees = dict["defaultAssignees"] as! [String]
            }
            if dict.keys.contains("isAllowSelfApproval") {
                self.isAllowSelfApproval = dict["isAllowSelfApproval"] as! Bool
            }
            if dict.keys.contains("isRequireDiscussionProcessed") {
                self.isRequireDiscussionProcessed = dict["isRequireDiscussionProcessed"] as! Bool
            }
            if dict.keys.contains("isRequired") {
                self.isRequired = dict["isRequired"] as! Bool
            }
            if dict.keys.contains("isResetApprovalWhenNewPush") {
                self.isResetApprovalWhenNewPush = dict["isResetApprovalWhenNewPush"] as! Bool
            }
            if dict.keys.contains("minimumApproval") {
                self.minimumApproval = dict["minimumApproval"] as! Int32
            }
            if dict.keys.contains("mrMode") {
                self.mrMode = dict["mrMode"] as! String
            }
            if dict.keys.contains("whiteList") {
                self.whiteList = dict["whiteList"] as! String
            }
        }
    }
    public class TestSettingDTO : Tea.TeaModel {
        public class CheckConfig : Tea.TeaModel {
            public class CheckItems : Tea.TeaModel {
                public var isRequired: Bool?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isRequired != nil {
                        map["isRequired"] = self.isRequired!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("isRequired") {
                        self.isRequired = dict["isRequired"] as! Bool
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                }
            }
            public var checkItems: [UpdateProtectedBranchesRequest.TestSettingDTO.CheckConfig.CheckItems]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkItems != nil {
                    var tmp : [Any] = []
                    for k in self.checkItems! {
                        tmp.append(k.toMap())
                    }
                    map["checkItems"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("checkItems") {
                    var tmp : [UpdateProtectedBranchesRequest.TestSettingDTO.CheckConfig.CheckItems] = []
                    for v in dict["checkItems"] as! [Any] {
                        var model = UpdateProtectedBranchesRequest.TestSettingDTO.CheckConfig.CheckItems()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.checkItems = tmp
                }
            }
        }
        public class CheckTaskQualityConfig : Tea.TeaModel {
            public var bizNo: String?

            public var enabled: Bool?

            public var message: String?

            public var taskName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizNo != nil {
                    map["bizNo"] = self.bizNo!
                }
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                if self.taskName != nil {
                    map["taskName"] = self.taskName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("bizNo") {
                    self.bizNo = dict["bizNo"] as! String
                }
                if dict.keys.contains("enabled") {
                    self.enabled = dict["enabled"] as! Bool
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
                if dict.keys.contains("taskName") {
                    self.taskName = dict["taskName"] as! String
                }
            }
        }
        public class CodeGuidelinesDetection : Tea.TeaModel {
            public var enabled: Bool?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("enabled") {
                    self.enabled = dict["enabled"] as! Bool
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
            }
        }
        public class SensitiveInfoDetection : Tea.TeaModel {
            public var enabled: Bool?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enabled != nil {
                    map["enabled"] = self.enabled!
                }
                if self.message != nil {
                    map["message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("enabled") {
                    self.enabled = dict["enabled"] as! Bool
                }
                if dict.keys.contains("message") {
                    self.message = dict["message"] as! String
                }
            }
        }
        public var checkConfig: UpdateProtectedBranchesRequest.TestSettingDTO.CheckConfig?

        public var checkTaskQualityConfig: UpdateProtectedBranchesRequest.TestSettingDTO.CheckTaskQualityConfig?

        public var codeGuidelinesDetection: UpdateProtectedBranchesRequest.TestSettingDTO.CodeGuidelinesDetection?

        public var isRequired: Bool?

        public var sensitiveInfoDetection: UpdateProtectedBranchesRequest.TestSettingDTO.SensitiveInfoDetection?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkConfig?.validate()
            try self.checkTaskQualityConfig?.validate()
            try self.codeGuidelinesDetection?.validate()
            try self.sensitiveInfoDetection?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkConfig != nil {
                map["checkConfig"] = self.checkConfig?.toMap()
            }
            if self.checkTaskQualityConfig != nil {
                map["checkTaskQualityConfig"] = self.checkTaskQualityConfig?.toMap()
            }
            if self.codeGuidelinesDetection != nil {
                map["codeGuidelinesDetection"] = self.codeGuidelinesDetection?.toMap()
            }
            if self.isRequired != nil {
                map["isRequired"] = self.isRequired!
            }
            if self.sensitiveInfoDetection != nil {
                map["sensitiveInfoDetection"] = self.sensitiveInfoDetection?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("checkConfig") {
                var model = UpdateProtectedBranchesRequest.TestSettingDTO.CheckConfig()
                model.fromMap(dict["checkConfig"] as! [String: Any])
                self.checkConfig = model
            }
            if dict.keys.contains("checkTaskQualityConfig") {
                var model = UpdateProtectedBranchesRequest.TestSettingDTO.CheckTaskQualityConfig()
                model.fromMap(dict["checkTaskQualityConfig"] as! [String: Any])
                self.checkTaskQualityConfig = model
            }
            if dict.keys.contains("codeGuidelinesDetection") {
                var model = UpdateProtectedBranchesRequest.TestSettingDTO.CodeGuidelinesDetection()
                model.fromMap(dict["codeGuidelinesDetection"] as! [String: Any])
                self.codeGuidelinesDetection = model
            }
            if dict.keys.contains("isRequired") {
                self.isRequired = dict["isRequired"] as! Bool
            }
            if dict.keys.contains("sensitiveInfoDetection") {
                var model = UpdateProtectedBranchesRequest.TestSettingDTO.SensitiveInfoDetection()
                model.fromMap(dict["sensitiveInfoDetection"] as! [String: Any])
                self.sensitiveInfoDetection = model
            }
        }
    }
    public var accessToken: String?

    public var allowMergeRoles: [Int32]?

    public var allowMergeUserIds: [String]?

    public var allowPushRoles: [Int32]?

    public var allowPushUserIds: [String]?

    public var branch: String?

    public var id: Int64?

    public var mergeRequestSetting: UpdateProtectedBranchesRequest.MergeRequestSetting?

    public var testSettingDTO: UpdateProtectedBranchesRequest.TestSettingDTO?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mergeRequestSetting?.validate()
        try self.testSettingDTO?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.allowMergeRoles != nil {
            map["allowMergeRoles"] = self.allowMergeRoles!
        }
        if self.allowMergeUserIds != nil {
            map["allowMergeUserIds"] = self.allowMergeUserIds!
        }
        if self.allowPushRoles != nil {
            map["allowPushRoles"] = self.allowPushRoles!
        }
        if self.allowPushUserIds != nil {
            map["allowPushUserIds"] = self.allowPushUserIds!
        }
        if self.branch != nil {
            map["branch"] = self.branch!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.mergeRequestSetting != nil {
            map["mergeRequestSetting"] = self.mergeRequestSetting?.toMap()
        }
        if self.testSettingDTO != nil {
            map["testSettingDTO"] = self.testSettingDTO?.toMap()
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("allowMergeRoles") {
            self.allowMergeRoles = dict["allowMergeRoles"] as! [Int32]
        }
        if dict.keys.contains("allowMergeUserIds") {
            self.allowMergeUserIds = dict["allowMergeUserIds"] as! [String]
        }
        if dict.keys.contains("allowPushRoles") {
            self.allowPushRoles = dict["allowPushRoles"] as! [Int32]
        }
        if dict.keys.contains("allowPushUserIds") {
            self.allowPushUserIds = dict["allowPushUserIds"] as! [String]
        }
        if dict.keys.contains("branch") {
            self.branch = dict["branch"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("mergeRequestSetting") {
            var model = UpdateProtectedBranchesRequest.MergeRequestSetting()
            model.fromMap(dict["mergeRequestSetting"] as! [String: Any])
            self.mergeRequestSetting = model
        }
        if dict.keys.contains("testSettingDTO") {
            var model = UpdateProtectedBranchesRequest.TestSettingDTO()
            model.fromMap(dict["testSettingDTO"] as! [String: Any])
            self.testSettingDTO = model
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class UpdateProtectedBranchesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class MergeRequestSetting : Tea.TeaModel {
            public var allowMergeRequestRoles: [Int32]?

            public var defaultAssignees: [String]?

            public var isAllowSelfApproval: Bool?

            public var isRequireDiscussionProcessed: Bool?

            public var isRequired: Bool?

            public var isResetApprovalWhenNewPush: Bool?

            public var minimumApproval: Int32?

            public var mrMode: String?

            public var whiteList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowMergeRequestRoles != nil {
                    map["allowMergeRequestRoles"] = self.allowMergeRequestRoles!
                }
                if self.defaultAssignees != nil {
                    map["defaultAssignees"] = self.defaultAssignees!
                }
                if self.isAllowSelfApproval != nil {
                    map["isAllowSelfApproval"] = self.isAllowSelfApproval!
                }
                if self.isRequireDiscussionProcessed != nil {
                    map["isRequireDiscussionProcessed"] = self.isRequireDiscussionProcessed!
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.isResetApprovalWhenNewPush != nil {
                    map["isResetApprovalWhenNewPush"] = self.isResetApprovalWhenNewPush!
                }
                if self.minimumApproval != nil {
                    map["minimumApproval"] = self.minimumApproval!
                }
                if self.mrMode != nil {
                    map["mrMode"] = self.mrMode!
                }
                if self.whiteList != nil {
                    map["whiteList"] = self.whiteList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("allowMergeRequestRoles") {
                    self.allowMergeRequestRoles = dict["allowMergeRequestRoles"] as! [Int32]
                }
                if dict.keys.contains("defaultAssignees") {
                    self.defaultAssignees = dict["defaultAssignees"] as! [String]
                }
                if dict.keys.contains("isAllowSelfApproval") {
                    self.isAllowSelfApproval = dict["isAllowSelfApproval"] as! Bool
                }
                if dict.keys.contains("isRequireDiscussionProcessed") {
                    self.isRequireDiscussionProcessed = dict["isRequireDiscussionProcessed"] as! Bool
                }
                if dict.keys.contains("isRequired") {
                    self.isRequired = dict["isRequired"] as! Bool
                }
                if dict.keys.contains("isResetApprovalWhenNewPush") {
                    self.isResetApprovalWhenNewPush = dict["isResetApprovalWhenNewPush"] as! Bool
                }
                if dict.keys.contains("minimumApproval") {
                    self.minimumApproval = dict["minimumApproval"] as! Int32
                }
                if dict.keys.contains("mrMode") {
                    self.mrMode = dict["mrMode"] as! String
                }
                if dict.keys.contains("whiteList") {
                    self.whiteList = dict["whiteList"] as! String
                }
            }
        }
        public class TestSettingDTO : Tea.TeaModel {
            public class CheckConfig : Tea.TeaModel {
                public class CheckItems : Tea.TeaModel {
                    public var isRequired: Bool?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isRequired != nil {
                            map["isRequired"] = self.isRequired!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("isRequired") {
                            self.isRequired = dict["isRequired"] as! Bool
                        }
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                    }
                }
                public var checkItems: [UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkItems != nil {
                        var tmp : [Any] = []
                        for k in self.checkItems! {
                            tmp.append(k.toMap())
                        }
                        map["checkItems"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("checkItems") {
                        var tmp : [UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems] = []
                        for v in dict["checkItems"] as! [Any] {
                            var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig.CheckItems()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.checkItems = tmp
                    }
                }
            }
            public class CheckTaskQualityConfig : Tea.TeaModel {
                public var bizNo: String?

                public var enabled: Bool?

                public var message: String?

                public var taskName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizNo != nil {
                        map["bizNo"] = self.bizNo!
                    }
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    if self.taskName != nil {
                        map["taskName"] = self.taskName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("bizNo") {
                        self.bizNo = dict["bizNo"] as! String
                    }
                    if dict.keys.contains("enabled") {
                        self.enabled = dict["enabled"] as! Bool
                    }
                    if dict.keys.contains("message") {
                        self.message = dict["message"] as! String
                    }
                    if dict.keys.contains("taskName") {
                        self.taskName = dict["taskName"] as! String
                    }
                }
            }
            public class CodeGuidelinesDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("enabled") {
                        self.enabled = dict["enabled"] as! Bool
                    }
                    if dict.keys.contains("message") {
                        self.message = dict["message"] as! String
                    }
                }
            }
            public class SensitiveInfoDetection : Tea.TeaModel {
                public var enabled: Bool?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enabled != nil {
                        map["enabled"] = self.enabled!
                    }
                    if self.message != nil {
                        map["message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("enabled") {
                        self.enabled = dict["enabled"] as! Bool
                    }
                    if dict.keys.contains("message") {
                        self.message = dict["message"] as! String
                    }
                }
            }
            public var checkConfig: UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig?

            public var checkTaskQualityConfig: UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig?

            public var codeGuidelinesDetection: UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection?

            public var isRequired: Bool?

            public var sensitiveInfoDetection: UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.SensitiveInfoDetection?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.checkConfig?.validate()
                try self.checkTaskQualityConfig?.validate()
                try self.codeGuidelinesDetection?.validate()
                try self.sensitiveInfoDetection?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkConfig != nil {
                    map["checkConfig"] = self.checkConfig?.toMap()
                }
                if self.checkTaskQualityConfig != nil {
                    map["checkTaskQualityConfig"] = self.checkTaskQualityConfig?.toMap()
                }
                if self.codeGuidelinesDetection != nil {
                    map["codeGuidelinesDetection"] = self.codeGuidelinesDetection?.toMap()
                }
                if self.isRequired != nil {
                    map["isRequired"] = self.isRequired!
                }
                if self.sensitiveInfoDetection != nil {
                    map["sensitiveInfoDetection"] = self.sensitiveInfoDetection?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("checkConfig") {
                    var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckConfig()
                    model.fromMap(dict["checkConfig"] as! [String: Any])
                    self.checkConfig = model
                }
                if dict.keys.contains("checkTaskQualityConfig") {
                    var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CheckTaskQualityConfig()
                    model.fromMap(dict["checkTaskQualityConfig"] as! [String: Any])
                    self.checkTaskQualityConfig = model
                }
                if dict.keys.contains("codeGuidelinesDetection") {
                    var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.CodeGuidelinesDetection()
                    model.fromMap(dict["codeGuidelinesDetection"] as! [String: Any])
                    self.codeGuidelinesDetection = model
                }
                if dict.keys.contains("isRequired") {
                    self.isRequired = dict["isRequired"] as! Bool
                }
                if dict.keys.contains("sensitiveInfoDetection") {
                    var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO.SensitiveInfoDetection()
                    model.fromMap(dict["sensitiveInfoDetection"] as! [String: Any])
                    self.sensitiveInfoDetection = model
                }
            }
        }
        public var allowMergeRoles: [Int32]?

        public var allowMergeUserIds: [Int64]?

        public var allowPushRoles: [Int32]?

        public var allowPushUserIds: [Int64]?

        public var branch: String?

        public var id: Int64?

        public var mergeRequestSetting: UpdateProtectedBranchesResponseBody.Result.MergeRequestSetting?

        public var testSettingDTO: UpdateProtectedBranchesResponseBody.Result.TestSettingDTO?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mergeRequestSetting?.validate()
            try self.testSettingDTO?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowMergeRoles != nil {
                map["allowMergeRoles"] = self.allowMergeRoles!
            }
            if self.allowMergeUserIds != nil {
                map["allowMergeUserIds"] = self.allowMergeUserIds!
            }
            if self.allowPushRoles != nil {
                map["allowPushRoles"] = self.allowPushRoles!
            }
            if self.allowPushUserIds != nil {
                map["allowPushUserIds"] = self.allowPushUserIds!
            }
            if self.branch != nil {
                map["branch"] = self.branch!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.mergeRequestSetting != nil {
                map["mergeRequestSetting"] = self.mergeRequestSetting?.toMap()
            }
            if self.testSettingDTO != nil {
                map["testSettingDTO"] = self.testSettingDTO?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("allowMergeRoles") {
                self.allowMergeRoles = dict["allowMergeRoles"] as! [Int32]
            }
            if dict.keys.contains("allowMergeUserIds") {
                self.allowMergeUserIds = dict["allowMergeUserIds"] as! [Int64]
            }
            if dict.keys.contains("allowPushRoles") {
                self.allowPushRoles = dict["allowPushRoles"] as! [Int32]
            }
            if dict.keys.contains("allowPushUserIds") {
                self.allowPushUserIds = dict["allowPushUserIds"] as! [Int64]
            }
            if dict.keys.contains("branch") {
                self.branch = dict["branch"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("mergeRequestSetting") {
                var model = UpdateProtectedBranchesResponseBody.Result.MergeRequestSetting()
                model.fromMap(dict["mergeRequestSetting"] as! [String: Any])
                self.mergeRequestSetting = model
            }
            if dict.keys.contains("testSettingDTO") {
                var model = UpdateProtectedBranchesResponseBody.Result.TestSettingDTO()
                model.fromMap(dict["testSettingDTO"] as! [String: Any])
                self.testSettingDTO = model
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateProtectedBranchesResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdateProtectedBranchesResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateProtectedBranchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateProtectedBranchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateProtectedBranchesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePushReviewOnOffRequest : Tea.TeaModel {
    public var organizationId: String?

    public var trunkMode: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        if self.trunkMode != nil {
            map["trunkMode"] = self.trunkMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
        if dict.keys.contains("trunkMode") {
            self.trunkMode = dict["trunkMode"] as! Bool
        }
    }
}

public class UpdatePushReviewOnOffResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var result: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                self.result = dict["result"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdatePushReviewOnOffResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdatePushReviewOnOffResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdatePushReviewOnOffResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePushReviewOnOffResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePushReviewOnOffResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePushRuleRequest : Tea.TeaModel {
    public class RuleInfos : Tea.TeaModel {
        public var checkerName: String?

        public var checkerType: String?

        public var extraMessage: String?

        public var fileRuleRegexes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkerName != nil {
                map["checkerName"] = self.checkerName!
            }
            if self.checkerType != nil {
                map["checkerType"] = self.checkerType!
            }
            if self.extraMessage != nil {
                map["extraMessage"] = self.extraMessage!
            }
            if self.fileRuleRegexes != nil {
                map["fileRuleRegexes"] = self.fileRuleRegexes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("checkerName") {
                self.checkerName = dict["checkerName"] as! String
            }
            if dict.keys.contains("checkerType") {
                self.checkerType = dict["checkerType"] as! String
            }
            if dict.keys.contains("extraMessage") {
                self.extraMessage = dict["extraMessage"] as! String
            }
            if dict.keys.contains("fileRuleRegexes") {
                self.fileRuleRegexes = dict["fileRuleRegexes"] as! [String]
            }
        }
    }
    public var accessToken: String?

    public var ruleInfos: [UpdatePushRuleRequest.RuleInfos]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.ruleInfos != nil {
            var tmp : [Any] = []
            for k in self.ruleInfos! {
                tmp.append(k.toMap())
            }
            map["ruleInfos"] = tmp
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("ruleInfos") {
            var tmp : [UpdatePushRuleRequest.RuleInfos] = []
            for v in dict["ruleInfos"] as! [Any] {
                var model = UpdatePushRuleRequest.RuleInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ruleInfos = tmp
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class UpdatePushRuleResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class RuleInfos : Tea.TeaModel {
            public var checkerName: String?

            public var checkerType: String?

            public var extraMessage: String?

            public var fileRuleRegexes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkerName != nil {
                    map["checkerName"] = self.checkerName!
                }
                if self.checkerType != nil {
                    map["checkerType"] = self.checkerType!
                }
                if self.extraMessage != nil {
                    map["extraMessage"] = self.extraMessage!
                }
                if self.fileRuleRegexes != nil {
                    map["fileRuleRegexes"] = self.fileRuleRegexes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("checkerName") {
                    self.checkerName = dict["checkerName"] as! String
                }
                if dict.keys.contains("checkerType") {
                    self.checkerType = dict["checkerType"] as! String
                }
                if dict.keys.contains("extraMessage") {
                    self.extraMessage = dict["extraMessage"] as! String
                }
                if dict.keys.contains("fileRuleRegexes") {
                    self.fileRuleRegexes = dict["fileRuleRegexes"] as! [String]
                }
            }
        }
        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var ruleInfos: [UpdatePushRuleResponseBody.Result.RuleInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.ruleInfos != nil {
                var tmp : [Any] = []
                for k in self.ruleInfos! {
                    tmp.append(k.toMap())
                }
                map["ruleInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("ruleInfos") {
                var tmp : [UpdatePushRuleResponseBody.Result.RuleInfos] = []
                for v in dict["ruleInfos"] as! [Any] {
                    var model = UpdatePushRuleResponseBody.Result.RuleInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleInfos = tmp
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdatePushRuleResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdatePushRuleResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdatePushRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePushRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePushRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRepositoryRequest : Tea.TeaModel {
    public class ProjectCloneDownloadMethodList : Tea.TeaModel {
        public var allowed: Bool?

        public var permissionCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowed != nil {
                map["allowed"] = self.allowed!
            }
            if self.permissionCode != nil {
                map["permissionCode"] = self.permissionCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("allowed") {
                self.allowed = dict["allowed"] as! Bool
            }
            if dict.keys.contains("permissionCode") {
                self.permissionCode = dict["permissionCode"] as! String
            }
        }
    }
    public class ProjectCloneDownloadRoleList : Tea.TeaModel {
        public var allowed: Bool?

        public var roleCode: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowed != nil {
                map["allowed"] = self.allowed!
            }
            if self.roleCode != nil {
                map["roleCode"] = self.roleCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("allowed") {
                self.allowed = dict["allowed"] as! Bool
            }
            if dict.keys.contains("roleCode") {
                self.roleCode = dict["roleCode"] as! Int32
            }
        }
    }
    public var accessToken: String?

    public var adminSettingLanguage: String?

    public var avatar: String?

    public var buildsEnabled: Bool?

    public var checkEmail: Bool?

    public var defaultBranch: String?

    public var description_: String?

    public var id: Int64?

    public var issuesEnabled: Bool?

    public var mergeRequestsEnabled: Bool?

    public var name: String?

    public var openCloneDownloadControl: Bool?

    public var path: String?

    public var projectCloneDownloadMethodList: [UpdateRepositoryRequest.ProjectCloneDownloadMethodList]?

    public var projectCloneDownloadRoleList: [UpdateRepositoryRequest.ProjectCloneDownloadRoleList]?

    public var snippetsEnabled: Bool?

    public var visibilityLevel: Int32?

    public var wikiEnabled: Bool?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.adminSettingLanguage != nil {
            map["adminSettingLanguage"] = self.adminSettingLanguage!
        }
        if self.avatar != nil {
            map["avatar"] = self.avatar!
        }
        if self.buildsEnabled != nil {
            map["buildsEnabled"] = self.buildsEnabled!
        }
        if self.checkEmail != nil {
            map["checkEmail"] = self.checkEmail!
        }
        if self.defaultBranch != nil {
            map["defaultBranch"] = self.defaultBranch!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.issuesEnabled != nil {
            map["issuesEnabled"] = self.issuesEnabled!
        }
        if self.mergeRequestsEnabled != nil {
            map["mergeRequestsEnabled"] = self.mergeRequestsEnabled!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.openCloneDownloadControl != nil {
            map["openCloneDownloadControl"] = self.openCloneDownloadControl!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        if self.projectCloneDownloadMethodList != nil {
            var tmp : [Any] = []
            for k in self.projectCloneDownloadMethodList! {
                tmp.append(k.toMap())
            }
            map["projectCloneDownloadMethodList"] = tmp
        }
        if self.projectCloneDownloadRoleList != nil {
            var tmp : [Any] = []
            for k in self.projectCloneDownloadRoleList! {
                tmp.append(k.toMap())
            }
            map["projectCloneDownloadRoleList"] = tmp
        }
        if self.snippetsEnabled != nil {
            map["snippetsEnabled"] = self.snippetsEnabled!
        }
        if self.visibilityLevel != nil {
            map["visibilityLevel"] = self.visibilityLevel!
        }
        if self.wikiEnabled != nil {
            map["wikiEnabled"] = self.wikiEnabled!
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("adminSettingLanguage") {
            self.adminSettingLanguage = dict["adminSettingLanguage"] as! String
        }
        if dict.keys.contains("avatar") {
            self.avatar = dict["avatar"] as! String
        }
        if dict.keys.contains("buildsEnabled") {
            self.buildsEnabled = dict["buildsEnabled"] as! Bool
        }
        if dict.keys.contains("checkEmail") {
            self.checkEmail = dict["checkEmail"] as! Bool
        }
        if dict.keys.contains("defaultBranch") {
            self.defaultBranch = dict["defaultBranch"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("issuesEnabled") {
            self.issuesEnabled = dict["issuesEnabled"] as! Bool
        }
        if dict.keys.contains("mergeRequestsEnabled") {
            self.mergeRequestsEnabled = dict["mergeRequestsEnabled"] as! Bool
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("openCloneDownloadControl") {
            self.openCloneDownloadControl = dict["openCloneDownloadControl"] as! Bool
        }
        if dict.keys.contains("path") {
            self.path = dict["path"] as! String
        }
        if dict.keys.contains("projectCloneDownloadMethodList") {
            var tmp : [UpdateRepositoryRequest.ProjectCloneDownloadMethodList] = []
            for v in dict["projectCloneDownloadMethodList"] as! [Any] {
                var model = UpdateRepositoryRequest.ProjectCloneDownloadMethodList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.projectCloneDownloadMethodList = tmp
        }
        if dict.keys.contains("projectCloneDownloadRoleList") {
            var tmp : [UpdateRepositoryRequest.ProjectCloneDownloadRoleList] = []
            for v in dict["projectCloneDownloadRoleList"] as! [Any] {
                var model = UpdateRepositoryRequest.ProjectCloneDownloadRoleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.projectCloneDownloadRoleList = tmp
        }
        if dict.keys.contains("snippetsEnabled") {
            self.snippetsEnabled = dict["snippetsEnabled"] as! Bool
        }
        if dict.keys.contains("visibilityLevel") {
            self.visibilityLevel = dict["visibilityLevel"] as! Int32
        }
        if dict.keys.contains("wikiEnabled") {
            self.wikiEnabled = dict["wikiEnabled"] as! Bool
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class UpdateRepositoryResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Namespace : Tea.TeaModel {
            public var avatar: String?

            public var createdAt: String?

            public var description_: String?

            public var id: Int64?

            public var name: String?

            public var ownerId: Int64?

            public var path: String?

            public var updatedAt: String?

            public var visibilityLevel: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.createdAt != nil {
                    map["createdAt"] = self.createdAt!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.id != nil {
                    map["id"] = self.id!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.ownerId != nil {
                    map["ownerId"] = self.ownerId!
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.updatedAt != nil {
                    map["updatedAt"] = self.updatedAt!
                }
                if self.visibilityLevel != nil {
                    map["visibilityLevel"] = self.visibilityLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("avatar") {
                    self.avatar = dict["avatar"] as! String
                }
                if dict.keys.contains("createdAt") {
                    self.createdAt = dict["createdAt"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("id") {
                    self.id = dict["id"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("ownerId") {
                    self.ownerId = dict["ownerId"] as! Int64
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("updatedAt") {
                    self.updatedAt = dict["updatedAt"] as! String
                }
                if dict.keys.contains("visibilityLevel") {
                    self.visibilityLevel = dict["visibilityLevel"] as! Int32
                }
            }
        }
        public var archived: Bool?

        public var avatarUrl: String?

        public var buildsEnabled: Bool?

        public var createdAt: String?

        public var creatorId: Int64?

        public var defaultBranch: String?

        public var description_: String?

        public var httpUrlToRepo: String?

        public var id: Int64?

        public var issuesEnabled: Bool?

        public var lastActivityAt: String?

        public var mergeRequestsEnabled: Bool?

        public var name: String?

        public var nameWithNamespace: String?

        public var namespace: UpdateRepositoryResponseBody.Result.Namespace?

        public var path: String?

        public var pathWithNamespace: String?

        public var snippetsEnabled: Bool?

        public var sshUrlToRepo: String?

        public var visibilityLevel: Int32?

        public var webUrl: String?

        public var wikiEnabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.namespace?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archived != nil {
                map["archived"] = self.archived!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.buildsEnabled != nil {
                map["buildsEnabled"] = self.buildsEnabled!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.creatorId != nil {
                map["creatorId"] = self.creatorId!
            }
            if self.defaultBranch != nil {
                map["defaultBranch"] = self.defaultBranch!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.httpUrlToRepo != nil {
                map["httpUrlToRepo"] = self.httpUrlToRepo!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.issuesEnabled != nil {
                map["issuesEnabled"] = self.issuesEnabled!
            }
            if self.lastActivityAt != nil {
                map["lastActivityAt"] = self.lastActivityAt!
            }
            if self.mergeRequestsEnabled != nil {
                map["mergeRequestsEnabled"] = self.mergeRequestsEnabled!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.nameWithNamespace != nil {
                map["nameWithNamespace"] = self.nameWithNamespace!
            }
            if self.namespace != nil {
                map["namespace"] = self.namespace?.toMap()
            }
            if self.path != nil {
                map["path"] = self.path!
            }
            if self.pathWithNamespace != nil {
                map["pathWithNamespace"] = self.pathWithNamespace!
            }
            if self.snippetsEnabled != nil {
                map["snippetsEnabled"] = self.snippetsEnabled!
            }
            if self.sshUrlToRepo != nil {
                map["sshUrlToRepo"] = self.sshUrlToRepo!
            }
            if self.visibilityLevel != nil {
                map["visibilityLevel"] = self.visibilityLevel!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            if self.wikiEnabled != nil {
                map["wikiEnabled"] = self.wikiEnabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("archived") {
                self.archived = dict["archived"] as! Bool
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("buildsEnabled") {
                self.buildsEnabled = dict["buildsEnabled"] as! Bool
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("creatorId") {
                self.creatorId = dict["creatorId"] as! Int64
            }
            if dict.keys.contains("defaultBranch") {
                self.defaultBranch = dict["defaultBranch"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("httpUrlToRepo") {
                self.httpUrlToRepo = dict["httpUrlToRepo"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("issuesEnabled") {
                self.issuesEnabled = dict["issuesEnabled"] as! Bool
            }
            if dict.keys.contains("lastActivityAt") {
                self.lastActivityAt = dict["lastActivityAt"] as! String
            }
            if dict.keys.contains("mergeRequestsEnabled") {
                self.mergeRequestsEnabled = dict["mergeRequestsEnabled"] as! Bool
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("nameWithNamespace") {
                self.nameWithNamespace = dict["nameWithNamespace"] as! String
            }
            if dict.keys.contains("namespace") {
                var model = UpdateRepositoryResponseBody.Result.Namespace()
                model.fromMap(dict["namespace"] as! [String: Any])
                self.namespace = model
            }
            if dict.keys.contains("path") {
                self.path = dict["path"] as! String
            }
            if dict.keys.contains("pathWithNamespace") {
                self.pathWithNamespace = dict["pathWithNamespace"] as! String
            }
            if dict.keys.contains("snippetsEnabled") {
                self.snippetsEnabled = dict["snippetsEnabled"] as! Bool
            }
            if dict.keys.contains("sshUrlToRepo") {
                self.sshUrlToRepo = dict["sshUrlToRepo"] as! String
            }
            if dict.keys.contains("visibilityLevel") {
                self.visibilityLevel = dict["visibilityLevel"] as! Int32
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
            if dict.keys.contains("wikiEnabled") {
                self.wikiEnabled = dict["wikiEnabled"] as! Bool
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateRepositoryResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdateRepositoryResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateRepositoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRepositoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateRepositoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateRepositoryMemberRequest : Tea.TeaModel {
    public class RelatedInfos : Tea.TeaModel {
        public var relatedId: String?

        public var sourceId: Int64?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.relatedId != nil {
                map["relatedId"] = self.relatedId!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("relatedId") {
                self.relatedId = dict["relatedId"] as! String
            }
            if dict.keys.contains("sourceId") {
                self.sourceId = dict["sourceId"] as! Int64
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
        }
    }
    public var accessToken: String?

    public var accessLevel: Int32?

    public var expireAt: String?

    public var memberType: String?

    public var relatedId: String?

    public var relatedInfos: [UpdateRepositoryMemberRequest.RelatedInfos]?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessToken != nil {
            map["accessToken"] = self.accessToken!
        }
        if self.accessLevel != nil {
            map["accessLevel"] = self.accessLevel!
        }
        if self.expireAt != nil {
            map["expireAt"] = self.expireAt!
        }
        if self.memberType != nil {
            map["memberType"] = self.memberType!
        }
        if self.relatedId != nil {
            map["relatedId"] = self.relatedId!
        }
        if self.relatedInfos != nil {
            var tmp : [Any] = []
            for k in self.relatedInfos! {
                tmp.append(k.toMap())
            }
            map["relatedInfos"] = tmp
        }
        if self.organizationId != nil {
            map["organizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessToken") {
            self.accessToken = dict["accessToken"] as! String
        }
        if dict.keys.contains("accessLevel") {
            self.accessLevel = dict["accessLevel"] as! Int32
        }
        if dict.keys.contains("expireAt") {
            self.expireAt = dict["expireAt"] as! String
        }
        if dict.keys.contains("memberType") {
            self.memberType = dict["memberType"] as! String
        }
        if dict.keys.contains("relatedId") {
            self.relatedId = dict["relatedId"] as! String
        }
        if dict.keys.contains("relatedInfos") {
            var tmp : [UpdateRepositoryMemberRequest.RelatedInfos] = []
            for v in dict["relatedInfos"] as! [Any] {
                var model = UpdateRepositoryMemberRequest.RelatedInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.relatedInfos = tmp
        }
        if dict.keys.contains("organizationId") {
            self.organizationId = dict["organizationId"] as! String
        }
    }
}

public class UpdateRepositoryMemberResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessLevel: Int32?

        public var avatarUrl: String?

        public var email: String?

        public var expireAt: String?

        public var id: Int64?

        public var memberName: String?

        public var memberType: String?

        public var name: String?

        public var sourceId: Int64?

        public var sourceType: String?

        public var state: String?

        public var username: String?

        public var webUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessLevel != nil {
                map["accessLevel"] = self.accessLevel!
            }
            if self.avatarUrl != nil {
                map["avatarUrl"] = self.avatarUrl!
            }
            if self.email != nil {
                map["email"] = self.email!
            }
            if self.expireAt != nil {
                map["expireAt"] = self.expireAt!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.memberName != nil {
                map["memberName"] = self.memberName!
            }
            if self.memberType != nil {
                map["memberType"] = self.memberType!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceId != nil {
                map["sourceId"] = self.sourceId!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.username != nil {
                map["username"] = self.username!
            }
            if self.webUrl != nil {
                map["webUrl"] = self.webUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accessLevel") {
                self.accessLevel = dict["accessLevel"] as! Int32
            }
            if dict.keys.contains("avatarUrl") {
                self.avatarUrl = dict["avatarUrl"] as! String
            }
            if dict.keys.contains("email") {
                self.email = dict["email"] as! String
            }
            if dict.keys.contains("expireAt") {
                self.expireAt = dict["expireAt"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("memberName") {
                self.memberName = dict["memberName"] as! String
            }
            if dict.keys.contains("memberType") {
                self.memberType = dict["memberType"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceId") {
                self.sourceId = dict["sourceId"] as! Int64
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("username") {
                self.username = dict["username"] as! String
            }
            if dict.keys.contains("webUrl") {
                self.webUrl = dict["webUrl"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var result: UpdateRepositoryMemberResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.result != nil {
            map["result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("result") {
            var model = UpdateRepositoryMemberResponseBody.Result()
            model.fromMap(dict["result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateRepositoryMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRepositoryMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateRepositoryMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateResourceMemberRequest : Tea.TeaModel {
    public var roleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.roleName != nil {
            map["roleName"] = self.roleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("roleName") {
            self.roleName = dict["roleName"] as! String
        }
    }
}

public class UpdateResourceMemberResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateResourceMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateResourceMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateResourceMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTestCaseRequest : Tea.TeaModel {
    public class UpdateWorkitemPropertyRequest : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldIdentifier") {
                self.fieldIdentifier = dict["fieldIdentifier"] as! String
            }
            if dict.keys.contains("fieldValue") {
                self.fieldValue = dict["fieldValue"] as! String
            }
        }
    }
    public var updateWorkitemPropertyRequest: [UpdateTestCaseRequest.UpdateWorkitemPropertyRequest]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateWorkitemPropertyRequest != nil {
            var tmp : [Any] = []
            for k in self.updateWorkitemPropertyRequest! {
                tmp.append(k.toMap())
            }
            map["updateWorkitemPropertyRequest"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("updateWorkitemPropertyRequest") {
            var tmp : [UpdateTestCaseRequest.UpdateWorkitemPropertyRequest] = []
            for v in dict["updateWorkitemPropertyRequest"] as! [Any] {
                var model = UpdateTestCaseRequest.UpdateWorkitemPropertyRequest()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.updateWorkitemPropertyRequest = tmp
        }
    }
}

public class UpdateTestCaseResponseBody : Tea.TeaModel {
    public class Testcase : Tea.TeaModel {
        public class AssignedTo : Tea.TeaModel {
            public var assignIdentifier: String?

            public var name: String?

            public var tbRoleId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assignIdentifier != nil {
                    map["assignIdentifier"] = self.assignIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.tbRoleId != nil {
                    map["tbRoleId"] = self.tbRoleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("assignIdentifier") {
                    self.assignIdentifier = dict["assignIdentifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("tbRoleId") {
                    self.tbRoleId = dict["tbRoleId"] as! String
                }
            }
        }
        public class Creator : Tea.TeaModel {
            public var createIdentifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createIdentifier != nil {
                    map["createIdentifier"] = self.createIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("createIdentifier") {
                    self.createIdentifier = dict["createIdentifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public class DetailInfo : Tea.TeaModel {
            public class ExpectedResult : Tea.TeaModel {
                public var expectContent: String?

                public var expectContentType: String?

                public var expectIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.expectContent != nil {
                        map["expectContent"] = self.expectContent!
                    }
                    if self.expectContentType != nil {
                        map["expectContentType"] = self.expectContentType!
                    }
                    if self.expectIdentifier != nil {
                        map["expectIdentifier"] = self.expectIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("expectContent") {
                        self.expectContent = dict["expectContent"] as! String
                    }
                    if dict.keys.contains("expectContentType") {
                        self.expectContentType = dict["expectContentType"] as! String
                    }
                    if dict.keys.contains("expectIdentifier") {
                        self.expectIdentifier = dict["expectIdentifier"] as! String
                    }
                }
            }
            public class Precondition : Tea.TeaModel {
                public var preContent: String?

                public var preContentType: String?

                public var preIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.preContent != nil {
                        map["preContent"] = self.preContent!
                    }
                    if self.preContentType != nil {
                        map["preContentType"] = self.preContentType!
                    }
                    if self.preIdentifier != nil {
                        map["preIdentifier"] = self.preIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("preContent") {
                        self.preContent = dict["preContent"] as! String
                    }
                    if dict.keys.contains("preContentType") {
                        self.preContentType = dict["preContentType"] as! String
                    }
                    if dict.keys.contains("preIdentifier") {
                        self.preIdentifier = dict["preIdentifier"] as! String
                    }
                }
            }
            public class StepContent : Tea.TeaModel {
                public var stepContent: String?

                public var stepContentType: String?

                public var stepIdentifier: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.stepContent != nil {
                        map["stepContent"] = self.stepContent!
                    }
                    if self.stepContentType != nil {
                        map["stepContentType"] = self.stepContentType!
                    }
                    if self.stepIdentifier != nil {
                        map["stepIdentifier"] = self.stepIdentifier!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("stepContent") {
                        self.stepContent = dict["stepContent"] as! String
                    }
                    if dict.keys.contains("stepContentType") {
                        self.stepContentType = dict["stepContentType"] as! String
                    }
                    if dict.keys.contains("stepIdentifier") {
                        self.stepIdentifier = dict["stepIdentifier"] as! String
                    }
                }
            }
            public var expectedResult: UpdateTestCaseResponseBody.Testcase.DetailInfo.ExpectedResult?

            public var precondition: UpdateTestCaseResponseBody.Testcase.DetailInfo.Precondition?

            public var stepContent: UpdateTestCaseResponseBody.Testcase.DetailInfo.StepContent?

            public var stepType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.expectedResult?.validate()
                try self.precondition?.validate()
                try self.stepContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expectedResult != nil {
                    map["expectedResult"] = self.expectedResult?.toMap()
                }
                if self.precondition != nil {
                    map["precondition"] = self.precondition?.toMap()
                }
                if self.stepContent != nil {
                    map["stepContent"] = self.stepContent?.toMap()
                }
                if self.stepType != nil {
                    map["stepType"] = self.stepType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("expectedResult") {
                    var model = UpdateTestCaseResponseBody.Testcase.DetailInfo.ExpectedResult()
                    model.fromMap(dict["expectedResult"] as! [String: Any])
                    self.expectedResult = model
                }
                if dict.keys.contains("precondition") {
                    var model = UpdateTestCaseResponseBody.Testcase.DetailInfo.Precondition()
                    model.fromMap(dict["precondition"] as! [String: Any])
                    self.precondition = model
                }
                if dict.keys.contains("stepContent") {
                    var model = UpdateTestCaseResponseBody.Testcase.DetailInfo.StepContent()
                    model.fromMap(dict["stepContent"] as! [String: Any])
                    self.stepContent = model
                }
                if dict.keys.contains("stepType") {
                    self.stepType = dict["stepType"] as! String
                }
            }
        }
        public class Directory : Tea.TeaModel {
            public var childIdentifier: String?

            public var directoryIdentifier: String?

            public var name: String?

            public var pathName: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.childIdentifier != nil {
                    map["childIdentifier"] = self.childIdentifier!
                }
                if self.directoryIdentifier != nil {
                    map["directoryIdentifier"] = self.directoryIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.pathName != nil {
                    map["pathName"] = self.pathName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("childIdentifier") {
                    self.childIdentifier = dict["childIdentifier"] as! String
                }
                if dict.keys.contains("directoryIdentifier") {
                    self.directoryIdentifier = dict["directoryIdentifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("pathName") {
                    self.pathName = dict["pathName"] as! [String]
                }
            }
        }
        public class Modifier : Tea.TeaModel {
            public var modifyIdentifier: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.modifyIdentifier != nil {
                    map["modifyIdentifier"] = self.modifyIdentifier!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("modifyIdentifier") {
                    self.modifyIdentifier = dict["modifyIdentifier"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
            }
        }
        public var assignedTo: UpdateTestCaseResponseBody.Testcase.AssignedTo?

        public var categoryIdentifier: String?

        public var creator: UpdateTestCaseResponseBody.Testcase.Creator?

        public var detailInfo: UpdateTestCaseResponseBody.Testcase.DetailInfo?

        public var directory: UpdateTestCaseResponseBody.Testcase.Directory?

        public var identifier: String?

        public var modifier: UpdateTestCaseResponseBody.Testcase.Modifier?

        public var spaceIdentifier: String?

        public var spaceType: String?

        public var subject: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.assignedTo?.validate()
            try self.creator?.validate()
            try self.detailInfo?.validate()
            try self.directory?.validate()
            try self.modifier?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo?.toMap()
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator?.toMap()
            }
            if self.detailInfo != nil {
                map["detailInfo"] = self.detailInfo?.toMap()
            }
            if self.directory != nil {
                map["directory"] = self.directory?.toMap()
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier?.toMap()
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedTo") {
                var model = UpdateTestCaseResponseBody.Testcase.AssignedTo()
                model.fromMap(dict["assignedTo"] as! [String: Any])
                self.assignedTo = model
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                var model = UpdateTestCaseResponseBody.Testcase.Creator()
                model.fromMap(dict["creator"] as! [String: Any])
                self.creator = model
            }
            if dict.keys.contains("detailInfo") {
                var model = UpdateTestCaseResponseBody.Testcase.DetailInfo()
                model.fromMap(dict["detailInfo"] as! [String: Any])
                self.detailInfo = model
            }
            if dict.keys.contains("directory") {
                var model = UpdateTestCaseResponseBody.Testcase.Directory()
                model.fromMap(dict["directory"] as! [String: Any])
                self.directory = model
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("modifier") {
                var model = UpdateTestCaseResponseBody.Testcase.Modifier()
                model.fromMap(dict["modifier"] as! [String: Any])
                self.modifier = model
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("spaceType") {
                self.spaceType = dict["spaceType"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
        }
    }
    public var testcase: UpdateTestCaseResponseBody.Testcase?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.testcase?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.testcase != nil {
            map["Testcase"] = self.testcase?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Testcase") {
            var model = UpdateTestCaseResponseBody.Testcase()
            model.fromMap(dict["Testcase"] as! [String: Any])
            self.testcase = model
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateTestCaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTestCaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTestCaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTestResultRequest : Tea.TeaModel {
    public var executor: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executor != nil {
            map["executor"] = self.executor!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("executor") {
            self.executor = dict["executor"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
    }
}

public class UpdateTestResultResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateTestResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTestResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTestResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateVariableGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var variables: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.variables != nil {
            map["variables"] = self.variables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("variables") {
            self.variables = dict["variables"] as! String
        }
    }
}

public class UpdateVariableGroupResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
    }
}

public class UpdateVariableGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateVariableGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateVariableGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWorkItemRequest : Tea.TeaModel {
    public var fieldType: String?

    public var identifier: String?

    public var propertyKey: String?

    public var propertyValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fieldType != nil {
            map["fieldType"] = self.fieldType!
        }
        if self.identifier != nil {
            map["identifier"] = self.identifier!
        }
        if self.propertyKey != nil {
            map["propertyKey"] = self.propertyKey!
        }
        if self.propertyValue != nil {
            map["propertyValue"] = self.propertyValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("fieldType") {
            self.fieldType = dict["fieldType"] as! String
        }
        if dict.keys.contains("identifier") {
            self.identifier = dict["identifier"] as! String
        }
        if dict.keys.contains("propertyKey") {
            self.propertyKey = dict["propertyKey"] as! String
        }
        if dict.keys.contains("propertyValue") {
            self.propertyValue = dict["propertyValue"] as! String
        }
    }
}

public class UpdateWorkItemResponseBody : Tea.TeaModel {
    public class Workitem : Tea.TeaModel {
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var document: String?

        public var documentFormat: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var parentIdentifier: String?

        public var serialNumber: String?

        public var spaceIdentifier: String?

        public var spaceName: String?

        public var spaceType: String?

        public var sprintIdentifier: String?

        public var status: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subject: String?

        public var updateStatusAt: Int64?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.document != nil {
                map["document"] = self.document!
            }
            if self.documentFormat != nil {
                map["documentFormat"] = self.documentFormat!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceName != nil {
                map["spaceName"] = self.spaceName!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.sprintIdentifier != nil {
                map["sprintIdentifier"] = self.sprintIdentifier!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.updateStatusAt != nil {
                map["updateStatusAt"] = self.updateStatusAt!
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedTo") {
                self.assignedTo = dict["assignedTo"] as! String
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("document") {
                self.document = dict["document"] as! String
            }
            if dict.keys.contains("documentFormat") {
                self.documentFormat = dict["documentFormat"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("logicalStatus") {
                self.logicalStatus = dict["logicalStatus"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("parentIdentifier") {
                self.parentIdentifier = dict["parentIdentifier"] as! String
            }
            if dict.keys.contains("serialNumber") {
                self.serialNumber = dict["serialNumber"] as! String
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("spaceName") {
                self.spaceName = dict["spaceName"] as! String
            }
            if dict.keys.contains("spaceType") {
                self.spaceType = dict["spaceType"] as! String
            }
            if dict.keys.contains("sprintIdentifier") {
                self.sprintIdentifier = dict["sprintIdentifier"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("statusIdentifier") {
                self.statusIdentifier = dict["statusIdentifier"] as! String
            }
            if dict.keys.contains("statusStageIdentifier") {
                self.statusStageIdentifier = dict["statusStageIdentifier"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("updateStatusAt") {
                self.updateStatusAt = dict["updateStatusAt"] as! Int64
            }
            if dict.keys.contains("workitemTypeIdentifier") {
                self.workitemTypeIdentifier = dict["workitemTypeIdentifier"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: Bool?

    public var workitem: UpdateWorkItemResponseBody.Workitem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitem != nil {
            map["workitem"] = self.workitem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("workitem") {
            var model = UpdateWorkItemResponseBody.Workitem()
            model.fromMap(dict["workitem"] as! [String: Any])
            self.workitem = model
        }
    }
}

public class UpdateWorkItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWorkItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWorkitemCommentRequest : Tea.TeaModel {
    public var commentId: Int64?

    public var content: String?

    public var formatType: String?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commentId != nil {
            map["commentId"] = self.commentId!
        }
        if self.content != nil {
            map["content"] = self.content!
        }
        if self.formatType != nil {
            map["formatType"] = self.formatType!
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("commentId") {
            self.commentId = dict["commentId"] as! Int64
        }
        if dict.keys.contains("content") {
            self.content = dict["content"] as! String
        }
        if dict.keys.contains("formatType") {
            self.formatType = dict["formatType"] as! String
        }
        if dict.keys.contains("workitemIdentifier") {
            self.workitemIdentifier = dict["workitemIdentifier"] as! String
        }
    }
}

public class UpdateWorkitemCommentResponseBody : Tea.TeaModel {
    public class Comment : Tea.TeaModel {
        public class User : Tea.TeaModel {
            public var account: String?

            public var avatar: String?

            public var displayName: String?

            public var identifier: String?

            public var nickName: String?

            public var realName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["account"] = self.account!
                }
                if self.avatar != nil {
                    map["avatar"] = self.avatar!
                }
                if self.displayName != nil {
                    map["displayName"] = self.displayName!
                }
                if self.identifier != nil {
                    map["identifier"] = self.identifier!
                }
                if self.nickName != nil {
                    map["nickName"] = self.nickName!
                }
                if self.realName != nil {
                    map["realName"] = self.realName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("account") {
                    self.account = dict["account"] as! String
                }
                if dict.keys.contains("avatar") {
                    self.avatar = dict["avatar"] as! String
                }
                if dict.keys.contains("displayName") {
                    self.displayName = dict["displayName"] as! String
                }
                if dict.keys.contains("identifier") {
                    self.identifier = dict["identifier"] as! String
                }
                if dict.keys.contains("nickName") {
                    self.nickName = dict["nickName"] as! String
                }
                if dict.keys.contains("realName") {
                    self.realName = dict["realName"] as! String
                }
            }
        }
        public var content: String?

        public var createTime: Int64?

        public var formatType: String?

        public var id: String?

        public var isTop: Bool?

        public var modifiedTime: Int64?

        public var parentId: Int64?

        public var targetIdentifier: String?

        public var targetType: String?

        public var topTime: Int64?

        public var user: UpdateWorkitemCommentResponseBody.Comment.User?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.user?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.formatType != nil {
                map["formatType"] = self.formatType!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.isTop != nil {
                map["isTop"] = self.isTop!
            }
            if self.modifiedTime != nil {
                map["modifiedTime"] = self.modifiedTime!
            }
            if self.parentId != nil {
                map["parentId"] = self.parentId!
            }
            if self.targetIdentifier != nil {
                map["targetIdentifier"] = self.targetIdentifier!
            }
            if self.targetType != nil {
                map["targetType"] = self.targetType!
            }
            if self.topTime != nil {
                map["topTime"] = self.topTime!
            }
            if self.user != nil {
                map["user"] = self.user?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("formatType") {
                self.formatType = dict["formatType"] as! String
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! String
            }
            if dict.keys.contains("isTop") {
                self.isTop = dict["isTop"] as! Bool
            }
            if dict.keys.contains("modifiedTime") {
                self.modifiedTime = dict["modifiedTime"] as! Int64
            }
            if dict.keys.contains("parentId") {
                self.parentId = dict["parentId"] as! Int64
            }
            if dict.keys.contains("targetIdentifier") {
                self.targetIdentifier = dict["targetIdentifier"] as! String
            }
            if dict.keys.contains("targetType") {
                self.targetType = dict["targetType"] as! String
            }
            if dict.keys.contains("topTime") {
                self.topTime = dict["topTime"] as! Int64
            }
            if dict.keys.contains("user") {
                var model = UpdateWorkitemCommentResponseBody.Comment.User()
                model.fromMap(dict["user"] as! [String: Any])
                self.user = model
            }
        }
    }
    public var comment: UpdateWorkitemCommentResponseBody.Comment?

    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.comment?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["comment"] = self.comment?.toMap()
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("comment") {
            var model = UpdateWorkitemCommentResponseBody.Comment()
            model.fromMap(dict["comment"] as! [String: Any])
            self.comment = model
        }
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
    }
}

public class UpdateWorkitemCommentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkitemCommentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWorkitemCommentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWorkitemFieldRequest : Tea.TeaModel {
    public class UpdateWorkitemPropertyRequest : Tea.TeaModel {
        public var fieldIdentifier: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldIdentifier != nil {
                map["fieldIdentifier"] = self.fieldIdentifier!
            }
            if self.fieldValue != nil {
                map["fieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fieldIdentifier") {
                self.fieldIdentifier = dict["fieldIdentifier"] as! String
            }
            if dict.keys.contains("fieldValue") {
                self.fieldValue = dict["fieldValue"] as! String
            }
        }
    }
    public var updateWorkitemPropertyRequest: [UpdateWorkitemFieldRequest.UpdateWorkitemPropertyRequest]?

    public var workitemIdentifier: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.updateWorkitemPropertyRequest != nil {
            var tmp : [Any] = []
            for k in self.updateWorkitemPropertyRequest! {
                tmp.append(k.toMap())
            }
            map["updateWorkitemPropertyRequest"] = tmp
        }
        if self.workitemIdentifier != nil {
            map["workitemIdentifier"] = self.workitemIdentifier!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("updateWorkitemPropertyRequest") {
            var tmp : [UpdateWorkitemFieldRequest.UpdateWorkitemPropertyRequest] = []
            for v in dict["updateWorkitemPropertyRequest"] as! [Any] {
                var model = UpdateWorkitemFieldRequest.UpdateWorkitemPropertyRequest()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.updateWorkitemPropertyRequest = tmp
        }
        if dict.keys.contains("workitemIdentifier") {
            self.workitemIdentifier = dict["workitemIdentifier"] as! String
        }
    }
}

public class UpdateWorkitemFieldResponseBody : Tea.TeaModel {
    public class Workitem : Tea.TeaModel {
        public var assignedTo: String?

        public var categoryIdentifier: String?

        public var creator: String?

        public var document: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var identifier: String?

        public var logicalStatus: String?

        public var modifier: String?

        public var parentIdentifier: String?

        public var serialNumber: String?

        public var spaceIdentifier: String?

        public var spaceName: String?

        public var spaceType: String?

        public var sprintIdentifier: String?

        public var status: String?

        public var statusIdentifier: String?

        public var statusStageIdentifier: String?

        public var subject: String?

        public var updateStatusAt: Int64?

        public var workitemTypeIdentifier: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignedTo != nil {
                map["assignedTo"] = self.assignedTo!
            }
            if self.categoryIdentifier != nil {
                map["categoryIdentifier"] = self.categoryIdentifier!
            }
            if self.creator != nil {
                map["creator"] = self.creator!
            }
            if self.document != nil {
                map["document"] = self.document!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.identifier != nil {
                map["identifier"] = self.identifier!
            }
            if self.logicalStatus != nil {
                map["logicalStatus"] = self.logicalStatus!
            }
            if self.modifier != nil {
                map["modifier"] = self.modifier!
            }
            if self.parentIdentifier != nil {
                map["parentIdentifier"] = self.parentIdentifier!
            }
            if self.serialNumber != nil {
                map["serialNumber"] = self.serialNumber!
            }
            if self.spaceIdentifier != nil {
                map["spaceIdentifier"] = self.spaceIdentifier!
            }
            if self.spaceName != nil {
                map["spaceName"] = self.spaceName!
            }
            if self.spaceType != nil {
                map["spaceType"] = self.spaceType!
            }
            if self.sprintIdentifier != nil {
                map["sprintIdentifier"] = self.sprintIdentifier!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.statusIdentifier != nil {
                map["statusIdentifier"] = self.statusIdentifier!
            }
            if self.statusStageIdentifier != nil {
                map["statusStageIdentifier"] = self.statusStageIdentifier!
            }
            if self.subject != nil {
                map["subject"] = self.subject!
            }
            if self.updateStatusAt != nil {
                map["updateStatusAt"] = self.updateStatusAt!
            }
            if self.workitemTypeIdentifier != nil {
                map["workitemTypeIdentifier"] = self.workitemTypeIdentifier!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("assignedTo") {
                self.assignedTo = dict["assignedTo"] as! String
            }
            if dict.keys.contains("categoryIdentifier") {
                self.categoryIdentifier = dict["categoryIdentifier"] as! String
            }
            if dict.keys.contains("creator") {
                self.creator = dict["creator"] as! String
            }
            if dict.keys.contains("document") {
                self.document = dict["document"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("identifier") {
                self.identifier = dict["identifier"] as! String
            }
            if dict.keys.contains("logicalStatus") {
                self.logicalStatus = dict["logicalStatus"] as! String
            }
            if dict.keys.contains("modifier") {
                self.modifier = dict["modifier"] as! String
            }
            if dict.keys.contains("parentIdentifier") {
                self.parentIdentifier = dict["parentIdentifier"] as! String
            }
            if dict.keys.contains("serialNumber") {
                self.serialNumber = dict["serialNumber"] as! String
            }
            if dict.keys.contains("spaceIdentifier") {
                self.spaceIdentifier = dict["spaceIdentifier"] as! String
            }
            if dict.keys.contains("spaceName") {
                self.spaceName = dict["spaceName"] as! String
            }
            if dict.keys.contains("spaceType") {
                self.spaceType = dict["spaceType"] as! String
            }
            if dict.keys.contains("sprintIdentifier") {
                self.sprintIdentifier = dict["sprintIdentifier"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("statusIdentifier") {
                self.statusIdentifier = dict["statusIdentifier"] as! String
            }
            if dict.keys.contains("statusStageIdentifier") {
                self.statusStageIdentifier = dict["statusStageIdentifier"] as! String
            }
            if dict.keys.contains("subject") {
                self.subject = dict["subject"] as! String
            }
            if dict.keys.contains("updateStatusAt") {
                self.updateStatusAt = dict["updateStatusAt"] as! Int64
            }
            if dict.keys.contains("workitemTypeIdentifier") {
                self.workitemTypeIdentifier = dict["workitemTypeIdentifier"] as! String
            }
        }
    }
    public var errorCode: String?

    public var errorMsg: String?

    public var requestId: String?

    public var success: Bool?

    public var workitem: UpdateWorkitemFieldResponseBody.Workitem?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.workitem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMsg != nil {
            map["errorMsg"] = self.errorMsg!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        if self.workitem != nil {
            map["workitem"] = self.workitem?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMsg") {
            self.errorMsg = dict["errorMsg"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! Bool
        }
        if dict.keys.contains("workitem") {
            var model = UpdateWorkitemFieldResponseBody.Workitem()
            model.fromMap(dict["workitem"] as! [String: Any])
            self.workitem = model
        }
    }
}

public class UpdateWorkitemFieldResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWorkitemFieldResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWorkitemFieldResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class WorkitemAttachmentCreateRequest : Tea.TeaModel {
    public var fileKey: String?

    public var originalFilename: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileKey != nil {
            map["fileKey"] = self.fileKey!
        }
        if self.originalFilename != nil {
            map["originalFilename"] = self.originalFilename!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("fileKey") {
            self.fileKey = dict["fileKey"] as! String
        }
        if dict.keys.contains("originalFilename") {
            self.originalFilename = dict["originalFilename"] as! String
        }
    }
}

public class WorkitemAttachmentCreateResponseBody : Tea.TeaModel {
    public var errorCode: String?

    public var errorMessage: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorCode") {
            self.errorCode = dict["errorCode"] as! String
        }
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("success") {
            self.success = dict["success"] as! String
        }
    }
}

public class WorkitemAttachmentCreateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WorkitemAttachmentCreateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = WorkitemAttachmentCreateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
