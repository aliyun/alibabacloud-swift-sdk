import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class QueryIncidentTracingSubNodesCountRequest : Tea.TeaModel {
    public var vertexIdAndTypeList: [[String]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.vertexIdAndTypeList != nil {
            map["VertexIdAndTypeList"] = self.vertexIdAndTypeList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VertexIdAndTypeList") && dict["VertexIdAndTypeList"] != nil {
            self.vertexIdAndTypeList = dict["VertexIdAndTypeList"] as! [[String]]
        }
    }
}

public class AddAssetSelectionCriteriaRequest : Tea.TeaModel {
    public class TargetOperationList : Tea.TeaModel {
        public var operation: String?

        public var target: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operation != nil {
                map["Operation"] = self.operation!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Operation") && dict["Operation"] != nil {
                self.operation = dict["Operation"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
        }
    }
    public var criteria: String?

    public var criteriaOperation: String?

    public var selectionKey: String?

    public var targetOperationList: [AddAssetSelectionCriteriaRequest.TargetOperationList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.criteriaOperation != nil {
            map["CriteriaOperation"] = self.criteriaOperation!
        }
        if self.selectionKey != nil {
            map["SelectionKey"] = self.selectionKey!
        }
        if self.targetOperationList != nil {
            var tmp : [Any] = []
            for k in self.targetOperationList! {
                tmp.append(k.toMap())
            }
            map["TargetOperationList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CriteriaOperation") && dict["CriteriaOperation"] != nil {
            self.criteriaOperation = dict["CriteriaOperation"] as! String
        }
        if dict.keys.contains("SelectionKey") && dict["SelectionKey"] != nil {
            self.selectionKey = dict["SelectionKey"] as! String
        }
        if dict.keys.contains("TargetOperationList") && dict["TargetOperationList"] != nil {
            var tmp : [AddAssetSelectionCriteriaRequest.TargetOperationList] = []
            for v in dict["TargetOperationList"] as! [Any] {
                var model = AddAssetSelectionCriteriaRequest.TargetOperationList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.targetOperationList = tmp
        }
    }
}

public class AddAssetSelectionCriteriaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddAssetSelectionCriteriaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAssetSelectionCriteriaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddAssetSelectionCriteriaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCheckInstanceResultWhiteListRequest : Tea.TeaModel {
    public var checkGroupId: String?

    public var checkId: Int64?

    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkGroupId != nil {
            map["CheckGroupId"] = self.checkGroupId!
        }
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckGroupId") && dict["CheckGroupId"] != nil {
            self.checkGroupId = dict["CheckGroupId"] as! String
        }
        if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
            self.checkId = dict["CheckId"] as! Int64
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class AddCheckInstanceResultWhiteListResponseBody : Tea.TeaModel {
    public var data: [String: Any]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String: Any]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCheckInstanceResultWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCheckInstanceResultWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddCheckInstanceResultWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCheckResultWhiteListRequest : Tea.TeaModel {
    public var checkIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkIds != nil {
            map["CheckIds"] = self.checkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckIds") && dict["CheckIds"] != nil {
            self.checkIds = dict["CheckIds"] as! [Int64]
        }
    }
}

public class AddCheckResultWhiteListResponseBody : Tea.TeaModel {
    public var data: [String: Any]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String: Any]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCheckResultWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCheckResultWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddCheckResultWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddClientUserDefineRuleRequest : Tea.TeaModel {
    public var actionType: Int32?

    public var cmdline: String?

    public var filePath: String?

    public var IP: String?

    public var md5List: String?

    public var name: String?

    public var newFilePath: String?

    public var parentCmdline: String?

    public var parentProcPath: String?

    public var platform: String?

    public var port: Int32?

    public var portStr: String?

    public var procPath: String?

    public var registryContent: String?

    public var registryKey: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.cmdline != nil {
            map["Cmdline"] = self.cmdline!
        }
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.IP != nil {
            map["IP"] = self.IP!
        }
        if self.md5List != nil {
            map["Md5List"] = self.md5List!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.newFilePath != nil {
            map["NewFilePath"] = self.newFilePath!
        }
        if self.parentCmdline != nil {
            map["ParentCmdline"] = self.parentCmdline!
        }
        if self.parentProcPath != nil {
            map["ParentProcPath"] = self.parentProcPath!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.portStr != nil {
            map["PortStr"] = self.portStr!
        }
        if self.procPath != nil {
            map["ProcPath"] = self.procPath!
        }
        if self.registryContent != nil {
            map["RegistryContent"] = self.registryContent!
        }
        if self.registryKey != nil {
            map["RegistryKey"] = self.registryKey!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionType") && dict["ActionType"] != nil {
            self.actionType = dict["ActionType"] as! Int32
        }
        if dict.keys.contains("Cmdline") && dict["Cmdline"] != nil {
            self.cmdline = dict["Cmdline"] as! String
        }
        if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("IP") && dict["IP"] != nil {
            self.IP = dict["IP"] as! String
        }
        if dict.keys.contains("Md5List") && dict["Md5List"] != nil {
            self.md5List = dict["Md5List"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NewFilePath") && dict["NewFilePath"] != nil {
            self.newFilePath = dict["NewFilePath"] as! String
        }
        if dict.keys.contains("ParentCmdline") && dict["ParentCmdline"] != nil {
            self.parentCmdline = dict["ParentCmdline"] as! String
        }
        if dict.keys.contains("ParentProcPath") && dict["ParentProcPath"] != nil {
            self.parentProcPath = dict["ParentProcPath"] as! String
        }
        if dict.keys.contains("Platform") && dict["Platform"] != nil {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("PortStr") && dict["PortStr"] != nil {
            self.portStr = dict["PortStr"] as! String
        }
        if dict.keys.contains("ProcPath") && dict["ProcPath"] != nil {
            self.procPath = dict["ProcPath"] as! String
        }
        if dict.keys.contains("RegistryContent") && dict["RegistryContent"] != nil {
            self.registryContent = dict["RegistryContent"] as! String
        }
        if dict.keys.contains("RegistryKey") && dict["RegistryKey"] != nil {
            self.registryKey = dict["RegistryKey"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class AddClientUserDefineRuleResponseBody : Tea.TeaModel {
    public class UserDefineRuleAddResult : Tea.TeaModel {
        public var id: Int64?

        public var platform: String?

        public var switchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.platform != nil {
                map["Platform"] = self.platform!
            }
            if self.switchId != nil {
                map["SwitchId"] = self.switchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Platform") && dict["Platform"] != nil {
                self.platform = dict["Platform"] as! String
            }
            if dict.keys.contains("SwitchId") && dict["SwitchId"] != nil {
                self.switchId = dict["SwitchId"] as! String
            }
        }
    }
    public var requestId: String?

    public var userDefineRuleAddResult: AddClientUserDefineRuleResponseBody.UserDefineRuleAddResult?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userDefineRuleAddResult?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userDefineRuleAddResult != nil {
            map["UserDefineRuleAddResult"] = self.userDefineRuleAddResult?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserDefineRuleAddResult") && dict["UserDefineRuleAddResult"] != nil {
            var model = AddClientUserDefineRuleResponseBody.UserDefineRuleAddResult()
            model.fromMap(dict["UserDefineRuleAddResult"] as! [String: Any])
            self.userDefineRuleAddResult = model
        }
    }
}

public class AddClientUserDefineRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddClientUserDefineRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddClientUserDefineRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddImageVulWhiteListRequest : Tea.TeaModel {
    public var lang: String?

    public var reason: String?

    public var source: String?

    public var target: String?

    public var type: String?

    public var whitelist: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.whitelist != nil {
            map["Whitelist"] = self.whitelist!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Whitelist") && dict["Whitelist"] != nil {
            self.whitelist = dict["Whitelist"] as! String
        }
    }
}

public class AddImageVulWhiteListResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddImageVulWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddImageVulWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddImageVulWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddInstallCodeRequest : Tea.TeaModel {
    public var expiredDate: Int64?

    public var groupId: Int64?

    public var onlyImage: Bool?

    public var os: String?

    public var proxyCluster: String?

    public var vendorName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.expiredDate != nil {
            map["ExpiredDate"] = self.expiredDate!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.onlyImage != nil {
            map["OnlyImage"] = self.onlyImage!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.proxyCluster != nil {
            map["ProxyCluster"] = self.proxyCluster!
        }
        if self.vendorName != nil {
            map["VendorName"] = self.vendorName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExpiredDate") && dict["ExpiredDate"] != nil {
            self.expiredDate = dict["ExpiredDate"] as! Int64
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("OnlyImage") && dict["OnlyImage"] != nil {
            self.onlyImage = dict["OnlyImage"] as! Bool
        }
        if dict.keys.contains("Os") && dict["Os"] != nil {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("ProxyCluster") && dict["ProxyCluster"] != nil {
            self.proxyCluster = dict["ProxyCluster"] as! String
        }
        if dict.keys.contains("VendorName") && dict["VendorName"] != nil {
            self.vendorName = dict["VendorName"] as! String
        }
    }
}

public class AddInstallCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddInstallCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddInstallCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddInstallCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPrivateRegistryRequest : Tea.TeaModel {
    public var domainName: String?

    public var extraParam: String?

    public var netType: Int64?

    public var password: String?

    public var port: Int32?

    public var protocolType: Int64?

    public var registryHostIp: String?

    public var registryRegionId: String?

    public var registryType: String?

    public var registryVersion: String?

    public var transPerHour: Int32?

    public var userName: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.extraParam != nil {
            map["ExtraParam"] = self.extraParam!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.registryHostIp != nil {
            map["RegistryHostIp"] = self.registryHostIp!
        }
        if self.registryRegionId != nil {
            map["RegistryRegionId"] = self.registryRegionId!
        }
        if self.registryType != nil {
            map["RegistryType"] = self.registryType!
        }
        if self.registryVersion != nil {
            map["RegistryVersion"] = self.registryVersion!
        }
        if self.transPerHour != nil {
            map["TransPerHour"] = self.transPerHour!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("ExtraParam") && dict["ExtraParam"] != nil {
            self.extraParam = dict["ExtraParam"] as! String
        }
        if dict.keys.contains("NetType") && dict["NetType"] != nil {
            self.netType = dict["NetType"] as! Int64
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("ProtocolType") && dict["ProtocolType"] != nil {
            self.protocolType = dict["ProtocolType"] as! Int64
        }
        if dict.keys.contains("RegistryHostIp") && dict["RegistryHostIp"] != nil {
            self.registryHostIp = dict["RegistryHostIp"] as! String
        }
        if dict.keys.contains("RegistryRegionId") && dict["RegistryRegionId"] != nil {
            self.registryRegionId = dict["RegistryRegionId"] as! String
        }
        if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
            self.registryType = dict["RegistryType"] as! String
        }
        if dict.keys.contains("RegistryVersion") && dict["RegistryVersion"] != nil {
            self.registryVersion = dict["RegistryVersion"] as! String
        }
        if dict.keys.contains("TransPerHour") && dict["TransPerHour"] != nil {
            self.transPerHour = dict["TransPerHour"] as! Int32
        }
        if dict.keys.contains("UserName") && dict["UserName"] != nil {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class AddPrivateRegistryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var aliUid: Int64?

        public var domainName: String?

        public var id: Int64?

        public var netType: Int64?

        public var password: String?

        public var protocolType: Int64?

        public var regionId: String?

        public var registryHostIp: String?

        public var registryType: String?

        public var registryVersion: String?

        public var token: String?

        public var transPerHour: Int32?

        public var userName: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.registryHostIp != nil {
                map["RegistryHostIp"] = self.registryHostIp!
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.registryVersion != nil {
                map["RegistryVersion"] = self.registryVersion!
            }
            if self.token != nil {
                map["Token"] = self.token!
            }
            if self.transPerHour != nil {
                map["TransPerHour"] = self.transPerHour!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliUid") && dict["AliUid"] != nil {
                self.aliUid = dict["AliUid"] as! Int64
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("NetType") && dict["NetType"] != nil {
                self.netType = dict["NetType"] as! Int64
            }
            if dict.keys.contains("Password") && dict["Password"] != nil {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("ProtocolType") && dict["ProtocolType"] != nil {
                self.protocolType = dict["ProtocolType"] as! Int64
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegistryHostIp") && dict["RegistryHostIp"] != nil {
                self.registryHostIp = dict["RegistryHostIp"] as! String
            }
            if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("RegistryVersion") && dict["RegistryVersion"] != nil {
                self.registryVersion = dict["RegistryVersion"] as! String
            }
            if dict.keys.contains("Token") && dict["Token"] != nil {
                self.token = dict["Token"] as! String
            }
            if dict.keys.contains("TransPerHour") && dict["TransPerHour"] != nil {
                self.transPerHour = dict["TransPerHour"] as! Int32
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var data: AddPrivateRegistryResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AddPrivateRegistryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPrivateRegistryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPrivateRegistryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddPrivateRegistryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTagWithUuidRequest : Tea.TeaModel {
    public var tagName: String?

    public var uuidList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tagName != nil {
            map["TagName"] = self.tagName!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TagName") && dict["TagName"] != nil {
            self.tagName = dict["TagName"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! String
        }
    }
}

public class AddTagWithUuidResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddTagWithUuidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTagWithUuidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddTagWithUuidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddUninstallClientsByUuidsRequest : Tea.TeaModel {
    public var callMethod: String?

    public var feedback: String?

    public var region: String?

    public var sourceIp: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callMethod != nil {
            map["CallMethod"] = self.callMethod!
        }
        if self.feedback != nil {
            map["Feedback"] = self.feedback!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallMethod") && dict["CallMethod"] != nil {
            self.callMethod = dict["CallMethod"] as! String
        }
        if dict.keys.contains("Feedback") && dict["Feedback"] != nil {
            self.feedback = dict["Feedback"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class AddUninstallClientsByUuidsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddUninstallClientsByUuidsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddUninstallClientsByUuidsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddUninstallClientsByUuidsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddVpcHoneyPotRequest : Tea.TeaModel {
    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class AddVpcHoneyPotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddVpcHoneyPotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddVpcHoneyPotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddVpcHoneyPotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AdvanceSecurityEventOperationsRequest : Tea.TeaModel {
    public var eventName: String?

    public var eventType: String?

    public var resourceOwnerId: Int64?

    public var ruleId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventName != nil {
            map["EventName"] = self.eventName!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventName") && dict["EventName"] != nil {
            self.eventName = dict["EventName"] as! String
        }
        if dict.keys.contains("EventType") && dict["EventType"] != nil {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int32
        }
    }
}

public class AdvanceSecurityEventOperationsResponseBody : Tea.TeaModel {
    public class SecurityEventOperationsResponse : Tea.TeaModel {
        public class MarkField : Tea.TeaModel {
            public var filedAliasName: String?

            public var filedName: String?

            public var markMisType: String?

            public var markMisValue: String?

            public var supportedMisType: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.filedAliasName != nil {
                    map["FiledAliasName"] = self.filedAliasName!
                }
                if self.filedName != nil {
                    map["FiledName"] = self.filedName!
                }
                if self.markMisType != nil {
                    map["MarkMisType"] = self.markMisType!
                }
                if self.markMisValue != nil {
                    map["MarkMisValue"] = self.markMisValue!
                }
                if self.supportedMisType != nil {
                    map["SupportedMisType"] = self.supportedMisType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FiledAliasName") && dict["FiledAliasName"] != nil {
                    self.filedAliasName = dict["FiledAliasName"] as! String
                }
                if dict.keys.contains("FiledName") && dict["FiledName"] != nil {
                    self.filedName = dict["FiledName"] as! String
                }
                if dict.keys.contains("MarkMisType") && dict["MarkMisType"] != nil {
                    self.markMisType = dict["MarkMisType"] as! String
                }
                if dict.keys.contains("MarkMisValue") && dict["MarkMisValue"] != nil {
                    self.markMisValue = dict["MarkMisValue"] as! String
                }
                if dict.keys.contains("SupportedMisType") && dict["SupportedMisType"] != nil {
                    self.supportedMisType = dict["SupportedMisType"] as! [String]
                }
            }
        }
        public class MarkFieldsSource : Tea.TeaModel {
            public var filedAliasName: String?

            public var filedName: String?

            public var markMisValue: String?

            public var supportedMisType: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.filedAliasName != nil {
                    map["FiledAliasName"] = self.filedAliasName!
                }
                if self.filedName != nil {
                    map["FiledName"] = self.filedName!
                }
                if self.markMisValue != nil {
                    map["MarkMisValue"] = self.markMisValue!
                }
                if self.supportedMisType != nil {
                    map["SupportedMisType"] = self.supportedMisType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FiledAliasName") && dict["FiledAliasName"] != nil {
                    self.filedAliasName = dict["FiledAliasName"] as! String
                }
                if dict.keys.contains("FiledName") && dict["FiledName"] != nil {
                    self.filedName = dict["FiledName"] as! String
                }
                if dict.keys.contains("MarkMisValue") && dict["MarkMisValue"] != nil {
                    self.markMisValue = dict["MarkMisValue"] as! String
                }
                if dict.keys.contains("SupportedMisType") && dict["SupportedMisType"] != nil {
                    self.supportedMisType = dict["SupportedMisType"] as! [String]
                }
            }
        }
        public var markField: [AdvanceSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkField]?

        public var markFieldsSource: [AdvanceSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkFieldsSource]?

        public var operationCode: String?

        public var operationParams: String?

        public var userCanOperate: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.markField != nil {
                var tmp : [Any] = []
                for k in self.markField! {
                    tmp.append(k.toMap())
                }
                map["MarkField"] = tmp
            }
            if self.markFieldsSource != nil {
                var tmp : [Any] = []
                for k in self.markFieldsSource! {
                    tmp.append(k.toMap())
                }
                map["MarkFieldsSource"] = tmp
            }
            if self.operationCode != nil {
                map["OperationCode"] = self.operationCode!
            }
            if self.operationParams != nil {
                map["OperationParams"] = self.operationParams!
            }
            if self.userCanOperate != nil {
                map["UserCanOperate"] = self.userCanOperate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MarkField") && dict["MarkField"] != nil {
                var tmp : [AdvanceSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkField] = []
                for v in dict["MarkField"] as! [Any] {
                    var model = AdvanceSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkField()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.markField = tmp
            }
            if dict.keys.contains("MarkFieldsSource") && dict["MarkFieldsSource"] != nil {
                var tmp : [AdvanceSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkFieldsSource] = []
                for v in dict["MarkFieldsSource"] as! [Any] {
                    var model = AdvanceSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkFieldsSource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.markFieldsSource = tmp
            }
            if dict.keys.contains("OperationCode") && dict["OperationCode"] != nil {
                self.operationCode = dict["OperationCode"] as! String
            }
            if dict.keys.contains("OperationParams") && dict["OperationParams"] != nil {
                self.operationParams = dict["OperationParams"] as! String
            }
            if dict.keys.contains("UserCanOperate") && dict["UserCanOperate"] != nil {
                self.userCanOperate = dict["UserCanOperate"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var securityEventOperationsResponse: [AdvanceSecurityEventOperationsResponseBody.SecurityEventOperationsResponse]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityEventOperationsResponse != nil {
            var tmp : [Any] = []
            for k in self.securityEventOperationsResponse! {
                tmp.append(k.toMap())
            }
            map["SecurityEventOperationsResponse"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityEventOperationsResponse") && dict["SecurityEventOperationsResponse"] != nil {
            var tmp : [AdvanceSecurityEventOperationsResponseBody.SecurityEventOperationsResponse] = []
            for v in dict["SecurityEventOperationsResponse"] as! [Any] {
                var model = AdvanceSecurityEventOperationsResponseBody.SecurityEventOperationsResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityEventOperationsResponse = tmp
        }
    }
}

public class AdvanceSecurityEventOperationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AdvanceSecurityEventOperationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AdvanceSecurityEventOperationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchOperateCommonOverallConfigRequest : Tea.TeaModel {
    public var config: String?

    public var typeList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.typeList != nil {
            map["TypeList"] = self.typeList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("TypeList") && dict["TypeList"] != nil {
            self.typeList = dict["TypeList"] as! [String]
        }
    }
}

public class BatchOperateCommonOverallConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchOperateCommonOverallConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchOperateCommonOverallConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BatchOperateCommonOverallConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindAuthToMachineRequest : Tea.TeaModel {
    public var authVersion: Int32?

    public var autoBind: Int32?

    public var bind: [String]?

    public var bindAll: Bool?

    public var criteria: String?

    public var logicalExp: String?

    public var unBind: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authVersion != nil {
            map["AuthVersion"] = self.authVersion!
        }
        if self.autoBind != nil {
            map["AutoBind"] = self.autoBind!
        }
        if self.bind != nil {
            map["Bind"] = self.bind!
        }
        if self.bindAll != nil {
            map["BindAll"] = self.bindAll!
        }
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.logicalExp != nil {
            map["LogicalExp"] = self.logicalExp!
        }
        if self.unBind != nil {
            map["UnBind"] = self.unBind!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthVersion") && dict["AuthVersion"] != nil {
            self.authVersion = dict["AuthVersion"] as! Int32
        }
        if dict.keys.contains("AutoBind") && dict["AutoBind"] != nil {
            self.autoBind = dict["AutoBind"] as! Int32
        }
        if dict.keys.contains("Bind") && dict["Bind"] != nil {
            self.bind = dict["Bind"] as! [String]
        }
        if dict.keys.contains("BindAll") && dict["BindAll"] != nil {
            self.bindAll = dict["BindAll"] as! Bool
        }
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("LogicalExp") && dict["LogicalExp"] != nil {
            self.logicalExp = dict["LogicalExp"] as! String
        }
        if dict.keys.contains("UnBind") && dict["UnBind"] != nil {
            self.unBind = dict["UnBind"] as! [String]
        }
    }
}

public class BindAuthToMachineResponseBody : Tea.TeaModel {
    public var bindCount: Int32?

    public var insufficientCoreCount: Int32?

    public var insufficientEcsCount: Int32?

    public var requestId: String?

    public var resultCode: Int32?

    public var unBindCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bindCount != nil {
            map["BindCount"] = self.bindCount!
        }
        if self.insufficientCoreCount != nil {
            map["InsufficientCoreCount"] = self.insufficientCoreCount!
        }
        if self.insufficientEcsCount != nil {
            map["InsufficientEcsCount"] = self.insufficientEcsCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.unBindCount != nil {
            map["UnBindCount"] = self.unBindCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BindCount") && dict["BindCount"] != nil {
            self.bindCount = dict["BindCount"] as! Int32
        }
        if dict.keys.contains("InsufficientCoreCount") && dict["InsufficientCoreCount"] != nil {
            self.insufficientCoreCount = dict["InsufficientCoreCount"] as! Int32
        }
        if dict.keys.contains("InsufficientEcsCount") && dict["InsufficientEcsCount"] != nil {
            self.insufficientEcsCount = dict["InsufficientEcsCount"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
            self.resultCode = dict["ResultCode"] as! Int32
        }
        if dict.keys.contains("UnBindCount") && dict["UnBindCount"] != nil {
            self.unBindCount = dict["UnBindCount"] as! Int32
        }
    }
}

public class BindAuthToMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindAuthToMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BindAuthToMachineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelOnceTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class CancelOnceTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelOnceTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelOnceTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelOnceTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeAssetRefreshTaskConfigRequest : Tea.TeaModel {
    public class AssetRefreshConfigs : Tea.TeaModel {
        public var schedulePeriod: Int32?

        public var status: Int32?

        public var vendor: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schedulePeriod != nil {
                map["SchedulePeriod"] = self.schedulePeriod!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vendor != nil {
                map["Vendor"] = self.vendor!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SchedulePeriod") && dict["SchedulePeriod"] != nil {
                self.schedulePeriod = dict["SchedulePeriod"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                self.vendor = dict["Vendor"] as! Int32
            }
        }
    }
    public var assetRefreshConfigs: [ChangeAssetRefreshTaskConfigRequest.AssetRefreshConfigs]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetRefreshConfigs != nil {
            var tmp : [Any] = []
            for k in self.assetRefreshConfigs! {
                tmp.append(k.toMap())
            }
            map["AssetRefreshConfigs"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetRefreshConfigs") && dict["AssetRefreshConfigs"] != nil {
            var tmp : [ChangeAssetRefreshTaskConfigRequest.AssetRefreshConfigs] = []
            for v in dict["AssetRefreshConfigs"] as! [Any] {
                var model = ChangeAssetRefreshTaskConfigRequest.AssetRefreshConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.assetRefreshConfigs = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ChangeAssetRefreshTaskConfigResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeAssetRefreshTaskConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeAssetRefreshTaskConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeAssetRefreshTaskConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeCheckConfigRequest : Tea.TeaModel {
    public class AddedCheck : Tea.TeaModel {
        public var checkId: Int64?

        public var sectionId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.sectionId != nil {
                map["SectionId"] = self.sectionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                self.checkId = dict["CheckId"] as! Int64
            }
            if dict.keys.contains("SectionId") && dict["SectionId"] != nil {
                self.sectionId = dict["SectionId"] as! Int64
            }
        }
    }
    public class ConfigRequirementIds : Tea.TeaModel {
        public var addIds: [Int64]?

        public var removeIds: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addIds != nil {
                map["AddIds"] = self.addIds!
            }
            if self.removeIds != nil {
                map["RemoveIds"] = self.removeIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddIds") && dict["AddIds"] != nil {
                self.addIds = dict["AddIds"] as! [Int64]
            }
            if dict.keys.contains("RemoveIds") && dict["RemoveIds"] != nil {
                self.removeIds = dict["RemoveIds"] as! [Int64]
            }
        }
    }
    public class ConfigStandardIds : Tea.TeaModel {
        public var addIds: [Int64]?

        public var removeIds: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.addIds != nil {
                map["AddIds"] = self.addIds!
            }
            if self.removeIds != nil {
                map["RemoveIds"] = self.removeIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AddIds") && dict["AddIds"] != nil {
                self.addIds = dict["AddIds"] as! [Int64]
            }
            if dict.keys.contains("RemoveIds") && dict["RemoveIds"] != nil {
                self.removeIds = dict["RemoveIds"] as! [Int64]
            }
        }
    }
    public class RemovedCheck : Tea.TeaModel {
        public var checkId: Int64?

        public var sectionId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.sectionId != nil {
                map["SectionId"] = self.sectionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                self.checkId = dict["CheckId"] as! Int64
            }
            if dict.keys.contains("SectionId") && dict["SectionId"] != nil {
                self.sectionId = dict["SectionId"] as! Int64
            }
        }
    }
    public var addedCheck: [ChangeCheckConfigRequest.AddedCheck]?

    public var configRequirementIds: ChangeCheckConfigRequest.ConfigRequirementIds?

    public var configStandardIds: ChangeCheckConfigRequest.ConfigStandardIds?

    public var cycleDays: [Int32]?

    public var enableAddCheck: Bool?

    public var enableAutoCheck: Bool?

    public var endTime: Int32?

    public var regionId: String?

    public var removedCheck: [ChangeCheckConfigRequest.RemovedCheck]?

    public var standardIds: [Int64]?

    public var startTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configRequirementIds?.validate()
        try self.configStandardIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addedCheck != nil {
            var tmp : [Any] = []
            for k in self.addedCheck! {
                tmp.append(k.toMap())
            }
            map["AddedCheck"] = tmp
        }
        if self.configRequirementIds != nil {
            map["ConfigRequirementIds"] = self.configRequirementIds?.toMap()
        }
        if self.configStandardIds != nil {
            map["ConfigStandardIds"] = self.configStandardIds?.toMap()
        }
        if self.cycleDays != nil {
            map["CycleDays"] = self.cycleDays!
        }
        if self.enableAddCheck != nil {
            map["EnableAddCheck"] = self.enableAddCheck!
        }
        if self.enableAutoCheck != nil {
            map["EnableAutoCheck"] = self.enableAutoCheck!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removedCheck != nil {
            var tmp : [Any] = []
            for k in self.removedCheck! {
                tmp.append(k.toMap())
            }
            map["RemovedCheck"] = tmp
        }
        if self.standardIds != nil {
            map["StandardIds"] = self.standardIds!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddedCheck") && dict["AddedCheck"] != nil {
            var tmp : [ChangeCheckConfigRequest.AddedCheck] = []
            for v in dict["AddedCheck"] as! [Any] {
                var model = ChangeCheckConfigRequest.AddedCheck()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addedCheck = tmp
        }
        if dict.keys.contains("ConfigRequirementIds") && dict["ConfigRequirementIds"] != nil {
            var model = ChangeCheckConfigRequest.ConfigRequirementIds()
            model.fromMap(dict["ConfigRequirementIds"] as! [String: Any])
            self.configRequirementIds = model
        }
        if dict.keys.contains("ConfigStandardIds") && dict["ConfigStandardIds"] != nil {
            var model = ChangeCheckConfigRequest.ConfigStandardIds()
            model.fromMap(dict["ConfigStandardIds"] as! [String: Any])
            self.configStandardIds = model
        }
        if dict.keys.contains("CycleDays") && dict["CycleDays"] != nil {
            self.cycleDays = dict["CycleDays"] as! [Int32]
        }
        if dict.keys.contains("EnableAddCheck") && dict["EnableAddCheck"] != nil {
            self.enableAddCheck = dict["EnableAddCheck"] as! Bool
        }
        if dict.keys.contains("EnableAutoCheck") && dict["EnableAutoCheck"] != nil {
            self.enableAutoCheck = dict["EnableAutoCheck"] as! Bool
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemovedCheck") && dict["RemovedCheck"] != nil {
            var tmp : [ChangeCheckConfigRequest.RemovedCheck] = []
            for v in dict["RemovedCheck"] as! [Any] {
                var model = ChangeCheckConfigRequest.RemovedCheck()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.removedCheck = tmp
        }
        if dict.keys.contains("StandardIds") && dict["StandardIds"] != nil {
            self.standardIds = dict["StandardIds"] as! [Int64]
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int32
        }
    }
}

public class ChangeCheckConfigShrinkRequest : Tea.TeaModel {
    public class AddedCheck : Tea.TeaModel {
        public var checkId: Int64?

        public var sectionId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.sectionId != nil {
                map["SectionId"] = self.sectionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                self.checkId = dict["CheckId"] as! Int64
            }
            if dict.keys.contains("SectionId") && dict["SectionId"] != nil {
                self.sectionId = dict["SectionId"] as! Int64
            }
        }
    }
    public class RemovedCheck : Tea.TeaModel {
        public var checkId: Int64?

        public var sectionId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.sectionId != nil {
                map["SectionId"] = self.sectionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                self.checkId = dict["CheckId"] as! Int64
            }
            if dict.keys.contains("SectionId") && dict["SectionId"] != nil {
                self.sectionId = dict["SectionId"] as! Int64
            }
        }
    }
    public var addedCheck: [ChangeCheckConfigShrinkRequest.AddedCheck]?

    public var configRequirementIdsShrink: String?

    public var configStandardIdsShrink: String?

    public var cycleDays: [Int32]?

    public var enableAddCheck: Bool?

    public var enableAutoCheck: Bool?

    public var endTime: Int32?

    public var regionId: String?

    public var removedCheck: [ChangeCheckConfigShrinkRequest.RemovedCheck]?

    public var standardIds: [Int64]?

    public var startTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addedCheck != nil {
            var tmp : [Any] = []
            for k in self.addedCheck! {
                tmp.append(k.toMap())
            }
            map["AddedCheck"] = tmp
        }
        if self.configRequirementIdsShrink != nil {
            map["ConfigRequirementIds"] = self.configRequirementIdsShrink!
        }
        if self.configStandardIdsShrink != nil {
            map["ConfigStandardIds"] = self.configStandardIdsShrink!
        }
        if self.cycleDays != nil {
            map["CycleDays"] = self.cycleDays!
        }
        if self.enableAddCheck != nil {
            map["EnableAddCheck"] = self.enableAddCheck!
        }
        if self.enableAutoCheck != nil {
            map["EnableAutoCheck"] = self.enableAutoCheck!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removedCheck != nil {
            var tmp : [Any] = []
            for k in self.removedCheck! {
                tmp.append(k.toMap())
            }
            map["RemovedCheck"] = tmp
        }
        if self.standardIds != nil {
            map["StandardIds"] = self.standardIds!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddedCheck") && dict["AddedCheck"] != nil {
            var tmp : [ChangeCheckConfigShrinkRequest.AddedCheck] = []
            for v in dict["AddedCheck"] as! [Any] {
                var model = ChangeCheckConfigShrinkRequest.AddedCheck()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addedCheck = tmp
        }
        if dict.keys.contains("ConfigRequirementIds") && dict["ConfigRequirementIds"] != nil {
            self.configRequirementIdsShrink = dict["ConfigRequirementIds"] as! String
        }
        if dict.keys.contains("ConfigStandardIds") && dict["ConfigStandardIds"] != nil {
            self.configStandardIdsShrink = dict["ConfigStandardIds"] as! String
        }
        if dict.keys.contains("CycleDays") && dict["CycleDays"] != nil {
            self.cycleDays = dict["CycleDays"] as! [Int32]
        }
        if dict.keys.contains("EnableAddCheck") && dict["EnableAddCheck"] != nil {
            self.enableAddCheck = dict["EnableAddCheck"] as! Bool
        }
        if dict.keys.contains("EnableAutoCheck") && dict["EnableAutoCheck"] != nil {
            self.enableAutoCheck = dict["EnableAutoCheck"] as! Bool
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemovedCheck") && dict["RemovedCheck"] != nil {
            var tmp : [ChangeCheckConfigShrinkRequest.RemovedCheck] = []
            for v in dict["RemovedCheck"] as! [Any] {
                var model = ChangeCheckConfigShrinkRequest.RemovedCheck()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.removedCheck = tmp
        }
        if dict.keys.contains("StandardIds") && dict["StandardIds"] != nil {
            self.standardIds = dict["StandardIds"] as! [Int64]
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int32
        }
    }
}

public class ChangeCheckConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeCheckConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeCheckConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeCheckConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeCheckCustomConfigRequest : Tea.TeaModel {
    public class CustomConfigs : Tea.TeaModel {
        public var name: String?

        public var operation: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.operation != nil {
                map["Operation"] = self.operation!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Operation") && dict["Operation"] != nil {
                self.operation = dict["Operation"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var checkId: Int64?

    public var customConfigs: [ChangeCheckCustomConfigRequest.CustomConfigs]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.customConfigs != nil {
            var tmp : [Any] = []
            for k in self.customConfigs! {
                tmp.append(k.toMap())
            }
            map["CustomConfigs"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
            self.checkId = dict["CheckId"] as! Int64
        }
        if dict.keys.contains("CustomConfigs") && dict["CustomConfigs"] != nil {
            var tmp : [ChangeCheckCustomConfigRequest.CustomConfigs] = []
            for v in dict["CustomConfigs"] as! [Any] {
                var model = ChangeCheckCustomConfigRequest.CustomConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customConfigs = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ChangeCheckCustomConfigResponseBody : Tea.TeaModel {
    public class IllegalCustomConfigs : Tea.TeaModel {
        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var illegalCustomConfigs: [ChangeCheckCustomConfigResponseBody.IllegalCustomConfigs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.illegalCustomConfigs != nil {
            var tmp : [Any] = []
            for k in self.illegalCustomConfigs! {
                tmp.append(k.toMap())
            }
            map["IllegalCustomConfigs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IllegalCustomConfigs") && dict["IllegalCustomConfigs"] != nil {
            var tmp : [ChangeCheckCustomConfigResponseBody.IllegalCustomConfigs] = []
            for v in dict["IllegalCustomConfigs"] as! [Any] {
                var model = ChangeCheckCustomConfigResponseBody.IllegalCustomConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.illegalCustomConfigs = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeCheckCustomConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeCheckCustomConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeCheckCustomConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeSecurityScoreRuleRequest : Tea.TeaModel {
    public class SecurityScoreRuleList : Tea.TeaModel {
        public class SecurityScoreItemList : Tea.TeaModel {
            public var score: Int32?

            public var scoreThreshold: Int32?

            public var subRuleType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.scoreThreshold != nil {
                    map["ScoreThreshold"] = self.scoreThreshold!
                }
                if self.subRuleType != nil {
                    map["SubRuleType"] = self.subRuleType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Score") && dict["Score"] != nil {
                    self.score = dict["Score"] as! Int32
                }
                if dict.keys.contains("ScoreThreshold") && dict["ScoreThreshold"] != nil {
                    self.scoreThreshold = dict["ScoreThreshold"] as! Int32
                }
                if dict.keys.contains("SubRuleType") && dict["SubRuleType"] != nil {
                    self.subRuleType = dict["SubRuleType"] as! String
                }
            }
        }
        public var ruleType: String?

        public var score: Int32?

        public var securityScoreItemList: [ChangeSecurityScoreRuleRequest.SecurityScoreRuleList.SecurityScoreItemList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            if self.score != nil {
                map["Score"] = self.score!
            }
            if self.securityScoreItemList != nil {
                var tmp : [Any] = []
                for k in self.securityScoreItemList! {
                    tmp.append(k.toMap())
                }
                map["SecurityScoreItemList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                self.ruleType = dict["RuleType"] as! String
            }
            if dict.keys.contains("Score") && dict["Score"] != nil {
                self.score = dict["Score"] as! Int32
            }
            if dict.keys.contains("SecurityScoreItemList") && dict["SecurityScoreItemList"] != nil {
                var tmp : [ChangeSecurityScoreRuleRequest.SecurityScoreRuleList.SecurityScoreItemList] = []
                for v in dict["SecurityScoreItemList"] as! [Any] {
                    var model = ChangeSecurityScoreRuleRequest.SecurityScoreRuleList.SecurityScoreItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityScoreItemList = tmp
            }
        }
    }
    public var resetSecurityScoreRule: Bool?

    public var securityScoreRuleList: [ChangeSecurityScoreRuleRequest.SecurityScoreRuleList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resetSecurityScoreRule != nil {
            map["ResetSecurityScoreRule"] = self.resetSecurityScoreRule!
        }
        if self.securityScoreRuleList != nil {
            var tmp : [Any] = []
            for k in self.securityScoreRuleList! {
                tmp.append(k.toMap())
            }
            map["SecurityScoreRuleList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResetSecurityScoreRule") && dict["ResetSecurityScoreRule"] != nil {
            self.resetSecurityScoreRule = dict["ResetSecurityScoreRule"] as! Bool
        }
        if dict.keys.contains("SecurityScoreRuleList") && dict["SecurityScoreRuleList"] != nil {
            var tmp : [ChangeSecurityScoreRuleRequest.SecurityScoreRuleList] = []
            for v in dict["SecurityScoreRuleList"] as! [Any] {
                var model = ChangeSecurityScoreRuleRequest.SecurityScoreRuleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityScoreRuleList = tmp
        }
    }
}

public class ChangeSecurityScoreRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeSecurityScoreRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeSecurityScoreRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeSecurityScoreRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeUserLangRequest : Tea.TeaModel {
    public var userLang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.userLang != nil {
            map["UserLang"] = self.userLang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("UserLang") && dict["UserLang"] != nil {
            self.userLang = dict["UserLang"] as! String
        }
    }
}

public class ChangeUserLangResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeUserLangResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeUserLangResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeUserLangResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckQuaraFileIdRequest : Tea.TeaModel {
    public var quaraFileIds: [String]?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.quaraFileIds != nil {
            map["QuaraFileIds"] = self.quaraFileIds!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QuaraFileIds") && dict["QuaraFileIds"] != nil {
            self.quaraFileIds = dict["QuaraFileIds"] as! [String]
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class CheckQuaraFileIdResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CheckQuaraFileIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckQuaraFileIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CheckQuaraFileIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckSecurityEventIdRequest : Tea.TeaModel {
    public var securityEventIds: [String]?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityEventIds != nil {
            map["SecurityEventIds"] = self.securityEventIds!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityEventIds") && dict["SecurityEventIds"] != nil {
            self.securityEventIds = dict["SecurityEventIds"] as! [String]
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class CheckSecurityEventIdResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CheckSecurityEventIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckSecurityEventIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CheckSecurityEventIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckUserHasEcsRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class CheckUserHasEcsResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CheckUserHasEcsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckUserHasEcsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CheckUserHasEcsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfirmVirusEventsRequest : Tea.TeaModel {
    public var operationAll: Int32?

    public var operationCode: String?

    public var operationRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationAll != nil {
            map["OperationAll"] = self.operationAll!
        }
        if self.operationCode != nil {
            map["OperationCode"] = self.operationCode!
        }
        if self.operationRange != nil {
            map["OperationRange"] = self.operationRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationAll") && dict["OperationAll"] != nil {
            self.operationAll = dict["OperationAll"] as! Int32
        }
        if dict.keys.contains("OperationCode") && dict["OperationCode"] != nil {
            self.operationCode = dict["OperationCode"] as! String
        }
        if dict.keys.contains("OperationRange") && dict["OperationRange"] != nil {
            self.operationRange = dict["OperationRange"] as! String
        }
    }
}

public class ConfirmVirusEventsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ConfirmVirusEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmVirusEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ConfirmVirusEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAgentlessScanTaskRequest : Tea.TeaModel {
    public var autoDeleteDays: Int32?

    public var releaseAfterScan: Bool?

    public var scanDataDisk: Bool?

    public var targetType: Int32?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoDeleteDays != nil {
            map["AutoDeleteDays"] = self.autoDeleteDays!
        }
        if self.releaseAfterScan != nil {
            map["ReleaseAfterScan"] = self.releaseAfterScan!
        }
        if self.scanDataDisk != nil {
            map["ScanDataDisk"] = self.scanDataDisk!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoDeleteDays") && dict["AutoDeleteDays"] != nil {
            self.autoDeleteDays = dict["AutoDeleteDays"] as! Int32
        }
        if dict.keys.contains("ReleaseAfterScan") && dict["ReleaseAfterScan"] != nil {
            self.releaseAfterScan = dict["ReleaseAfterScan"] as! Bool
        }
        if dict.keys.contains("ScanDataDisk") && dict["ScanDataDisk"] != nil {
            self.scanDataDisk = dict["ScanDataDisk"] as! Bool
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! Int32
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class CreateAgentlessScanTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAgentlessScanTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAgentlessScanTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAgentlessScanTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAntiBruteForceRuleRequest : Tea.TeaModel {
    public var defaultRule: Bool?

    public var failCount: Int32?

    public var forbiddenTime: Int32?

    public var name: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public var span: Int32?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultRule != nil {
            map["DefaultRule"] = self.defaultRule!
        }
        if self.failCount != nil {
            map["FailCount"] = self.failCount!
        }
        if self.forbiddenTime != nil {
            map["ForbiddenTime"] = self.forbiddenTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.span != nil {
            map["Span"] = self.span!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultRule") && dict["DefaultRule"] != nil {
            self.defaultRule = dict["DefaultRule"] as! Bool
        }
        if dict.keys.contains("FailCount") && dict["FailCount"] != nil {
            self.failCount = dict["FailCount"] as! Int32
        }
        if dict.keys.contains("ForbiddenTime") && dict["ForbiddenTime"] != nil {
            self.forbiddenTime = dict["ForbiddenTime"] as! Int32
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Span") && dict["Span"] != nil {
            self.span = dict["Span"] as! Int32
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class CreateAntiBruteForceRuleResponseBody : Tea.TeaModel {
    public class CreateAntiBruteForceRule : Tea.TeaModel {
        public var ruleId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! Int64
            }
        }
    }
    public var createAntiBruteForceRule: CreateAntiBruteForceRuleResponseBody.CreateAntiBruteForceRule?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createAntiBruteForceRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createAntiBruteForceRule != nil {
            map["CreateAntiBruteForceRule"] = self.createAntiBruteForceRule?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateAntiBruteForceRule") && dict["CreateAntiBruteForceRule"] != nil {
            var model = CreateAntiBruteForceRuleResponseBody.CreateAntiBruteForceRule()
            model.fromMap(dict["CreateAntiBruteForceRule"] as! [String: Any])
            self.createAntiBruteForceRule = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAntiBruteForceRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAntiBruteForceRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAntiBruteForceRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAssetSelectionConfigRequest : Tea.TeaModel {
    public var businessType: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class CreateAssetSelectionConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var businessType: String?

        public var selectionKey: Int64?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessType != nil {
                map["BusinessType"] = self.businessType!
            }
            if self.selectionKey != nil {
                map["SelectionKey"] = self.selectionKey!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
                self.businessType = dict["BusinessType"] as! String
            }
            if dict.keys.contains("SelectionKey") && dict["SelectionKey"] != nil {
                self.selectionKey = dict["SelectionKey"] as! Int64
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
        }
    }
    public var data: CreateAssetSelectionConfigResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateAssetSelectionConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAssetSelectionConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAssetSelectionConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAssetSelectionConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBackupPolicyRequest : Tea.TeaModel {
    public var name: String?

    public var policy: [String: Any]?

    public var policyRegionId: String?

    public var policyVersion: String?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.policyRegionId != nil {
            map["PolicyRegionId"] = self.policyRegionId!
        }
        if self.policyVersion != nil {
            map["PolicyVersion"] = self.policyVersion!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policy = dict["Policy"] as! [String: Any]
        }
        if dict.keys.contains("PolicyRegionId") && dict["PolicyRegionId"] != nil {
            self.policyRegionId = dict["PolicyRegionId"] as! String
        }
        if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
            self.policyVersion = dict["PolicyVersion"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class CreateBackupPolicyShrinkRequest : Tea.TeaModel {
    public var name: String?

    public var policyShrink: String?

    public var policyRegionId: String?

    public var policyVersion: String?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.policyShrink != nil {
            map["Policy"] = self.policyShrink!
        }
        if self.policyRegionId != nil {
            map["PolicyRegionId"] = self.policyRegionId!
        }
        if self.policyVersion != nil {
            map["PolicyVersion"] = self.policyVersion!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policyShrink = dict["Policy"] as! String
        }
        if dict.keys.contains("PolicyRegionId") && dict["PolicyRegionId"] != nil {
            self.policyRegionId = dict["PolicyRegionId"] as! String
        }
        if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
            self.policyVersion = dict["PolicyVersion"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class CreateBackupPolicyResponseBody : Tea.TeaModel {
    public class BackupPolicy : Tea.TeaModel {
        public var id: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var backupPolicy: CreateBackupPolicyResponseBody.BackupPolicy?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backupPolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupPolicy != nil {
            map["BackupPolicy"] = self.backupPolicy?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackupPolicy") && dict["BackupPolicy"] != nil {
            var model = CreateBackupPolicyResponseBody.BackupPolicy()
            model.fromMap(dict["BackupPolicy"] as! [String: Any])
            self.backupPolicy = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBackupPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateContainerScanTaskRequest : Tea.TeaModel {
    public var clusterId: String?

    public var containerIds: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.containerIds != nil {
            map["ContainerIds"] = self.containerIds!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ContainerIds") && dict["ContainerIds"] != nil {
            self.containerIds = dict["ContainerIds"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class CreateContainerScanTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var canCreate: Bool?

        public var collectTime: Int64?

        public var execTime: Int64?

        public var finishCount: Int32?

        public var progress: Int32?

        public var result: String?

        public var status: String?

        public var taskId: String?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canCreate != nil {
                map["CanCreate"] = self.canCreate!
            }
            if self.collectTime != nil {
                map["CollectTime"] = self.collectTime!
            }
            if self.execTime != nil {
                map["ExecTime"] = self.execTime!
            }
            if self.finishCount != nil {
                map["FinishCount"] = self.finishCount!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanCreate") && dict["CanCreate"] != nil {
                self.canCreate = dict["CanCreate"] as! Bool
            }
            if dict.keys.contains("CollectTime") && dict["CollectTime"] != nil {
                self.collectTime = dict["CollectTime"] as! Int64
            }
            if dict.keys.contains("ExecTime") && dict["ExecTime"] != nil {
                self.execTime = dict["ExecTime"] as! Int64
            }
            if dict.keys.contains("FinishCount") && dict["FinishCount"] != nil {
                self.finishCount = dict["FinishCount"] as! Int32
            }
            if dict.keys.contains("Progress") && dict["Progress"] != nil {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: CreateContainerScanTaskResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateContainerScanTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateContainerScanTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateContainerScanTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateContainerScanTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateContainerScanTaskByAppNameRequest : Tea.TeaModel {
    public var appNames: String?

    public var clusterId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appNames != nil {
            map["AppNames"] = self.appNames!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppNames") && dict["AppNames"] != nil {
            self.appNames = dict["AppNames"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class CreateContainerScanTaskByAppNameResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var canCreate: Bool?

        public var collectTime: Int64?

        public var execTime: Int64?

        public var finishCount: Int32?

        public var progress: Int32?

        public var result: String?

        public var status: String?

        public var taskId: String?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canCreate != nil {
                map["CanCreate"] = self.canCreate!
            }
            if self.collectTime != nil {
                map["CollectTime"] = self.collectTime!
            }
            if self.execTime != nil {
                map["ExecTime"] = self.execTime!
            }
            if self.finishCount != nil {
                map["FinishCount"] = self.finishCount!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanCreate") && dict["CanCreate"] != nil {
                self.canCreate = dict["CanCreate"] as! Bool
            }
            if dict.keys.contains("CollectTime") && dict["CollectTime"] != nil {
                self.collectTime = dict["CollectTime"] as! Int64
            }
            if dict.keys.contains("ExecTime") && dict["ExecTime"] != nil {
                self.execTime = dict["ExecTime"] as! Int64
            }
            if dict.keys.contains("FinishCount") && dict["FinishCount"] != nil {
                self.finishCount = dict["FinishCount"] as! Int32
            }
            if dict.keys.contains("Progress") && dict["Progress"] != nil {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: CreateContainerScanTaskByAppNameResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateContainerScanTaskByAppNameResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateContainerScanTaskByAppNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateContainerScanTaskByAppNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateContainerScanTaskByAppNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomBlockRecordRequest : Tea.TeaModel {
    public var blockIp: String?

    public var bound: String?

    public var expireTime: Int64?

    public var resourceOwnerId: Int64?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockIp != nil {
            map["BlockIp"] = self.blockIp!
        }
        if self.bound != nil {
            map["Bound"] = self.bound!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockIp") && dict["BlockIp"] != nil {
            self.blockIp = dict["BlockIp"] as! String
        }
        if dict.keys.contains("Bound") && dict["Bound"] != nil {
            self.bound = dict["Bound"] as! String
        }
        if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
            self.expireTime = dict["ExpireTime"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class CreateCustomBlockRecordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomBlockRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomBlockRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCustomBlockRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCycleTaskRequest : Tea.TeaModel {
    public var enable: Int32?

    public var firstDateStr: Int64?

    public var intervalPeriod: Int32?

    public var param: String?

    public var periodUnit: String?

    public var source: String?

    public var targetEndTime: Int32?

    public var targetStartTime: Int32?

    public var taskName: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.firstDateStr != nil {
            map["FirstDateStr"] = self.firstDateStr!
        }
        if self.intervalPeriod != nil {
            map["IntervalPeriod"] = self.intervalPeriod!
        }
        if self.param != nil {
            map["Param"] = self.param!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.targetEndTime != nil {
            map["TargetEndTime"] = self.targetEndTime!
        }
        if self.targetStartTime != nil {
            map["TargetStartTime"] = self.targetStartTime!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Int32
        }
        if dict.keys.contains("FirstDateStr") && dict["FirstDateStr"] != nil {
            self.firstDateStr = dict["FirstDateStr"] as! Int64
        }
        if dict.keys.contains("IntervalPeriod") && dict["IntervalPeriod"] != nil {
            self.intervalPeriod = dict["IntervalPeriod"] as! Int32
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.param = dict["Param"] as! String
        }
        if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TargetEndTime") && dict["TargetEndTime"] != nil {
            self.targetEndTime = dict["TargetEndTime"] as! Int32
        }
        if dict.keys.contains("TargetStartTime") && dict["TargetStartTime"] != nil {
            self.targetStartTime = dict["TargetStartTime"] as! Int32
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class CreateCycleTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCycleTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCycleTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCycleTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFileDetectRequest : Tea.TeaModel {
    public var downloadUrl: String?

    public var hashKey: String?

    public var ossKey: String?

    public var sourceIp: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadUrl != nil {
            map["DownloadUrl"] = self.downloadUrl!
        }
        if self.hashKey != nil {
            map["HashKey"] = self.hashKey!
        }
        if self.ossKey != nil {
            map["OssKey"] = self.ossKey!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
            self.downloadUrl = dict["DownloadUrl"] as! String
        }
        if dict.keys.contains("HashKey") && dict["HashKey"] != nil {
            self.hashKey = dict["HashKey"] as! String
        }
        if dict.keys.contains("OssKey") && dict["OssKey"] != nil {
            self.ossKey = dict["OssKey"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class CreateFileDetectResponseBody : Tea.TeaModel {
    public var hashKey: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hashKey != nil {
            map["HashKey"] = self.hashKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HashKey") && dict["HashKey"] != nil {
            self.hashKey = dict["HashKey"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFileDetectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFileDetectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFileDetectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFileDetectUploadUrlRequest : Tea.TeaModel {
    public class HashKeyContextList : Tea.TeaModel {
        public var fileSize: Int32?

        public var hashKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.hashKey != nil {
                map["HashKey"] = self.hashKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileSize") && dict["FileSize"] != nil {
                self.fileSize = dict["FileSize"] as! Int32
            }
            if dict.keys.contains("HashKey") && dict["HashKey"] != nil {
                self.hashKey = dict["HashKey"] as! String
            }
        }
    }
    public var hashKeyContextList: [CreateFileDetectUploadUrlRequest.HashKeyContextList]?

    public var hashKeyList: [String]?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hashKeyContextList != nil {
            var tmp : [Any] = []
            for k in self.hashKeyContextList! {
                tmp.append(k.toMap())
            }
            map["HashKeyContextList"] = tmp
        }
        if self.hashKeyList != nil {
            map["HashKeyList"] = self.hashKeyList!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HashKeyContextList") && dict["HashKeyContextList"] != nil {
            var tmp : [CreateFileDetectUploadUrlRequest.HashKeyContextList] = []
            for v in dict["HashKeyContextList"] as! [Any] {
                var model = CreateFileDetectUploadUrlRequest.HashKeyContextList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hashKeyContextList = tmp
        }
        if dict.keys.contains("HashKeyList") && dict["HashKeyList"] != nil {
            self.hashKeyList = dict["HashKeyList"] as! [String]
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class CreateFileDetectUploadUrlResponseBody : Tea.TeaModel {
    public class UploadUrlList : Tea.TeaModel {
        public class Context : Tea.TeaModel {
            public var accessId: String?

            public var ossKey: String?

            public var policy: String?

            public var signature: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessId != nil {
                    map["AccessId"] = self.accessId!
                }
                if self.ossKey != nil {
                    map["OssKey"] = self.ossKey!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.signature != nil {
                    map["Signature"] = self.signature!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessId") && dict["AccessId"] != nil {
                    self.accessId = dict["AccessId"] as! String
                }
                if dict.keys.contains("OssKey") && dict["OssKey"] != nil {
                    self.ossKey = dict["OssKey"] as! String
                }
                if dict.keys.contains("Policy") && dict["Policy"] != nil {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("Signature") && dict["Signature"] != nil {
                    self.signature = dict["Signature"] as! String
                }
            }
        }
        public var code: String?

        public var context: CreateFileDetectUploadUrlResponseBody.UploadUrlList.Context?

        public var expire: String?

        public var fileExist: Bool?

        public var hashKey: String?

        public var internalUrl: String?

        public var message: String?

        public var publicUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.context?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.context != nil {
                map["Context"] = self.context?.toMap()
            }
            if self.expire != nil {
                map["Expire"] = self.expire!
            }
            if self.fileExist != nil {
                map["FileExist"] = self.fileExist!
            }
            if self.hashKey != nil {
                map["HashKey"] = self.hashKey!
            }
            if self.internalUrl != nil {
                map["InternalUrl"] = self.internalUrl!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.publicUrl != nil {
                map["PublicUrl"] = self.publicUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Context") && dict["Context"] != nil {
                var model = CreateFileDetectUploadUrlResponseBody.UploadUrlList.Context()
                model.fromMap(dict["Context"] as! [String: Any])
                self.context = model
            }
            if dict.keys.contains("Expire") && dict["Expire"] != nil {
                self.expire = dict["Expire"] as! String
            }
            if dict.keys.contains("FileExist") && dict["FileExist"] != nil {
                self.fileExist = dict["FileExist"] as! Bool
            }
            if dict.keys.contains("HashKey") && dict["HashKey"] != nil {
                self.hashKey = dict["HashKey"] as! String
            }
            if dict.keys.contains("InternalUrl") && dict["InternalUrl"] != nil {
                self.internalUrl = dict["InternalUrl"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PublicUrl") && dict["PublicUrl"] != nil {
                self.publicUrl = dict["PublicUrl"] as! String
            }
        }
    }
    public var requestId: String?

    public var uploadUrlList: [CreateFileDetectUploadUrlResponseBody.UploadUrlList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uploadUrlList != nil {
            var tmp : [Any] = []
            for k in self.uploadUrlList! {
                tmp.append(k.toMap())
            }
            map["UploadUrlList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UploadUrlList") && dict["UploadUrlList"] != nil {
            var tmp : [CreateFileDetectUploadUrlResponseBody.UploadUrlList] = []
            for v in dict["UploadUrlList"] as! [Any] {
                var model = CreateFileDetectUploadUrlResponseBody.UploadUrlList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uploadUrlList = tmp
        }
    }
}

public class CreateFileDetectUploadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFileDetectUploadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFileDetectUploadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFileProtectRuleRequest : Tea.TeaModel {
    public var alertLevel: Int32?

    public var fileOps: [String]?

    public var filePaths: [String]?

    public var procPaths: [String]?

    public var ruleAction: String?

    public var ruleName: String?

    public var status: Int32?

    public var switchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertLevel != nil {
            map["AlertLevel"] = self.alertLevel!
        }
        if self.fileOps != nil {
            map["FileOps"] = self.fileOps!
        }
        if self.filePaths != nil {
            map["FilePaths"] = self.filePaths!
        }
        if self.procPaths != nil {
            map["ProcPaths"] = self.procPaths!
        }
        if self.ruleAction != nil {
            map["RuleAction"] = self.ruleAction!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.switchId != nil {
            map["SwitchId"] = self.switchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertLevel") && dict["AlertLevel"] != nil {
            self.alertLevel = dict["AlertLevel"] as! Int32
        }
        if dict.keys.contains("FileOps") && dict["FileOps"] != nil {
            self.fileOps = dict["FileOps"] as! [String]
        }
        if dict.keys.contains("FilePaths") && dict["FilePaths"] != nil {
            self.filePaths = dict["FilePaths"] as! [String]
        }
        if dict.keys.contains("ProcPaths") && dict["ProcPaths"] != nil {
            self.procPaths = dict["ProcPaths"] as! [String]
        }
        if dict.keys.contains("RuleAction") && dict["RuleAction"] != nil {
            self.ruleAction = dict["RuleAction"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("SwitchId") && dict["SwitchId"] != nil {
            self.switchId = dict["SwitchId"] as! String
        }
    }
}

public class CreateFileProtectRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var ruleId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int64
        }
    }
}

public class CreateFileProtectRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFileProtectRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFileProtectRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHoneypotRequest : Tea.TeaModel {
    public var honeypotImageId: String?

    public var honeypotImageName: String?

    public var honeypotName: String?

    public var meta: String?

    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeypotImageId != nil {
            map["HoneypotImageId"] = self.honeypotImageId!
        }
        if self.honeypotImageName != nil {
            map["HoneypotImageName"] = self.honeypotImageName!
        }
        if self.honeypotName != nil {
            map["HoneypotName"] = self.honeypotName!
        }
        if self.meta != nil {
            map["Meta"] = self.meta!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneypotImageId") && dict["HoneypotImageId"] != nil {
            self.honeypotImageId = dict["HoneypotImageId"] as! String
        }
        if dict.keys.contains("HoneypotImageName") && dict["HoneypotImageName"] != nil {
            self.honeypotImageName = dict["HoneypotImageName"] as! String
        }
        if dict.keys.contains("HoneypotName") && dict["HoneypotName"] != nil {
            self.honeypotName = dict["HoneypotName"] as! String
        }
        if dict.keys.contains("Meta") && dict["Meta"] != nil {
            self.meta = dict["Meta"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class CreateHoneypotResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var controlNodeName: String?

        public var honeypotId: String?

        public var honeypotImageDisplayName: String?

        public var honeypotImageName: String?

        public var honeypotName: String?

        public var nodeId: String?

        public var presetId: String?

        public var state: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.controlNodeName != nil {
                map["ControlNodeName"] = self.controlNodeName!
            }
            if self.honeypotId != nil {
                map["HoneypotId"] = self.honeypotId!
            }
            if self.honeypotImageDisplayName != nil {
                map["HoneypotImageDisplayName"] = self.honeypotImageDisplayName!
            }
            if self.honeypotImageName != nil {
                map["HoneypotImageName"] = self.honeypotImageName!
            }
            if self.honeypotName != nil {
                map["HoneypotName"] = self.honeypotName!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.presetId != nil {
                map["PresetId"] = self.presetId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ControlNodeName") && dict["ControlNodeName"] != nil {
                self.controlNodeName = dict["ControlNodeName"] as! String
            }
            if dict.keys.contains("HoneypotId") && dict["HoneypotId"] != nil {
                self.honeypotId = dict["HoneypotId"] as! String
            }
            if dict.keys.contains("HoneypotImageDisplayName") && dict["HoneypotImageDisplayName"] != nil {
                self.honeypotImageDisplayName = dict["HoneypotImageDisplayName"] as! String
            }
            if dict.keys.contains("HoneypotImageName") && dict["HoneypotImageName"] != nil {
                self.honeypotImageName = dict["HoneypotImageName"] as! String
            }
            if dict.keys.contains("HoneypotName") && dict["HoneypotName"] != nil {
                self.honeypotName = dict["HoneypotName"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PresetId") && dict["PresetId"] != nil {
                self.presetId = dict["PresetId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! [String]
            }
        }
    }
    public var code: String?

    public var data: CreateHoneypotResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateHoneypotResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateHoneypotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHoneypotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateHoneypotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHoneypotNodeRequest : Tea.TeaModel {
    public var allowHoneypotAccessInternet: Bool?

    public var availableProbeNum: Int32?

    public var nodeName: String?

    public var securityGroupProbeIpList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowHoneypotAccessInternet != nil {
            map["AllowHoneypotAccessInternet"] = self.allowHoneypotAccessInternet!
        }
        if self.availableProbeNum != nil {
            map["AvailableProbeNum"] = self.availableProbeNum!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.securityGroupProbeIpList != nil {
            map["SecurityGroupProbeIpList"] = self.securityGroupProbeIpList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowHoneypotAccessInternet") && dict["AllowHoneypotAccessInternet"] != nil {
            self.allowHoneypotAccessInternet = dict["AllowHoneypotAccessInternet"] as! Bool
        }
        if dict.keys.contains("AvailableProbeNum") && dict["AvailableProbeNum"] != nil {
            self.availableProbeNum = dict["AvailableProbeNum"] as! Int32
        }
        if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("SecurityGroupProbeIpList") && dict["SecurityGroupProbeIpList"] != nil {
            self.securityGroupProbeIpList = dict["SecurityGroupProbeIpList"] as! [String]
        }
    }
}

public class CreateHoneypotNodeResponseBody : Tea.TeaModel {
    public class HoneypotNode : Tea.TeaModel {
        public var nodeId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
        }
    }
    public var code: String?

    public var honeypotNode: CreateHoneypotNodeResponseBody.HoneypotNode?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.honeypotNode?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.honeypotNode != nil {
            map["HoneypotNode"] = self.honeypotNode?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HoneypotNode") && dict["HoneypotNode"] != nil {
            var model = CreateHoneypotNodeResponseBody.HoneypotNode()
            model.fromMap(dict["HoneypotNode"] as! [String: Any])
            self.honeypotNode = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateHoneypotNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHoneypotNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateHoneypotNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHoneypotPresetRequest : Tea.TeaModel {
    public var honeypotImageName: String?

    public var lang: String?

    public var meta: String?

    public var nodeId: String?

    public var presetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeypotImageName != nil {
            map["HoneypotImageName"] = self.honeypotImageName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.meta != nil {
            map["Meta"] = self.meta!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.presetName != nil {
            map["PresetName"] = self.presetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneypotImageName") && dict["HoneypotImageName"] != nil {
            self.honeypotImageName = dict["HoneypotImageName"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Meta") && dict["Meta"] != nil {
            self.meta = dict["Meta"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("PresetName") && dict["PresetName"] != nil {
            self.presetName = dict["PresetName"] as! String
        }
    }
}

public class CreateHoneypotPresetResponseBody : Tea.TeaModel {
    public class HoneypotPreset : Tea.TeaModel {
        public var honeypotPresetId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.honeypotPresetId != nil {
                map["HoneypotPresetId"] = self.honeypotPresetId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HoneypotPresetId") && dict["HoneypotPresetId"] != nil {
                self.honeypotPresetId = dict["HoneypotPresetId"] as! String
            }
        }
    }
    public var code: String?

    public var honeypotPreset: CreateHoneypotPresetResponseBody.HoneypotPreset?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.honeypotPreset?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.honeypotPreset != nil {
            map["HoneypotPreset"] = self.honeypotPreset?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HoneypotPreset") && dict["HoneypotPreset"] != nil {
            var model = CreateHoneypotPresetResponseBody.HoneypotPreset()
            model.fromMap(dict["HoneypotPreset"] as! [String: Any])
            self.honeypotPreset = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateHoneypotPresetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHoneypotPresetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateHoneypotPresetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHoneypotProbeRequest : Tea.TeaModel {
    public class HoneypotBindList : Tea.TeaModel {
        public class BindPortList : Tea.TeaModel {
            public var bindPort: Bool?

            public var endPort: Int32?

            public var fixed: Bool?

            public var startPort: Int32?

            public var targetPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindPort != nil {
                    map["BindPort"] = self.bindPort!
                }
                if self.endPort != nil {
                    map["EndPort"] = self.endPort!
                }
                if self.fixed != nil {
                    map["Fixed"] = self.fixed!
                }
                if self.startPort != nil {
                    map["StartPort"] = self.startPort!
                }
                if self.targetPort != nil {
                    map["TargetPort"] = self.targetPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindPort") && dict["BindPort"] != nil {
                    self.bindPort = dict["BindPort"] as! Bool
                }
                if dict.keys.contains("EndPort") && dict["EndPort"] != nil {
                    self.endPort = dict["EndPort"] as! Int32
                }
                if dict.keys.contains("Fixed") && dict["Fixed"] != nil {
                    self.fixed = dict["Fixed"] as! Bool
                }
                if dict.keys.contains("StartPort") && dict["StartPort"] != nil {
                    self.startPort = dict["StartPort"] as! Int32
                }
                if dict.keys.contains("TargetPort") && dict["TargetPort"] != nil {
                    self.targetPort = dict["TargetPort"] as! Int32
                }
            }
        }
        public var bindPortList: [CreateHoneypotProbeRequest.HoneypotBindList.BindPortList]?

        public var honeypotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindPortList != nil {
                var tmp : [Any] = []
                for k in self.bindPortList! {
                    tmp.append(k.toMap())
                }
                map["BindPortList"] = tmp
            }
            if self.honeypotId != nil {
                map["HoneypotId"] = self.honeypotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindPortList") && dict["BindPortList"] != nil {
                var tmp : [CreateHoneypotProbeRequest.HoneypotBindList.BindPortList] = []
                for v in dict["BindPortList"] as! [Any] {
                    var model = CreateHoneypotProbeRequest.HoneypotBindList.BindPortList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bindPortList = tmp
            }
            if dict.keys.contains("HoneypotId") && dict["HoneypotId"] != nil {
                self.honeypotId = dict["HoneypotId"] as! String
            }
        }
    }
    public var arp: Bool?

    public var businessGroupId: String?

    public var controlNodeId: String?

    public var displayName: String?

    public var honeypotBindList: [CreateHoneypotProbeRequest.HoneypotBindList]?

    public var ping: Bool?

    public var probeType: String?

    public var probeVersion: String?

    public var proxyIp: String?

    public var uuid: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arp != nil {
            map["Arp"] = self.arp!
        }
        if self.businessGroupId != nil {
            map["BusinessGroupId"] = self.businessGroupId!
        }
        if self.controlNodeId != nil {
            map["ControlNodeId"] = self.controlNodeId!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.honeypotBindList != nil {
            var tmp : [Any] = []
            for k in self.honeypotBindList! {
                tmp.append(k.toMap())
            }
            map["HoneypotBindList"] = tmp
        }
        if self.ping != nil {
            map["Ping"] = self.ping!
        }
        if self.probeType != nil {
            map["ProbeType"] = self.probeType!
        }
        if self.probeVersion != nil {
            map["ProbeVersion"] = self.probeVersion!
        }
        if self.proxyIp != nil {
            map["ProxyIp"] = self.proxyIp!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Arp") && dict["Arp"] != nil {
            self.arp = dict["Arp"] as! Bool
        }
        if dict.keys.contains("BusinessGroupId") && dict["BusinessGroupId"] != nil {
            self.businessGroupId = dict["BusinessGroupId"] as! String
        }
        if dict.keys.contains("ControlNodeId") && dict["ControlNodeId"] != nil {
            self.controlNodeId = dict["ControlNodeId"] as! String
        }
        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("HoneypotBindList") && dict["HoneypotBindList"] != nil {
            var tmp : [CreateHoneypotProbeRequest.HoneypotBindList] = []
            for v in dict["HoneypotBindList"] as! [Any] {
                var model = CreateHoneypotProbeRequest.HoneypotBindList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.honeypotBindList = tmp
        }
        if dict.keys.contains("Ping") && dict["Ping"] != nil {
            self.ping = dict["Ping"] as! Bool
        }
        if dict.keys.contains("ProbeType") && dict["ProbeType"] != nil {
            self.probeType = dict["ProbeType"] as! String
        }
        if dict.keys.contains("ProbeVersion") && dict["ProbeVersion"] != nil {
            self.probeVersion = dict["ProbeVersion"] as! String
        }
        if dict.keys.contains("ProxyIp") && dict["ProxyIp"] != nil {
            self.proxyIp = dict["ProxyIp"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateHoneypotProbeResponseBody : Tea.TeaModel {
    public class HoneypotProbe : Tea.TeaModel {
        public var probeId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.probeId != nil {
                map["ProbeId"] = self.probeId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProbeId") && dict["ProbeId"] != nil {
                self.probeId = dict["ProbeId"] as! String
            }
        }
    }
    public var code: String?

    public var honeypotProbe: CreateHoneypotProbeResponseBody.HoneypotProbe?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.honeypotProbe?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.honeypotProbe != nil {
            map["HoneypotProbe"] = self.honeypotProbe?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HoneypotProbe") && dict["HoneypotProbe"] != nil {
            var model = CreateHoneypotProbeResponseBody.HoneypotProbe()
            model.fromMap(dict["HoneypotProbe"] as! [String: Any])
            self.honeypotProbe = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateHoneypotProbeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHoneypotProbeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateHoneypotProbeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHoneypotProbeBindRequest : Tea.TeaModel {
    public class BindPortList : Tea.TeaModel {
        public var bindPort: Bool?

        public var endPort: Int32?

        public var fixed: Bool?

        public var proto: String?

        public var startPort: Int32?

        public var targetPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindPort != nil {
                map["BindPort"] = self.bindPort!
            }
            if self.endPort != nil {
                map["EndPort"] = self.endPort!
            }
            if self.fixed != nil {
                map["Fixed"] = self.fixed!
            }
            if self.proto != nil {
                map["Proto"] = self.proto!
            }
            if self.startPort != nil {
                map["StartPort"] = self.startPort!
            }
            if self.targetPort != nil {
                map["TargetPort"] = self.targetPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindPort") && dict["BindPort"] != nil {
                self.bindPort = dict["BindPort"] as! Bool
            }
            if dict.keys.contains("EndPort") && dict["EndPort"] != nil {
                self.endPort = dict["EndPort"] as! Int32
            }
            if dict.keys.contains("Fixed") && dict["Fixed"] != nil {
                self.fixed = dict["Fixed"] as! Bool
            }
            if dict.keys.contains("Proto") && dict["Proto"] != nil {
                self.proto = dict["Proto"] as! String
            }
            if dict.keys.contains("StartPort") && dict["StartPort"] != nil {
                self.startPort = dict["StartPort"] as! Int32
            }
            if dict.keys.contains("TargetPort") && dict["TargetPort"] != nil {
                self.targetPort = dict["TargetPort"] as! Int32
            }
        }
    }
    public var bindPortList: [CreateHoneypotProbeBindRequest.BindPortList]?

    public var honeypotId: String?

    public var lang: String?

    public var probeId: String?

    public var serviceIpList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bindPortList != nil {
            var tmp : [Any] = []
            for k in self.bindPortList! {
                tmp.append(k.toMap())
            }
            map["BindPortList"] = tmp
        }
        if self.honeypotId != nil {
            map["HoneypotId"] = self.honeypotId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.probeId != nil {
            map["ProbeId"] = self.probeId!
        }
        if self.serviceIpList != nil {
            map["ServiceIpList"] = self.serviceIpList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BindPortList") && dict["BindPortList"] != nil {
            var tmp : [CreateHoneypotProbeBindRequest.BindPortList] = []
            for v in dict["BindPortList"] as! [Any] {
                var model = CreateHoneypotProbeBindRequest.BindPortList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bindPortList = tmp
        }
        if dict.keys.contains("HoneypotId") && dict["HoneypotId"] != nil {
            self.honeypotId = dict["HoneypotId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ProbeId") && dict["ProbeId"] != nil {
            self.probeId = dict["ProbeId"] as! String
        }
        if dict.keys.contains("ServiceIpList") && dict["ServiceIpList"] != nil {
            self.serviceIpList = dict["ServiceIpList"] as! [String]
        }
    }
}

public class CreateHoneypotProbeBindResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateHoneypotProbeBindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHoneypotProbeBindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateHoneypotProbeBindResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInterceptionRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterName: String?

    public var dstTargetList: [String: Any]?

    public var interceptType: Int64?

    public var orderIndex: Int64?

    public var ruleName: String?

    public var ruleSwitch: Int32?

    public var ruleType: String?

    public var srcTarget: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.dstTargetList != nil {
            map["DstTargetList"] = self.dstTargetList!
        }
        if self.interceptType != nil {
            map["InterceptType"] = self.interceptType!
        }
        if self.orderIndex != nil {
            map["OrderIndex"] = self.orderIndex!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleSwitch != nil {
            map["RuleSwitch"] = self.ruleSwitch!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.srcTarget != nil {
            map["SrcTarget"] = self.srcTarget!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("DstTargetList") && dict["DstTargetList"] != nil {
            self.dstTargetList = dict["DstTargetList"] as! [String: Any]
        }
        if dict.keys.contains("InterceptType") && dict["InterceptType"] != nil {
            self.interceptType = dict["InterceptType"] as! Int64
        }
        if dict.keys.contains("OrderIndex") && dict["OrderIndex"] != nil {
            self.orderIndex = dict["OrderIndex"] as! Int64
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleSwitch") && dict["RuleSwitch"] != nil {
            self.ruleSwitch = dict["RuleSwitch"] as! Int32
        }
        if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
            self.ruleType = dict["RuleType"] as! String
        }
        if dict.keys.contains("SrcTarget") && dict["SrcTarget"] != nil {
            self.srcTarget = dict["SrcTarget"] as! [String: Any]
        }
    }
}

public class CreateInterceptionRuleShrinkRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterName: String?

    public var dstTargetListShrink: String?

    public var interceptType: Int64?

    public var orderIndex: Int64?

    public var ruleName: String?

    public var ruleSwitch: Int32?

    public var ruleType: String?

    public var srcTargetShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.dstTargetListShrink != nil {
            map["DstTargetList"] = self.dstTargetListShrink!
        }
        if self.interceptType != nil {
            map["InterceptType"] = self.interceptType!
        }
        if self.orderIndex != nil {
            map["OrderIndex"] = self.orderIndex!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleSwitch != nil {
            map["RuleSwitch"] = self.ruleSwitch!
        }
        if self.ruleType != nil {
            map["RuleType"] = self.ruleType!
        }
        if self.srcTargetShrink != nil {
            map["SrcTarget"] = self.srcTargetShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("DstTargetList") && dict["DstTargetList"] != nil {
            self.dstTargetListShrink = dict["DstTargetList"] as! String
        }
        if dict.keys.contains("InterceptType") && dict["InterceptType"] != nil {
            self.interceptType = dict["InterceptType"] as! Int64
        }
        if dict.keys.contains("OrderIndex") && dict["OrderIndex"] != nil {
            self.orderIndex = dict["OrderIndex"] as! Int64
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleSwitch") && dict["RuleSwitch"] != nil {
            self.ruleSwitch = dict["RuleSwitch"] as! Int32
        }
        if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
            self.ruleType = dict["RuleType"] as! String
        }
        if dict.keys.contains("SrcTarget") && dict["SrcTarget"] != nil {
            self.srcTargetShrink = dict["SrcTarget"] as! String
        }
    }
}

public class CreateInterceptionRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateInterceptionRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInterceptionRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateInterceptionRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInterceptionTargetRequest : Tea.TeaModel {
    public var appName: String?

    public var clusterId: String?

    public var clusterName: String?

    public var imageList: [String]?

    public var namespace: String?

    public var tagList: [String]?

    public var targetName: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.imageList != nil {
            map["ImageList"] = self.imageList!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.tagList != nil {
            map["TagList"] = self.tagList!
        }
        if self.targetName != nil {
            map["TargetName"] = self.targetName!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ImageList") && dict["ImageList"] != nil {
            self.imageList = dict["ImageList"] as! [String]
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("TagList") && dict["TagList"] != nil {
            self.tagList = dict["TagList"] as! [String]
        }
        if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
            self.targetName = dict["TargetName"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class CreateInterceptionTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class CreateInterceptionTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInterceptionTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateInterceptionTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateJenkinsImageRegistryRequest : Tea.TeaModel {
    public var domainName: String?

    public var extraParam: String?

    public var netType: Int32?

    public var password: String?

    public var persistenceDay: Int32?

    public var protocolType: Int32?

    public var regionId: String?

    public var registryHostIp: String?

    public var registryName: String?

    public var registryType: String?

    public var registryVersion: String?

    public var sourceIp: String?

    public var transPerHour: Int32?

    public var userName: String?

    public var vpcId: String?

    public var whiteList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.extraParam != nil {
            map["ExtraParam"] = self.extraParam!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.persistenceDay != nil {
            map["PersistenceDay"] = self.persistenceDay!
        }
        if self.protocolType != nil {
            map["ProtocolType"] = self.protocolType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.registryHostIp != nil {
            map["RegistryHostIp"] = self.registryHostIp!
        }
        if self.registryName != nil {
            map["RegistryName"] = self.registryName!
        }
        if self.registryType != nil {
            map["RegistryType"] = self.registryType!
        }
        if self.registryVersion != nil {
            map["RegistryVersion"] = self.registryVersion!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.transPerHour != nil {
            map["TransPerHour"] = self.transPerHour!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.whiteList != nil {
            map["WhiteList"] = self.whiteList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("ExtraParam") && dict["ExtraParam"] != nil {
            self.extraParam = dict["ExtraParam"] as! String
        }
        if dict.keys.contains("NetType") && dict["NetType"] != nil {
            self.netType = dict["NetType"] as! Int32
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PersistenceDay") && dict["PersistenceDay"] != nil {
            self.persistenceDay = dict["PersistenceDay"] as! Int32
        }
        if dict.keys.contains("ProtocolType") && dict["ProtocolType"] != nil {
            self.protocolType = dict["ProtocolType"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RegistryHostIp") && dict["RegistryHostIp"] != nil {
            self.registryHostIp = dict["RegistryHostIp"] as! String
        }
        if dict.keys.contains("RegistryName") && dict["RegistryName"] != nil {
            self.registryName = dict["RegistryName"] as! String
        }
        if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
            self.registryType = dict["RegistryType"] as! String
        }
        if dict.keys.contains("RegistryVersion") && dict["RegistryVersion"] != nil {
            self.registryVersion = dict["RegistryVersion"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("TransPerHour") && dict["TransPerHour"] != nil {
            self.transPerHour = dict["TransPerHour"] as! Int32
        }
        if dict.keys.contains("UserName") && dict["UserName"] != nil {
            self.userName = dict["UserName"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
            self.whiteList = dict["WhiteList"] as! String
        }
    }
}

public class CreateJenkinsImageRegistryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var blackList: String?

        public var domainName: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var netType: Int32?

        public var password: String?

        public var persistenceDay: Int32?

        public var protocolType: Int32?

        public var regionId: String?

        public var registryHostIp: String?

        public var registryName: String?

        public var registryType: String?

        public var token: String?

        public var transPerHour: Int32?

        public var userName: String?

        public var vpcId: String?

        public var whiteList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blackList != nil {
                map["BlackList"] = self.blackList!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.persistenceDay != nil {
                map["PersistenceDay"] = self.persistenceDay!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.registryHostIp != nil {
                map["RegistryHostIp"] = self.registryHostIp!
            }
            if self.registryName != nil {
                map["RegistryName"] = self.registryName!
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.token != nil {
                map["Token"] = self.token!
            }
            if self.transPerHour != nil {
                map["TransPerHour"] = self.transPerHour!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.whiteList != nil {
                map["WhiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlackList") && dict["BlackList"] != nil {
                self.blackList = dict["BlackList"] as! String
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("NetType") && dict["NetType"] != nil {
                self.netType = dict["NetType"] as! Int32
            }
            if dict.keys.contains("Password") && dict["Password"] != nil {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("PersistenceDay") && dict["PersistenceDay"] != nil {
                self.persistenceDay = dict["PersistenceDay"] as! Int32
            }
            if dict.keys.contains("ProtocolType") && dict["ProtocolType"] != nil {
                self.protocolType = dict["ProtocolType"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegistryHostIp") && dict["RegistryHostIp"] != nil {
                self.registryHostIp = dict["RegistryHostIp"] as! String
            }
            if dict.keys.contains("RegistryName") && dict["RegistryName"] != nil {
                self.registryName = dict["RegistryName"] as! String
            }
            if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("Token") && dict["Token"] != nil {
                self.token = dict["Token"] as! String
            }
            if dict.keys.contains("TransPerHour") && dict["TransPerHour"] != nil {
                self.transPerHour = dict["TransPerHour"] as! Int32
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                self.whiteList = dict["WhiteList"] as! String
            }
        }
    }
    public var data: CreateJenkinsImageRegistryResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var timeCost: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeCost != nil {
            map["TimeCost"] = self.timeCost!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateJenkinsImageRegistryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TimeCost") && dict["TimeCost"] != nil {
            self.timeCost = dict["TimeCost"] as! Int64
        }
    }
}

public class CreateJenkinsImageRegistryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateJenkinsImageRegistryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateJenkinsImageRegistryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMaliciousNoteRequest : Tea.TeaModel {
    public var eventId: Int64?

    public var note: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! Int64
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
    }
}

public class CreateMaliciousNoteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateMaliciousNoteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMaliciousNoteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateMaliciousNoteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOpaClusterPluginRequest : Tea.TeaModel {
    public var clusterIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") && dict["ClusterIds"] != nil {
            self.clusterIds = dict["ClusterIds"] as! [String]
        }
    }
}

public class CreateOpaClusterPluginResponseBody : Tea.TeaModel {
    public class InstallStatus : Tea.TeaModel {
        public var clusterId: String?

        public var installStatus: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.installStatus != nil {
                map["InstallStatus"] = self.installStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("InstallStatus") && dict["InstallStatus"] != nil {
                self.installStatus = dict["InstallStatus"] as! Bool
            }
        }
    }
    public var installStatus: [CreateOpaClusterPluginResponseBody.InstallStatus]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.installStatus != nil {
            var tmp : [Any] = []
            for k in self.installStatus! {
                tmp.append(k.toMap())
            }
            map["InstallStatus"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstallStatus") && dict["InstallStatus"] != nil {
            var tmp : [CreateOpaClusterPluginResponseBody.InstallStatus] = []
            for v in dict["InstallStatus"] as! [Any] {
                var model = CreateOpaClusterPluginResponseBody.InstallStatus()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.installStatus = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOpaClusterPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOpaClusterPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOpaClusterPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateAssetGroupRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var groupName: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class CreateOrUpdateAssetGroupResponseBody : Tea.TeaModel {
    public var groupId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateAssetGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateAssetGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateAssetGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrUpdateDingTalkRequest : Tea.TeaModel {
    public var configList: String?

    public var dingTalkLang: String?

    public var groupIdList: String?

    public var id: Int64?

    public var intervalTime: Int64?

    public var ruleActionName: String?

    public var sendUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configList != nil {
            map["ConfigList"] = self.configList!
        }
        if self.dingTalkLang != nil {
            map["DingTalkLang"] = self.dingTalkLang!
        }
        if self.groupIdList != nil {
            map["GroupIdList"] = self.groupIdList!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.intervalTime != nil {
            map["IntervalTime"] = self.intervalTime!
        }
        if self.ruleActionName != nil {
            map["RuleActionName"] = self.ruleActionName!
        }
        if self.sendUrl != nil {
            map["SendUrl"] = self.sendUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigList") && dict["ConfigList"] != nil {
            self.configList = dict["ConfigList"] as! String
        }
        if dict.keys.contains("DingTalkLang") && dict["DingTalkLang"] != nil {
            self.dingTalkLang = dict["DingTalkLang"] as! String
        }
        if dict.keys.contains("GroupIdList") && dict["GroupIdList"] != nil {
            self.groupIdList = dict["GroupIdList"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IntervalTime") && dict["IntervalTime"] != nil {
            self.intervalTime = dict["IntervalTime"] as! Int64
        }
        if dict.keys.contains("RuleActionName") && dict["RuleActionName"] != nil {
            self.ruleActionName = dict["RuleActionName"] as! String
        }
        if dict.keys.contains("SendUrl") && dict["SendUrl"] != nil {
            self.sendUrl = dict["SendUrl"] as! String
        }
    }
}

public class CreateOrUpdateDingTalkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateOrUpdateDingTalkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateDingTalkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateOrUpdateDingTalkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRestoreJobRequest : Tea.TeaModel {
    public var includes: String?

    public var snapshotHash: String?

    public var snapshotId: String?

    public var snapshotVersion: String?

    public var sourceType: String?

    public var target: String?

    public var uuid: String?

    public var vaultId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includes != nil {
            map["Includes"] = self.includes!
        }
        if self.snapshotHash != nil {
            map["SnapshotHash"] = self.snapshotHash!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.snapshotVersion != nil {
            map["SnapshotVersion"] = self.snapshotVersion!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.vaultId != nil {
            map["VaultId"] = self.vaultId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Includes") && dict["Includes"] != nil {
            self.includes = dict["Includes"] as! String
        }
        if dict.keys.contains("SnapshotHash") && dict["SnapshotHash"] != nil {
            self.snapshotHash = dict["SnapshotHash"] as! String
        }
        if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("SnapshotVersion") && dict["SnapshotVersion"] != nil {
            self.snapshotVersion = dict["SnapshotVersion"] as! String
        }
        if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("VaultId") && dict["VaultId"] != nil {
            self.vaultId = dict["VaultId"] as! String
        }
    }
}

public class CreateRestoreJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateRestoreJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRestoreJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateRestoreJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateServiceLinkedRoleRequest : Tea.TeaModel {
    public var serviceLinkedRole: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serviceLinkedRole != nil {
            map["ServiceLinkedRole"] = self.serviceLinkedRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ServiceLinkedRole") && dict["ServiceLinkedRole"] != nil {
            self.serviceLinkedRole = dict["ServiceLinkedRole"] as! String
        }
    }
}

public class CreateServiceLinkedRoleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateServiceLinkedRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceLinkedRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateServiceLinkedRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateServiceTrailRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateServiceTrailResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateServiceTrailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateServiceTrailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateServiceTrailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSimilarSecurityEventsQueryTaskRequest : Tea.TeaModel {
    public var resourceOwnerId: Int64?

    public var securityEventId: Int64?

    public var similarEventScenarioCode: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEventId != nil {
            map["SecurityEventId"] = self.securityEventId!
        }
        if self.similarEventScenarioCode != nil {
            map["SimilarEventScenarioCode"] = self.similarEventScenarioCode!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEventId") && dict["SecurityEventId"] != nil {
            self.securityEventId = dict["SecurityEventId"] as! Int64
        }
        if dict.keys.contains("SimilarEventScenarioCode") && dict["SimilarEventScenarioCode"] != nil {
            self.similarEventScenarioCode = dict["SimilarEventScenarioCode"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class CreateSimilarSecurityEventsQueryTaskResponseBody : Tea.TeaModel {
    public class CreateSimilarSecurityEventsQueryTaskResponse : Tea.TeaModel {
        public var status: String?

        public var taskId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! Int64
            }
        }
    }
    public var createSimilarSecurityEventsQueryTaskResponse: CreateSimilarSecurityEventsQueryTaskResponseBody.CreateSimilarSecurityEventsQueryTaskResponse?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.createSimilarSecurityEventsQueryTaskResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createSimilarSecurityEventsQueryTaskResponse != nil {
            map["CreateSimilarSecurityEventsQueryTaskResponse"] = self.createSimilarSecurityEventsQueryTaskResponse?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateSimilarSecurityEventsQueryTaskResponse") && dict["CreateSimilarSecurityEventsQueryTaskResponse"] != nil {
            var model = CreateSimilarSecurityEventsQueryTaskResponseBody.CreateSimilarSecurityEventsQueryTaskResponse()
            model.fromMap(dict["CreateSimilarSecurityEventsQueryTaskResponse"] as! [String: Any])
            self.createSimilarSecurityEventsQueryTaskResponse = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSimilarSecurityEventsQueryTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSimilarSecurityEventsQueryTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSimilarSecurityEventsQueryTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSuspEventNoteRequest : Tea.TeaModel {
    public var eventId: Int64?

    public var note: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! Int64
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
    }
}

public class CreateSuspEventNoteResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateSuspEventNoteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSuspEventNoteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSuspEventNoteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUniBackupPolicyRequest : Tea.TeaModel {
    public var accountName: String?

    public var accountPassword: String?

    public var databaseAddByUser: String?

    public var databaseType: String?

    public var fullPlan: [String: Any]?

    public var incPlan: [String: Any]?

    public var instanceId: String?

    public var policyName: String?

    public var retention: Int32?

    public var speedLimiter: Int64?

    public var uniRegionId: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPassword != nil {
            map["AccountPassword"] = self.accountPassword!
        }
        if self.databaseAddByUser != nil {
            map["DatabaseAddByUser"] = self.databaseAddByUser!
        }
        if self.databaseType != nil {
            map["DatabaseType"] = self.databaseType!
        }
        if self.fullPlan != nil {
            map["FullPlan"] = self.fullPlan!
        }
        if self.incPlan != nil {
            map["IncPlan"] = self.incPlan!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.policyName != nil {
            map["PolicyName"] = self.policyName!
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        if self.speedLimiter != nil {
            map["SpeedLimiter"] = self.speedLimiter!
        }
        if self.uniRegionId != nil {
            map["UniRegionId"] = self.uniRegionId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountName") && dict["AccountName"] != nil {
            self.accountName = dict["AccountName"] as! String
        }
        if dict.keys.contains("AccountPassword") && dict["AccountPassword"] != nil {
            self.accountPassword = dict["AccountPassword"] as! String
        }
        if dict.keys.contains("DatabaseAddByUser") && dict["DatabaseAddByUser"] != nil {
            self.databaseAddByUser = dict["DatabaseAddByUser"] as! String
        }
        if dict.keys.contains("DatabaseType") && dict["DatabaseType"] != nil {
            self.databaseType = dict["DatabaseType"] as! String
        }
        if dict.keys.contains("FullPlan") && dict["FullPlan"] != nil {
            self.fullPlan = dict["FullPlan"] as! [String: Any]
        }
        if dict.keys.contains("IncPlan") && dict["IncPlan"] != nil {
            self.incPlan = dict["IncPlan"] as! [String: Any]
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PolicyName") && dict["PolicyName"] != nil {
            self.policyName = dict["PolicyName"] as! String
        }
        if dict.keys.contains("Retention") && dict["Retention"] != nil {
            self.retention = dict["Retention"] as! Int32
        }
        if dict.keys.contains("SpeedLimiter") && dict["SpeedLimiter"] != nil {
            self.speedLimiter = dict["SpeedLimiter"] as! Int64
        }
        if dict.keys.contains("UniRegionId") && dict["UniRegionId"] != nil {
            self.uniRegionId = dict["UniRegionId"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class CreateUniBackupPolicyShrinkRequest : Tea.TeaModel {
    public var accountName: String?

    public var accountPassword: String?

    public var databaseAddByUser: String?

    public var databaseType: String?

    public var fullPlanShrink: String?

    public var incPlanShrink: String?

    public var instanceId: String?

    public var policyName: String?

    public var retention: Int32?

    public var speedLimiter: Int64?

    public var uniRegionId: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPassword != nil {
            map["AccountPassword"] = self.accountPassword!
        }
        if self.databaseAddByUser != nil {
            map["DatabaseAddByUser"] = self.databaseAddByUser!
        }
        if self.databaseType != nil {
            map["DatabaseType"] = self.databaseType!
        }
        if self.fullPlanShrink != nil {
            map["FullPlan"] = self.fullPlanShrink!
        }
        if self.incPlanShrink != nil {
            map["IncPlan"] = self.incPlanShrink!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.policyName != nil {
            map["PolicyName"] = self.policyName!
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        if self.speedLimiter != nil {
            map["SpeedLimiter"] = self.speedLimiter!
        }
        if self.uniRegionId != nil {
            map["UniRegionId"] = self.uniRegionId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountName") && dict["AccountName"] != nil {
            self.accountName = dict["AccountName"] as! String
        }
        if dict.keys.contains("AccountPassword") && dict["AccountPassword"] != nil {
            self.accountPassword = dict["AccountPassword"] as! String
        }
        if dict.keys.contains("DatabaseAddByUser") && dict["DatabaseAddByUser"] != nil {
            self.databaseAddByUser = dict["DatabaseAddByUser"] as! String
        }
        if dict.keys.contains("DatabaseType") && dict["DatabaseType"] != nil {
            self.databaseType = dict["DatabaseType"] as! String
        }
        if dict.keys.contains("FullPlan") && dict["FullPlan"] != nil {
            self.fullPlanShrink = dict["FullPlan"] as! String
        }
        if dict.keys.contains("IncPlan") && dict["IncPlan"] != nil {
            self.incPlanShrink = dict["IncPlan"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PolicyName") && dict["PolicyName"] != nil {
            self.policyName = dict["PolicyName"] as! String
        }
        if dict.keys.contains("Retention") && dict["Retention"] != nil {
            self.retention = dict["Retention"] as! Int32
        }
        if dict.keys.contains("SpeedLimiter") && dict["SpeedLimiter"] != nil {
            self.speedLimiter = dict["SpeedLimiter"] as! Int64
        }
        if dict.keys.contains("UniRegionId") && dict["UniRegionId"] != nil {
            self.uniRegionId = dict["UniRegionId"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class CreateUniBackupPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateUniBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUniBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateUniBackupPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUniRestorePlanRequest : Tea.TeaModel {
    public var database: String?

    public var instanceUuid: String?

    public var policyId: Int64?

    public var resetScn: String?

    public var resetTime: String?

    public var restoreInfo: String?

    public var timePoint: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.database != nil {
            map["Database"] = self.database!
        }
        if self.instanceUuid != nil {
            map["InstanceUuid"] = self.instanceUuid!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.resetScn != nil {
            map["ResetScn"] = self.resetScn!
        }
        if self.resetTime != nil {
            map["ResetTime"] = self.resetTime!
        }
        if self.restoreInfo != nil {
            map["RestoreInfo"] = self.restoreInfo!
        }
        if self.timePoint != nil {
            map["TimePoint"] = self.timePoint!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Database") && dict["Database"] != nil {
            self.database = dict["Database"] as! String
        }
        if dict.keys.contains("InstanceUuid") && dict["InstanceUuid"] != nil {
            self.instanceUuid = dict["InstanceUuid"] as! String
        }
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! Int64
        }
        if dict.keys.contains("ResetScn") && dict["ResetScn"] != nil {
            self.resetScn = dict["ResetScn"] as! String
        }
        if dict.keys.contains("ResetTime") && dict["ResetTime"] != nil {
            self.resetTime = dict["ResetTime"] as! String
        }
        if dict.keys.contains("RestoreInfo") && dict["RestoreInfo"] != nil {
            self.restoreInfo = dict["RestoreInfo"] as! String
        }
        if dict.keys.contains("TimePoint") && dict["TimePoint"] != nil {
            self.timePoint = dict["TimePoint"] as! Int64
        }
    }
}

public class CreateUniRestorePlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateUniRestorePlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUniRestorePlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateUniRestorePlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVulAutoRepairConfigRequest : Tea.TeaModel {
    public class VulAutoRepairConfigList : Tea.TeaModel {
        public var aliasName: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                self.aliasName = dict["AliasName"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var reason: String?

    public var type: String?

    public var vulAutoRepairConfigList: [CreateVulAutoRepairConfigRequest.VulAutoRepairConfigList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.vulAutoRepairConfigList != nil {
            var tmp : [Any] = []
            for k in self.vulAutoRepairConfigList! {
                tmp.append(k.toMap())
            }
            map["VulAutoRepairConfigList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VulAutoRepairConfigList") && dict["VulAutoRepairConfigList"] != nil {
            var tmp : [CreateVulAutoRepairConfigRequest.VulAutoRepairConfigList] = []
            for v in dict["VulAutoRepairConfigList"] as! [Any] {
                var model = CreateVulAutoRepairConfigRequest.VulAutoRepairConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vulAutoRepairConfigList = tmp
        }
    }
}

public class CreateVulAutoRepairConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateVulAutoRepairConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVulAutoRepairConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateVulAutoRepairConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAntiBruteForceRuleRequest : Tea.TeaModel {
    public var ids: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! [Int64]
        }
    }
}

public class DeleteAntiBruteForceRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAntiBruteForceRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAntiBruteForceRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAntiBruteForceRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBackupPolicyRequest : Tea.TeaModel {
    public var id: Int64?

    public var policyVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.policyVersion != nil {
            map["PolicyVersion"] = self.policyVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
            self.policyVersion = dict["PolicyVersion"] as! String
        }
    }
}

public class DeleteBackupPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBackupPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBackupPolicyMachineRequest : Tea.TeaModel {
    public var policyId: Int64?

    public var policyVersion: String?

    public var uuid: String?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.policyVersion != nil {
            map["PolicyVersion"] = self.policyVersion!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! Int64
        }
        if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
            self.policyVersion = dict["PolicyVersion"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class DeleteBackupPolicyMachineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBackupPolicyMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBackupPolicyMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBackupPolicyMachineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBinarySecurityPolicyRequest : Tea.TeaModel {
    public var name: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DeleteBinarySecurityPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBinarySecurityPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBinarySecurityPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBinarySecurityPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteClientUserDefineRuleRequest : Tea.TeaModel {
    public var idList: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.idList != nil {
            map["IdList"] = self.idList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IdList") && dict["IdList"] != nil {
            self.idList = dict["IdList"] as! [Int64]
        }
    }
}

public class DeleteClientUserDefineRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteClientUserDefineRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteClientUserDefineRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteClientUserDefineRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomBlockRecordRequest : Tea.TeaModel {
    public var id: Int64?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteCustomBlockRecordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomBlockRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomBlockRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCustomBlockRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCycleTaskRequest : Tea.TeaModel {
    public var configId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigId") && dict["ConfigId"] != nil {
            self.configId = dict["ConfigId"] as! String
        }
    }
}

public class DeleteCycleTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCycleTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCycleTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCycleTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFileProtectRuleRequest : Tea.TeaModel {
    public var id: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! [Int64]
        }
    }
}

public class DeleteFileProtectRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteFileProtectRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFileProtectRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteFileProtectRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGroupRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DeleteGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHoneypotRequest : Tea.TeaModel {
    public var honeypotId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeypotId != nil {
            map["HoneypotId"] = self.honeypotId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneypotId") && dict["HoneypotId"] != nil {
            self.honeypotId = dict["HoneypotId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteHoneypotResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteHoneypotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHoneypotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteHoneypotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHoneypotNodeRequest : Tea.TeaModel {
    public var lang: String?

    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class DeleteHoneypotNodeResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteHoneypotNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHoneypotNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteHoneypotNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHoneypotPresetRequest : Tea.TeaModel {
    public var honeypotPresetId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeypotPresetId != nil {
            map["HoneypotPresetId"] = self.honeypotPresetId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneypotPresetId") && dict["HoneypotPresetId"] != nil {
            self.honeypotPresetId = dict["HoneypotPresetId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteHoneypotPresetResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteHoneypotPresetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHoneypotPresetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteHoneypotPresetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHoneypotProbeRequest : Tea.TeaModel {
    public var lang: String?

    public var probeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.probeId != nil {
            map["ProbeId"] = self.probeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ProbeId") && dict["ProbeId"] != nil {
            self.probeId = dict["ProbeId"] as! String
        }
    }
}

public class DeleteHoneypotProbeResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteHoneypotProbeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHoneypotProbeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteHoneypotProbeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHoneypotProbeBindRequest : Tea.TeaModel {
    public var bindId: String?

    public var lang: String?

    public var probeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bindId != nil {
            map["BindId"] = self.bindId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.probeId != nil {
            map["ProbeId"] = self.probeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BindId") && dict["BindId"] != nil {
            self.bindId = dict["BindId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ProbeId") && dict["ProbeId"] != nil {
            self.probeId = dict["ProbeId"] as! String
        }
    }
}

public class DeleteHoneypotProbeBindResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteHoneypotProbeBindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHoneypotProbeBindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteHoneypotProbeBindResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteImageVulWhitelistRequest : Tea.TeaModel {
    public var ids: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DeleteImageVulWhitelistResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteImageVulWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImageVulWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteImageVulWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstallCodeRequest : Tea.TeaModel {
    public var captchaCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.captchaCode != nil {
            map["CaptchaCode"] = self.captchaCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CaptchaCode") && dict["CaptchaCode"] != nil {
            self.captchaCode = dict["CaptchaCode"] as! String
        }
    }
}

public class DeleteInstallCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteInstallCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstallCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteInstallCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInterceptionRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var ruleIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.ruleIds != nil {
            map["RuleIds"] = self.ruleIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RuleIds") && dict["RuleIds"] != nil {
            self.ruleIds = dict["RuleIds"] as! [Int64]
        }
    }
}

public class DeleteInterceptionRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteInterceptionRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInterceptionRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteInterceptionRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInterceptionTargetRequest : Tea.TeaModel {
    public var targetIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.targetIds != nil {
            map["TargetIds"] = self.targetIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TargetIds") && dict["TargetIds"] != nil {
            self.targetIds = dict["TargetIds"] as! String
        }
    }
}

public class DeleteInterceptionTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteInterceptionTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInterceptionTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteInterceptionTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLoginBaseConfigRequest : Tea.TeaModel {
    public var config: String?

    public var target: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DeleteLoginBaseConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLoginBaseConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLoginBaseConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteLoginBaseConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMaliciousNoteRequest : Tea.TeaModel {
    public var noteId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.noteId != nil {
            map["NoteId"] = self.noteId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NoteId") && dict["NoteId"] != nil {
            self.noteId = dict["NoteId"] as! Int64
        }
    }
}

public class DeleteMaliciousNoteResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMaliciousNoteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMaliciousNoteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteMaliciousNoteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrivateRegistryRequest : Tea.TeaModel {
    public var registryId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.registryId != nil {
            map["RegistryId"] = self.registryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegistryId") && dict["RegistryId"] != nil {
            self.registryId = dict["RegistryId"] as! Int64
        }
    }
}

public class DeletePrivateRegistryResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePrivateRegistryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrivateRegistryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeletePrivateRegistryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSecurityEventMarkMissListRequest : Tea.TeaModel {
    public var ids: [Int64]?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! [Int64]
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteSecurityEventMarkMissListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSecurityEventMarkMissListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecurityEventMarkMissListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSecurityEventMarkMissListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteServiceTrailRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteServiceTrailResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteServiceTrailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteServiceTrailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteServiceTrailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteStrategyRequest : Tea.TeaModel {
    public var id: String?

    public var lang: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DeleteStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSuspEventNodeRequest : Tea.TeaModel {
    public var noteId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.noteId != nil {
            map["NoteId"] = self.noteId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NoteId") && dict["NoteId"] != nil {
            self.noteId = dict["NoteId"] as! Int64
        }
    }
}

public class DeleteSuspEventNodeResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteSuspEventNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSuspEventNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSuspEventNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTagWithUuidRequest : Tea.TeaModel {
    public var tagName: String?

    public var uuidList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tagName != nil {
            map["TagName"] = self.tagName!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TagName") && dict["TagName"] != nil {
            self.tagName = dict["TagName"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! String
        }
    }
}

public class DeleteTagWithUuidResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTagWithUuidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTagWithUuidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteTagWithUuidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteUniBackupPolicyRequest : Tea.TeaModel {
    public var policyId: Int64?

    public var policyIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.policyIds != nil {
            map["PolicyIds"] = self.policyIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! Int64
        }
        if dict.keys.contains("PolicyIds") && dict["PolicyIds"] != nil {
            self.policyIds = dict["PolicyIds"] as! String
        }
    }
}

public class DeleteUniBackupPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteUniBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUniBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteUniBackupPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVpcHoneyPotRequest : Tea.TeaModel {
    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DeleteVpcHoneyPotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVpcHoneyPotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpcHoneyPotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteVpcHoneyPotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVulWhitelistRequest : Tea.TeaModel {
    public var id: String?

    public var whitelist: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.whitelist != nil {
            map["Whitelist"] = self.whitelist!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Whitelist") && dict["Whitelist"] != nil {
            self.whitelist = dict["Whitelist"] as! String
        }
    }
}

public class DeleteVulWhitelistResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVulWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVulWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteVulWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccessKeyLeakDetailRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DescribeAccessKeyLeakDetailResponseBody : Tea.TeaModel {
    public var accesskeyId: String?

    public var asset: String?

    public var code: String?

    public var dealTime: String?

    public var dealType: String?

    public var githubFileName: String?

    public var githubFileType: String?

    public var githubFileUpdateTime: String?

    public var githubFileUrl: String?

    public var githubRepoName: String?

    public var githubRepoUrl: String?

    public var githubUser: String?

    public var githubUserPicUrl: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var remark: String?

    public var requestId: String?

    public var source: String?

    public var tokenValid: Int32?

    public var type: String?

    public var whitelistStatus: String?

    public var whitelistTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accesskeyId != nil {
            map["AccesskeyId"] = self.accesskeyId!
        }
        if self.asset != nil {
            map["Asset"] = self.asset!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.dealTime != nil {
            map["DealTime"] = self.dealTime!
        }
        if self.dealType != nil {
            map["DealType"] = self.dealType!
        }
        if self.githubFileName != nil {
            map["GithubFileName"] = self.githubFileName!
        }
        if self.githubFileType != nil {
            map["GithubFileType"] = self.githubFileType!
        }
        if self.githubFileUpdateTime != nil {
            map["GithubFileUpdateTime"] = self.githubFileUpdateTime!
        }
        if self.githubFileUrl != nil {
            map["GithubFileUrl"] = self.githubFileUrl!
        }
        if self.githubRepoName != nil {
            map["GithubRepoName"] = self.githubRepoName!
        }
        if self.githubRepoUrl != nil {
            map["GithubRepoUrl"] = self.githubRepoUrl!
        }
        if self.githubUser != nil {
            map["GithubUser"] = self.githubUser!
        }
        if self.githubUserPicUrl != nil {
            map["GithubUserPicUrl"] = self.githubUserPicUrl!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.tokenValid != nil {
            map["TokenValid"] = self.tokenValid!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.whitelistStatus != nil {
            map["WhitelistStatus"] = self.whitelistStatus!
        }
        if self.whitelistTime != nil {
            map["WhitelistTime"] = self.whitelistTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccesskeyId") && dict["AccesskeyId"] != nil {
            self.accesskeyId = dict["AccesskeyId"] as! String
        }
        if dict.keys.contains("Asset") && dict["Asset"] != nil {
            self.asset = dict["Asset"] as! String
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DealTime") && dict["DealTime"] != nil {
            self.dealTime = dict["DealTime"] as! String
        }
        if dict.keys.contains("DealType") && dict["DealType"] != nil {
            self.dealType = dict["DealType"] as! String
        }
        if dict.keys.contains("GithubFileName") && dict["GithubFileName"] != nil {
            self.githubFileName = dict["GithubFileName"] as! String
        }
        if dict.keys.contains("GithubFileType") && dict["GithubFileType"] != nil {
            self.githubFileType = dict["GithubFileType"] as! String
        }
        if dict.keys.contains("GithubFileUpdateTime") && dict["GithubFileUpdateTime"] != nil {
            self.githubFileUpdateTime = dict["GithubFileUpdateTime"] as! String
        }
        if dict.keys.contains("GithubFileUrl") && dict["GithubFileUrl"] != nil {
            self.githubFileUrl = dict["GithubFileUrl"] as! String
        }
        if dict.keys.contains("GithubRepoName") && dict["GithubRepoName"] != nil {
            self.githubRepoName = dict["GithubRepoName"] as! String
        }
        if dict.keys.contains("GithubRepoUrl") && dict["GithubRepoUrl"] != nil {
            self.githubRepoUrl = dict["GithubRepoUrl"] as! String
        }
        if dict.keys.contains("GithubUser") && dict["GithubUser"] != nil {
            self.githubUser = dict["GithubUser"] as! String
        }
        if dict.keys.contains("GithubUserPicUrl") && dict["GithubUserPicUrl"] != nil {
            self.githubUserPicUrl = dict["GithubUserPicUrl"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! String
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TokenValid") && dict["TokenValid"] != nil {
            self.tokenValid = dict["TokenValid"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("WhitelistStatus") && dict["WhitelistStatus"] != nil {
            self.whitelistStatus = dict["WhitelistStatus"] as! String
        }
        if dict.keys.contains("WhitelistTime") && dict["WhitelistTime"] != nil {
            self.whitelistTime = dict["WhitelistTime"] as! Int64
        }
    }
}

public class DescribeAccessKeyLeakDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccessKeyLeakDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAccessKeyLeakDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccesskeyLeakListRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var query: String?

    public var startTs: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.query != nil {
            map["Query"] = self.query!
        }
        if self.startTs != nil {
            map["StartTs"] = self.startTs!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Query") && dict["Query"] != nil {
            self.query = dict["Query"] as! String
        }
        if dict.keys.contains("StartTs") && dict["StartTs"] != nil {
            self.startTs = dict["StartTs"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeAccesskeyLeakListResponseBody : Tea.TeaModel {
    public class AccessKeyLeakList : Tea.TeaModel {
        public var accesskeyId: String?

        public var aliUserName: String?

        public var asset: String?

        public var dealTime: String?

        public var dealType: String?

        public var gmtModified: Int64?

        public var id: Int64?

        public var status: String?

        public var type: String?

        public var url: String?

        public var userType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accesskeyId != nil {
                map["AccesskeyId"] = self.accesskeyId!
            }
            if self.aliUserName != nil {
                map["AliUserName"] = self.aliUserName!
            }
            if self.asset != nil {
                map["Asset"] = self.asset!
            }
            if self.dealTime != nil {
                map["DealTime"] = self.dealTime!
            }
            if self.dealType != nil {
                map["DealType"] = self.dealType!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            if self.userType != nil {
                map["UserType"] = self.userType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccesskeyId") && dict["AccesskeyId"] != nil {
                self.accesskeyId = dict["AccesskeyId"] as! String
            }
            if dict.keys.contains("AliUserName") && dict["AliUserName"] != nil {
                self.aliUserName = dict["AliUserName"] as! String
            }
            if dict.keys.contains("Asset") && dict["Asset"] != nil {
                self.asset = dict["Asset"] as! String
            }
            if dict.keys.contains("DealTime") && dict["DealTime"] != nil {
                self.dealTime = dict["DealTime"] as! String
            }
            if dict.keys.contains("DealType") && dict["DealType"] != nil {
                self.dealType = dict["DealType"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
            if dict.keys.contains("UserType") && dict["UserType"] != nil {
                self.userType = dict["UserType"] as! String
            }
        }
    }
    public var accessKeyLeakList: [DescribeAccesskeyLeakListResponseBody.AccessKeyLeakList]?

    public var akLeakCount: Int32?

    public var currentPage: Int32?

    public var gmtLast: Int64?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessKeyLeakList != nil {
            var tmp : [Any] = []
            for k in self.accessKeyLeakList! {
                tmp.append(k.toMap())
            }
            map["AccessKeyLeakList"] = tmp
        }
        if self.akLeakCount != nil {
            map["AkLeakCount"] = self.akLeakCount!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.gmtLast != nil {
            map["GmtLast"] = self.gmtLast!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessKeyLeakList") && dict["AccessKeyLeakList"] != nil {
            var tmp : [DescribeAccesskeyLeakListResponseBody.AccessKeyLeakList] = []
            for v in dict["AccessKeyLeakList"] as! [Any] {
                var model = DescribeAccesskeyLeakListResponseBody.AccessKeyLeakList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.accessKeyLeakList = tmp
        }
        if dict.keys.contains("AkLeakCount") && dict["AkLeakCount"] != nil {
            self.akLeakCount = dict["AkLeakCount"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("GmtLast") && dict["GmtLast"] != nil {
            self.gmtLast = dict["GmtLast"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAccesskeyLeakListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccesskeyLeakListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAccesskeyLeakListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAffectedAssetsRequest : Tea.TeaModel {
    public var current: String?

    public var levels: String?

    public var pageSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["Current"] = self.current!
        }
        if self.levels != nil {
            map["Levels"] = self.levels!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Current") && dict["Current"] != nil {
            self.current = dict["Current"] as! String
        }
        if dict.keys.contains("Levels") && dict["Levels"] != nil {
            self.levels = dict["Levels"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
    }
}

public class DescribeAffectedAssetsResponseBody : Tea.TeaModel {
    public class AssetList : Tea.TeaModel {
        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var riskNum: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.riskNum != nil {
                map["RiskNum"] = self.riskNum!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("RiskNum") && dict["RiskNum"] != nil {
                self.riskNum = dict["RiskNum"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var assetList: [DescribeAffectedAssetsResponseBody.AssetList]?

    public var pageInfo: DescribeAffectedAssetsResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetList != nil {
            var tmp : [Any] = []
            for k in self.assetList! {
                tmp.append(k.toMap())
            }
            map["AssetList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetList") && dict["AssetList"] != nil {
            var tmp : [DescribeAffectedAssetsResponseBody.AssetList] = []
            for v in dict["AssetList"] as! [Any] {
                var model = DescribeAffectedAssetsResponseBody.AssetList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.assetList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeAffectedAssetsResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAffectedAssetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAffectedAssetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAffectedAssetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAffectedMaliciousFileImagesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterName: String?

    public var containerId: String?

    public var currentPage: Int32?

    public var image: String?

    public var imageDigest: String?

    public var imageLayer: String?

    public var imageTag: String?

    public var lang: String?

    public var levels: String?

    public var maliciousMd5: String?

    public var namespace: String?

    public var pageSize: String?

    public var pod: String?

    public var repoId: String?

    public var repoInstanceId: String?

    public var repoName: String?

    public var repoNamespace: String?

    public var repoRegionId: String?

    public var scanRange: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.image != nil {
            map["Image"] = self.image!
        }
        if self.imageDigest != nil {
            map["ImageDigest"] = self.imageDigest!
        }
        if self.imageLayer != nil {
            map["ImageLayer"] = self.imageLayer!
        }
        if self.imageTag != nil {
            map["ImageTag"] = self.imageTag!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.levels != nil {
            map["Levels"] = self.levels!
        }
        if self.maliciousMd5 != nil {
            map["MaliciousMd5"] = self.maliciousMd5!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pod != nil {
            map["Pod"] = self.pod!
        }
        if self.repoId != nil {
            map["RepoId"] = self.repoId!
        }
        if self.repoInstanceId != nil {
            map["RepoInstanceId"] = self.repoInstanceId!
        }
        if self.repoName != nil {
            map["RepoName"] = self.repoName!
        }
        if self.repoNamespace != nil {
            map["RepoNamespace"] = self.repoNamespace!
        }
        if self.repoRegionId != nil {
            map["RepoRegionId"] = self.repoRegionId!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
            self.containerId = dict["ContainerId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Image") && dict["Image"] != nil {
            self.image = dict["Image"] as! String
        }
        if dict.keys.contains("ImageDigest") && dict["ImageDigest"] != nil {
            self.imageDigest = dict["ImageDigest"] as! String
        }
        if dict.keys.contains("ImageLayer") && dict["ImageLayer"] != nil {
            self.imageLayer = dict["ImageLayer"] as! String
        }
        if dict.keys.contains("ImageTag") && dict["ImageTag"] != nil {
            self.imageTag = dict["ImageTag"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Levels") && dict["Levels"] != nil {
            self.levels = dict["Levels"] as! String
        }
        if dict.keys.contains("MaliciousMd5") && dict["MaliciousMd5"] != nil {
            self.maliciousMd5 = dict["MaliciousMd5"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Pod") && dict["Pod"] != nil {
            self.pod = dict["Pod"] as! String
        }
        if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
            self.repoId = dict["RepoId"] as! String
        }
        if dict.keys.contains("RepoInstanceId") && dict["RepoInstanceId"] != nil {
            self.repoInstanceId = dict["RepoInstanceId"] as! String
        }
        if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
            self.repoName = dict["RepoName"] as! String
        }
        if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
            self.repoNamespace = dict["RepoNamespace"] as! String
        }
        if dict.keys.contains("RepoRegionId") && dict["RepoRegionId"] != nil {
            self.repoRegionId = dict["RepoRegionId"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
    }
}

public class DescribeAffectedMaliciousFileImagesResponseBody : Tea.TeaModel {
    public class AffectedMaliciousFileImagesResponse : Tea.TeaModel {
        public var clusterId: String?

        public var clusterName: String?

        public var containerId: String?

        public var digest: String?

        public var downloadUrl: String?

        public var filePath: String?

        public var firstScanTimestamp: Int64?

        public var highLight: String?

        public var image: String?

        public var imageUuid: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var latestScanTimestamp: Int64?

        public var latestVerifyTimestamp: Int64?

        public var layer: String?

        public var level: String?

        public var maliciousMd5: String?

        public var namespace: String?

        public var pod: String?

        public var repoId: String?

        public var repoInstanceId: String?

        public var repoName: String?

        public var repoRegionId: String?

        public var status: Int32?

        public var tag: String?

        public var targetId: String?

        public var targetName: String?

        public var targetType: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.containerId != nil {
                map["ContainerId"] = self.containerId!
            }
            if self.digest != nil {
                map["Digest"] = self.digest!
            }
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.firstScanTimestamp != nil {
                map["FirstScanTimestamp"] = self.firstScanTimestamp!
            }
            if self.highLight != nil {
                map["HighLight"] = self.highLight!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imageUuid != nil {
                map["ImageUuid"] = self.imageUuid!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.latestScanTimestamp != nil {
                map["LatestScanTimestamp"] = self.latestScanTimestamp!
            }
            if self.latestVerifyTimestamp != nil {
                map["LatestVerifyTimestamp"] = self.latestVerifyTimestamp!
            }
            if self.layer != nil {
                map["Layer"] = self.layer!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.maliciousMd5 != nil {
                map["MaliciousMd5"] = self.maliciousMd5!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.pod != nil {
                map["Pod"] = self.pod!
            }
            if self.repoId != nil {
                map["RepoId"] = self.repoId!
            }
            if self.repoInstanceId != nil {
                map["RepoInstanceId"] = self.repoInstanceId!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoRegionId != nil {
                map["RepoRegionId"] = self.repoRegionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                self.containerId = dict["ContainerId"] as! String
            }
            if dict.keys.contains("Digest") && dict["Digest"] != nil {
                self.digest = dict["Digest"] as! String
            }
            if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                self.downloadUrl = dict["DownloadUrl"] as! String
            }
            if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("FirstScanTimestamp") && dict["FirstScanTimestamp"] != nil {
                self.firstScanTimestamp = dict["FirstScanTimestamp"] as! Int64
            }
            if dict.keys.contains("HighLight") && dict["HighLight"] != nil {
                self.highLight = dict["HighLight"] as! String
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
                self.imageUuid = dict["ImageUuid"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LatestScanTimestamp") && dict["LatestScanTimestamp"] != nil {
                self.latestScanTimestamp = dict["LatestScanTimestamp"] as! Int64
            }
            if dict.keys.contains("LatestVerifyTimestamp") && dict["LatestVerifyTimestamp"] != nil {
                self.latestVerifyTimestamp = dict["LatestVerifyTimestamp"] as! Int64
            }
            if dict.keys.contains("Layer") && dict["Layer"] != nil {
                self.layer = dict["Layer"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("MaliciousMd5") && dict["MaliciousMd5"] != nil {
                self.maliciousMd5 = dict["MaliciousMd5"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Pod") && dict["Pod"] != nil {
                self.pod = dict["Pod"] as! String
            }
            if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
                self.repoId = dict["RepoId"] as! String
            }
            if dict.keys.contains("RepoInstanceId") && dict["RepoInstanceId"] != nil {
                self.repoInstanceId = dict["RepoInstanceId"] as! String
            }
            if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoRegionId") && dict["RepoRegionId"] != nil {
                self.repoRegionId = dict["RepoRegionId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! String
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var affectedMaliciousFileImagesResponse: [DescribeAffectedMaliciousFileImagesResponseBody.AffectedMaliciousFileImagesResponse]?

    public var pageInfo: DescribeAffectedMaliciousFileImagesResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.affectedMaliciousFileImagesResponse != nil {
            var tmp : [Any] = []
            for k in self.affectedMaliciousFileImagesResponse! {
                tmp.append(k.toMap())
            }
            map["AffectedMaliciousFileImagesResponse"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AffectedMaliciousFileImagesResponse") && dict["AffectedMaliciousFileImagesResponse"] != nil {
            var tmp : [DescribeAffectedMaliciousFileImagesResponseBody.AffectedMaliciousFileImagesResponse] = []
            for v in dict["AffectedMaliciousFileImagesResponse"] as! [Any] {
                var model = DescribeAffectedMaliciousFileImagesResponseBody.AffectedMaliciousFileImagesResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.affectedMaliciousFileImagesResponse = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeAffectedMaliciousFileImagesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAffectedMaliciousFileImagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAffectedMaliciousFileImagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAffectedMaliciousFileImagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAgentInstallStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeAgentInstallStatusResponseBody : Tea.TeaModel {
    public class AegisClientInvokeStatusResponseList : Tea.TeaModel {
        public var message: String?

        public var resuleCode: String?

        public var result: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.resuleCode != nil {
                map["ResuleCode"] = self.resuleCode!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("ResuleCode") && dict["ResuleCode"] != nil {
                self.resuleCode = dict["ResuleCode"] as! String
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var aegisClientInvokeStatusResponseList: [DescribeAgentInstallStatusResponseBody.AegisClientInvokeStatusResponseList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aegisClientInvokeStatusResponseList != nil {
            var tmp : [Any] = []
            for k in self.aegisClientInvokeStatusResponseList! {
                tmp.append(k.toMap())
            }
            map["AegisClientInvokeStatusResponseList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AegisClientInvokeStatusResponseList") && dict["AegisClientInvokeStatusResponseList"] != nil {
            var tmp : [DescribeAgentInstallStatusResponseBody.AegisClientInvokeStatusResponseList] = []
            for v in dict["AegisClientInvokeStatusResponseList"] as! [Any] {
                var model = DescribeAgentInstallStatusResponseBody.AegisClientInvokeStatusResponseList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aegisClientInvokeStatusResponseList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAgentInstallStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAgentInstallStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAgentInstallStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAlarmEventDetailRequest : Tea.TeaModel {
    public var alarmUniqueInfo: String?

    public var from: String?

    public var lang: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmUniqueInfo != nil {
            map["AlarmUniqueInfo"] = self.alarmUniqueInfo!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmUniqueInfo") && dict["AlarmUniqueInfo"] != nil {
            self.alarmUniqueInfo = dict["AlarmUniqueInfo"] as! String
        }
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeAlarmEventDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CauseDetails : Tea.TeaModel {
            public class Value : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var key: String?

            public var value: [DescribeAlarmEventDetailResponseBody.Data.CauseDetails.Value]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    var tmp : [Any] = []
                    for k in self.value! {
                        tmp.append(k.toMap())
                    }
                    map["Value"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    var tmp : [DescribeAlarmEventDetailResponseBody.Data.CauseDetails.Value] = []
                    for v in dict["Value"] as! [Any] {
                        var model = DescribeAlarmEventDetailResponseBody.Data.CauseDetails.Value()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.value = tmp
                }
            }
        }
        public var alarmEventAliasName: String?

        public var alarmEventDesc: String?

        public var alarmUniqueInfo: String?

        public var appName: String?

        public var canBeDealOnLine: Bool?

        public var canCancelFault: Bool?

        public var causeDetails: [DescribeAlarmEventDetailResponseBody.Data.CauseDetails]?

        public var containHwMode: Bool?

        public var containerId: String?

        public var containerImageId: String?

        public var containerImageName: String?

        public var dataSource: String?

        public var endTime: Int64?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var k8sClusterId: String?

        public var k8sClusterName: String?

        public var k8sNamespace: String?

        public var k8sNodeId: String?

        public var k8sNodeName: String?

        public var k8sPodName: String?

        public var level: String?

        public var solution: String?

        public var startTime: Int64?

        public var type: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmEventAliasName != nil {
                map["AlarmEventAliasName"] = self.alarmEventAliasName!
            }
            if self.alarmEventDesc != nil {
                map["AlarmEventDesc"] = self.alarmEventDesc!
            }
            if self.alarmUniqueInfo != nil {
                map["AlarmUniqueInfo"] = self.alarmUniqueInfo!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.canBeDealOnLine != nil {
                map["CanBeDealOnLine"] = self.canBeDealOnLine!
            }
            if self.canCancelFault != nil {
                map["CanCancelFault"] = self.canCancelFault!
            }
            if self.causeDetails != nil {
                var tmp : [Any] = []
                for k in self.causeDetails! {
                    tmp.append(k.toMap())
                }
                map["CauseDetails"] = tmp
            }
            if self.containHwMode != nil {
                map["ContainHwMode"] = self.containHwMode!
            }
            if self.containerId != nil {
                map["ContainerId"] = self.containerId!
            }
            if self.containerImageId != nil {
                map["ContainerImageId"] = self.containerImageId!
            }
            if self.containerImageName != nil {
                map["ContainerImageName"] = self.containerImageName!
            }
            if self.dataSource != nil {
                map["DataSource"] = self.dataSource!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.k8sClusterId != nil {
                map["K8sClusterId"] = self.k8sClusterId!
            }
            if self.k8sClusterName != nil {
                map["K8sClusterName"] = self.k8sClusterName!
            }
            if self.k8sNamespace != nil {
                map["K8sNamespace"] = self.k8sNamespace!
            }
            if self.k8sNodeId != nil {
                map["K8sNodeId"] = self.k8sNodeId!
            }
            if self.k8sNodeName != nil {
                map["K8sNodeName"] = self.k8sNodeName!
            }
            if self.k8sPodName != nil {
                map["K8sPodName"] = self.k8sPodName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.solution != nil {
                map["Solution"] = self.solution!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmEventAliasName") && dict["AlarmEventAliasName"] != nil {
                self.alarmEventAliasName = dict["AlarmEventAliasName"] as! String
            }
            if dict.keys.contains("AlarmEventDesc") && dict["AlarmEventDesc"] != nil {
                self.alarmEventDesc = dict["AlarmEventDesc"] as! String
            }
            if dict.keys.contains("AlarmUniqueInfo") && dict["AlarmUniqueInfo"] != nil {
                self.alarmUniqueInfo = dict["AlarmUniqueInfo"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CanBeDealOnLine") && dict["CanBeDealOnLine"] != nil {
                self.canBeDealOnLine = dict["CanBeDealOnLine"] as! Bool
            }
            if dict.keys.contains("CanCancelFault") && dict["CanCancelFault"] != nil {
                self.canCancelFault = dict["CanCancelFault"] as! Bool
            }
            if dict.keys.contains("CauseDetails") && dict["CauseDetails"] != nil {
                var tmp : [DescribeAlarmEventDetailResponseBody.Data.CauseDetails] = []
                for v in dict["CauseDetails"] as! [Any] {
                    var model = DescribeAlarmEventDetailResponseBody.Data.CauseDetails()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.causeDetails = tmp
            }
            if dict.keys.contains("ContainHwMode") && dict["ContainHwMode"] != nil {
                self.containHwMode = dict["ContainHwMode"] as! Bool
            }
            if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                self.containerId = dict["ContainerId"] as! String
            }
            if dict.keys.contains("ContainerImageId") && dict["ContainerImageId"] != nil {
                self.containerImageId = dict["ContainerImageId"] as! String
            }
            if dict.keys.contains("ContainerImageName") && dict["ContainerImageName"] != nil {
                self.containerImageName = dict["ContainerImageName"] as! String
            }
            if dict.keys.contains("DataSource") && dict["DataSource"] != nil {
                self.dataSource = dict["DataSource"] as! String
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("K8sClusterId") && dict["K8sClusterId"] != nil {
                self.k8sClusterId = dict["K8sClusterId"] as! String
            }
            if dict.keys.contains("K8sClusterName") && dict["K8sClusterName"] != nil {
                self.k8sClusterName = dict["K8sClusterName"] as! String
            }
            if dict.keys.contains("K8sNamespace") && dict["K8sNamespace"] != nil {
                self.k8sNamespace = dict["K8sNamespace"] as! String
            }
            if dict.keys.contains("K8sNodeId") && dict["K8sNodeId"] != nil {
                self.k8sNodeId = dict["K8sNodeId"] as! String
            }
            if dict.keys.contains("K8sNodeName") && dict["K8sNodeName"] != nil {
                self.k8sNodeName = dict["K8sNodeName"] as! String
            }
            if dict.keys.contains("K8sPodName") && dict["K8sPodName"] != nil {
                self.k8sPodName = dict["K8sPodName"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Solution") && dict["Solution"] != nil {
                self.solution = dict["Solution"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var data: DescribeAlarmEventDetailResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeAlarmEventDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAlarmEventDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlarmEventDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAlarmEventDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAlarmEventStackInfoRequest : Tea.TeaModel {
    public var eventName: String?

    public var lang: String?

    public var resourceDirectoryAccountId: Int64?

    public var sourceIp: String?

    public var uniqueInfo: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventName != nil {
            map["EventName"] = self.eventName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uniqueInfo != nil {
            map["UniqueInfo"] = self.uniqueInfo!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventName") && dict["EventName"] != nil {
            self.eventName = dict["EventName"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("UniqueInfo") && dict["UniqueInfo"] != nil {
            self.uniqueInfo = dict["UniqueInfo"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeAlarmEventStackInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var stackInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.stackInfo != nil {
            map["StackInfo"] = self.stackInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StackInfo") && dict["StackInfo"] != nil {
            self.stackInfo = dict["StackInfo"] as! String
        }
    }
}

public class DescribeAlarmEventStackInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAlarmEventStackInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAlarmEventStackInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAllEntityResponseBody : Tea.TeaModel {
    public class EntityList : Tea.TeaModel {
        public var groupId: Int32?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var os: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int32
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var entityList: [DescribeAllEntityResponseBody.EntityList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entityList != nil {
            var tmp : [Any] = []
            for k in self.entityList! {
                tmp.append(k.toMap())
            }
            map["EntityList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EntityList") && dict["EntityList"] != nil {
            var tmp : [DescribeAllEntityResponseBody.EntityList] = []
            for v in dict["EntityList"] as! [Any] {
                var model = DescribeAllEntityResponseBody.EntityList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.entityList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAllEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAllEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAllEntityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAllGroupsRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeAllGroupsResponseBody : Tea.TeaModel {
    public class Groups : Tea.TeaModel {
        public var groupFlag: Int32?

        public var groupId: Int32?

        public var groupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupFlag != nil {
                map["GroupFlag"] = self.groupFlag!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupFlag") && dict["GroupFlag"] != nil {
                self.groupFlag = dict["GroupFlag"] as! Int32
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int32
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
        }
    }
    public var count: Int32?

    public var groups: [DescribeAllGroupsResponseBody.Groups]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.groups != nil {
            var tmp : [Any] = []
            for k in self.groups! {
                tmp.append(k.toMap())
            }
            map["Groups"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Groups") && dict["Groups"] != nil {
            var tmp : [DescribeAllGroupsResponseBody.Groups] = []
            for v in dict["Groups"] as! [Any] {
                var model = DescribeAllGroupsResponseBody.Groups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groups = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAllGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAllGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAllGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAllImageBaselineRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeAllImageBaselineResponseBody : Tea.TeaModel {
    public class ImageBaselines : Tea.TeaModel {
        public class BaselineClassList : Tea.TeaModel {
            public class BaselineNameList : Tea.TeaModel {
                public class BaselineItemList : Tea.TeaModel {
                    public var alias: String?

                    public var classKey: String?

                    public var itemKey: String?

                    public var nameKey: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.alias != nil {
                            map["Alias"] = self.alias!
                        }
                        if self.classKey != nil {
                            map["ClassKey"] = self.classKey!
                        }
                        if self.itemKey != nil {
                            map["ItemKey"] = self.itemKey!
                        }
                        if self.nameKey != nil {
                            map["NameKey"] = self.nameKey!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Alias") && dict["Alias"] != nil {
                            self.alias = dict["Alias"] as! String
                        }
                        if dict.keys.contains("ClassKey") && dict["ClassKey"] != nil {
                            self.classKey = dict["ClassKey"] as! String
                        }
                        if dict.keys.contains("ItemKey") && dict["ItemKey"] != nil {
                            self.itemKey = dict["ItemKey"] as! String
                        }
                        if dict.keys.contains("NameKey") && dict["NameKey"] != nil {
                            self.nameKey = dict["NameKey"] as! String
                        }
                    }
                }
                public var alias: String?

                public var baselineItemList: [DescribeAllImageBaselineResponseBody.ImageBaselines.BaselineClassList.BaselineNameList.BaselineItemList]?

                public var classKey: String?

                public var nameKey: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alias != nil {
                        map["Alias"] = self.alias!
                    }
                    if self.baselineItemList != nil {
                        var tmp : [Any] = []
                        for k in self.baselineItemList! {
                            tmp.append(k.toMap())
                        }
                        map["BaselineItemList"] = tmp
                    }
                    if self.classKey != nil {
                        map["ClassKey"] = self.classKey!
                    }
                    if self.nameKey != nil {
                        map["NameKey"] = self.nameKey!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Alias") && dict["Alias"] != nil {
                        self.alias = dict["Alias"] as! String
                    }
                    if dict.keys.contains("BaselineItemList") && dict["BaselineItemList"] != nil {
                        var tmp : [DescribeAllImageBaselineResponseBody.ImageBaselines.BaselineClassList.BaselineNameList.BaselineItemList] = []
                        for v in dict["BaselineItemList"] as! [Any] {
                            var model = DescribeAllImageBaselineResponseBody.ImageBaselines.BaselineClassList.BaselineNameList.BaselineItemList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.baselineItemList = tmp
                    }
                    if dict.keys.contains("ClassKey") && dict["ClassKey"] != nil {
                        self.classKey = dict["ClassKey"] as! String
                    }
                    if dict.keys.contains("NameKey") && dict["NameKey"] != nil {
                        self.nameKey = dict["NameKey"] as! String
                    }
                }
            }
            public var alias: String?

            public var baselineNameList: [DescribeAllImageBaselineResponseBody.ImageBaselines.BaselineClassList.BaselineNameList]?

            public var classKey: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.baselineNameList != nil {
                    var tmp : [Any] = []
                    for k in self.baselineNameList! {
                        tmp.append(k.toMap())
                    }
                    map["BaselineNameList"] = tmp
                }
                if self.classKey != nil {
                    map["ClassKey"] = self.classKey!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("BaselineNameList") && dict["BaselineNameList"] != nil {
                    var tmp : [DescribeAllImageBaselineResponseBody.ImageBaselines.BaselineClassList.BaselineNameList] = []
                    for v in dict["BaselineNameList"] as! [Any] {
                        var model = DescribeAllImageBaselineResponseBody.ImageBaselines.BaselineClassList.BaselineNameList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.baselineNameList = tmp
                }
                if dict.keys.contains("ClassKey") && dict["ClassKey"] != nil {
                    self.classKey = dict["ClassKey"] as! String
                }
            }
        }
        public var baselineClassList: [DescribeAllImageBaselineResponseBody.ImageBaselines.BaselineClassList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineClassList != nil {
                var tmp : [Any] = []
                for k in self.baselineClassList! {
                    tmp.append(k.toMap())
                }
                map["BaselineClassList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineClassList") && dict["BaselineClassList"] != nil {
                var tmp : [DescribeAllImageBaselineResponseBody.ImageBaselines.BaselineClassList] = []
                for v in dict["BaselineClassList"] as! [Any] {
                    var model = DescribeAllImageBaselineResponseBody.ImageBaselines.BaselineClassList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.baselineClassList = tmp
            }
        }
    }
    public var imageBaselines: DescribeAllImageBaselineResponseBody.ImageBaselines?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageBaselines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageBaselines != nil {
            map["ImageBaselines"] = self.imageBaselines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageBaselines") && dict["ImageBaselines"] != nil {
            var model = DescribeAllImageBaselineResponseBody.ImageBaselines()
            model.fromMap(dict["ImageBaselines"] as! [String: Any])
            self.imageBaselines = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAllImageBaselineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAllImageBaselineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAllImageBaselineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntiBruteForceRulesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var id: Int64?

    public var name: String?

    public var pageSize: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeAntiBruteForceRulesResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class Rules : Tea.TeaModel {
        public var createTimestamp: Int64?

        public var defaultRule: Bool?

        public var enableSmartRule: Bool?

        public var failCount: Int32?

        public var forbiddenTime: Int32?

        public var id: Int64?

        public var machineCount: Int32?

        public var name: String?

        public var span: Int32?

        public var uuidList: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.defaultRule != nil {
                map["DefaultRule"] = self.defaultRule!
            }
            if self.enableSmartRule != nil {
                map["EnableSmartRule"] = self.enableSmartRule!
            }
            if self.failCount != nil {
                map["FailCount"] = self.failCount!
            }
            if self.forbiddenTime != nil {
                map["ForbiddenTime"] = self.forbiddenTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.machineCount != nil {
                map["MachineCount"] = self.machineCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.span != nil {
                map["Span"] = self.span!
            }
            if self.uuidList != nil {
                map["UuidList"] = self.uuidList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimestamp") && dict["CreateTimestamp"] != nil {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("DefaultRule") && dict["DefaultRule"] != nil {
                self.defaultRule = dict["DefaultRule"] as! Bool
            }
            if dict.keys.contains("EnableSmartRule") && dict["EnableSmartRule"] != nil {
                self.enableSmartRule = dict["EnableSmartRule"] as! Bool
            }
            if dict.keys.contains("FailCount") && dict["FailCount"] != nil {
                self.failCount = dict["FailCount"] as! Int32
            }
            if dict.keys.contains("ForbiddenTime") && dict["ForbiddenTime"] != nil {
                self.forbiddenTime = dict["ForbiddenTime"] as! Int32
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("MachineCount") && dict["MachineCount"] != nil {
                self.machineCount = dict["MachineCount"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Span") && dict["Span"] != nil {
                self.span = dict["Span"] as! Int32
            }
            if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
                self.uuidList = dict["UuidList"] as! [String]
            }
        }
    }
    public var pageInfo: DescribeAntiBruteForceRulesResponseBody.PageInfo?

    public var requestId: String?

    public var rules: [DescribeAntiBruteForceRulesResponseBody.Rules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rules != nil {
            var tmp : [Any] = []
            for k in self.rules! {
                tmp.append(k.toMap())
            }
            map["Rules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeAntiBruteForceRulesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Rules") && dict["Rules"] != nil {
            var tmp : [DescribeAntiBruteForceRulesResponseBody.Rules] = []
            for v in dict["Rules"] as! [Any] {
                var model = DescribeAntiBruteForceRulesResponseBody.Rules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.rules = tmp
        }
    }
}

public class DescribeAntiBruteForceRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntiBruteForceRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAntiBruteForceRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppVulScanCycleResponseBody : Tea.TeaModel {
    public var cycle: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cycle != nil {
            map["Cycle"] = self.cycle!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cycle") && dict["Cycle"] != nil {
            self.cycle = dict["Cycle"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAppVulScanCycleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppVulScanCycleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAppVulScanCycleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAssetDetailByUuidRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeAssetDetailByUuidResponseBody : Tea.TeaModel {
    public class AssetDetail : Tea.TeaModel {
        public var assetType: String?

        public var authModifyTime: Int64?

        public var authVersion: Int32?

        public var bind: Bool?

        public var clientStatus: String?

        public var clientVersion: String?

        public var cpu: Int32?

        public var cpuInfo: String?

        public var createTime: Int64?

        public var diskInfoList: [String]?

        public var flag: Int32?

        public var groupTrace: String?

        public var hostName: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var ipList: [String]?

        public var kernel: String?

        public var macList: [String]?

        public var mem: Int32?

        public var memory: Int64?

        public var os: String?

        public var osDetail: String?

        public var osName: String?

        public var region: String?

        public var regionId: String?

        public var regionName: String?

        public var sysInfo: String?

        public var tag: String?

        public var uuid: String?

        public var vpcInstanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assetType != nil {
                map["AssetType"] = self.assetType!
            }
            if self.authModifyTime != nil {
                map["AuthModifyTime"] = self.authModifyTime!
            }
            if self.authVersion != nil {
                map["AuthVersion"] = self.authVersion!
            }
            if self.bind != nil {
                map["Bind"] = self.bind!
            }
            if self.clientStatus != nil {
                map["ClientStatus"] = self.clientStatus!
            }
            if self.clientVersion != nil {
                map["ClientVersion"] = self.clientVersion!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.cpuInfo != nil {
                map["CpuInfo"] = self.cpuInfo!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.diskInfoList != nil {
                map["DiskInfoList"] = self.diskInfoList!
            }
            if self.flag != nil {
                map["Flag"] = self.flag!
            }
            if self.groupTrace != nil {
                map["GroupTrace"] = self.groupTrace!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.ipList != nil {
                map["IpList"] = self.ipList!
            }
            if self.kernel != nil {
                map["Kernel"] = self.kernel!
            }
            if self.macList != nil {
                map["MacList"] = self.macList!
            }
            if self.mem != nil {
                map["Mem"] = self.mem!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.osDetail != nil {
                map["OsDetail"] = self.osDetail!
            }
            if self.osName != nil {
                map["OsName"] = self.osName!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.sysInfo != nil {
                map["SysInfo"] = self.sysInfo!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vpcInstanceId != nil {
                map["VpcInstanceId"] = self.vpcInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
                self.assetType = dict["AssetType"] as! String
            }
            if dict.keys.contains("AuthModifyTime") && dict["AuthModifyTime"] != nil {
                self.authModifyTime = dict["AuthModifyTime"] as! Int64
            }
            if dict.keys.contains("AuthVersion") && dict["AuthVersion"] != nil {
                self.authVersion = dict["AuthVersion"] as! Int32
            }
            if dict.keys.contains("Bind") && dict["Bind"] != nil {
                self.bind = dict["Bind"] as! Bool
            }
            if dict.keys.contains("ClientStatus") && dict["ClientStatus"] != nil {
                self.clientStatus = dict["ClientStatus"] as! String
            }
            if dict.keys.contains("ClientVersion") && dict["ClientVersion"] != nil {
                self.clientVersion = dict["ClientVersion"] as! String
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CpuInfo") && dict["CpuInfo"] != nil {
                self.cpuInfo = dict["CpuInfo"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("DiskInfoList") && dict["DiskInfoList"] != nil {
                self.diskInfoList = dict["DiskInfoList"] as! [String]
            }
            if dict.keys.contains("Flag") && dict["Flag"] != nil {
                self.flag = dict["Flag"] as! Int32
            }
            if dict.keys.contains("GroupTrace") && dict["GroupTrace"] != nil {
                self.groupTrace = dict["GroupTrace"] as! String
            }
            if dict.keys.contains("HostName") && dict["HostName"] != nil {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("IpList") && dict["IpList"] != nil {
                self.ipList = dict["IpList"] as! [String]
            }
            if dict.keys.contains("Kernel") && dict["Kernel"] != nil {
                self.kernel = dict["Kernel"] as! String
            }
            if dict.keys.contains("MacList") && dict["MacList"] != nil {
                self.macList = dict["MacList"] as! [String]
            }
            if dict.keys.contains("Mem") && dict["Mem"] != nil {
                self.mem = dict["Mem"] as! Int32
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Int64
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("OsDetail") && dict["OsDetail"] != nil {
                self.osDetail = dict["OsDetail"] as! String
            }
            if dict.keys.contains("OsName") && dict["OsName"] != nil {
                self.osName = dict["OsName"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                self.regionName = dict["RegionName"] as! String
            }
            if dict.keys.contains("SysInfo") && dict["SysInfo"] != nil {
                self.sysInfo = dict["SysInfo"] as! String
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VpcInstanceId") && dict["VpcInstanceId"] != nil {
                self.vpcInstanceId = dict["VpcInstanceId"] as! String
            }
        }
    }
    public var assetDetail: DescribeAssetDetailByUuidResponseBody.AssetDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.assetDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetDetail != nil {
            map["AssetDetail"] = self.assetDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetDetail") && dict["AssetDetail"] != nil {
            var model = DescribeAssetDetailByUuidResponseBody.AssetDetail()
            model.fromMap(dict["AssetDetail"] as! [String: Any])
            self.assetDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAssetDetailByUuidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAssetDetailByUuidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAssetDetailByUuidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAssetDetailByUuidsRequest : Tea.TeaModel {
    public var lang: String?

    public var resourceDirectoryAccountId: Int64?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! Int64
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeAssetDetailByUuidsResponseBody : Tea.TeaModel {
    public class AssetList : Tea.TeaModel {
        public var assetType: String?

        public var clientStatus: String?

        public var flag: Int32?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var os: String?

        public var osName: String?

        public var region: String?

        public var regionId: String?

        public var regionName: String?

        public var uuid: String?

        public var vpcInstanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assetType != nil {
                map["AssetType"] = self.assetType!
            }
            if self.clientStatus != nil {
                map["ClientStatus"] = self.clientStatus!
            }
            if self.flag != nil {
                map["Flag"] = self.flag!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.osName != nil {
                map["OsName"] = self.osName!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vpcInstanceId != nil {
                map["VpcInstanceId"] = self.vpcInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
                self.assetType = dict["AssetType"] as! String
            }
            if dict.keys.contains("ClientStatus") && dict["ClientStatus"] != nil {
                self.clientStatus = dict["ClientStatus"] as! String
            }
            if dict.keys.contains("Flag") && dict["Flag"] != nil {
                self.flag = dict["Flag"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("OsName") && dict["OsName"] != nil {
                self.osName = dict["OsName"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                self.regionName = dict["RegionName"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VpcInstanceId") && dict["VpcInstanceId"] != nil {
                self.vpcInstanceId = dict["VpcInstanceId"] as! String
            }
        }
    }
    public var assetList: [DescribeAssetDetailByUuidsResponseBody.AssetList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetList != nil {
            var tmp : [Any] = []
            for k in self.assetList! {
                tmp.append(k.toMap())
            }
            map["AssetList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetList") && dict["AssetList"] != nil {
            var tmp : [DescribeAssetDetailByUuidsResponseBody.AssetList] = []
            for v in dict["AssetList"] as! [Any] {
                var model = DescribeAssetDetailByUuidsResponseBody.AssetList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.assetList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAssetDetailByUuidsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAssetDetailByUuidsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAssetDetailByUuidsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAssetSummaryResponseBody : Tea.TeaModel {
    public class AssetsSummary : Tea.TeaModel {
        public var totalAssetAllRegion: Int32?

        public var totalCoreAllRegion: Int32?

        public var totalCoreNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.totalAssetAllRegion != nil {
                map["TotalAssetAllRegion"] = self.totalAssetAllRegion!
            }
            if self.totalCoreAllRegion != nil {
                map["TotalCoreAllRegion"] = self.totalCoreAllRegion!
            }
            if self.totalCoreNum != nil {
                map["TotalCoreNum"] = self.totalCoreNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TotalAssetAllRegion") && dict["TotalAssetAllRegion"] != nil {
                self.totalAssetAllRegion = dict["TotalAssetAllRegion"] as! Int32
            }
            if dict.keys.contains("TotalCoreAllRegion") && dict["TotalCoreAllRegion"] != nil {
                self.totalCoreAllRegion = dict["TotalCoreAllRegion"] as! Int32
            }
            if dict.keys.contains("TotalCoreNum") && dict["TotalCoreNum"] != nil {
                self.totalCoreNum = dict["TotalCoreNum"] as! Int32
            }
        }
    }
    public var assetsSummary: DescribeAssetSummaryResponseBody.AssetsSummary?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.assetsSummary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetsSummary != nil {
            map["AssetsSummary"] = self.assetsSummary?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetsSummary") && dict["AssetsSummary"] != nil {
            var model = DescribeAssetSummaryResponseBody.AssetsSummary()
            model.fromMap(dict["AssetsSummary"] as! [String: Any])
            self.assetsSummary = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAssetSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAssetSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAssetSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAssetsSecurityEventSummaryRequest : Tea.TeaModel {
    public var clusterId: String?

    public var containerFieldName: String?

    public var containerFieldValue: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.containerFieldName != nil {
            map["ContainerFieldName"] = self.containerFieldName!
        }
        if self.containerFieldValue != nil {
            map["ContainerFieldValue"] = self.containerFieldValue!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ContainerFieldName") && dict["ContainerFieldName"] != nil {
            self.containerFieldName = dict["ContainerFieldName"] as! String
        }
        if dict.keys.contains("ContainerFieldValue") && dict["ContainerFieldValue"] != nil {
            self.containerFieldValue = dict["ContainerFieldValue"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeAssetsSecurityEventSummaryResponseBody : Tea.TeaModel {
    public class Assets : Tea.TeaModel {
        public var assetType: String?

        public var riskCount: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assetType != nil {
                map["AssetType"] = self.assetType!
            }
            if self.riskCount != nil {
                map["RiskCount"] = self.riskCount!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
                self.assetType = dict["AssetType"] as! String
            }
            if dict.keys.contains("RiskCount") && dict["RiskCount"] != nil {
                self.riskCount = dict["RiskCount"] as! Int64
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var assets: [DescribeAssetsSecurityEventSummaryResponseBody.Assets]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assets != nil {
            var tmp : [Any] = []
            for k in self.assets! {
                tmp.append(k.toMap())
            }
            map["Assets"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Assets") && dict["Assets"] != nil {
            var tmp : [DescribeAssetsSecurityEventSummaryResponseBody.Assets] = []
            for v in dict["Assets"] as! [Any] {
                var model = DescribeAssetsSecurityEventSummaryResponseBody.Assets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.assets = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAssetsSecurityEventSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAssetsSecurityEventSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAssetsSecurityEventSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAttachRecordsRequest : Tea.TeaModel {
    public var applicationId: String?

    public var ecsUUIDList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.ecsUUIDList != nil {
            map["EcsUUIDList"] = self.ecsUUIDList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationId") && dict["ApplicationId"] != nil {
            self.applicationId = dict["ApplicationId"] as! String
        }
        if dict.keys.contains("EcsUUIDList") && dict["EcsUUIDList"] != nil {
            self.ecsUUIDList = dict["EcsUUIDList"] as! [String]
        }
    }
}

public class DescribeAttachRecordsResponseBody : Tea.TeaModel {
    public class AccessList : Tea.TeaModel {
        public var attachState: Int64?

        public var attachSwitch: String?

        public var ecsUUID: String?

        public var installMsg: String?

        public var installState: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachState != nil {
                map["AttachState"] = self.attachState!
            }
            if self.attachSwitch != nil {
                map["AttachSwitch"] = self.attachSwitch!
            }
            if self.ecsUUID != nil {
                map["EcsUUID"] = self.ecsUUID!
            }
            if self.installMsg != nil {
                map["InstallMsg"] = self.installMsg!
            }
            if self.installState != nil {
                map["InstallState"] = self.installState!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachState") && dict["AttachState"] != nil {
                self.attachState = dict["AttachState"] as! Int64
            }
            if dict.keys.contains("AttachSwitch") && dict["AttachSwitch"] != nil {
                self.attachSwitch = dict["AttachSwitch"] as! String
            }
            if dict.keys.contains("EcsUUID") && dict["EcsUUID"] != nil {
                self.ecsUUID = dict["EcsUUID"] as! String
            }
            if dict.keys.contains("InstallMsg") && dict["InstallMsg"] != nil {
                self.installMsg = dict["InstallMsg"] as! String
            }
            if dict.keys.contains("InstallState") && dict["InstallState"] != nil {
                self.installState = dict["InstallState"] as! Int64
            }
        }
    }
    public var accessList: [DescribeAttachRecordsResponseBody.AccessList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessList != nil {
            var tmp : [Any] = []
            for k in self.accessList! {
                tmp.append(k.toMap())
            }
            map["AccessList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessList") && dict["AccessList"] != nil {
            var tmp : [DescribeAttachRecordsResponseBody.AccessList] = []
            for v in dict["AccessList"] as! [Any] {
                var model = DescribeAttachRecordsResponseBody.AccessList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.accessList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAttachRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAttachRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAttachRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAttackAnalysisDataRequest : Tea.TeaModel {
    public var base64: String?

    public var currentPage: Int32?

    public var data: String?

    public var endTime: Int64?

    public var lang: String?

    public var pageSize: Int32?

    public var startTime: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.base64 != nil {
            map["Base64"] = self.base64!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Base64") && dict["Base64"] != nil {
            self.base64 = dict["Base64"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeAttackAnalysisDataResponseBody : Tea.TeaModel {
    public var data: String?

    public var page: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Page") && dict["Page"] != nil {
            self.page = dict["Page"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeAttackAnalysisDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAttackAnalysisDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAttackAnalysisDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAutoDelConfigResponseBody : Tea.TeaModel {
    public var days: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.days != nil {
            map["Days"] = self.days!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Days") && dict["Days"] != nil {
            self.days = dict["Days"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAutoDelConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoDelConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAutoDelConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackUpExportInfoRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var exportType: String?

    public var lang: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.exportType != nil {
            map["ExportType"] = self.exportType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ExportType") && dict["ExportType"] != nil {
            self.exportType = dict["ExportType"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeBackUpExportInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var currentCount: Int32?

        public var fileName: String?

        public var gmtCreate: Int64?

        public var id: Int64?

        public var link: String?

        public var message: String?

        public var progress: Int32?

        public var status: String?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentCount != nil {
                map["CurrentCount"] = self.currentCount!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.link != nil {
                map["Link"] = self.link!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentCount") && dict["CurrentCount"] != nil {
                self.currentCount = dict["CurrentCount"] as! Int32
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Link") && dict["Link"] != nil {
                self.link = dict["Link"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Progress") && dict["Progress"] != nil {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: [DescribeBackUpExportInfoResponseBody.Data]?

    public var pageInfo: DescribeBackUpExportInfoResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeBackUpExportInfoResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeBackUpExportInfoResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeBackUpExportInfoResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBackUpExportInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackUpExportInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBackUpExportInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackupClientsRequest : Tea.TeaModel {
    public var supportRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.supportRegionId != nil {
            map["SupportRegionId"] = self.supportRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SupportRegionId") && dict["SupportRegionId"] != nil {
            self.supportRegionId = dict["SupportRegionId"] as! String
        }
    }
}

public class DescribeBackupClientsResponseBody : Tea.TeaModel {
    public class Clients : Tea.TeaModel {
        public var clientId: String?

        public var clientStatus: String?

        public var clientVersion: String?

        public var instanceId: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.clientStatus != nil {
                map["ClientStatus"] = self.clientStatus!
            }
            if self.clientVersion != nil {
                map["ClientVersion"] = self.clientVersion!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientId") && dict["ClientId"] != nil {
                self.clientId = dict["ClientId"] as! String
            }
            if dict.keys.contains("ClientStatus") && dict["ClientStatus"] != nil {
                self.clientStatus = dict["ClientStatus"] as! String
            }
            if dict.keys.contains("ClientVersion") && dict["ClientVersion"] != nil {
                self.clientVersion = dict["ClientVersion"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var clients: [DescribeBackupClientsResponseBody.Clients]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clients != nil {
            var tmp : [Any] = []
            for k in self.clients! {
                tmp.append(k.toMap())
            }
            map["Clients"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clients") && dict["Clients"] != nil {
            var tmp : [DescribeBackupClientsResponseBody.Clients] = []
            for v in dict["Clients"] as! [Any] {
                var model = DescribeBackupClientsResponseBody.Clients()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.clients = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBackupClientsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupClientsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBackupClientsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackupFilesRequest : Tea.TeaModel {
    public var currentPage: String?

    public var pageSize: String?

    public var path: String?

    public var snapshotHash: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.snapshotHash != nil {
            map["SnapshotHash"] = self.snapshotHash!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("SnapshotHash") && dict["SnapshotHash"] != nil {
            self.snapshotHash = dict["SnapshotHash"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeBackupFilesResponseBody : Tea.TeaModel {
    public class BackupFiles : Tea.TeaModel {
        public var name: String?

        public var size: Int64?

        public var subtree: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.subtree != nil {
                map["Subtree"] = self.subtree!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("Subtree") && dict["Subtree"] != nil {
                self.subtree = dict["Subtree"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var backupFiles: [DescribeBackupFilesResponseBody.BackupFiles]?

    public var pageInfo: DescribeBackupFilesResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupFiles != nil {
            var tmp : [Any] = []
            for k in self.backupFiles! {
                tmp.append(k.toMap())
            }
            map["BackupFiles"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackupFiles") && dict["BackupFiles"] != nil {
            var tmp : [DescribeBackupFilesResponseBody.BackupFiles] = []
            for v in dict["BackupFiles"] as! [Any] {
                var model = DescribeBackupFilesResponseBody.BackupFiles()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backupFiles = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeBackupFilesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBackupFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBackupFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackupMachineStatusRequest : Tea.TeaModel {
    public var policyId: Int64?

    public var policyVersion: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.policyVersion != nil {
            map["PolicyVersion"] = self.policyVersion!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! Int64
        }
        if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
            self.policyVersion = dict["PolicyVersion"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeBackupMachineStatusResponseBody : Tea.TeaModel {
    public class BackupMachineStatus : Tea.TeaModel {
        public class ErrorList : Tea.TeaModel {
            public var errorCode: String?

            public var errorStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorStatus != nil {
                    map["ErrorStatus"] = self.errorStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorStatus") && dict["ErrorStatus"] != nil {
                    self.errorStatus = dict["ErrorStatus"] as! String
                }
            }
        }
        public var clientId: String?

        public var clientStatus: String?

        public var clientVersion: String?

        public var errorCode: String?

        public var errorList: [DescribeBackupMachineStatusResponseBody.BackupMachineStatus.ErrorList]?

        public var instanceId: String?

        public var regionId: String?

        public var savedBackupCount: Int32?

        public var status: String?

        public var uuid: String?

        public var vaultId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.clientStatus != nil {
                map["ClientStatus"] = self.clientStatus!
            }
            if self.clientVersion != nil {
                map["ClientVersion"] = self.clientVersion!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorList != nil {
                var tmp : [Any] = []
                for k in self.errorList! {
                    tmp.append(k.toMap())
                }
                map["ErrorList"] = tmp
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.savedBackupCount != nil {
                map["SavedBackupCount"] = self.savedBackupCount!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vaultId != nil {
                map["VaultId"] = self.vaultId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientId") && dict["ClientId"] != nil {
                self.clientId = dict["ClientId"] as! String
            }
            if dict.keys.contains("ClientStatus") && dict["ClientStatus"] != nil {
                self.clientStatus = dict["ClientStatus"] as! String
            }
            if dict.keys.contains("ClientVersion") && dict["ClientVersion"] != nil {
                self.clientVersion = dict["ClientVersion"] as! String
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorList") && dict["ErrorList"] != nil {
                var tmp : [DescribeBackupMachineStatusResponseBody.BackupMachineStatus.ErrorList] = []
                for v in dict["ErrorList"] as! [Any] {
                    var model = DescribeBackupMachineStatusResponseBody.BackupMachineStatus.ErrorList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.errorList = tmp
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("SavedBackupCount") && dict["SavedBackupCount"] != nil {
                self.savedBackupCount = dict["SavedBackupCount"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VaultId") && dict["VaultId"] != nil {
                self.vaultId = dict["VaultId"] as! String
            }
        }
    }
    public var backupMachineStatus: DescribeBackupMachineStatusResponseBody.BackupMachineStatus?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backupMachineStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupMachineStatus != nil {
            map["BackupMachineStatus"] = self.backupMachineStatus?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackupMachineStatus") && dict["BackupMachineStatus"] != nil {
            var model = DescribeBackupMachineStatusResponseBody.BackupMachineStatus()
            model.fromMap(dict["BackupMachineStatus"] as! [String: Any])
            self.backupMachineStatus = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBackupMachineStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupMachineStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBackupMachineStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackupPoliciesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var machineRemark: String?

    public var name: String?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.machineRemark != nil {
            map["MachineRemark"] = self.machineRemark!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("MachineRemark") && dict["MachineRemark"] != nil {
            self.machineRemark = dict["MachineRemark"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeBackupPoliciesResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class Policies : Tea.TeaModel {
        public var clientErrorCount: Int32?

        public var clientErrorUuidList: [String]?

        public var clientStatus: String?

        public var healthClientCount: Int32?

        public var healthClientUuidList: [String]?

        public var id: Int64?

        public var name: String?

        public var policy: String?

        public var policyRegionId: String?

        public var policyVersion: String?

        public var remarkedUuidList: [String]?

        public var serverType: String?

        public var serviceErrorCount: Int32?

        public var serviceErrorUuidList: [String]?

        public var status: String?

        public var upgradeStatus: String?

        public var uuidList: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientErrorCount != nil {
                map["ClientErrorCount"] = self.clientErrorCount!
            }
            if self.clientErrorUuidList != nil {
                map["ClientErrorUuidList"] = self.clientErrorUuidList!
            }
            if self.clientStatus != nil {
                map["ClientStatus"] = self.clientStatus!
            }
            if self.healthClientCount != nil {
                map["HealthClientCount"] = self.healthClientCount!
            }
            if self.healthClientUuidList != nil {
                map["HealthClientUuidList"] = self.healthClientUuidList!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.policyRegionId != nil {
                map["PolicyRegionId"] = self.policyRegionId!
            }
            if self.policyVersion != nil {
                map["PolicyVersion"] = self.policyVersion!
            }
            if self.remarkedUuidList != nil {
                map["RemarkedUuidList"] = self.remarkedUuidList!
            }
            if self.serverType != nil {
                map["ServerType"] = self.serverType!
            }
            if self.serviceErrorCount != nil {
                map["ServiceErrorCount"] = self.serviceErrorCount!
            }
            if self.serviceErrorUuidList != nil {
                map["ServiceErrorUuidList"] = self.serviceErrorUuidList!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.upgradeStatus != nil {
                map["UpgradeStatus"] = self.upgradeStatus!
            }
            if self.uuidList != nil {
                map["UuidList"] = self.uuidList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientErrorCount") && dict["ClientErrorCount"] != nil {
                self.clientErrorCount = dict["ClientErrorCount"] as! Int32
            }
            if dict.keys.contains("ClientErrorUuidList") && dict["ClientErrorUuidList"] != nil {
                self.clientErrorUuidList = dict["ClientErrorUuidList"] as! [String]
            }
            if dict.keys.contains("ClientStatus") && dict["ClientStatus"] != nil {
                self.clientStatus = dict["ClientStatus"] as! String
            }
            if dict.keys.contains("HealthClientCount") && dict["HealthClientCount"] != nil {
                self.healthClientCount = dict["HealthClientCount"] as! Int32
            }
            if dict.keys.contains("HealthClientUuidList") && dict["HealthClientUuidList"] != nil {
                self.healthClientUuidList = dict["HealthClientUuidList"] as! [String]
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Policy") && dict["Policy"] != nil {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PolicyRegionId") && dict["PolicyRegionId"] != nil {
                self.policyRegionId = dict["PolicyRegionId"] as! String
            }
            if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
                self.policyVersion = dict["PolicyVersion"] as! String
            }
            if dict.keys.contains("RemarkedUuidList") && dict["RemarkedUuidList"] != nil {
                self.remarkedUuidList = dict["RemarkedUuidList"] as! [String]
            }
            if dict.keys.contains("ServerType") && dict["ServerType"] != nil {
                self.serverType = dict["ServerType"] as! String
            }
            if dict.keys.contains("ServiceErrorCount") && dict["ServiceErrorCount"] != nil {
                self.serviceErrorCount = dict["ServiceErrorCount"] as! Int32
            }
            if dict.keys.contains("ServiceErrorUuidList") && dict["ServiceErrorUuidList"] != nil {
                self.serviceErrorUuidList = dict["ServiceErrorUuidList"] as! [String]
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UpgradeStatus") && dict["UpgradeStatus"] != nil {
                self.upgradeStatus = dict["UpgradeStatus"] as! String
            }
            if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
                self.uuidList = dict["UuidList"] as! [String]
            }
        }
    }
    public var pageInfo: DescribeBackupPoliciesResponseBody.PageInfo?

    public var policies: [DescribeBackupPoliciesResponseBody.Policies]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.policies != nil {
            var tmp : [Any] = []
            for k in self.policies! {
                tmp.append(k.toMap())
            }
            map["Policies"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeBackupPoliciesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("Policies") && dict["Policies"] != nil {
            var tmp : [DescribeBackupPoliciesResponseBody.Policies] = []
            for v in dict["Policies"] as! [Any] {
                var model = DescribeBackupPoliciesResponseBody.Policies()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.policies = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBackupPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBackupPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackupPolicyRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class DescribeBackupPolicyResponseBody : Tea.TeaModel {
    public class BackupPolicyDetail : Tea.TeaModel {
        public var clientStatus: String?

        public var id: Int64?

        public var name: String?

        public var policy: String?

        public var policyVersion: String?

        public var regionId: String?

        public var status: String?

        public var uuidList: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientStatus != nil {
                map["ClientStatus"] = self.clientStatus!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.policyVersion != nil {
                map["PolicyVersion"] = self.policyVersion!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuidList != nil {
                map["UuidList"] = self.uuidList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientStatus") && dict["ClientStatus"] != nil {
                self.clientStatus = dict["ClientStatus"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Policy") && dict["Policy"] != nil {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
                self.policyVersion = dict["PolicyVersion"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
                self.uuidList = dict["UuidList"] as! [String]
            }
        }
    }
    public var backupPolicyDetail: DescribeBackupPolicyResponseBody.BackupPolicyDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backupPolicyDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupPolicyDetail != nil {
            map["BackupPolicyDetail"] = self.backupPolicyDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackupPolicyDetail") && dict["BackupPolicyDetail"] != nil {
            var model = DescribeBackupPolicyResponseBody.BackupPolicyDetail()
            model.fromMap(dict["BackupPolicyDetail"] as! [String: Any])
            self.backupPolicyDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBackupPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackupRestoreCountResponseBody : Tea.TeaModel {
    public class BackupRestoreCount : Tea.TeaModel {
        public var recovering: Int32?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recovering != nil {
                map["Recovering"] = self.recovering!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Recovering") && dict["Recovering"] != nil {
                self.recovering = dict["Recovering"] as! Int32
            }
            if dict.keys.contains("Total") && dict["Total"] != nil {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var backupRestoreCount: DescribeBackupRestoreCountResponseBody.BackupRestoreCount?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backupRestoreCount?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupRestoreCount != nil {
            map["BackupRestoreCount"] = self.backupRestoreCount?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackupRestoreCount") && dict["BackupRestoreCount"] != nil {
            var model = DescribeBackupRestoreCountResponseBody.BackupRestoreCount()
            model.fromMap(dict["BackupRestoreCount"] as! [String: Any])
            self.backupRestoreCount = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBackupRestoreCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupRestoreCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBackupRestoreCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBruteForceRecordsRequest : Tea.TeaModel {
    public var blockIp: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resourceOwnerId: Int64?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockIp != nil {
            map["BlockIp"] = self.blockIp!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockIp") && dict["BlockIp"] != nil {
            self.blockIp = dict["BlockIp"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class DescribeBruteForceRecordsResponseBody : Tea.TeaModel {
    public class MachineList : Tea.TeaModel {
        public var aliNetOnline: Bool?

        public var blockExpireDate: Int64?

        public var blockIp: String?

        public var blockType: String?

        public var errorCode: String?

        public var id: Int64?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var port: String?

        public var ruleName: String?

        public var source: String?

        public var status: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliNetOnline != nil {
                map["AliNetOnline"] = self.aliNetOnline!
            }
            if self.blockExpireDate != nil {
                map["BlockExpireDate"] = self.blockExpireDate!
            }
            if self.blockIp != nil {
                map["BlockIp"] = self.blockIp!
            }
            if self.blockType != nil {
                map["BlockType"] = self.blockType!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliNetOnline") && dict["AliNetOnline"] != nil {
                self.aliNetOnline = dict["AliNetOnline"] as! Bool
            }
            if dict.keys.contains("BlockExpireDate") && dict["BlockExpireDate"] != nil {
                self.blockExpireDate = dict["BlockExpireDate"] as! Int64
            }
            if dict.keys.contains("BlockIp") && dict["BlockIp"] != nil {
                self.blockIp = dict["BlockIp"] as! String
            }
            if dict.keys.contains("BlockType") && dict["BlockType"] != nil {
                self.blockType = dict["BlockType"] as! String
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var machineList: [DescribeBruteForceRecordsResponseBody.MachineList]?

    public var pageInfo: DescribeBruteForceRecordsResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.machineList != nil {
            var tmp : [Any] = []
            for k in self.machineList! {
                tmp.append(k.toMap())
            }
            map["MachineList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MachineList") && dict["MachineList"] != nil {
            var tmp : [DescribeBruteForceRecordsResponseBody.MachineList] = []
            for v in dict["MachineList"] as! [Any] {
                var model = DescribeBruteForceRecordsResponseBody.MachineList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.machineList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeBruteForceRecordsResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBruteForceRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBruteForceRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBruteForceRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBruteForceSummaryRequest : Tea.TeaModel {
    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeBruteForceSummaryResponseBody : Tea.TeaModel {
    public class BruteForceSummary : Tea.TeaModel {
        public var allStrategyCount: Int32?

        public var antiBruteForceRuleCount: String?

        public var customEffectiveCount: String?

        public var customRecordCount: String?

        public var effectiveCount: Int32?

        public var systemEffectiveCount: String?

        public var systemRecordCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allStrategyCount != nil {
                map["AllStrategyCount"] = self.allStrategyCount!
            }
            if self.antiBruteForceRuleCount != nil {
                map["AntiBruteForceRuleCount"] = self.antiBruteForceRuleCount!
            }
            if self.customEffectiveCount != nil {
                map["CustomEffectiveCount"] = self.customEffectiveCount!
            }
            if self.customRecordCount != nil {
                map["CustomRecordCount"] = self.customRecordCount!
            }
            if self.effectiveCount != nil {
                map["EffectiveCount"] = self.effectiveCount!
            }
            if self.systemEffectiveCount != nil {
                map["SystemEffectiveCount"] = self.systemEffectiveCount!
            }
            if self.systemRecordCount != nil {
                map["SystemRecordCount"] = self.systemRecordCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllStrategyCount") && dict["AllStrategyCount"] != nil {
                self.allStrategyCount = dict["AllStrategyCount"] as! Int32
            }
            if dict.keys.contains("AntiBruteForceRuleCount") && dict["AntiBruteForceRuleCount"] != nil {
                self.antiBruteForceRuleCount = dict["AntiBruteForceRuleCount"] as! String
            }
            if dict.keys.contains("CustomEffectiveCount") && dict["CustomEffectiveCount"] != nil {
                self.customEffectiveCount = dict["CustomEffectiveCount"] as! String
            }
            if dict.keys.contains("CustomRecordCount") && dict["CustomRecordCount"] != nil {
                self.customRecordCount = dict["CustomRecordCount"] as! String
            }
            if dict.keys.contains("EffectiveCount") && dict["EffectiveCount"] != nil {
                self.effectiveCount = dict["EffectiveCount"] as! Int32
            }
            if dict.keys.contains("SystemEffectiveCount") && dict["SystemEffectiveCount"] != nil {
                self.systemEffectiveCount = dict["SystemEffectiveCount"] as! String
            }
            if dict.keys.contains("SystemRecordCount") && dict["SystemRecordCount"] != nil {
                self.systemRecordCount = dict["SystemRecordCount"] as! String
            }
        }
    }
    public var bruteForceSummary: DescribeBruteForceSummaryResponseBody.BruteForceSummary?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bruteForceSummary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bruteForceSummary != nil {
            map["BruteForceSummary"] = self.bruteForceSummary?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BruteForceSummary") && dict["BruteForceSummary"] != nil {
            var model = DescribeBruteForceSummaryResponseBody.BruteForceSummary()
            model.fromMap(dict["BruteForceSummary"] as! [String: Any])
            self.bruteForceSummary = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBruteForceSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBruteForceSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBruteForceSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCanFixVulListRequest : Tea.TeaModel {
    public var aliasName: String?

    public var clusterId: String?

    public var clusterName: String?

    public var containerId: String?

    public var currentPage: Int32?

    public var dealed: String?

    public var digest: String?

    public var image: String?

    public var instanceId: String?

    public var name: String?

    public var namespace: String?

    public var necessity: String?

    public var pageSize: Int32?

    public var pod: String?

    public var regionId: String?

    public var repoId: String?

    public var repoInstanceId: String?

    public var repoName: String?

    public var repoNamespace: String?

    public var repoRegionId: String?

    public var scanRange: [String]?

    public var statusList: String?

    public var tag: String?

    public var type: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliasName != nil {
            map["AliasName"] = self.aliasName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.digest != nil {
            map["Digest"] = self.digest!
        }
        if self.image != nil {
            map["Image"] = self.image!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.necessity != nil {
            map["Necessity"] = self.necessity!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pod != nil {
            map["Pod"] = self.pod!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repoId != nil {
            map["RepoId"] = self.repoId!
        }
        if self.repoInstanceId != nil {
            map["RepoInstanceId"] = self.repoInstanceId!
        }
        if self.repoName != nil {
            map["RepoName"] = self.repoName!
        }
        if self.repoNamespace != nil {
            map["RepoNamespace"] = self.repoNamespace!
        }
        if self.repoRegionId != nil {
            map["RepoRegionId"] = self.repoRegionId!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
            self.aliasName = dict["AliasName"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
            self.containerId = dict["ContainerId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("Digest") && dict["Digest"] != nil {
            self.digest = dict["Digest"] as! String
        }
        if dict.keys.contains("Image") && dict["Image"] != nil {
            self.image = dict["Image"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
            self.necessity = dict["Necessity"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Pod") && dict["Pod"] != nil {
            self.pod = dict["Pod"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
            self.repoId = dict["RepoId"] as! String
        }
        if dict.keys.contains("RepoInstanceId") && dict["RepoInstanceId"] != nil {
            self.repoInstanceId = dict["RepoInstanceId"] as! String
        }
        if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
            self.repoName = dict["RepoName"] as! String
        }
        if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
            self.repoNamespace = dict["RepoNamespace"] as! String
        }
        if dict.keys.contains("RepoRegionId") && dict["RepoRegionId"] != nil {
            self.repoRegionId = dict["RepoRegionId"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeCanFixVulListResponseBody : Tea.TeaModel {
    public class VulRecords : Tea.TeaModel {
        public class ExtendContentJson : Tea.TeaModel {
            public class RpmEntityList : Tea.TeaModel {
                public var fullVersion: String?

                public var layer: String?

                public var matchDetail: String?

                public var matchList: [String]?

                public var name: String?

                public var path: String?

                public var updateCmd: String?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fullVersion != nil {
                        map["FullVersion"] = self.fullVersion!
                    }
                    if self.layer != nil {
                        map["Layer"] = self.layer!
                    }
                    if self.matchDetail != nil {
                        map["MatchDetail"] = self.matchDetail!
                    }
                    if self.matchList != nil {
                        map["MatchList"] = self.matchList!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.updateCmd != nil {
                        map["UpdateCmd"] = self.updateCmd!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FullVersion") && dict["FullVersion"] != nil {
                        self.fullVersion = dict["FullVersion"] as! String
                    }
                    if dict.keys.contains("Layer") && dict["Layer"] != nil {
                        self.layer = dict["Layer"] as! String
                    }
                    if dict.keys.contains("MatchDetail") && dict["MatchDetail"] != nil {
                        self.matchDetail = dict["MatchDetail"] as! String
                    }
                    if dict.keys.contains("MatchList") && dict["MatchList"] != nil {
                        self.matchList = dict["MatchList"] as! [String]
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("UpdateCmd") && dict["UpdateCmd"] != nil {
                        self.updateCmd = dict["UpdateCmd"] as! String
                    }
                    if dict.keys.contains("Version") && dict["Version"] != nil {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public var os: String?

            public var osRelease: String?

            public var rpmEntityList: [DescribeCanFixVulListResponseBody.VulRecords.ExtendContentJson.RpmEntityList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.os != nil {
                    map["Os"] = self.os!
                }
                if self.osRelease != nil {
                    map["OsRelease"] = self.osRelease!
                }
                if self.rpmEntityList != nil {
                    var tmp : [Any] = []
                    for k in self.rpmEntityList! {
                        tmp.append(k.toMap())
                    }
                    map["RpmEntityList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Os") && dict["Os"] != nil {
                    self.os = dict["Os"] as! String
                }
                if dict.keys.contains("OsRelease") && dict["OsRelease"] != nil {
                    self.osRelease = dict["OsRelease"] as! String
                }
                if dict.keys.contains("RpmEntityList") && dict["RpmEntityList"] != nil {
                    var tmp : [DescribeCanFixVulListResponseBody.VulRecords.ExtendContentJson.RpmEntityList] = []
                    for v in dict["RpmEntityList"] as! [Any] {
                        var model = DescribeCanFixVulListResponseBody.VulRecords.ExtendContentJson.RpmEntityList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rpmEntityList = tmp
                }
            }
        }
        public var aliasName: String?

        public var canFix: String?

        public var canUpdate: Bool?

        public var clusterId: String?

        public var clusterName: String?

        public var containerId: String?

        public var extendContentJson: DescribeCanFixVulListResponseBody.VulRecords.ExtendContentJson?

        public var firstTs: Int64?

        public var image: String?

        public var imageDigest: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var lastTs: Int64?

        public var layers: [String]?

        public var maliciousSource: String?

        public var modifyTs: Int64?

        public var name: String?

        public var namespace: String?

        public var necessity: String?

        public var pod: String?

        public var primaryId: Int64?

        public var related: String?

        public var repoName: String?

        public var repoNamespace: String?

        public var scanTime: Int64?

        public var status: Int32?

        public var tag: String?

        public var targetId: String?

        public var targetName: String?

        public var targetType: String?

        public var type: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.extendContentJson?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.canFix != nil {
                map["CanFix"] = self.canFix!
            }
            if self.canUpdate != nil {
                map["CanUpdate"] = self.canUpdate!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.containerId != nil {
                map["ContainerId"] = self.containerId!
            }
            if self.extendContentJson != nil {
                map["ExtendContentJson"] = self.extendContentJson?.toMap()
            }
            if self.firstTs != nil {
                map["FirstTs"] = self.firstTs!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imageDigest != nil {
                map["ImageDigest"] = self.imageDigest!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.lastTs != nil {
                map["LastTs"] = self.lastTs!
            }
            if self.layers != nil {
                map["Layers"] = self.layers!
            }
            if self.maliciousSource != nil {
                map["MaliciousSource"] = self.maliciousSource!
            }
            if self.modifyTs != nil {
                map["ModifyTs"] = self.modifyTs!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.necessity != nil {
                map["Necessity"] = self.necessity!
            }
            if self.pod != nil {
                map["Pod"] = self.pod!
            }
            if self.primaryId != nil {
                map["PrimaryId"] = self.primaryId!
            }
            if self.related != nil {
                map["Related"] = self.related!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            if self.scanTime != nil {
                map["ScanTime"] = self.scanTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                self.aliasName = dict["AliasName"] as! String
            }
            if dict.keys.contains("CanFix") && dict["CanFix"] != nil {
                self.canFix = dict["CanFix"] as! String
            }
            if dict.keys.contains("CanUpdate") && dict["CanUpdate"] != nil {
                self.canUpdate = dict["CanUpdate"] as! Bool
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                self.containerId = dict["ContainerId"] as! String
            }
            if dict.keys.contains("ExtendContentJson") && dict["ExtendContentJson"] != nil {
                var model = DescribeCanFixVulListResponseBody.VulRecords.ExtendContentJson()
                model.fromMap(dict["ExtendContentJson"] as! [String: Any])
                self.extendContentJson = model
            }
            if dict.keys.contains("FirstTs") && dict["FirstTs"] != nil {
                self.firstTs = dict["FirstTs"] as! Int64
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImageDigest") && dict["ImageDigest"] != nil {
                self.imageDigest = dict["ImageDigest"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LastTs") && dict["LastTs"] != nil {
                self.lastTs = dict["LastTs"] as! Int64
            }
            if dict.keys.contains("Layers") && dict["Layers"] != nil {
                self.layers = dict["Layers"] as! [String]
            }
            if dict.keys.contains("MaliciousSource") && dict["MaliciousSource"] != nil {
                self.maliciousSource = dict["MaliciousSource"] as! String
            }
            if dict.keys.contains("ModifyTs") && dict["ModifyTs"] != nil {
                self.modifyTs = dict["ModifyTs"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
                self.necessity = dict["Necessity"] as! String
            }
            if dict.keys.contains("Pod") && dict["Pod"] != nil {
                self.pod = dict["Pod"] as! String
            }
            if dict.keys.contains("PrimaryId") && dict["PrimaryId"] != nil {
                self.primaryId = dict["PrimaryId"] as! Int64
            }
            if dict.keys.contains("Related") && dict["Related"] != nil {
                self.related = dict["Related"] as! String
            }
            if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                self.repoNamespace = dict["RepoNamespace"] as! String
            }
            if dict.keys.contains("ScanTime") && dict["ScanTime"] != nil {
                self.scanTime = dict["ScanTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! String
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var requestId: String?

    public var vulRecords: [DescribeCanFixVulListResponseBody.VulRecords]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vulRecords != nil {
            var tmp : [Any] = []
            for k in self.vulRecords! {
                tmp.append(k.toMap())
            }
            map["VulRecords"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VulRecords") && dict["VulRecords"] != nil {
            var tmp : [DescribeCanFixVulListResponseBody.VulRecords] = []
            for v in dict["VulRecords"] as! [Any] {
                var model = DescribeCanFixVulListResponseBody.VulRecords()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vulRecords = tmp
        }
    }
}

public class DescribeCanFixVulListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCanFixVulListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCanFixVulListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCheckEcsWarningsRequest : Tea.TeaModel {
    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeCheckEcsWarningsResponseBody : Tea.TeaModel {
    public var canTry: String?

    public var requestId: String?

    public var sasVersion: String?

    public var weakPasswordCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.canTry != nil {
            map["CanTry"] = self.canTry!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sasVersion != nil {
            map["SasVersion"] = self.sasVersion!
        }
        if self.weakPasswordCount != nil {
            map["WeakPasswordCount"] = self.weakPasswordCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CanTry") && dict["CanTry"] != nil {
            self.canTry = dict["CanTry"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SasVersion") && dict["SasVersion"] != nil {
            self.sasVersion = dict["SasVersion"] as! String
        }
        if dict.keys.contains("WeakPasswordCount") && dict["WeakPasswordCount"] != nil {
            self.weakPasswordCount = dict["WeakPasswordCount"] as! String
        }
    }
}

public class DescribeCheckEcsWarningsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCheckEcsWarningsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCheckEcsWarningsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCheckFixDetailsRequest : Tea.TeaModel {
    public var checkIds: String?

    public var lang: String?

    public var riskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkIds != nil {
            map["CheckIds"] = self.checkIds!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.riskId != nil {
            map["RiskId"] = self.riskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckIds") && dict["CheckIds"] != nil {
            self.checkIds = dict["CheckIds"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
            self.riskId = dict["RiskId"] as! Int64
        }
    }
}

public class DescribeCheckFixDetailsResponseBody : Tea.TeaModel {
    public class CheckFixDetails : Tea.TeaModel {
        public class Rules : Tea.TeaModel {
            public class ParamList : Tea.TeaModel {
                public var enumValue: String?

                public var maxValue: Int32?

                public var minValue: Int32?

                public var paramDefaultValue: String?

                public var paramDesc: String?

                public var paramName: String?

                public var paramType: Int32?

                public var ruleId: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enumValue != nil {
                        map["EnumValue"] = self.enumValue!
                    }
                    if self.maxValue != nil {
                        map["MaxValue"] = self.maxValue!
                    }
                    if self.minValue != nil {
                        map["MinValue"] = self.minValue!
                    }
                    if self.paramDefaultValue != nil {
                        map["ParamDefaultValue"] = self.paramDefaultValue!
                    }
                    if self.paramDesc != nil {
                        map["ParamDesc"] = self.paramDesc!
                    }
                    if self.paramName != nil {
                        map["ParamName"] = self.paramName!
                    }
                    if self.paramType != nil {
                        map["ParamType"] = self.paramType!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EnumValue") && dict["EnumValue"] != nil {
                        self.enumValue = dict["EnumValue"] as! String
                    }
                    if dict.keys.contains("MaxValue") && dict["MaxValue"] != nil {
                        self.maxValue = dict["MaxValue"] as! Int32
                    }
                    if dict.keys.contains("MinValue") && dict["MinValue"] != nil {
                        self.minValue = dict["MinValue"] as! Int32
                    }
                    if dict.keys.contains("ParamDefaultValue") && dict["ParamDefaultValue"] != nil {
                        self.paramDefaultValue = dict["ParamDefaultValue"] as! String
                    }
                    if dict.keys.contains("ParamDesc") && dict["ParamDesc"] != nil {
                        self.paramDesc = dict["ParamDesc"] as! String
                    }
                    if dict.keys.contains("ParamName") && dict["ParamName"] != nil {
                        self.paramName = dict["ParamName"] as! String
                    }
                    if dict.keys.contains("ParamType") && dict["ParamType"] != nil {
                        self.paramType = dict["ParamType"] as! Int32
                    }
                    if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                        self.ruleId = dict["RuleId"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var checkId: Int64?

            public var defaultValue: Int32?

            public var optional_: Int32?

            public var paramList: [DescribeCheckFixDetailsResponseBody.CheckFixDetails.Rules.ParamList]?

            public var ruleDesc: String?

            public var ruleId: String?

            public var value: Int32?

            public var varName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.checkId != nil {
                    map["CheckId"] = self.checkId!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.optional_ != nil {
                    map["Optional"] = self.optional_!
                }
                if self.paramList != nil {
                    var tmp : [Any] = []
                    for k in self.paramList! {
                        tmp.append(k.toMap())
                    }
                    map["ParamList"] = tmp
                }
                if self.ruleDesc != nil {
                    map["RuleDesc"] = self.ruleDesc!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.varName != nil {
                    map["VarName"] = self.varName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                    self.checkId = dict["CheckId"] as! Int64
                }
                if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                    self.defaultValue = dict["DefaultValue"] as! Int32
                }
                if dict.keys.contains("Optional") && dict["Optional"] != nil {
                    self.optional_ = dict["Optional"] as! Int32
                }
                if dict.keys.contains("ParamList") && dict["ParamList"] != nil {
                    var tmp : [DescribeCheckFixDetailsResponseBody.CheckFixDetails.Rules.ParamList] = []
                    for v in dict["ParamList"] as! [Any] {
                        var model = DescribeCheckFixDetailsResponseBody.CheckFixDetails.Rules.ParamList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.paramList = tmp
                }
                if dict.keys.contains("RuleDesc") && dict["RuleDesc"] != nil {
                    self.ruleDesc = dict["RuleDesc"] as! String
                }
                if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! Int32
                }
                if dict.keys.contains("VarName") && dict["VarName"] != nil {
                    self.varName = dict["VarName"] as! String
                }
            }
        }
        public var checkDesc: String?

        public var checkId: Int64?

        public var checkItem: String?

        public var rules: [DescribeCheckFixDetailsResponseBody.CheckFixDetails.Rules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkDesc != nil {
                map["CheckDesc"] = self.checkDesc!
            }
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.checkItem != nil {
                map["CheckItem"] = self.checkItem!
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckDesc") && dict["CheckDesc"] != nil {
                self.checkDesc = dict["CheckDesc"] as! String
            }
            if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                self.checkId = dict["CheckId"] as! Int64
            }
            if dict.keys.contains("CheckItem") && dict["CheckItem"] != nil {
                self.checkItem = dict["CheckItem"] as! String
            }
            if dict.keys.contains("Rules") && dict["Rules"] != nil {
                var tmp : [DescribeCheckFixDetailsResponseBody.CheckFixDetails.Rules] = []
                for v in dict["Rules"] as! [Any] {
                    var model = DescribeCheckFixDetailsResponseBody.CheckFixDetails.Rules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.rules = tmp
            }
        }
    }
    public var checkFixDetails: [DescribeCheckFixDetailsResponseBody.CheckFixDetails]?

    public var count: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkFixDetails != nil {
            var tmp : [Any] = []
            for k in self.checkFixDetails! {
                tmp.append(k.toMap())
            }
            map["CheckFixDetails"] = tmp
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckFixDetails") && dict["CheckFixDetails"] != nil {
            var tmp : [DescribeCheckFixDetailsResponseBody.CheckFixDetails] = []
            for v in dict["CheckFixDetails"] as! [Any] {
                var model = DescribeCheckFixDetailsResponseBody.CheckFixDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.checkFixDetails = tmp
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCheckFixDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCheckFixDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCheckFixDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCheckWarningDetailRequest : Tea.TeaModel {
    public var checkWarningId: Int64?

    public var lang: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkWarningId != nil {
            map["CheckWarningId"] = self.checkWarningId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckWarningId") && dict["CheckWarningId"] != nil {
            self.checkWarningId = dict["CheckWarningId"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeCheckWarningDetailResponseBody : Tea.TeaModel {
    public class CheckDetailColumns : Tea.TeaModel {
        public class Grids : Tea.TeaModel {
            public var key: String?

            public var showName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.showName != nil {
                    map["ShowName"] = self.showName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                    self.showName = dict["ShowName"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var grids: [DescribeCheckWarningDetailResponseBody.CheckDetailColumns.Grids]?

        public var key: String?

        public var showName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.grids != nil {
                var tmp : [Any] = []
                for k in self.grids! {
                    tmp.append(k.toMap())
                }
                map["Grids"] = tmp
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Grids") && dict["Grids"] != nil {
                var tmp : [DescribeCheckWarningDetailResponseBody.CheckDetailColumns.Grids] = []
                for v in dict["Grids"] as! [Any] {
                    var model = DescribeCheckWarningDetailResponseBody.CheckDetailColumns.Grids()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.grids = tmp
            }
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                self.showName = dict["ShowName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var advice: String?

    public var checkDetailAssetInfo: [[String: String]]?

    public var checkDetailColumns: [DescribeCheckWarningDetailResponseBody.CheckDetailColumns]?

    public var checkId: Int64?

    public var description_: String?

    public var item: String?

    public var level: String?

    public var prompt: String?

    public var requestId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advice != nil {
            map["Advice"] = self.advice!
        }
        if self.checkDetailAssetInfo != nil {
            map["CheckDetailAssetInfo"] = self.checkDetailAssetInfo!
        }
        if self.checkDetailColumns != nil {
            var tmp : [Any] = []
            for k in self.checkDetailColumns! {
                tmp.append(k.toMap())
            }
            map["CheckDetailColumns"] = tmp
        }
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.item != nil {
            map["Item"] = self.item!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.prompt != nil {
            map["Prompt"] = self.prompt!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Advice") && dict["Advice"] != nil {
            self.advice = dict["Advice"] as! String
        }
        if dict.keys.contains("CheckDetailAssetInfo") && dict["CheckDetailAssetInfo"] != nil {
            self.checkDetailAssetInfo = dict["CheckDetailAssetInfo"] as! [[String: String]]
        }
        if dict.keys.contains("CheckDetailColumns") && dict["CheckDetailColumns"] != nil {
            var tmp : [DescribeCheckWarningDetailResponseBody.CheckDetailColumns] = []
            for v in dict["CheckDetailColumns"] as! [Any] {
                var model = DescribeCheckWarningDetailResponseBody.CheckDetailColumns()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.checkDetailColumns = tmp
        }
        if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
            self.checkId = dict["CheckId"] as! Int64
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Item") && dict["Item"] != nil {
            self.item = dict["Item"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("Prompt") && dict["Prompt"] != nil {
            self.prompt = dict["Prompt"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeCheckWarningDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCheckWarningDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCheckWarningDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCheckWarningMachinesRequest : Tea.TeaModel {
    public var checkId: Int64?

    public var lang: String?

    public var riskId: Int64?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.riskId != nil {
            map["RiskId"] = self.riskId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
            self.checkId = dict["CheckId"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
            self.riskId = dict["RiskId"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class DescribeCheckWarningMachinesResponseBody : Tea.TeaModel {
    public class Machines : Tea.TeaModel {
        public var bind: Bool?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var regionId: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bind != nil {
                map["Bind"] = self.bind!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bind") && dict["Bind"] != nil {
                self.bind = dict["Bind"] as! Bool
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var count: Int32?

    public var machines: [DescribeCheckWarningMachinesResponseBody.Machines]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.machines != nil {
            var tmp : [Any] = []
            for k in self.machines! {
                tmp.append(k.toMap())
            }
            map["Machines"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Machines") && dict["Machines"] != nil {
            var tmp : [DescribeCheckWarningMachinesResponseBody.Machines] = []
            for v in dict["Machines"] as! [Any] {
                var model = DescribeCheckWarningMachinesResponseBody.Machines()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.machines = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCheckWarningMachinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCheckWarningMachinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCheckWarningMachinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCheckWarningSummaryRequest : Tea.TeaModel {
    public var clusterId: String?

    public var containerFieldName: String?

    public var containerFieldValue: String?

    public var currentPage: Int32?

    public var groupId: Int64?

    public var lang: String?

    public var pageSize: Int32?

    public var riskName: String?

    public var riskStatus: Int32?

    public var sourceIp: String?

    public var status: String?

    public var strategyId: Int64?

    public var targetType: String?

    public var typeName: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.containerFieldName != nil {
            map["ContainerFieldName"] = self.containerFieldName!
        }
        if self.containerFieldValue != nil {
            map["ContainerFieldValue"] = self.containerFieldValue!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskName != nil {
            map["RiskName"] = self.riskName!
        }
        if self.riskStatus != nil {
            map["RiskStatus"] = self.riskStatus!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.typeName != nil {
            map["TypeName"] = self.typeName!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ContainerFieldName") && dict["ContainerFieldName"] != nil {
            self.containerFieldName = dict["ContainerFieldName"] as! String
        }
        if dict.keys.contains("ContainerFieldValue") && dict["ContainerFieldValue"] != nil {
            self.containerFieldValue = dict["ContainerFieldValue"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskName") && dict["RiskName"] != nil {
            self.riskName = dict["RiskName"] as! String
        }
        if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
            self.riskStatus = dict["RiskStatus"] as! Int32
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
            self.strategyId = dict["StrategyId"] as! Int64
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
            self.typeName = dict["TypeName"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeCheckWarningSummaryResponseBody : Tea.TeaModel {
    public class WarningSummarys : Tea.TeaModel {
        public var checkCount: Int32?

        public var checkExploit: Bool?

        public var containerRisk: Bool?

        public var databaseRisk: Bool?

        public var highWarningCount: Int32?

        public var lastFoundTime: String?

        public var level: String?

        public var lowWarningCount: Int32?

        public var mediumWarningCount: Int32?

        public var riskId: Int64?

        public var riskName: String?

        public var subTypeAlias: String?

        public var typeAlias_: String?

        public var warningMachineCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkCount != nil {
                map["CheckCount"] = self.checkCount!
            }
            if self.checkExploit != nil {
                map["CheckExploit"] = self.checkExploit!
            }
            if self.containerRisk != nil {
                map["ContainerRisk"] = self.containerRisk!
            }
            if self.databaseRisk != nil {
                map["DatabaseRisk"] = self.databaseRisk!
            }
            if self.highWarningCount != nil {
                map["HighWarningCount"] = self.highWarningCount!
            }
            if self.lastFoundTime != nil {
                map["LastFoundTime"] = self.lastFoundTime!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.lowWarningCount != nil {
                map["LowWarningCount"] = self.lowWarningCount!
            }
            if self.mediumWarningCount != nil {
                map["MediumWarningCount"] = self.mediumWarningCount!
            }
            if self.riskId != nil {
                map["RiskId"] = self.riskId!
            }
            if self.riskName != nil {
                map["RiskName"] = self.riskName!
            }
            if self.subTypeAlias != nil {
                map["SubTypeAlias"] = self.subTypeAlias!
            }
            if self.typeAlias_ != nil {
                map["TypeAlias"] = self.typeAlias_!
            }
            if self.warningMachineCount != nil {
                map["WarningMachineCount"] = self.warningMachineCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckCount") && dict["CheckCount"] != nil {
                self.checkCount = dict["CheckCount"] as! Int32
            }
            if dict.keys.contains("CheckExploit") && dict["CheckExploit"] != nil {
                self.checkExploit = dict["CheckExploit"] as! Bool
            }
            if dict.keys.contains("ContainerRisk") && dict["ContainerRisk"] != nil {
                self.containerRisk = dict["ContainerRisk"] as! Bool
            }
            if dict.keys.contains("DatabaseRisk") && dict["DatabaseRisk"] != nil {
                self.databaseRisk = dict["DatabaseRisk"] as! Bool
            }
            if dict.keys.contains("HighWarningCount") && dict["HighWarningCount"] != nil {
                self.highWarningCount = dict["HighWarningCount"] as! Int32
            }
            if dict.keys.contains("LastFoundTime") && dict["LastFoundTime"] != nil {
                self.lastFoundTime = dict["LastFoundTime"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("LowWarningCount") && dict["LowWarningCount"] != nil {
                self.lowWarningCount = dict["LowWarningCount"] as! Int32
            }
            if dict.keys.contains("MediumWarningCount") && dict["MediumWarningCount"] != nil {
                self.mediumWarningCount = dict["MediumWarningCount"] as! Int32
            }
            if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
                self.riskId = dict["RiskId"] as! Int64
            }
            if dict.keys.contains("RiskName") && dict["RiskName"] != nil {
                self.riskName = dict["RiskName"] as! String
            }
            if dict.keys.contains("SubTypeAlias") && dict["SubTypeAlias"] != nil {
                self.subTypeAlias = dict["SubTypeAlias"] as! String
            }
            if dict.keys.contains("TypeAlias") && dict["TypeAlias"] != nil {
                self.typeAlias_ = dict["TypeAlias"] as! String
            }
            if dict.keys.contains("WarningMachineCount") && dict["WarningMachineCount"] != nil {
                self.warningMachineCount = dict["WarningMachineCount"] as! Int32
            }
        }
    }
    public var count: Int32?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var warningSummarys: [DescribeCheckWarningSummaryResponseBody.WarningSummarys]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.warningSummarys != nil {
            var tmp : [Any] = []
            for k in self.warningSummarys! {
                tmp.append(k.toMap())
            }
            map["WarningSummarys"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("WarningSummarys") && dict["WarningSummarys"] != nil {
            var tmp : [DescribeCheckWarningSummaryResponseBody.WarningSummarys] = []
            for v in dict["WarningSummarys"] as! [Any] {
                var model = DescribeCheckWarningSummaryResponseBody.WarningSummarys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.warningSummarys = tmp
        }
    }
}

public class DescribeCheckWarningSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCheckWarningSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCheckWarningSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCheckWarningsRequest : Tea.TeaModel {
    public var checkId: Int64?

    public var checkType: String?

    public var containerName: String?

    public var currentPage: Int32?

    public var lang: String?

    public var pageSize: Int32?

    public var riskId: Int64?

    public var riskStatus: Int32?

    public var sourceIp: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.checkType != nil {
            map["CheckType"] = self.checkType!
        }
        if self.containerName != nil {
            map["ContainerName"] = self.containerName!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskId != nil {
            map["RiskId"] = self.riskId!
        }
        if self.riskStatus != nil {
            map["RiskStatus"] = self.riskStatus!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
            self.checkId = dict["CheckId"] as! Int64
        }
        if dict.keys.contains("CheckType") && dict["CheckType"] != nil {
            self.checkType = dict["CheckType"] as! String
        }
        if dict.keys.contains("ContainerName") && dict["ContainerName"] != nil {
            self.containerName = dict["ContainerName"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
            self.riskId = dict["RiskId"] as! Int64
        }
        if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
            self.riskStatus = dict["RiskStatus"] as! Int32
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeCheckWarningsResponseBody : Tea.TeaModel {
    public class CheckWarnings : Tea.TeaModel {
        public var checkId: Int64?

        public var checkWarningId: Int64?

        public var execErrorMessage: String?

        public var fixStatus: Int32?

        public var item: String?

        public var level: String?

        public var reason: String?

        public var status: Int32?

        public var type: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.checkWarningId != nil {
                map["CheckWarningId"] = self.checkWarningId!
            }
            if self.execErrorMessage != nil {
                map["ExecErrorMessage"] = self.execErrorMessage!
            }
            if self.fixStatus != nil {
                map["FixStatus"] = self.fixStatus!
            }
            if self.item != nil {
                map["Item"] = self.item!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                self.checkId = dict["CheckId"] as! Int64
            }
            if dict.keys.contains("CheckWarningId") && dict["CheckWarningId"] != nil {
                self.checkWarningId = dict["CheckWarningId"] as! Int64
            }
            if dict.keys.contains("ExecErrorMessage") && dict["ExecErrorMessage"] != nil {
                self.execErrorMessage = dict["ExecErrorMessage"] as! String
            }
            if dict.keys.contains("FixStatus") && dict["FixStatus"] != nil {
                self.fixStatus = dict["FixStatus"] as! Int32
            }
            if dict.keys.contains("Item") && dict["Item"] != nil {
                self.item = dict["Item"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var checkWarnings: [DescribeCheckWarningsResponseBody.CheckWarnings]?

    public var count: Int32?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkWarnings != nil {
            var tmp : [Any] = []
            for k in self.checkWarnings! {
                tmp.append(k.toMap())
            }
            map["CheckWarnings"] = tmp
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckWarnings") && dict["CheckWarnings"] != nil {
            var tmp : [DescribeCheckWarningsResponseBody.CheckWarnings] = []
            for v in dict["CheckWarnings"] as! [Any] {
                var model = DescribeCheckWarningsResponseBody.CheckWarnings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.checkWarnings = tmp
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeCheckWarningsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCheckWarningsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCheckWarningsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClientConfSetupRequest : Tea.TeaModel {
    public var strategyTag: String?

    public var strategyTagValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.strategyTag != nil {
            map["StrategyTag"] = self.strategyTag!
        }
        if self.strategyTagValue != nil {
            map["StrategyTagValue"] = self.strategyTagValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("StrategyTag") && dict["StrategyTag"] != nil {
            self.strategyTag = dict["StrategyTag"] as! String
        }
        if dict.keys.contains("StrategyTagValue") && dict["StrategyTagValue"] != nil {
            self.strategyTagValue = dict["StrategyTagValue"] as! String
        }
    }
}

public class DescribeClientConfSetupResponseBody : Tea.TeaModel {
    public class ClientConf : Tea.TeaModel {
        public var config: String?

        public var strategyTag: String?

        public var strategyTagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.strategyTag != nil {
                map["StrategyTag"] = self.strategyTag!
            }
            if self.strategyTagValue != nil {
                map["StrategyTagValue"] = self.strategyTagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("StrategyTag") && dict["StrategyTag"] != nil {
                self.strategyTag = dict["StrategyTag"] as! String
            }
            if dict.keys.contains("StrategyTagValue") && dict["StrategyTagValue"] != nil {
                self.strategyTagValue = dict["StrategyTagValue"] as! String
            }
        }
    }
    public var clientConf: DescribeClientConfSetupResponseBody.ClientConf?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clientConf?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientConf != nil {
            map["ClientConf"] = self.clientConf?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientConf") && dict["ClientConf"] != nil {
            var model = DescribeClientConfSetupResponseBody.ClientConf()
            model.fromMap(dict["ClientConf"] as! [String: Any])
            self.clientConf = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClientConfSetupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClientConfSetupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClientConfSetupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClientConfStrategyRequest : Tea.TeaModel {
    public var tag: String?

    public var tagValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.tagValue != nil {
            map["TagValue"] = self.tagValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
        if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
            self.tagValue = dict["TagValue"] as! String
        }
    }
}

public class DescribeClientConfStrategyResponseBody : Tea.TeaModel {
    public class TargetList : Tea.TeaModel {
        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var requestId: String?

    public var targetList: [DescribeClientConfStrategyResponseBody.TargetList]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.targetList != nil {
            var tmp : [Any] = []
            for k in self.targetList! {
                tmp.append(k.toMap())
            }
            map["TargetList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TargetList") && dict["TargetList"] != nil {
            var tmp : [DescribeClientConfStrategyResponseBody.TargetList] = []
            for v in dict["TargetList"] as! [Any] {
                var model = DescribeClientConfStrategyResponseBody.TargetList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.targetList = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeClientConfStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClientConfStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClientConfStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudCenterInstancesRequest : Tea.TeaModel {
    public var criteria: String?

    public var currentPage: Int32?

    public var importance: Int32?

    public var lang: String?

    public var logicalExp: String?

    public var machineTypes: String?

    public var nextToken: String?

    public var noGroupTrace: Bool?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceDirectoryAccountId: Int64?

    public var useNextToken: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.importance != nil {
            map["Importance"] = self.importance!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.logicalExp != nil {
            map["LogicalExp"] = self.logicalExp!
        }
        if self.machineTypes != nil {
            map["MachineTypes"] = self.machineTypes!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.noGroupTrace != nil {
            map["NoGroupTrace"] = self.noGroupTrace!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.useNextToken != nil {
            map["UseNextToken"] = self.useNextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Importance") && dict["Importance"] != nil {
            self.importance = dict["Importance"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LogicalExp") && dict["LogicalExp"] != nil {
            self.logicalExp = dict["LogicalExp"] as! String
        }
        if dict.keys.contains("MachineTypes") && dict["MachineTypes"] != nil {
            self.machineTypes = dict["MachineTypes"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("NoGroupTrace") && dict["NoGroupTrace"] != nil {
            self.noGroupTrace = dict["NoGroupTrace"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! Int64
        }
        if dict.keys.contains("UseNextToken") && dict["UseNextToken"] != nil {
            self.useNextToken = dict["UseNextToken"] as! Bool
        }
    }
}

public class DescribeCloudCenterInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var alarmStatus: String?

        public var assetType: String?

        public var authModifyTime: Int64?

        public var authVersion: Int32?

        public var authVersionName: String?

        public var bind: Bool?

        public var clientStatus: String?

        public var clusterId: String?

        public var clusterName: String?

        public var cores: Int32?

        public var cpuInfo: String?

        public var createdTime: Int64?

        public var exposedStatus: Int32?

        public var flag: Int32?

        public var groupId: Int64?

        public var groupTrace: String?

        public var hcStatus: String?

        public var healthCheckCount: Int32?

        public var importance: Int32?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var ipListString: String?

        public var kernel: String?

        public var lastLoginTimestamp: Int64?

        public var macListString: String?

        public var mem: Int32?

        public var os: String?

        public var osName: String?

        public var podCount: Int32?

        public var region: String?

        public var regionId: String?

        public var regionName: String?

        public var riskCount: String?

        public var riskStatus: String?

        public var safeEventCount: Int32?

        public var status: String?

        public var tag: String?

        public var tagId: String?

        public var uuid: String?

        public var vendor: Int32?

        public var vendorName: String?

        public var vpcInstanceId: String?

        public var vulCount: Int32?

        public var vulStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmStatus != nil {
                map["AlarmStatus"] = self.alarmStatus!
            }
            if self.assetType != nil {
                map["AssetType"] = self.assetType!
            }
            if self.authModifyTime != nil {
                map["AuthModifyTime"] = self.authModifyTime!
            }
            if self.authVersion != nil {
                map["AuthVersion"] = self.authVersion!
            }
            if self.authVersionName != nil {
                map["AuthVersionName"] = self.authVersionName!
            }
            if self.bind != nil {
                map["Bind"] = self.bind!
            }
            if self.clientStatus != nil {
                map["ClientStatus"] = self.clientStatus!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.cpuInfo != nil {
                map["CpuInfo"] = self.cpuInfo!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.exposedStatus != nil {
                map["ExposedStatus"] = self.exposedStatus!
            }
            if self.flag != nil {
                map["Flag"] = self.flag!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupTrace != nil {
                map["GroupTrace"] = self.groupTrace!
            }
            if self.hcStatus != nil {
                map["HcStatus"] = self.hcStatus!
            }
            if self.healthCheckCount != nil {
                map["HealthCheckCount"] = self.healthCheckCount!
            }
            if self.importance != nil {
                map["Importance"] = self.importance!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.ipListString != nil {
                map["IpListString"] = self.ipListString!
            }
            if self.kernel != nil {
                map["Kernel"] = self.kernel!
            }
            if self.lastLoginTimestamp != nil {
                map["LastLoginTimestamp"] = self.lastLoginTimestamp!
            }
            if self.macListString != nil {
                map["MacListString"] = self.macListString!
            }
            if self.mem != nil {
                map["Mem"] = self.mem!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.osName != nil {
                map["OsName"] = self.osName!
            }
            if self.podCount != nil {
                map["PodCount"] = self.podCount!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.riskCount != nil {
                map["RiskCount"] = self.riskCount!
            }
            if self.riskStatus != nil {
                map["RiskStatus"] = self.riskStatus!
            }
            if self.safeEventCount != nil {
                map["SafeEventCount"] = self.safeEventCount!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.tagId != nil {
                map["TagId"] = self.tagId!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vendor != nil {
                map["Vendor"] = self.vendor!
            }
            if self.vendorName != nil {
                map["VendorName"] = self.vendorName!
            }
            if self.vpcInstanceId != nil {
                map["VpcInstanceId"] = self.vpcInstanceId!
            }
            if self.vulCount != nil {
                map["VulCount"] = self.vulCount!
            }
            if self.vulStatus != nil {
                map["VulStatus"] = self.vulStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmStatus") && dict["AlarmStatus"] != nil {
                self.alarmStatus = dict["AlarmStatus"] as! String
            }
            if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
                self.assetType = dict["AssetType"] as! String
            }
            if dict.keys.contains("AuthModifyTime") && dict["AuthModifyTime"] != nil {
                self.authModifyTime = dict["AuthModifyTime"] as! Int64
            }
            if dict.keys.contains("AuthVersion") && dict["AuthVersion"] != nil {
                self.authVersion = dict["AuthVersion"] as! Int32
            }
            if dict.keys.contains("AuthVersionName") && dict["AuthVersionName"] != nil {
                self.authVersionName = dict["AuthVersionName"] as! String
            }
            if dict.keys.contains("Bind") && dict["Bind"] != nil {
                self.bind = dict["Bind"] as! Bool
            }
            if dict.keys.contains("ClientStatus") && dict["ClientStatus"] != nil {
                self.clientStatus = dict["ClientStatus"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("Cores") && dict["Cores"] != nil {
                self.cores = dict["Cores"] as! Int32
            }
            if dict.keys.contains("CpuInfo") && dict["CpuInfo"] != nil {
                self.cpuInfo = dict["CpuInfo"] as! String
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("ExposedStatus") && dict["ExposedStatus"] != nil {
                self.exposedStatus = dict["ExposedStatus"] as! Int32
            }
            if dict.keys.contains("Flag") && dict["Flag"] != nil {
                self.flag = dict["Flag"] as! Int32
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("GroupTrace") && dict["GroupTrace"] != nil {
                self.groupTrace = dict["GroupTrace"] as! String
            }
            if dict.keys.contains("HcStatus") && dict["HcStatus"] != nil {
                self.hcStatus = dict["HcStatus"] as! String
            }
            if dict.keys.contains("HealthCheckCount") && dict["HealthCheckCount"] != nil {
                self.healthCheckCount = dict["HealthCheckCount"] as! Int32
            }
            if dict.keys.contains("Importance") && dict["Importance"] != nil {
                self.importance = dict["Importance"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("IpListString") && dict["IpListString"] != nil {
                self.ipListString = dict["IpListString"] as! String
            }
            if dict.keys.contains("Kernel") && dict["Kernel"] != nil {
                self.kernel = dict["Kernel"] as! String
            }
            if dict.keys.contains("LastLoginTimestamp") && dict["LastLoginTimestamp"] != nil {
                self.lastLoginTimestamp = dict["LastLoginTimestamp"] as! Int64
            }
            if dict.keys.contains("MacListString") && dict["MacListString"] != nil {
                self.macListString = dict["MacListString"] as! String
            }
            if dict.keys.contains("Mem") && dict["Mem"] != nil {
                self.mem = dict["Mem"] as! Int32
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("OsName") && dict["OsName"] != nil {
                self.osName = dict["OsName"] as! String
            }
            if dict.keys.contains("PodCount") && dict["PodCount"] != nil {
                self.podCount = dict["PodCount"] as! Int32
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                self.regionName = dict["RegionName"] as! String
            }
            if dict.keys.contains("RiskCount") && dict["RiskCount"] != nil {
                self.riskCount = dict["RiskCount"] as! String
            }
            if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
                self.riskStatus = dict["RiskStatus"] as! String
            }
            if dict.keys.contains("SafeEventCount") && dict["SafeEventCount"] != nil {
                self.safeEventCount = dict["SafeEventCount"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("TagId") && dict["TagId"] != nil {
                self.tagId = dict["TagId"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                self.vendor = dict["Vendor"] as! Int32
            }
            if dict.keys.contains("VendorName") && dict["VendorName"] != nil {
                self.vendorName = dict["VendorName"] as! String
            }
            if dict.keys.contains("VpcInstanceId") && dict["VpcInstanceId"] != nil {
                self.vpcInstanceId = dict["VpcInstanceId"] as! String
            }
            if dict.keys.contains("VulCount") && dict["VulCount"] != nil {
                self.vulCount = dict["VulCount"] as! Int32
            }
            if dict.keys.contains("VulStatus") && dict["VulStatus"] != nil {
                self.vulStatus = dict["VulStatus"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var nextToken: String?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var instances: [DescribeCloudCenterInstancesResponseBody.Instances]?

    public var pageInfo: DescribeCloudCenterInstancesResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") && dict["Instances"] != nil {
            var tmp : [DescribeCloudCenterInstancesResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = DescribeCloudCenterInstancesResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeCloudCenterInstancesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeCloudCenterInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudCenterInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCloudCenterInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudProductFieldStatisticsResponseBody : Tea.TeaModel {
    public class GroupedFields : Tea.TeaModel {
        public var categoryCount: String?

        public var instanceCount: Int32?

        public var riskInstanceCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categoryCount != nil {
                map["CategoryCount"] = self.categoryCount!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.riskInstanceCount != nil {
                map["RiskInstanceCount"] = self.riskInstanceCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CategoryCount") && dict["CategoryCount"] != nil {
                self.categoryCount = dict["CategoryCount"] as! String
            }
            if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("RiskInstanceCount") && dict["RiskInstanceCount"] != nil {
                self.riskInstanceCount = dict["RiskInstanceCount"] as! Int32
            }
        }
    }
    public var groupedFields: DescribeCloudProductFieldStatisticsResponseBody.GroupedFields?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.groupedFields?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupedFields != nil {
            map["GroupedFields"] = self.groupedFields?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupedFields") && dict["GroupedFields"] != nil {
            var model = DescribeCloudProductFieldStatisticsResponseBody.GroupedFields()
            model.fromMap(dict["GroupedFields"] as! [String: Any])
            self.groupedFields = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCloudProductFieldStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudProductFieldStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCloudProductFieldStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterBasicInfoRequest : Tea.TeaModel {
    public var clusterId: String?

    public var targetType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeClusterBasicInfoResponseBody : Tea.TeaModel {
    public class ClusterInfo : Tea.TeaModel {
        public var clusterId: String?

        public var clusterName: String?

        public var clusterType: String?

        public var createTime: Int64?

        public var currentVersion: String?

        public var instanceCount: Int32?

        public var regionId: String?

        public var state: String?

        public var targetResult: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.currentVersion != nil {
                map["CurrentVersion"] = self.currentVersion!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.targetResult != nil {
                map["TargetResult"] = self.targetResult!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CurrentVersion") && dict["CurrentVersion"] != nil {
                self.currentVersion = dict["CurrentVersion"] as! String
            }
            if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TargetResult") && dict["TargetResult"] != nil {
                self.targetResult = dict["TargetResult"] as! Bool
            }
        }
    }
    public var clusterInfo: DescribeClusterBasicInfoResponseBody.ClusterInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterInfo != nil {
            map["ClusterInfo"] = self.clusterInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterInfo") && dict["ClusterInfo"] != nil {
            var model = DescribeClusterBasicInfoResponseBody.ClusterInfo()
            model.fromMap(dict["ClusterInfo"] as! [String: Any])
            self.clusterInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClusterBasicInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterBasicInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterBasicInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterInfoListRequest : Tea.TeaModel {
    public var target: String?

    public var targetType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.target != nil {
            map["Target"] = self.target!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeClusterInfoListResponseBody : Tea.TeaModel {
    public class ClusterList : Tea.TeaModel {
        public var clusterId: String?

        public var clusterName: String?

        public var clusterType: String?

        public var regionId: String?

        public var state: String?

        public var targetResult: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.targetResult != nil {
                map["TargetResult"] = self.targetResult!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TargetResult") && dict["TargetResult"] != nil {
                self.targetResult = dict["TargetResult"] as! Bool
            }
        }
    }
    public var clusterList: [DescribeClusterInfoListResponseBody.ClusterList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterList != nil {
            var tmp : [Any] = []
            for k in self.clusterList! {
                tmp.append(k.toMap())
            }
            map["ClusterList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterList") && dict["ClusterList"] != nil {
            var tmp : [DescribeClusterInfoListResponseBody.ClusterList] = []
            for v in dict["ClusterList"] as! [Any] {
                var model = DescribeClusterInfoListResponseBody.ClusterList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.clusterList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClusterInfoListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterInfoListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterInfoListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterNetworkRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class DescribeClusterNetworkResponseBody : Tea.TeaModel {
    public class ClusterNetwork : Tea.TeaModel {
        public class Edge : Tea.TeaModel {
            public var dstNodeId: String?

            public var dstNodeType: String?

            public var id: String?

            public var port: String?

            public var srcNodeId: String?

            public var srcNodeType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dstNodeId != nil {
                    map["DstNodeId"] = self.dstNodeId!
                }
                if self.dstNodeType != nil {
                    map["DstNodeType"] = self.dstNodeType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.srcNodeId != nil {
                    map["SrcNodeId"] = self.srcNodeId!
                }
                if self.srcNodeType != nil {
                    map["SrcNodeType"] = self.srcNodeType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DstNodeId") && dict["DstNodeId"] != nil {
                    self.dstNodeId = dict["DstNodeId"] as! String
                }
                if dict.keys.contains("DstNodeType") && dict["DstNodeType"] != nil {
                    self.dstNodeType = dict["DstNodeType"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("SrcNodeId") && dict["SrcNodeId"] != nil {
                    self.srcNodeId = dict["SrcNodeId"] as! String
                }
                if dict.keys.contains("SrcNodeType") && dict["SrcNodeType"] != nil {
                    self.srcNodeType = dict["SrcNodeType"] as! String
                }
            }
        }
        public class Node : Tea.TeaModel {
            public var cnnfSwitch: Int32?

            public var id: String?

            public var interceptionType: Int32?

            public var name: String?

            public var netTopoSwitch: String?

            public var riskLevel: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cnnfSwitch != nil {
                    map["CnnfSwitch"] = self.cnnfSwitch!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.interceptionType != nil {
                    map["InterceptionType"] = self.interceptionType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.netTopoSwitch != nil {
                    map["NetTopoSwitch"] = self.netTopoSwitch!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CnnfSwitch") && dict["CnnfSwitch"] != nil {
                    self.cnnfSwitch = dict["CnnfSwitch"] as! Int32
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("InterceptionType") && dict["InterceptionType"] != nil {
                    self.interceptionType = dict["InterceptionType"] as! Int32
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NetTopoSwitch") && dict["NetTopoSwitch"] != nil {
                    self.netTopoSwitch = dict["NetTopoSwitch"] as! String
                }
                if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                    self.riskLevel = dict["RiskLevel"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var edge: [DescribeClusterNetworkResponseBody.ClusterNetwork.Edge]?

        public var node: [DescribeClusterNetworkResponseBody.ClusterNetwork.Node]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edge != nil {
                var tmp : [Any] = []
                for k in self.edge! {
                    tmp.append(k.toMap())
                }
                map["Edge"] = tmp
            }
            if self.node != nil {
                var tmp : [Any] = []
                for k in self.node! {
                    tmp.append(k.toMap())
                }
                map["Node"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Edge") && dict["Edge"] != nil {
                var tmp : [DescribeClusterNetworkResponseBody.ClusterNetwork.Edge] = []
                for v in dict["Edge"] as! [Any] {
                    var model = DescribeClusterNetworkResponseBody.ClusterNetwork.Edge()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.edge = tmp
            }
            if dict.keys.contains("Node") && dict["Node"] != nil {
                var tmp : [DescribeClusterNetworkResponseBody.ClusterNetwork.Node] = []
                for v in dict["Node"] as! [Any] {
                    var model = DescribeClusterNetworkResponseBody.ClusterNetwork.Node()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.node = tmp
            }
        }
    }
    public var clusterNetwork: DescribeClusterNetworkResponseBody.ClusterNetwork?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterNetwork?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterNetwork != nil {
            map["ClusterNetwork"] = self.clusterNetwork?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterNetwork") && dict["ClusterNetwork"] != nil {
            var model = DescribeClusterNetworkResponseBody.ClusterNetwork()
            model.fromMap(dict["ClusterNetwork"] as! [String: Any])
            self.clusterNetwork = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClusterNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterVulStatisticsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var types: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Types") && dict["Types"] != nil {
            self.types = dict["Types"] as! String
        }
    }
}

public class DescribeClusterVulStatisticsResponseBody : Tea.TeaModel {
    public class VulStat : Tea.TeaModel {
        public var asapCount: String?

        public var laterCount: String?

        public var nntfCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asapCount != nil {
                map["AsapCount"] = self.asapCount!
            }
            if self.laterCount != nil {
                map["LaterCount"] = self.laterCount!
            }
            if self.nntfCount != nil {
                map["NntfCount"] = self.nntfCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsapCount") && dict["AsapCount"] != nil {
                self.asapCount = dict["AsapCount"] as! String
            }
            if dict.keys.contains("LaterCount") && dict["LaterCount"] != nil {
                self.laterCount = dict["LaterCount"] as! String
            }
            if dict.keys.contains("NntfCount") && dict["NntfCount"] != nil {
                self.nntfCount = dict["NntfCount"] as! String
            }
        }
    }
    public var requestId: String?

    public var vulStat: DescribeClusterVulStatisticsResponseBody.VulStat?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vulStat?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vulStat != nil {
            map["VulStat"] = self.vulStat?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VulStat") && dict["VulStat"] != nil {
            var model = DescribeClusterVulStatisticsResponseBody.VulStat()
            model.fromMap(dict["VulStat"] as! [String: Any])
            self.vulStat = model
        }
    }
}

public class DescribeClusterVulStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterVulStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterVulStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCommonOverallConfigRequest : Tea.TeaModel {
    public var sourceIp: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeCommonOverallConfigResponseBody : Tea.TeaModel {
    public class OverallConfig : Tea.TeaModel {
        public var config: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var overallConfig: DescribeCommonOverallConfigResponseBody.OverallConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.overallConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overallConfig != nil {
            map["OverallConfig"] = self.overallConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OverallConfig") && dict["OverallConfig"] != nil {
            var model = DescribeCommonOverallConfigResponseBody.OverallConfig()
            model.fromMap(dict["OverallConfig"] as! [String: Any])
            self.overallConfig = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCommonOverallConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCommonOverallConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCommonOverallConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCommonOverallConfigListRequest : Tea.TeaModel {
    public var sourceIp: String?

    public var typeList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.typeList != nil {
            map["TypeList"] = self.typeList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("TypeList") && dict["TypeList"] != nil {
            self.typeList = dict["TypeList"] as! [String]
        }
    }
}

public class DescribeCommonOverallConfigListResponseBody : Tea.TeaModel {
    public class OverallList : Tea.TeaModel {
        public var config: String?

        public var totalCount: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var overallList: [DescribeCommonOverallConfigListResponseBody.OverallList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overallList != nil {
            var tmp : [Any] = []
            for k in self.overallList! {
                tmp.append(k.toMap())
            }
            map["OverallList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OverallList") && dict["OverallList"] != nil {
            var tmp : [DescribeCommonOverallConfigListResponseBody.OverallList] = []
            for v in dict["OverallList"] as! [Any] {
                var model = DescribeCommonOverallConfigListResponseBody.OverallList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.overallList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCommonOverallConfigListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCommonOverallConfigListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCommonOverallConfigListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCommonTargetConfigRequest : Tea.TeaModel {
    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeCommonTargetConfigResponseBody : Tea.TeaModel {
    public class TargetList : Tea.TeaModel {
        public var flag: String?

        public var target: String?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flag != nil {
                map["Flag"] = self.flag!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Flag") && dict["Flag"] != nil {
                self.flag = dict["Flag"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
        }
    }
    public var requestId: String?

    public var targetList: [DescribeCommonTargetConfigResponseBody.TargetList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.targetList != nil {
            var tmp : [Any] = []
            for k in self.targetList! {
                tmp.append(k.toMap())
            }
            map["TargetList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TargetList") && dict["TargetList"] != nil {
            var tmp : [DescribeCommonTargetConfigResponseBody.TargetList] = []
            for v in dict["TargetList"] as! [Any] {
                var model = DescribeCommonTargetConfigResponseBody.TargetList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.targetList = tmp
        }
    }
}

public class DescribeCommonTargetConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCommonTargetConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCommonTargetConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCommonTargetResultListRequest : Tea.TeaModel {
    public var sourceIp: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeCommonTargetResultListResponseBody : Tea.TeaModel {
    public class TargetConfig : Tea.TeaModel {
        public var flag: String?

        public var targetDefault: String?

        public var targetList: [String]?

        public var targetType: String?

        public var totalCount: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flag != nil {
                map["Flag"] = self.flag!
            }
            if self.targetDefault != nil {
                map["TargetDefault"] = self.targetDefault!
            }
            if self.targetList != nil {
                map["TargetList"] = self.targetList!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Flag") && dict["Flag"] != nil {
                self.flag = dict["Flag"] as! String
            }
            if dict.keys.contains("TargetDefault") && dict["TargetDefault"] != nil {
                self.targetDefault = dict["TargetDefault"] as! String
            }
            if dict.keys.contains("TargetList") && dict["TargetList"] != nil {
                self.targetList = dict["TargetList"] as! [String]
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var targetConfig: DescribeCommonTargetResultListResponseBody.TargetConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.targetConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.targetConfig != nil {
            map["TargetConfig"] = self.targetConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TargetConfig") && dict["TargetConfig"] != nil {
            var model = DescribeCommonTargetResultListResponseBody.TargetConfig()
            model.fromMap(dict["TargetConfig"] as! [String: Any])
            self.targetConfig = model
        }
    }
}

public class DescribeCommonTargetResultListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCommonTargetResultListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCommonTargetResultListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConcernNecessityRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeConcernNecessityResponseBody : Tea.TeaModel {
    public var concernNecessity: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.concernNecessity != nil {
            map["ConcernNecessity"] = self.concernNecessity!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConcernNecessity") && dict["ConcernNecessity"] != nil {
            self.concernNecessity = dict["ConcernNecessity"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeConcernNecessityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConcernNecessityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeConcernNecessityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContainerCriteriaRequest : Tea.TeaModel {
    public var groupField: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupField != nil {
            map["GroupField"] = self.groupField!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupField") && dict["GroupField"] != nil {
            self.groupField = dict["GroupField"] as! String
        }
        if dict.keys.contains("Value") && dict["Value"] != nil {
            self.value = dict["Value"] as! String
        }
    }
}

public class DescribeContainerCriteriaResponseBody : Tea.TeaModel {
    public class CriteriaList : Tea.TeaModel {
        public var name: String?

        public var type: String?

        public var values: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Values") && dict["Values"] != nil {
                self.values = dict["Values"] as! String
            }
        }
    }
    public var criteriaList: [DescribeContainerCriteriaResponseBody.CriteriaList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteriaList != nil {
            var tmp : [Any] = []
            for k in self.criteriaList! {
                tmp.append(k.toMap())
            }
            map["CriteriaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CriteriaList") && dict["CriteriaList"] != nil {
            var tmp : [DescribeContainerCriteriaResponseBody.CriteriaList] = []
            for v in dict["CriteriaList"] as! [Any] {
                var model = DescribeContainerCriteriaResponseBody.CriteriaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.criteriaList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeContainerCriteriaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContainerCriteriaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeContainerCriteriaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContainerInstancesRequest : Tea.TeaModel {
    public var criteria: String?

    public var currentPage: Int32?

    public var logicalExp: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.logicalExp != nil {
            map["LogicalExp"] = self.logicalExp!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("LogicalExp") && dict["LogicalExp"] != nil {
            self.logicalExp = dict["LogicalExp"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeContainerInstancesResponseBody : Tea.TeaModel {
    public class ContainerInstanceList : Tea.TeaModel {
        public var alarmCount: Int32?

        public var alarmStatus: String?

        public var appName: String?

        public var clusterId: String?

        public var clusterName: String?

        public var containerId: String?

        public var createTimestamp: Int64?

        public var exposed: Int32?

        public var exposedDetail: String?

        public var hcCount: Int32?

        public var hcStatus: String?

        public var hostIp: String?

        public var image: String?

        public var imageDigest: String?

        public var imageId: String?

        public var imageRepoName: String?

        public var imageRepoNamespace: String?

        public var imageRepoTag: String?

        public var imageUuid: String?

        public var instanceId: String?

        public var namespace: String?

        public var nodeInfo: String?

        public var nodeName: String?

        public var pod: String?

        public var podIp: String?

        public var regionId: String?

        public var riskCount: String?

        public var riskStatus: String?

        public var updateMark: String?

        public var vulCount: Int32?

        public var vulStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmCount != nil {
                map["AlarmCount"] = self.alarmCount!
            }
            if self.alarmStatus != nil {
                map["AlarmStatus"] = self.alarmStatus!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.containerId != nil {
                map["ContainerId"] = self.containerId!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.exposed != nil {
                map["Exposed"] = self.exposed!
            }
            if self.exposedDetail != nil {
                map["ExposedDetail"] = self.exposedDetail!
            }
            if self.hcCount != nil {
                map["HcCount"] = self.hcCount!
            }
            if self.hcStatus != nil {
                map["HcStatus"] = self.hcStatus!
            }
            if self.hostIp != nil {
                map["HostIp"] = self.hostIp!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imageDigest != nil {
                map["ImageDigest"] = self.imageDigest!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageRepoName != nil {
                map["ImageRepoName"] = self.imageRepoName!
            }
            if self.imageRepoNamespace != nil {
                map["ImageRepoNamespace"] = self.imageRepoNamespace!
            }
            if self.imageRepoTag != nil {
                map["ImageRepoTag"] = self.imageRepoTag!
            }
            if self.imageUuid != nil {
                map["ImageUuid"] = self.imageUuid!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.nodeInfo != nil {
                map["NodeInfo"] = self.nodeInfo!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.pod != nil {
                map["Pod"] = self.pod!
            }
            if self.podIp != nil {
                map["PodIp"] = self.podIp!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.riskCount != nil {
                map["RiskCount"] = self.riskCount!
            }
            if self.riskStatus != nil {
                map["RiskStatus"] = self.riskStatus!
            }
            if self.updateMark != nil {
                map["UpdateMark"] = self.updateMark!
            }
            if self.vulCount != nil {
                map["VulCount"] = self.vulCount!
            }
            if self.vulStatus != nil {
                map["VulStatus"] = self.vulStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmCount") && dict["AlarmCount"] != nil {
                self.alarmCount = dict["AlarmCount"] as! Int32
            }
            if dict.keys.contains("AlarmStatus") && dict["AlarmStatus"] != nil {
                self.alarmStatus = dict["AlarmStatus"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                self.containerId = dict["ContainerId"] as! String
            }
            if dict.keys.contains("CreateTimestamp") && dict["CreateTimestamp"] != nil {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("Exposed") && dict["Exposed"] != nil {
                self.exposed = dict["Exposed"] as! Int32
            }
            if dict.keys.contains("ExposedDetail") && dict["ExposedDetail"] != nil {
                self.exposedDetail = dict["ExposedDetail"] as! String
            }
            if dict.keys.contains("HcCount") && dict["HcCount"] != nil {
                self.hcCount = dict["HcCount"] as! Int32
            }
            if dict.keys.contains("HcStatus") && dict["HcStatus"] != nil {
                self.hcStatus = dict["HcStatus"] as! String
            }
            if dict.keys.contains("HostIp") && dict["HostIp"] != nil {
                self.hostIp = dict["HostIp"] as! String
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImageDigest") && dict["ImageDigest"] != nil {
                self.imageDigest = dict["ImageDigest"] as! String
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageRepoName") && dict["ImageRepoName"] != nil {
                self.imageRepoName = dict["ImageRepoName"] as! String
            }
            if dict.keys.contains("ImageRepoNamespace") && dict["ImageRepoNamespace"] != nil {
                self.imageRepoNamespace = dict["ImageRepoNamespace"] as! String
            }
            if dict.keys.contains("ImageRepoTag") && dict["ImageRepoTag"] != nil {
                self.imageRepoTag = dict["ImageRepoTag"] as! String
            }
            if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
                self.imageUuid = dict["ImageUuid"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NodeInfo") && dict["NodeInfo"] != nil {
                self.nodeInfo = dict["NodeInfo"] as! String
            }
            if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("Pod") && dict["Pod"] != nil {
                self.pod = dict["Pod"] as! String
            }
            if dict.keys.contains("PodIp") && dict["PodIp"] != nil {
                self.podIp = dict["PodIp"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RiskCount") && dict["RiskCount"] != nil {
                self.riskCount = dict["RiskCount"] as! String
            }
            if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
                self.riskStatus = dict["RiskStatus"] as! String
            }
            if dict.keys.contains("UpdateMark") && dict["UpdateMark"] != nil {
                self.updateMark = dict["UpdateMark"] as! String
            }
            if dict.keys.contains("VulCount") && dict["VulCount"] != nil {
                self.vulCount = dict["VulCount"] as! Int32
            }
            if dict.keys.contains("VulStatus") && dict["VulStatus"] != nil {
                self.vulStatus = dict["VulStatus"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var containerInstanceList: [DescribeContainerInstancesResponseBody.ContainerInstanceList]?

    public var pageInfo: DescribeContainerInstancesResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containerInstanceList != nil {
            var tmp : [Any] = []
            for k in self.containerInstanceList! {
                tmp.append(k.toMap())
            }
            map["ContainerInstanceList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContainerInstanceList") && dict["ContainerInstanceList"] != nil {
            var tmp : [DescribeContainerInstancesResponseBody.ContainerInstanceList] = []
            for v in dict["ContainerInstanceList"] as! [Any] {
                var model = DescribeContainerInstancesResponseBody.ContainerInstanceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.containerInstanceList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeContainerInstancesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeContainerInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContainerInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeContainerInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContainerScanConfigRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeContainerScanConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var allCount: Int32?

        public var appNames: String?

        public var chooseCount: Int32?

        public var clusterId: String?

        public var clusterName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allCount != nil {
                map["AllCount"] = self.allCount!
            }
            if self.appNames != nil {
                map["AppNames"] = self.appNames!
            }
            if self.chooseCount != nil {
                map["ChooseCount"] = self.chooseCount!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllCount") && dict["AllCount"] != nil {
                self.allCount = dict["AllCount"] as! Int32
            }
            if dict.keys.contains("AppNames") && dict["AppNames"] != nil {
                self.appNames = dict["AppNames"] as! String
            }
            if dict.keys.contains("ChooseCount") && dict["ChooseCount"] != nil {
                self.chooseCount = dict["ChooseCount"] as! Int32
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
        }
    }
    public var data: DescribeContainerScanConfigResponseBody.Data?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeContainerScanConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeContainerScanConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContainerScanConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeContainerScanConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContainerStatisticsRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class DescribeContainerStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var remindAlarmCount: Int32?

        public var seriousAlarmCount: Int32?

        public var suspiciousAlarmCount: Int32?

        public var totalAlarmCount: Int32?

        public var totalNode: Int32?

        public var hasRiskNode: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.remindAlarmCount != nil {
                map["RemindAlarmCount"] = self.remindAlarmCount!
            }
            if self.seriousAlarmCount != nil {
                map["SeriousAlarmCount"] = self.seriousAlarmCount!
            }
            if self.suspiciousAlarmCount != nil {
                map["SuspiciousAlarmCount"] = self.suspiciousAlarmCount!
            }
            if self.totalAlarmCount != nil {
                map["TotalAlarmCount"] = self.totalAlarmCount!
            }
            if self.totalNode != nil {
                map["TotalNode"] = self.totalNode!
            }
            if self.hasRiskNode != nil {
                map["hasRiskNode"] = self.hasRiskNode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RemindAlarmCount") && dict["RemindAlarmCount"] != nil {
                self.remindAlarmCount = dict["RemindAlarmCount"] as! Int32
            }
            if dict.keys.contains("SeriousAlarmCount") && dict["SeriousAlarmCount"] != nil {
                self.seriousAlarmCount = dict["SeriousAlarmCount"] as! Int32
            }
            if dict.keys.contains("SuspiciousAlarmCount") && dict["SuspiciousAlarmCount"] != nil {
                self.suspiciousAlarmCount = dict["SuspiciousAlarmCount"] as! Int32
            }
            if dict.keys.contains("TotalAlarmCount") && dict["TotalAlarmCount"] != nil {
                self.totalAlarmCount = dict["TotalAlarmCount"] as! Int32
            }
            if dict.keys.contains("TotalNode") && dict["TotalNode"] != nil {
                self.totalNode = dict["TotalNode"] as! Int32
            }
            if dict.keys.contains("hasRiskNode") && dict["hasRiskNode"] != nil {
                self.hasRiskNode = dict["hasRiskNode"] as! Int32
            }
        }
    }
    public var data: DescribeContainerStatisticsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeContainerStatisticsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeContainerStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContainerStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeContainerStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeContainerTagsRequest : Tea.TeaModel {
    public var appName: String?

    public var clusterId: String?

    public var currentPage: Int32?

    public var fieldName: String?

    public var fieldValue: String?

    public var namespace: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.fieldName != nil {
            map["FieldName"] = self.fieldName!
        }
        if self.fieldValue != nil {
            map["FieldValue"] = self.fieldValue!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("FieldName") && dict["FieldName"] != nil {
            self.fieldName = dict["FieldName"] as! String
        }
        if dict.keys.contains("FieldValue") && dict["FieldValue"] != nil {
            self.fieldValue = dict["FieldValue"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeContainerTagsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var tagValues: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagValues != nil {
            map["TagValues"] = self.tagValues!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagValues") && dict["TagValues"] != nil {
            self.tagValues = dict["TagValues"] as! [String]
        }
    }
}

public class DescribeContainerTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeContainerTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeContainerTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCountNotScannedImageResponseBody : Tea.TeaModel {
    public var notScannedCnt: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notScannedCnt != nil {
            map["NotScannedCnt"] = self.notScannedCnt!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotScannedCnt") && dict["NotScannedCnt"] != nil {
            self.notScannedCnt = dict["NotScannedCnt"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCountNotScannedImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCountNotScannedImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCountNotScannedImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCountScannedImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scannedCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scannedCount != nil {
            map["ScannedCount"] = self.scannedCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScannedCount") && dict["ScannedCount"] != nil {
            self.scannedCount = dict["ScannedCount"] as! Int32
        }
    }
}

public class DescribeCountScannedImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCountScannedImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCountScannedImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCriteriaRequest : Tea.TeaModel {
    public var machineTypes: String?

    public var supportAutoTag: Bool?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.machineTypes != nil {
            map["MachineTypes"] = self.machineTypes!
        }
        if self.supportAutoTag != nil {
            map["SupportAutoTag"] = self.supportAutoTag!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MachineTypes") && dict["MachineTypes"] != nil {
            self.machineTypes = dict["MachineTypes"] as! String
        }
        if dict.keys.contains("SupportAutoTag") && dict["SupportAutoTag"] != nil {
            self.supportAutoTag = dict["SupportAutoTag"] as! Bool
        }
        if dict.keys.contains("Value") && dict["Value"] != nil {
            self.value = dict["Value"] as! String
        }
    }
}

public class DescribeCriteriaResponseBody : Tea.TeaModel {
    public class CriteriaList : Tea.TeaModel {
        public var multiValues: String?

        public var name: String?

        public var type: String?

        public var values: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.multiValues != nil {
                map["MultiValues"] = self.multiValues!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MultiValues") && dict["MultiValues"] != nil {
                self.multiValues = dict["MultiValues"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Values") && dict["Values"] != nil {
                self.values = dict["Values"] as! String
            }
        }
    }
    public var criteriaList: [DescribeCriteriaResponseBody.CriteriaList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteriaList != nil {
            var tmp : [Any] = []
            for k in self.criteriaList! {
                tmp.append(k.toMap())
            }
            map["CriteriaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CriteriaList") && dict["CriteriaList"] != nil {
            var tmp : [DescribeCriteriaResponseBody.CriteriaList] = []
            for v in dict["CriteriaList"] as! [Any] {
                var model = DescribeCriteriaResponseBody.CriteriaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.criteriaList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCriteriaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCriteriaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCriteriaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomBlockRecordsRequest : Tea.TeaModel {
    public var blockIp: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resourceOwnerId: Int64?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockIp != nil {
            map["BlockIp"] = self.blockIp!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockIp") && dict["BlockIp"] != nil {
            self.blockIp = dict["BlockIp"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class DescribeCustomBlockRecordsResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class RecordList : Tea.TeaModel {
        public class TargetList : Tea.TeaModel {
            public var target: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.target != nil {
                    map["Target"] = self.target!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Target") && dict["Target"] != nil {
                    self.target = dict["Target"] as! String
                }
                if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                    self.targetType = dict["TargetType"] as! String
                }
            }
        }
        public var blockExpireDate: Int64?

        public var blockIp: String?

        public var bound: String?

        public var enableCount: Int32?

        public var id: Int64?

        public var serverCount: Int32?

        public var source: String?

        public var status: Int32?

        public var targetList: [DescribeCustomBlockRecordsResponseBody.RecordList.TargetList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blockExpireDate != nil {
                map["BlockExpireDate"] = self.blockExpireDate!
            }
            if self.blockIp != nil {
                map["BlockIp"] = self.blockIp!
            }
            if self.bound != nil {
                map["Bound"] = self.bound!
            }
            if self.enableCount != nil {
                map["EnableCount"] = self.enableCount!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.serverCount != nil {
                map["ServerCount"] = self.serverCount!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.targetList != nil {
                var tmp : [Any] = []
                for k in self.targetList! {
                    tmp.append(k.toMap())
                }
                map["TargetList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlockExpireDate") && dict["BlockExpireDate"] != nil {
                self.blockExpireDate = dict["BlockExpireDate"] as! Int64
            }
            if dict.keys.contains("BlockIp") && dict["BlockIp"] != nil {
                self.blockIp = dict["BlockIp"] as! String
            }
            if dict.keys.contains("Bound") && dict["Bound"] != nil {
                self.bound = dict["Bound"] as! String
            }
            if dict.keys.contains("EnableCount") && dict["EnableCount"] != nil {
                self.enableCount = dict["EnableCount"] as! Int32
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ServerCount") && dict["ServerCount"] != nil {
                self.serverCount = dict["ServerCount"] as! Int32
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TargetList") && dict["TargetList"] != nil {
                var tmp : [DescribeCustomBlockRecordsResponseBody.RecordList.TargetList] = []
                for v in dict["TargetList"] as! [Any] {
                    var model = DescribeCustomBlockRecordsResponseBody.RecordList.TargetList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.targetList = tmp
            }
        }
    }
    public var pageInfo: DescribeCustomBlockRecordsResponseBody.PageInfo?

    public var recordList: [DescribeCustomBlockRecordsResponseBody.RecordList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.recordList != nil {
            var tmp : [Any] = []
            for k in self.recordList! {
                tmp.append(k.toMap())
            }
            map["RecordList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeCustomBlockRecordsResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RecordList") && dict["RecordList"] != nil {
            var tmp : [DescribeCustomBlockRecordsResponseBody.RecordList] = []
            for v in dict["RecordList"] as! [Any] {
                var model = DescribeCustomBlockRecordsResponseBody.RecordList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCustomBlockRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomBlockRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCustomBlockRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCycleTaskListRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var taskName: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class DescribeCycleTaskListResponseBody : Tea.TeaModel {
    public class CycleScheduleResponseList : Tea.TeaModel {
        public var configId: String?

        public var enable: Int32?

        public var firstDateStr: Int64?

        public var intervalPeriod: Int32?

        public var lastTaskId: String?

        public var nextStartTimeStr: Int64?

        public var param: String?

        public var periodUnit: String?

        public var targetEndTime: Int32?

        public var targetStartTime: Int32?

        public var taskName: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configId != nil {
                map["ConfigId"] = self.configId!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.firstDateStr != nil {
                map["FirstDateStr"] = self.firstDateStr!
            }
            if self.intervalPeriod != nil {
                map["IntervalPeriod"] = self.intervalPeriod!
            }
            if self.lastTaskId != nil {
                map["LastTaskId"] = self.lastTaskId!
            }
            if self.nextStartTimeStr != nil {
                map["NextStartTimeStr"] = self.nextStartTimeStr!
            }
            if self.param != nil {
                map["Param"] = self.param!
            }
            if self.periodUnit != nil {
                map["PeriodUnit"] = self.periodUnit!
            }
            if self.targetEndTime != nil {
                map["TargetEndTime"] = self.targetEndTime!
            }
            if self.targetStartTime != nil {
                map["TargetStartTime"] = self.targetStartTime!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigId") && dict["ConfigId"] != nil {
                self.configId = dict["ConfigId"] as! String
            }
            if dict.keys.contains("Enable") && dict["Enable"] != nil {
                self.enable = dict["Enable"] as! Int32
            }
            if dict.keys.contains("FirstDateStr") && dict["FirstDateStr"] != nil {
                self.firstDateStr = dict["FirstDateStr"] as! Int64
            }
            if dict.keys.contains("IntervalPeriod") && dict["IntervalPeriod"] != nil {
                self.intervalPeriod = dict["IntervalPeriod"] as! Int32
            }
            if dict.keys.contains("LastTaskId") && dict["LastTaskId"] != nil {
                self.lastTaskId = dict["LastTaskId"] as! String
            }
            if dict.keys.contains("NextStartTimeStr") && dict["NextStartTimeStr"] != nil {
                self.nextStartTimeStr = dict["NextStartTimeStr"] as! Int64
            }
            if dict.keys.contains("Param") && dict["Param"] != nil {
                self.param = dict["Param"] as! String
            }
            if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
                self.periodUnit = dict["PeriodUnit"] as! String
            }
            if dict.keys.contains("TargetEndTime") && dict["TargetEndTime"] != nil {
                self.targetEndTime = dict["TargetEndTime"] as! Int32
            }
            if dict.keys.contains("TargetStartTime") && dict["TargetStartTime"] != nil {
                self.targetStartTime = dict["TargetStartTime"] as! Int32
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var cycleScheduleResponseList: [DescribeCycleTaskListResponseBody.CycleScheduleResponseList]?

    public var pageInfo: DescribeCycleTaskListResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cycleScheduleResponseList != nil {
            var tmp : [Any] = []
            for k in self.cycleScheduleResponseList! {
                tmp.append(k.toMap())
            }
            map["CycleScheduleResponseList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CycleScheduleResponseList") && dict["CycleScheduleResponseList"] != nil {
            var tmp : [DescribeCycleTaskListResponseBody.CycleScheduleResponseList] = []
            for v in dict["CycleScheduleResponseList"] as! [Any] {
                var model = DescribeCycleTaskListResponseBody.CycleScheduleResponseList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cycleScheduleResponseList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeCycleTaskListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCycleTaskListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCycleTaskListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCycleTaskListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDingTalkRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var ruleActionName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ruleActionName != nil {
            map["RuleActionName"] = self.ruleActionName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RuleActionName") && dict["RuleActionName"] != nil {
            self.ruleActionName = dict["RuleActionName"] as! String
        }
    }
}

public class DescribeDingTalkResponseBody : Tea.TeaModel {
    public class ActionList : Tea.TeaModel {
        public var actionName: String?

        public var aliUid: Int64?

        public var configList: String?

        public var dingTalkLang: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var groupIdList: String?

        public var id: Int32?

        public var intervalTime: Int32?

        public var status: Int32?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionName != nil {
                map["ActionName"] = self.actionName!
            }
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.configList != nil {
                map["ConfigList"] = self.configList!
            }
            if self.dingTalkLang != nil {
                map["DingTalkLang"] = self.dingTalkLang!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.groupIdList != nil {
                map["GroupIdList"] = self.groupIdList!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.intervalTime != nil {
                map["IntervalTime"] = self.intervalTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionName") && dict["ActionName"] != nil {
                self.actionName = dict["ActionName"] as! String
            }
            if dict.keys.contains("AliUid") && dict["AliUid"] != nil {
                self.aliUid = dict["AliUid"] as! Int64
            }
            if dict.keys.contains("ConfigList") && dict["ConfigList"] != nil {
                self.configList = dict["ConfigList"] as! String
            }
            if dict.keys.contains("DingTalkLang") && dict["DingTalkLang"] != nil {
                self.dingTalkLang = dict["DingTalkLang"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("GroupIdList") && dict["GroupIdList"] != nil {
                self.groupIdList = dict["GroupIdList"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("IntervalTime") && dict["IntervalTime"] != nil {
                self.intervalTime = dict["IntervalTime"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var actionList: [DescribeDingTalkResponseBody.ActionList]?

    public var pageInfo: DescribeDingTalkResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionList != nil {
            var tmp : [Any] = []
            for k in self.actionList! {
                tmp.append(k.toMap())
            }
            map["ActionList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionList") && dict["ActionList"] != nil {
            var tmp : [DescribeDingTalkResponseBody.ActionList] = []
            for v in dict["ActionList"] as! [Any] {
                var model = DescribeDingTalkResponseBody.ActionList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.actionList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeDingTalkResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDingTalkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDingTalkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDingTalkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainCountRequest : Tea.TeaModel {
    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeDomainCountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var rootDomainsCount: Int32?

    public var subDomainsCount: Int32?

    public var totalDomainsCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rootDomainsCount != nil {
            map["RootDomainsCount"] = self.rootDomainsCount!
        }
        if self.subDomainsCount != nil {
            map["SubDomainsCount"] = self.subDomainsCount!
        }
        if self.totalDomainsCount != nil {
            map["TotalDomainsCount"] = self.totalDomainsCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RootDomainsCount") && dict["RootDomainsCount"] != nil {
            self.rootDomainsCount = dict["RootDomainsCount"] as! Int32
        }
        if dict.keys.contains("SubDomainsCount") && dict["SubDomainsCount"] != nil {
            self.subDomainsCount = dict["SubDomainsCount"] as! Int32
        }
        if dict.keys.contains("TotalDomainsCount") && dict["TotalDomainsCount"] != nil {
            self.totalDomainsCount = dict["TotalDomainsCount"] as! Int32
        }
    }
}

public class DescribeDomainCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDomainCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainDetailRequest : Tea.TeaModel {
    public var domainName: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeDomainDetailResponseBody : Tea.TeaModel {
    public class DomainDetailItems : Tea.TeaModel {
        public var assetType: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assetType != nil {
                map["AssetType"] = self.assetType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
                self.assetType = dict["AssetType"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var alarmCount: Int32?

    public var domain: String?

    public var domainDetailItems: [DescribeDomainDetailResponseBody.DomainDetailItems]?

    public var requestId: String?

    public var rootDomain: String?

    public var vulCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmCount != nil {
            map["AlarmCount"] = self.alarmCount!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.domainDetailItems != nil {
            var tmp : [Any] = []
            for k in self.domainDetailItems! {
                tmp.append(k.toMap())
            }
            map["DomainDetailItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rootDomain != nil {
            map["RootDomain"] = self.rootDomain!
        }
        if self.vulCount != nil {
            map["VulCount"] = self.vulCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmCount") && dict["AlarmCount"] != nil {
            self.alarmCount = dict["AlarmCount"] as! Int32
        }
        if dict.keys.contains("Domain") && dict["Domain"] != nil {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("DomainDetailItems") && dict["DomainDetailItems"] != nil {
            var tmp : [DescribeDomainDetailResponseBody.DomainDetailItems] = []
            for v in dict["DomainDetailItems"] as! [Any] {
                var model = DescribeDomainDetailResponseBody.DomainDetailItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.domainDetailItems = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RootDomain") && dict["RootDomain"] != nil {
            self.rootDomain = dict["RootDomain"] as! String
        }
        if dict.keys.contains("VulCount") && dict["VulCount"] != nil {
            self.vulCount = dict["VulCount"] as! Int32
        }
    }
}

public class DescribeDomainDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDomainDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainListRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var domainType: String?

    public var fuzzyDomain: String?

    public var pageSize: Int32?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.domainType != nil {
            map["DomainType"] = self.domainType!
        }
        if self.fuzzyDomain != nil {
            map["FuzzyDomain"] = self.fuzzyDomain!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("DomainType") && dict["DomainType"] != nil {
            self.domainType = dict["DomainType"] as! String
        }
        if dict.keys.contains("FuzzyDomain") && dict["FuzzyDomain"] != nil {
            self.fuzzyDomain = dict["FuzzyDomain"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeDomainListResponseBody : Tea.TeaModel {
    public class DomainListResponseList : Tea.TeaModel {
        public var domain: String?

        public var ipList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.ipList != nil {
                map["IpList"] = self.ipList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domain") && dict["Domain"] != nil {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("IpList") && dict["IpList"] != nil {
                self.ipList = dict["IpList"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var domainListResponseList: [DescribeDomainListResponseBody.DomainListResponseList]?

    public var pageInfo: DescribeDomainListResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainListResponseList != nil {
            var tmp : [Any] = []
            for k in self.domainListResponseList! {
                tmp.append(k.toMap())
            }
            map["DomainListResponseList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainListResponseList") && dict["DomainListResponseList"] != nil {
            var tmp : [DescribeDomainListResponseBody.DomainListResponseList] = []
            for v in dict["DomainListResponseList"] as! [Any] {
                var model = DescribeDomainListResponseBody.DomainListResponseList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.domainListResponseList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeDomainListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDomainListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeDomainListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEmgUserAgreementResponseBody : Tea.TeaModel {
    public var auth: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auth != nil {
            map["Auth"] = self.auth!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Auth") && dict["Auth"] != nil {
            self.auth = dict["Auth"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEmgUserAgreementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEmgUserAgreementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEmgUserAgreementResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEmgVulItemRequest : Tea.TeaModel {
    public var checkType: Int32?

    public var currentPage: Int32?

    public var lang: String?

    public var pageSize: Int32?

    public var riskStatus: String?

    public var scanType: String?

    public var vulName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkType != nil {
            map["CheckType"] = self.checkType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskStatus != nil {
            map["RiskStatus"] = self.riskStatus!
        }
        if self.scanType != nil {
            map["ScanType"] = self.scanType!
        }
        if self.vulName != nil {
            map["VulName"] = self.vulName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckType") && dict["CheckType"] != nil {
            self.checkType = dict["CheckType"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
            self.riskStatus = dict["RiskStatus"] as! String
        }
        if dict.keys.contains("ScanType") && dict["ScanType"] != nil {
            self.scanType = dict["ScanType"] as! String
        }
        if dict.keys.contains("VulName") && dict["VulName"] != nil {
            self.vulName = dict["VulName"] as! String
        }
    }
}

public class DescribeEmgVulItemResponseBody : Tea.TeaModel {
    public class GroupedVulItems : Tea.TeaModel {
        public var aliasName: String?

        public var checkType: Int32?

        public var gmtLastCheck: Int64?

        public var gmtPublish: Int64?

        public var name: String?

        public var pendingCount: Int32?

        public var progress: Int32?

        public var raspDefend: Int32?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.checkType != nil {
                map["CheckType"] = self.checkType!
            }
            if self.gmtLastCheck != nil {
                map["GmtLastCheck"] = self.gmtLastCheck!
            }
            if self.gmtPublish != nil {
                map["GmtPublish"] = self.gmtPublish!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pendingCount != nil {
                map["PendingCount"] = self.pendingCount!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.raspDefend != nil {
                map["RaspDefend"] = self.raspDefend!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                self.aliasName = dict["AliasName"] as! String
            }
            if dict.keys.contains("CheckType") && dict["CheckType"] != nil {
                self.checkType = dict["CheckType"] as! Int32
            }
            if dict.keys.contains("GmtLastCheck") && dict["GmtLastCheck"] != nil {
                self.gmtLastCheck = dict["GmtLastCheck"] as! Int64
            }
            if dict.keys.contains("GmtPublish") && dict["GmtPublish"] != nil {
                self.gmtPublish = dict["GmtPublish"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PendingCount") && dict["PendingCount"] != nil {
                self.pendingCount = dict["PendingCount"] as! Int32
            }
            if dict.keys.contains("Progress") && dict["Progress"] != nil {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("RaspDefend") && dict["RaspDefend"] != nil {
                self.raspDefend = dict["RaspDefend"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var groupedVulItems: [DescribeEmgVulItemResponseBody.GroupedVulItems]?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.groupedVulItems != nil {
            var tmp : [Any] = []
            for k in self.groupedVulItems! {
                tmp.append(k.toMap())
            }
            map["GroupedVulItems"] = tmp
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("GroupedVulItems") && dict["GroupedVulItems"] != nil {
            var tmp : [DescribeEmgVulItemResponseBody.GroupedVulItems] = []
            for v in dict["GroupedVulItems"] as! [Any] {
                var model = DescribeEmgVulItemResponseBody.GroupedVulItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groupedVulItems = tmp
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEmgVulItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEmgVulItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEmgVulItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventLevelCountRequest : Tea.TeaModel {
    public var clusterId: String?

    public var containerFieldName: String?

    public var containerFieldValue: String?

    public var containerIds: String?

    public var from: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.containerFieldName != nil {
            map["ContainerFieldName"] = self.containerFieldName!
        }
        if self.containerFieldValue != nil {
            map["ContainerFieldValue"] = self.containerFieldValue!
        }
        if self.containerIds != nil {
            map["ContainerIds"] = self.containerIds!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ContainerFieldName") && dict["ContainerFieldName"] != nil {
            self.containerFieldName = dict["ContainerFieldName"] as! String
        }
        if dict.keys.contains("ContainerFieldValue") && dict["ContainerFieldValue"] != nil {
            self.containerFieldValue = dict["ContainerFieldValue"] as! String
        }
        if dict.keys.contains("ContainerIds") && dict["ContainerIds"] != nil {
            self.containerIds = dict["ContainerIds"] as! String
        }
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class DescribeEventLevelCountResponseBody : Tea.TeaModel {
    public class EventLevels : Tea.TeaModel {
        public var remind: Int32?

        public var serious: Int32?

        public var suspicious: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.remind != nil {
                map["Remind"] = self.remind!
            }
            if self.serious != nil {
                map["Serious"] = self.serious!
            }
            if self.suspicious != nil {
                map["Suspicious"] = self.suspicious!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Remind") && dict["Remind"] != nil {
                self.remind = dict["Remind"] as! Int32
            }
            if dict.keys.contains("Serious") && dict["Serious"] != nil {
                self.serious = dict["Serious"] as! Int32
            }
            if dict.keys.contains("Suspicious") && dict["Suspicious"] != nil {
                self.suspicious = dict["Suspicious"] as! Int32
            }
        }
    }
    public var code: String?

    public var eventLevels: DescribeEventLevelCountResponseBody.EventLevels?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventLevels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.eventLevels != nil {
            map["EventLevels"] = self.eventLevels?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("EventLevels") && dict["EventLevels"] != nil {
            var model = DescribeEventLevelCountResponseBody.EventLevels()
            model.fromMap(dict["EventLevels"] as! [String: Any])
            self.eventLevels = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEventLevelCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventLevelCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEventLevelCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEventOnStageRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeEventOnStageResponseBody : Tea.TeaModel {
    public class SecurityEventStageResponse : Tea.TeaModel {
        public var securityEventOnStag: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityEventOnStag != nil {
                map["SecurityEventOnStag"] = self.securityEventOnStag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityEventOnStag") && dict["SecurityEventOnStag"] != nil {
                self.securityEventOnStag = dict["SecurityEventOnStag"] as! [String: Any]
            }
        }
    }
    public var requestId: String?

    public var securityEventStageResponse: DescribeEventOnStageResponseBody.SecurityEventStageResponse?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityEventStageResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityEventStageResponse != nil {
            map["SecurityEventStageResponse"] = self.securityEventStageResponse?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityEventStageResponse") && dict["SecurityEventStageResponse"] != nil {
            var model = DescribeEventOnStageResponseBody.SecurityEventStageResponse()
            model.fromMap(dict["SecurityEventStageResponse"] as! [String: Any])
            self.securityEventStageResponse = model
        }
    }
}

public class DescribeEventOnStageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEventOnStageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEventOnStageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExcludeSystemPathRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeExcludeSystemPathResponseBody : Tea.TeaModel {
    public class ExcludePaths : Tea.TeaModel {
        public var os: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var excludePaths: [DescribeExcludeSystemPathResponseBody.ExcludePaths]?

    public var pageInfo: DescribeExcludeSystemPathResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.excludePaths != nil {
            var tmp : [Any] = []
            for k in self.excludePaths! {
                tmp.append(k.toMap())
            }
            map["ExcludePaths"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExcludePaths") && dict["ExcludePaths"] != nil {
            var tmp : [DescribeExcludeSystemPathResponseBody.ExcludePaths] = []
            for v in dict["ExcludePaths"] as! [Any] {
                var model = DescribeExcludeSystemPathResponseBody.ExcludePaths()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.excludePaths = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeExcludeSystemPathResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeExcludeSystemPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExcludeSystemPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExcludeSystemPathResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExportInfoRequest : Tea.TeaModel {
    public var exportId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exportId != nil {
            map["ExportId"] = self.exportId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExportId") && dict["ExportId"] != nil {
            self.exportId = dict["ExportId"] as! Int64
        }
    }
}

public class DescribeExportInfoResponseBody : Tea.TeaModel {
    public var currentCount: Int32?

    public var exportStatus: String?

    public var fileName: String?

    public var id: Int64?

    public var link: String?

    public var message: String?

    public var progress: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentCount != nil {
            map["CurrentCount"] = self.currentCount!
        }
        if self.exportStatus != nil {
            map["ExportStatus"] = self.exportStatus!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.link != nil {
            map["Link"] = self.link!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.progress != nil {
            map["Progress"] = self.progress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentCount") && dict["CurrentCount"] != nil {
            self.currentCount = dict["CurrentCount"] as! Int32
        }
        if dict.keys.contains("ExportStatus") && dict["ExportStatus"] != nil {
            self.exportStatus = dict["ExportStatus"] as! String
        }
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Link") && dict["Link"] != nil {
            self.link = dict["Link"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Progress") && dict["Progress"] != nil {
            self.progress = dict["Progress"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeExportInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExportInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExportInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExposedCheckWarningRequest : Tea.TeaModel {
    public var lang: String?

    public var typeName: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.typeName != nil {
            map["TypeName"] = self.typeName!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
            self.typeName = dict["TypeName"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeExposedCheckWarningResponseBody : Tea.TeaModel {
    public class WarningList : Tea.TeaModel {
        public var riskId: Int64?

        public var riskName: String?

        public var subTypeAlias: String?

        public var typeAlias_: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.riskId != nil {
                map["RiskId"] = self.riskId!
            }
            if self.riskName != nil {
                map["RiskName"] = self.riskName!
            }
            if self.subTypeAlias != nil {
                map["SubTypeAlias"] = self.subTypeAlias!
            }
            if self.typeAlias_ != nil {
                map["TypeAlias"] = self.typeAlias_!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
                self.riskId = dict["RiskId"] as! Int64
            }
            if dict.keys.contains("RiskName") && dict["RiskName"] != nil {
                self.riskName = dict["RiskName"] as! String
            }
            if dict.keys.contains("SubTypeAlias") && dict["SubTypeAlias"] != nil {
                self.subTypeAlias = dict["SubTypeAlias"] as! String
            }
            if dict.keys.contains("TypeAlias") && dict["TypeAlias"] != nil {
                self.typeAlias_ = dict["TypeAlias"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var count: Int32?

    public var requestId: String?

    public var warningList: [DescribeExposedCheckWarningResponseBody.WarningList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.warningList != nil {
            var tmp : [Any] = []
            for k in self.warningList! {
                tmp.append(k.toMap())
            }
            map["WarningList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WarningList") && dict["WarningList"] != nil {
            var tmp : [DescribeExposedCheckWarningResponseBody.WarningList] = []
            for v in dict["WarningList"] as! [Any] {
                var model = DescribeExposedCheckWarningResponseBody.WarningList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.warningList = tmp
        }
    }
}

public class DescribeExposedCheckWarningResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExposedCheckWarningResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExposedCheckWarningResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExposedInstanceCriteriaRequest : Tea.TeaModel {
    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Value") && dict["Value"] != nil {
            self.value = dict["Value"] as! String
        }
    }
}

public class DescribeExposedInstanceCriteriaResponseBody : Tea.TeaModel {
    public class CriteriaList : Tea.TeaModel {
        public var name: String?

        public var type: String?

        public var values: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Values") && dict["Values"] != nil {
                self.values = dict["Values"] as! String
            }
        }
    }
    public var criteriaList: [DescribeExposedInstanceCriteriaResponseBody.CriteriaList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteriaList != nil {
            var tmp : [Any] = []
            for k in self.criteriaList! {
                tmp.append(k.toMap())
            }
            map["CriteriaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CriteriaList") && dict["CriteriaList"] != nil {
            var tmp : [DescribeExposedInstanceCriteriaResponseBody.CriteriaList] = []
            for v in dict["CriteriaList"] as! [Any] {
                var model = DescribeExposedInstanceCriteriaResponseBody.CriteriaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.criteriaList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeExposedInstanceCriteriaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExposedInstanceCriteriaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExposedInstanceCriteriaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExposedInstanceDetailRequest : Tea.TeaModel {
    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeExposedInstanceDetailResponseBody : Tea.TeaModel {
    public class ExposedChains : Tea.TeaModel {
        public class AllVulList : Tea.TeaModel {
            public var aliasName: String?

            public var name: String?

            public var necessity: String?

            public var type: String?

            public var uuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliasName != nil {
                    map["AliasName"] = self.aliasName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.necessity != nil {
                    map["Necessity"] = self.necessity!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.uuid != nil {
                    map["Uuid"] = self.uuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                    self.aliasName = dict["AliasName"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
                    self.necessity = dict["Necessity"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                    self.uuid = dict["Uuid"] as! String
                }
            }
        }
        public class RealVulList : Tea.TeaModel {
            public var aliasName: String?

            public var name: String?

            public var necessity: String?

            public var type: String?

            public var uuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliasName != nil {
                    map["AliasName"] = self.aliasName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.necessity != nil {
                    map["Necessity"] = self.necessity!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.uuid != nil {
                    map["Uuid"] = self.uuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                    self.aliasName = dict["AliasName"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
                    self.necessity = dict["Necessity"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                    self.uuid = dict["Uuid"] as! String
                }
            }
        }
        public var allVulList: [DescribeExposedInstanceDetailResponseBody.ExposedChains.AllVulList]?

        public var exposureComponent: String?

        public var exposureIp: String?

        public var exposurePort: String?

        public var exposureType: String?

        public var exposureTypeId: String?

        public var groupNo: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var realVulList: [DescribeExposedInstanceDetailResponseBody.ExposedChains.RealVulList]?

        public var regionId: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allVulList != nil {
                var tmp : [Any] = []
                for k in self.allVulList! {
                    tmp.append(k.toMap())
                }
                map["AllVulList"] = tmp
            }
            if self.exposureComponent != nil {
                map["ExposureComponent"] = self.exposureComponent!
            }
            if self.exposureIp != nil {
                map["ExposureIp"] = self.exposureIp!
            }
            if self.exposurePort != nil {
                map["ExposurePort"] = self.exposurePort!
            }
            if self.exposureType != nil {
                map["ExposureType"] = self.exposureType!
            }
            if self.exposureTypeId != nil {
                map["ExposureTypeId"] = self.exposureTypeId!
            }
            if self.groupNo != nil {
                map["GroupNo"] = self.groupNo!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.realVulList != nil {
                var tmp : [Any] = []
                for k in self.realVulList! {
                    tmp.append(k.toMap())
                }
                map["RealVulList"] = tmp
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllVulList") && dict["AllVulList"] != nil {
                var tmp : [DescribeExposedInstanceDetailResponseBody.ExposedChains.AllVulList] = []
                for v in dict["AllVulList"] as! [Any] {
                    var model = DescribeExposedInstanceDetailResponseBody.ExposedChains.AllVulList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.allVulList = tmp
            }
            if dict.keys.contains("ExposureComponent") && dict["ExposureComponent"] != nil {
                self.exposureComponent = dict["ExposureComponent"] as! String
            }
            if dict.keys.contains("ExposureIp") && dict["ExposureIp"] != nil {
                self.exposureIp = dict["ExposureIp"] as! String
            }
            if dict.keys.contains("ExposurePort") && dict["ExposurePort"] != nil {
                self.exposurePort = dict["ExposurePort"] as! String
            }
            if dict.keys.contains("ExposureType") && dict["ExposureType"] != nil {
                self.exposureType = dict["ExposureType"] as! String
            }
            if dict.keys.contains("ExposureTypeId") && dict["ExposureTypeId"] != nil {
                self.exposureTypeId = dict["ExposureTypeId"] as! String
            }
            if dict.keys.contains("GroupNo") && dict["GroupNo"] != nil {
                self.groupNo = dict["GroupNo"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("RealVulList") && dict["RealVulList"] != nil {
                var tmp : [DescribeExposedInstanceDetailResponseBody.ExposedChains.RealVulList] = []
                for v in dict["RealVulList"] as! [Any] {
                    var model = DescribeExposedInstanceDetailResponseBody.ExposedChains.RealVulList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.realVulList = tmp
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var exposedChains: [DescribeExposedInstanceDetailResponseBody.ExposedChains]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exposedChains != nil {
            var tmp : [Any] = []
            for k in self.exposedChains! {
                tmp.append(k.toMap())
            }
            map["ExposedChains"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExposedChains") && dict["ExposedChains"] != nil {
            var tmp : [DescribeExposedInstanceDetailResponseBody.ExposedChains] = []
            for v in dict["ExposedChains"] as! [Any] {
                var model = DescribeExposedInstanceDetailResponseBody.ExposedChains()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.exposedChains = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeExposedInstanceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExposedInstanceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExposedInstanceDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExposedInstanceListRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var exposureComponent: String?

    public var exposureIp: String?

    public var exposurePort: String?

    public var groupId: Int64?

    public var healthStatus: Bool?

    public var instanceId: String?

    public var instanceName: String?

    public var pageSize: Int32?

    public var vulStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.exposureComponent != nil {
            map["ExposureComponent"] = self.exposureComponent!
        }
        if self.exposureIp != nil {
            map["ExposureIp"] = self.exposureIp!
        }
        if self.exposurePort != nil {
            map["ExposurePort"] = self.exposurePort!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.vulStatus != nil {
            map["VulStatus"] = self.vulStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ExposureComponent") && dict["ExposureComponent"] != nil {
            self.exposureComponent = dict["ExposureComponent"] as! String
        }
        if dict.keys.contains("ExposureIp") && dict["ExposureIp"] != nil {
            self.exposureIp = dict["ExposureIp"] as! String
        }
        if dict.keys.contains("ExposurePort") && dict["ExposurePort"] != nil {
            self.exposurePort = dict["ExposurePort"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
            self.healthStatus = dict["HealthStatus"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("VulStatus") && dict["VulStatus"] != nil {
            self.vulStatus = dict["VulStatus"] as! Bool
        }
    }
}

public class DescribeExposedInstanceListResponseBody : Tea.TeaModel {
    public class ExposedInstances : Tea.TeaModel {
        public var asapVulCount: Int32?

        public var exploitHealthCount: Int32?

        public var exposureComponent: String?

        public var exposureIp: String?

        public var exposurePort: String?

        public var exposureType: String?

        public var exposureTypeId: String?

        public var groupId: Int64?

        public var groupName: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var laterVulCount: Int32?

        public var nntfVulCount: Int32?

        public var regionId: String?

        public var totalVulCount: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asapVulCount != nil {
                map["AsapVulCount"] = self.asapVulCount!
            }
            if self.exploitHealthCount != nil {
                map["ExploitHealthCount"] = self.exploitHealthCount!
            }
            if self.exposureComponent != nil {
                map["ExposureComponent"] = self.exposureComponent!
            }
            if self.exposureIp != nil {
                map["ExposureIp"] = self.exposureIp!
            }
            if self.exposurePort != nil {
                map["ExposurePort"] = self.exposurePort!
            }
            if self.exposureType != nil {
                map["ExposureType"] = self.exposureType!
            }
            if self.exposureTypeId != nil {
                map["ExposureTypeId"] = self.exposureTypeId!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.laterVulCount != nil {
                map["LaterVulCount"] = self.laterVulCount!
            }
            if self.nntfVulCount != nil {
                map["NntfVulCount"] = self.nntfVulCount!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.totalVulCount != nil {
                map["TotalVulCount"] = self.totalVulCount!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsapVulCount") && dict["AsapVulCount"] != nil {
                self.asapVulCount = dict["AsapVulCount"] as! Int32
            }
            if dict.keys.contains("ExploitHealthCount") && dict["ExploitHealthCount"] != nil {
                self.exploitHealthCount = dict["ExploitHealthCount"] as! Int32
            }
            if dict.keys.contains("ExposureComponent") && dict["ExposureComponent"] != nil {
                self.exposureComponent = dict["ExposureComponent"] as! String
            }
            if dict.keys.contains("ExposureIp") && dict["ExposureIp"] != nil {
                self.exposureIp = dict["ExposureIp"] as! String
            }
            if dict.keys.contains("ExposurePort") && dict["ExposurePort"] != nil {
                self.exposurePort = dict["ExposurePort"] as! String
            }
            if dict.keys.contains("ExposureType") && dict["ExposureType"] != nil {
                self.exposureType = dict["ExposureType"] as! String
            }
            if dict.keys.contains("ExposureTypeId") && dict["ExposureTypeId"] != nil {
                self.exposureTypeId = dict["ExposureTypeId"] as! String
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LaterVulCount") && dict["LaterVulCount"] != nil {
                self.laterVulCount = dict["LaterVulCount"] as! Int32
            }
            if dict.keys.contains("NntfVulCount") && dict["NntfVulCount"] != nil {
                self.nntfVulCount = dict["NntfVulCount"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("TotalVulCount") && dict["TotalVulCount"] != nil {
                self.totalVulCount = dict["TotalVulCount"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var exposedInstances: [DescribeExposedInstanceListResponseBody.ExposedInstances]?

    public var pageInfo: DescribeExposedInstanceListResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exposedInstances != nil {
            var tmp : [Any] = []
            for k in self.exposedInstances! {
                tmp.append(k.toMap())
            }
            map["ExposedInstances"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExposedInstances") && dict["ExposedInstances"] != nil {
            var tmp : [DescribeExposedInstanceListResponseBody.ExposedInstances] = []
            for v in dict["ExposedInstances"] as! [Any] {
                var model = DescribeExposedInstanceListResponseBody.ExposedInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.exposedInstances = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeExposedInstanceListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeExposedInstanceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExposedInstanceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExposedInstanceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExposedStatisticsResponseBody : Tea.TeaModel {
    public var exposedAsapVulCount: Int32?

    public var exposedComponentCount: Int32?

    public var exposedInstanceCount: Int32?

    public var exposedIpCount: Int32?

    public var exposedLaterVulCount: Int32?

    public var exposedNntfVulCount: Int32?

    public var exposedPortCount: Int32?

    public var exposedWeekPasswordMachineCount: Int32?

    public var gatewayAssetCount: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exposedAsapVulCount != nil {
            map["ExposedAsapVulCount"] = self.exposedAsapVulCount!
        }
        if self.exposedComponentCount != nil {
            map["ExposedComponentCount"] = self.exposedComponentCount!
        }
        if self.exposedInstanceCount != nil {
            map["ExposedInstanceCount"] = self.exposedInstanceCount!
        }
        if self.exposedIpCount != nil {
            map["ExposedIpCount"] = self.exposedIpCount!
        }
        if self.exposedLaterVulCount != nil {
            map["ExposedLaterVulCount"] = self.exposedLaterVulCount!
        }
        if self.exposedNntfVulCount != nil {
            map["ExposedNntfVulCount"] = self.exposedNntfVulCount!
        }
        if self.exposedPortCount != nil {
            map["ExposedPortCount"] = self.exposedPortCount!
        }
        if self.exposedWeekPasswordMachineCount != nil {
            map["ExposedWeekPasswordMachineCount"] = self.exposedWeekPasswordMachineCount!
        }
        if self.gatewayAssetCount != nil {
            map["GatewayAssetCount"] = self.gatewayAssetCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExposedAsapVulCount") && dict["ExposedAsapVulCount"] != nil {
            self.exposedAsapVulCount = dict["ExposedAsapVulCount"] as! Int32
        }
        if dict.keys.contains("ExposedComponentCount") && dict["ExposedComponentCount"] != nil {
            self.exposedComponentCount = dict["ExposedComponentCount"] as! Int32
        }
        if dict.keys.contains("ExposedInstanceCount") && dict["ExposedInstanceCount"] != nil {
            self.exposedInstanceCount = dict["ExposedInstanceCount"] as! Int32
        }
        if dict.keys.contains("ExposedIpCount") && dict["ExposedIpCount"] != nil {
            self.exposedIpCount = dict["ExposedIpCount"] as! Int32
        }
        if dict.keys.contains("ExposedLaterVulCount") && dict["ExposedLaterVulCount"] != nil {
            self.exposedLaterVulCount = dict["ExposedLaterVulCount"] as! Int32
        }
        if dict.keys.contains("ExposedNntfVulCount") && dict["ExposedNntfVulCount"] != nil {
            self.exposedNntfVulCount = dict["ExposedNntfVulCount"] as! Int32
        }
        if dict.keys.contains("ExposedPortCount") && dict["ExposedPortCount"] != nil {
            self.exposedPortCount = dict["ExposedPortCount"] as! Int32
        }
        if dict.keys.contains("ExposedWeekPasswordMachineCount") && dict["ExposedWeekPasswordMachineCount"] != nil {
            self.exposedWeekPasswordMachineCount = dict["ExposedWeekPasswordMachineCount"] as! Int32
        }
        if dict.keys.contains("GatewayAssetCount") && dict["GatewayAssetCount"] != nil {
            self.gatewayAssetCount = dict["GatewayAssetCount"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeExposedStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExposedStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExposedStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExposedStatisticsDetailRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var statisticsType: String?

    public var statisticsTypeGatewayType: String?

    public var statisticsTypeInstanceValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.statisticsType != nil {
            map["StatisticsType"] = self.statisticsType!
        }
        if self.statisticsTypeGatewayType != nil {
            map["StatisticsTypeGatewayType"] = self.statisticsTypeGatewayType!
        }
        if self.statisticsTypeInstanceValue != nil {
            map["StatisticsTypeInstanceValue"] = self.statisticsTypeInstanceValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StatisticsType") && dict["StatisticsType"] != nil {
            self.statisticsType = dict["StatisticsType"] as! String
        }
        if dict.keys.contains("StatisticsTypeGatewayType") && dict["StatisticsTypeGatewayType"] != nil {
            self.statisticsTypeGatewayType = dict["StatisticsTypeGatewayType"] as! String
        }
        if dict.keys.contains("StatisticsTypeInstanceValue") && dict["StatisticsTypeInstanceValue"] != nil {
            self.statisticsTypeInstanceValue = dict["StatisticsTypeInstanceValue"] as! String
        }
    }
}

public class DescribeExposedStatisticsDetailResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class StatisticsDetails : Tea.TeaModel {
        public var exposedCount: Int32?

        public var exposureComponent: String?

        public var exposureIp: String?

        public var exposurePort: String?

        public var exposureType: String?

        public var exposureTypeId: String?

        public var exposureTypeInstanceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.exposedCount != nil {
                map["ExposedCount"] = self.exposedCount!
            }
            if self.exposureComponent != nil {
                map["ExposureComponent"] = self.exposureComponent!
            }
            if self.exposureIp != nil {
                map["ExposureIp"] = self.exposureIp!
            }
            if self.exposurePort != nil {
                map["ExposurePort"] = self.exposurePort!
            }
            if self.exposureType != nil {
                map["ExposureType"] = self.exposureType!
            }
            if self.exposureTypeId != nil {
                map["ExposureTypeId"] = self.exposureTypeId!
            }
            if self.exposureTypeInstanceName != nil {
                map["ExposureTypeInstanceName"] = self.exposureTypeInstanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExposedCount") && dict["ExposedCount"] != nil {
                self.exposedCount = dict["ExposedCount"] as! Int32
            }
            if dict.keys.contains("ExposureComponent") && dict["ExposureComponent"] != nil {
                self.exposureComponent = dict["ExposureComponent"] as! String
            }
            if dict.keys.contains("ExposureIp") && dict["ExposureIp"] != nil {
                self.exposureIp = dict["ExposureIp"] as! String
            }
            if dict.keys.contains("ExposurePort") && dict["ExposurePort"] != nil {
                self.exposurePort = dict["ExposurePort"] as! String
            }
            if dict.keys.contains("ExposureType") && dict["ExposureType"] != nil {
                self.exposureType = dict["ExposureType"] as! String
            }
            if dict.keys.contains("ExposureTypeId") && dict["ExposureTypeId"] != nil {
                self.exposureTypeId = dict["ExposureTypeId"] as! String
            }
            if dict.keys.contains("ExposureTypeInstanceName") && dict["ExposureTypeInstanceName"] != nil {
                self.exposureTypeInstanceName = dict["ExposureTypeInstanceName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var pageInfo: DescribeExposedStatisticsDetailResponseBody.PageInfo?

    public var requestId: String?

    public var statisticsDetails: [DescribeExposedStatisticsDetailResponseBody.StatisticsDetails]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statisticsDetails != nil {
            var tmp : [Any] = []
            for k in self.statisticsDetails! {
                tmp.append(k.toMap())
            }
            map["StatisticsDetails"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeExposedStatisticsDetailResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatisticsDetails") && dict["StatisticsDetails"] != nil {
            var tmp : [DescribeExposedStatisticsDetailResponseBody.StatisticsDetails] = []
            for v in dict["StatisticsDetails"] as! [Any] {
                var model = DescribeExposedStatisticsDetailResponseBody.StatisticsDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statisticsDetails = tmp
        }
    }
}

public class DescribeExposedStatisticsDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExposedStatisticsDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeExposedStatisticsDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFieldStatisticsRequest : Tea.TeaModel {
    public var machineTypes: String?

    public var regionId: String?

    public var resourceDirectoryAccountId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.machineTypes != nil {
            map["MachineTypes"] = self.machineTypes!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MachineTypes") && dict["MachineTypes"] != nil {
            self.machineTypes = dict["MachineTypes"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! Int64
        }
    }
}

public class DescribeFieldStatisticsResponseBody : Tea.TeaModel {
    public class GroupedFields : Tea.TeaModel {
        public var aliYunInstanceCount: Int32?

        public var awsInstanceCount: Int32?

        public var azureInstanceCount: Int32?

        public var exposedInstanceCount: Int32?

        public var generalAssetCount: Int32?

        public var groupCount: Int32?

        public var huaweiInstanceCount: Int32?

        public var idcInstanceCount: Int32?

        public var importantAssetCount: Int32?

        public var instanceCount: Int32?

        public var instanceSyncTaskCount: Int32?

        public var newInstanceCount: Int32?

        public var noRiskInstanceCount: Int32?

        public var notRunningStatusCount: Int32?

        public var offlineInstanceCount: Int32?

        public var outMachineInstanceCount: Int32?

        public var pauseInstanceCount: Int32?

        public var regionCount: Int32?

        public var riskInstanceCount: Int32?

        public var tencentInstanceCount: Int32?

        public var testAssetCount: Int32?

        public var tripartiteInstanceCount: Int32?

        public var unKnowStatusInstanceCount: Int32?

        public var unprotectedInstanceCount: Int32?

        public var vpcCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliYunInstanceCount != nil {
                map["AliYunInstanceCount"] = self.aliYunInstanceCount!
            }
            if self.awsInstanceCount != nil {
                map["AwsInstanceCount"] = self.awsInstanceCount!
            }
            if self.azureInstanceCount != nil {
                map["AzureInstanceCount"] = self.azureInstanceCount!
            }
            if self.exposedInstanceCount != nil {
                map["ExposedInstanceCount"] = self.exposedInstanceCount!
            }
            if self.generalAssetCount != nil {
                map["GeneralAssetCount"] = self.generalAssetCount!
            }
            if self.groupCount != nil {
                map["GroupCount"] = self.groupCount!
            }
            if self.huaweiInstanceCount != nil {
                map["HuaweiInstanceCount"] = self.huaweiInstanceCount!
            }
            if self.idcInstanceCount != nil {
                map["IdcInstanceCount"] = self.idcInstanceCount!
            }
            if self.importantAssetCount != nil {
                map["ImportantAssetCount"] = self.importantAssetCount!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceSyncTaskCount != nil {
                map["InstanceSyncTaskCount"] = self.instanceSyncTaskCount!
            }
            if self.newInstanceCount != nil {
                map["NewInstanceCount"] = self.newInstanceCount!
            }
            if self.noRiskInstanceCount != nil {
                map["NoRiskInstanceCount"] = self.noRiskInstanceCount!
            }
            if self.notRunningStatusCount != nil {
                map["NotRunningStatusCount"] = self.notRunningStatusCount!
            }
            if self.offlineInstanceCount != nil {
                map["OfflineInstanceCount"] = self.offlineInstanceCount!
            }
            if self.outMachineInstanceCount != nil {
                map["OutMachineInstanceCount"] = self.outMachineInstanceCount!
            }
            if self.pauseInstanceCount != nil {
                map["PauseInstanceCount"] = self.pauseInstanceCount!
            }
            if self.regionCount != nil {
                map["RegionCount"] = self.regionCount!
            }
            if self.riskInstanceCount != nil {
                map["RiskInstanceCount"] = self.riskInstanceCount!
            }
            if self.tencentInstanceCount != nil {
                map["TencentInstanceCount"] = self.tencentInstanceCount!
            }
            if self.testAssetCount != nil {
                map["TestAssetCount"] = self.testAssetCount!
            }
            if self.tripartiteInstanceCount != nil {
                map["TripartiteInstanceCount"] = self.tripartiteInstanceCount!
            }
            if self.unKnowStatusInstanceCount != nil {
                map["UnKnowStatusInstanceCount"] = self.unKnowStatusInstanceCount!
            }
            if self.unprotectedInstanceCount != nil {
                map["UnprotectedInstanceCount"] = self.unprotectedInstanceCount!
            }
            if self.vpcCount != nil {
                map["VpcCount"] = self.vpcCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliYunInstanceCount") && dict["AliYunInstanceCount"] != nil {
                self.aliYunInstanceCount = dict["AliYunInstanceCount"] as! Int32
            }
            if dict.keys.contains("AwsInstanceCount") && dict["AwsInstanceCount"] != nil {
                self.awsInstanceCount = dict["AwsInstanceCount"] as! Int32
            }
            if dict.keys.contains("AzureInstanceCount") && dict["AzureInstanceCount"] != nil {
                self.azureInstanceCount = dict["AzureInstanceCount"] as! Int32
            }
            if dict.keys.contains("ExposedInstanceCount") && dict["ExposedInstanceCount"] != nil {
                self.exposedInstanceCount = dict["ExposedInstanceCount"] as! Int32
            }
            if dict.keys.contains("GeneralAssetCount") && dict["GeneralAssetCount"] != nil {
                self.generalAssetCount = dict["GeneralAssetCount"] as! Int32
            }
            if dict.keys.contains("GroupCount") && dict["GroupCount"] != nil {
                self.groupCount = dict["GroupCount"] as! Int32
            }
            if dict.keys.contains("HuaweiInstanceCount") && dict["HuaweiInstanceCount"] != nil {
                self.huaweiInstanceCount = dict["HuaweiInstanceCount"] as! Int32
            }
            if dict.keys.contains("IdcInstanceCount") && dict["IdcInstanceCount"] != nil {
                self.idcInstanceCount = dict["IdcInstanceCount"] as! Int32
            }
            if dict.keys.contains("ImportantAssetCount") && dict["ImportantAssetCount"] != nil {
                self.importantAssetCount = dict["ImportantAssetCount"] as! Int32
            }
            if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("InstanceSyncTaskCount") && dict["InstanceSyncTaskCount"] != nil {
                self.instanceSyncTaskCount = dict["InstanceSyncTaskCount"] as! Int32
            }
            if dict.keys.contains("NewInstanceCount") && dict["NewInstanceCount"] != nil {
                self.newInstanceCount = dict["NewInstanceCount"] as! Int32
            }
            if dict.keys.contains("NoRiskInstanceCount") && dict["NoRiskInstanceCount"] != nil {
                self.noRiskInstanceCount = dict["NoRiskInstanceCount"] as! Int32
            }
            if dict.keys.contains("NotRunningStatusCount") && dict["NotRunningStatusCount"] != nil {
                self.notRunningStatusCount = dict["NotRunningStatusCount"] as! Int32
            }
            if dict.keys.contains("OfflineInstanceCount") && dict["OfflineInstanceCount"] != nil {
                self.offlineInstanceCount = dict["OfflineInstanceCount"] as! Int32
            }
            if dict.keys.contains("OutMachineInstanceCount") && dict["OutMachineInstanceCount"] != nil {
                self.outMachineInstanceCount = dict["OutMachineInstanceCount"] as! Int32
            }
            if dict.keys.contains("PauseInstanceCount") && dict["PauseInstanceCount"] != nil {
                self.pauseInstanceCount = dict["PauseInstanceCount"] as! Int32
            }
            if dict.keys.contains("RegionCount") && dict["RegionCount"] != nil {
                self.regionCount = dict["RegionCount"] as! Int32
            }
            if dict.keys.contains("RiskInstanceCount") && dict["RiskInstanceCount"] != nil {
                self.riskInstanceCount = dict["RiskInstanceCount"] as! Int32
            }
            if dict.keys.contains("TencentInstanceCount") && dict["TencentInstanceCount"] != nil {
                self.tencentInstanceCount = dict["TencentInstanceCount"] as! Int32
            }
            if dict.keys.contains("TestAssetCount") && dict["TestAssetCount"] != nil {
                self.testAssetCount = dict["TestAssetCount"] as! Int32
            }
            if dict.keys.contains("TripartiteInstanceCount") && dict["TripartiteInstanceCount"] != nil {
                self.tripartiteInstanceCount = dict["TripartiteInstanceCount"] as! Int32
            }
            if dict.keys.contains("UnKnowStatusInstanceCount") && dict["UnKnowStatusInstanceCount"] != nil {
                self.unKnowStatusInstanceCount = dict["UnKnowStatusInstanceCount"] as! Int32
            }
            if dict.keys.contains("UnprotectedInstanceCount") && dict["UnprotectedInstanceCount"] != nil {
                self.unprotectedInstanceCount = dict["UnprotectedInstanceCount"] as! Int32
            }
            if dict.keys.contains("VpcCount") && dict["VpcCount"] != nil {
                self.vpcCount = dict["VpcCount"] as! Int32
            }
        }
    }
    public var groupedFields: DescribeFieldStatisticsResponseBody.GroupedFields?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.groupedFields?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupedFields != nil {
            map["GroupedFields"] = self.groupedFields?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupedFields") && dict["GroupedFields"] != nil {
            var model = DescribeFieldStatisticsResponseBody.GroupedFields()
            model.fromMap(dict["GroupedFields"] as! [String: Any])
            self.groupedFields = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFieldStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFieldStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFieldStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFrontVulPatchListRequest : Tea.TeaModel {
    public var info: String?

    public var lang: String?

    public var operateType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.info != nil {
            map["Info"] = self.info!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Info") && dict["Info"] != nil {
            self.info = dict["Info"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeFrontVulPatchListResponseBody : Tea.TeaModel {
    public class FrontPatchList : Tea.TeaModel {
        public class PatchList : Tea.TeaModel {
            public var aliasName: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliasName != nil {
                    map["AliasName"] = self.aliasName!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                    self.aliasName = dict["AliasName"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var patchList: [DescribeFrontVulPatchListResponseBody.FrontPatchList.PatchList]?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.patchList != nil {
                var tmp : [Any] = []
                for k in self.patchList! {
                    tmp.append(k.toMap())
                }
                map["PatchList"] = tmp
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PatchList") && dict["PatchList"] != nil {
                var tmp : [DescribeFrontVulPatchListResponseBody.FrontPatchList.PatchList] = []
                for v in dict["PatchList"] as! [Any] {
                    var model = DescribeFrontVulPatchListResponseBody.FrontPatchList.PatchList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.patchList = tmp
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var frontPatchList: [DescribeFrontVulPatchListResponseBody.FrontPatchList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.frontPatchList != nil {
            var tmp : [Any] = []
            for k in self.frontPatchList! {
                tmp.append(k.toMap())
            }
            map["FrontPatchList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FrontPatchList") && dict["FrontPatchList"] != nil {
            var tmp : [DescribeFrontVulPatchListResponseBody.FrontPatchList] = []
            for v in dict["FrontPatchList"] as! [Any] {
                var model = DescribeFrontVulPatchListResponseBody.FrontPatchList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.frontPatchList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFrontVulPatchListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFrontVulPatchListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFrontVulPatchListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupStructRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeGroupStructResponseBody : Tea.TeaModel {
    public var groupFather: Int32?

    public var groupFlag: Int32?

    public var groupId: Int64?

    public var groupIndex: Int32?

    public var groupLevel: Int32?

    public var groupName: String?

    public var groups: [String]?

    public var machineNum: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupFather != nil {
            map["GroupFather"] = self.groupFather!
        }
        if self.groupFlag != nil {
            map["GroupFlag"] = self.groupFlag!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupIndex != nil {
            map["GroupIndex"] = self.groupIndex!
        }
        if self.groupLevel != nil {
            map["GroupLevel"] = self.groupLevel!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.groups != nil {
            map["Groups"] = self.groups!
        }
        if self.machineNum != nil {
            map["MachineNum"] = self.machineNum!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupFather") && dict["GroupFather"] != nil {
            self.groupFather = dict["GroupFather"] as! Int32
        }
        if dict.keys.contains("GroupFlag") && dict["GroupFlag"] != nil {
            self.groupFlag = dict["GroupFlag"] as! Int32
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("GroupIndex") && dict["GroupIndex"] != nil {
            self.groupIndex = dict["GroupIndex"] as! Int32
        }
        if dict.keys.contains("GroupLevel") && dict["GroupLevel"] != nil {
            self.groupLevel = dict["GroupLevel"] as! Int32
        }
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Groups") && dict["Groups"] != nil {
            self.groups = dict["Groups"] as! [String]
        }
        if dict.keys.contains("MachineNum") && dict["MachineNum"] != nil {
            self.machineNum = dict["MachineNum"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGroupStructResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupStructResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeGroupStructResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupedContainerInstancesRequest : Tea.TeaModel {
    public var criteria: String?

    public var currentPage: Int32?

    public var fieldValue: String?

    public var groupField: String?

    public var logicalExp: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.fieldValue != nil {
            map["FieldValue"] = self.fieldValue!
        }
        if self.groupField != nil {
            map["GroupField"] = self.groupField!
        }
        if self.logicalExp != nil {
            map["LogicalExp"] = self.logicalExp!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("FieldValue") && dict["FieldValue"] != nil {
            self.fieldValue = dict["FieldValue"] as! String
        }
        if dict.keys.contains("GroupField") && dict["GroupField"] != nil {
            self.groupField = dict["GroupField"] as! String
        }
        if dict.keys.contains("LogicalExp") && dict["LogicalExp"] != nil {
            self.logicalExp = dict["LogicalExp"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeGroupedContainerInstancesResponseBody : Tea.TeaModel {
    public class GroupedContainerInstanceList : Tea.TeaModel {
        public var alarmCount: Int32?

        public var appName: String?

        public var clusterId: String?

        public var clusterName: String?

        public var clusterType: String?

        public var createTime: Int64?

        public var custerState: String?

        public var hcCount: Int32?

        public var hostIp: String?

        public var image: String?

        public var imageDigest: String?

        public var imageRepoName: String?

        public var imageRepoNamespace: String?

        public var imageRepoTag: String?

        public var imageUuid: String?

        public var instanceCount: Int32?

        public var instanceId: String?

        public var namespace: String?

        public var pod: String?

        public var podIp: String?

        public var regionId: String?

        public var riskInstanceCount: Int32?

        public var riskLevel: String?

        public var riskStatus: String?

        public var vulCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmCount != nil {
                map["AlarmCount"] = self.alarmCount!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.custerState != nil {
                map["CusterState"] = self.custerState!
            }
            if self.hcCount != nil {
                map["HcCount"] = self.hcCount!
            }
            if self.hostIp != nil {
                map["HostIp"] = self.hostIp!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imageDigest != nil {
                map["ImageDigest"] = self.imageDigest!
            }
            if self.imageRepoName != nil {
                map["ImageRepoName"] = self.imageRepoName!
            }
            if self.imageRepoNamespace != nil {
                map["ImageRepoNamespace"] = self.imageRepoNamespace!
            }
            if self.imageRepoTag != nil {
                map["ImageRepoTag"] = self.imageRepoTag!
            }
            if self.imageUuid != nil {
                map["ImageUuid"] = self.imageUuid!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.pod != nil {
                map["Pod"] = self.pod!
            }
            if self.podIp != nil {
                map["PodIp"] = self.podIp!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.riskInstanceCount != nil {
                map["RiskInstanceCount"] = self.riskInstanceCount!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.riskStatus != nil {
                map["RiskStatus"] = self.riskStatus!
            }
            if self.vulCount != nil {
                map["VulCount"] = self.vulCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmCount") && dict["AlarmCount"] != nil {
                self.alarmCount = dict["AlarmCount"] as! Int32
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CusterState") && dict["CusterState"] != nil {
                self.custerState = dict["CusterState"] as! String
            }
            if dict.keys.contains("HcCount") && dict["HcCount"] != nil {
                self.hcCount = dict["HcCount"] as! Int32
            }
            if dict.keys.contains("HostIp") && dict["HostIp"] != nil {
                self.hostIp = dict["HostIp"] as! String
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImageDigest") && dict["ImageDigest"] != nil {
                self.imageDigest = dict["ImageDigest"] as! String
            }
            if dict.keys.contains("ImageRepoName") && dict["ImageRepoName"] != nil {
                self.imageRepoName = dict["ImageRepoName"] as! String
            }
            if dict.keys.contains("ImageRepoNamespace") && dict["ImageRepoNamespace"] != nil {
                self.imageRepoNamespace = dict["ImageRepoNamespace"] as! String
            }
            if dict.keys.contains("ImageRepoTag") && dict["ImageRepoTag"] != nil {
                self.imageRepoTag = dict["ImageRepoTag"] as! String
            }
            if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
                self.imageUuid = dict["ImageUuid"] as! String
            }
            if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Pod") && dict["Pod"] != nil {
                self.pod = dict["Pod"] as! String
            }
            if dict.keys.contains("PodIp") && dict["PodIp"] != nil {
                self.podIp = dict["PodIp"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RiskInstanceCount") && dict["RiskInstanceCount"] != nil {
                self.riskInstanceCount = dict["RiskInstanceCount"] as! Int32
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
                self.riskStatus = dict["RiskStatus"] as! String
            }
            if dict.keys.contains("VulCount") && dict["VulCount"] != nil {
                self.vulCount = dict["VulCount"] as! Int32
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var groupedContainerInstanceList: [DescribeGroupedContainerInstancesResponseBody.GroupedContainerInstanceList]?

    public var pageInfo: DescribeGroupedContainerInstancesResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupedContainerInstanceList != nil {
            var tmp : [Any] = []
            for k in self.groupedContainerInstanceList! {
                tmp.append(k.toMap())
            }
            map["GroupedContainerInstanceList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupedContainerInstanceList") && dict["GroupedContainerInstanceList"] != nil {
            var tmp : [DescribeGroupedContainerInstancesResponseBody.GroupedContainerInstanceList] = []
            for v in dict["GroupedContainerInstanceList"] as! [Any] {
                var model = DescribeGroupedContainerInstancesResponseBody.GroupedContainerInstanceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groupedContainerInstanceList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeGroupedContainerInstancesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGroupedContainerInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupedContainerInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeGroupedContainerInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupedInstancesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var fieldValue: String?

    public var groupField: String?

    public var lang: String?

    public var machineTypes: String?

    public var noPage: Bool?

    public var pageSize: Int32?

    public var saleVersionCheckCode: String?

    public var vendor: Int32?

    public var vendors: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.fieldValue != nil {
            map["FieldValue"] = self.fieldValue!
        }
        if self.groupField != nil {
            map["GroupField"] = self.groupField!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.machineTypes != nil {
            map["MachineTypes"] = self.machineTypes!
        }
        if self.noPage != nil {
            map["NoPage"] = self.noPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.saleVersionCheckCode != nil {
            map["SaleVersionCheckCode"] = self.saleVersionCheckCode!
        }
        if self.vendor != nil {
            map["Vendor"] = self.vendor!
        }
        if self.vendors != nil {
            map["Vendors"] = self.vendors!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("FieldValue") && dict["FieldValue"] != nil {
            self.fieldValue = dict["FieldValue"] as! String
        }
        if dict.keys.contains("GroupField") && dict["GroupField"] != nil {
            self.groupField = dict["GroupField"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MachineTypes") && dict["MachineTypes"] != nil {
            self.machineTypes = dict["MachineTypes"] as! String
        }
        if dict.keys.contains("NoPage") && dict["NoPage"] != nil {
            self.noPage = dict["NoPage"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SaleVersionCheckCode") && dict["SaleVersionCheckCode"] != nil {
            self.saleVersionCheckCode = dict["SaleVersionCheckCode"] as! String
        }
        if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
            self.vendor = dict["Vendor"] as! Int32
        }
        if dict.keys.contains("Vendors") && dict["Vendors"] != nil {
            self.vendors = dict["Vendors"] as! String
        }
    }
}

public class DescribeGroupedInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var asapVulInstanceCount: Int64?

        public var authVersionCheckCount: Int32?

        public var fieldAliasName: String?

        public var groupFlag: Int32?

        public var instanceCount: String?

        public var os: String?

        public var riskInstanceCount: String?

        public var unProtectedInstanceCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asapVulInstanceCount != nil {
                map["AsapVulInstanceCount"] = self.asapVulInstanceCount!
            }
            if self.authVersionCheckCount != nil {
                map["AuthVersionCheckCount"] = self.authVersionCheckCount!
            }
            if self.fieldAliasName != nil {
                map["FieldAliasName"] = self.fieldAliasName!
            }
            if self.groupFlag != nil {
                map["GroupFlag"] = self.groupFlag!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.riskInstanceCount != nil {
                map["RiskInstanceCount"] = self.riskInstanceCount!
            }
            if self.unProtectedInstanceCount != nil {
                map["UnProtectedInstanceCount"] = self.unProtectedInstanceCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsapVulInstanceCount") && dict["AsapVulInstanceCount"] != nil {
                self.asapVulInstanceCount = dict["AsapVulInstanceCount"] as! Int64
            }
            if dict.keys.contains("AuthVersionCheckCount") && dict["AuthVersionCheckCount"] != nil {
                self.authVersionCheckCount = dict["AuthVersionCheckCount"] as! Int32
            }
            if dict.keys.contains("FieldAliasName") && dict["FieldAliasName"] != nil {
                self.fieldAliasName = dict["FieldAliasName"] as! String
            }
            if dict.keys.contains("GroupFlag") && dict["GroupFlag"] != nil {
                self.groupFlag = dict["GroupFlag"] as! Int32
            }
            if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                self.instanceCount = dict["InstanceCount"] as! String
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("RiskInstanceCount") && dict["RiskInstanceCount"] != nil {
                self.riskInstanceCount = dict["RiskInstanceCount"] as! String
            }
            if dict.keys.contains("UnProtectedInstanceCount") && dict["UnProtectedInstanceCount"] != nil {
                self.unProtectedInstanceCount = dict["UnProtectedInstanceCount"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var instances: [DescribeGroupedInstancesResponseBody.Instances]?

    public var pageInfo: DescribeGroupedInstancesResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") && dict["Instances"] != nil {
            var tmp : [DescribeGroupedInstancesResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = DescribeGroupedInstancesResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeGroupedInstancesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGroupedInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupedInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeGroupedInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupedMaliciousFilesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var currentPage: Int32?

    public var fuzzyMaliciousName: String?

    public var imageDigest: String?

    public var imageLayer: String?

    public var imageTag: String?

    public var lang: String?

    public var levels: String?

    public var maliciousMd5: String?

    public var pageSize: String?

    public var repoId: String?

    public var repoInstanceId: String?

    public var repoName: String?

    public var repoNamespace: String?

    public var repoRegionId: String?

    public var scanRange: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.fuzzyMaliciousName != nil {
            map["FuzzyMaliciousName"] = self.fuzzyMaliciousName!
        }
        if self.imageDigest != nil {
            map["ImageDigest"] = self.imageDigest!
        }
        if self.imageLayer != nil {
            map["ImageLayer"] = self.imageLayer!
        }
        if self.imageTag != nil {
            map["ImageTag"] = self.imageTag!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.levels != nil {
            map["Levels"] = self.levels!
        }
        if self.maliciousMd5 != nil {
            map["MaliciousMd5"] = self.maliciousMd5!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.repoId != nil {
            map["RepoId"] = self.repoId!
        }
        if self.repoInstanceId != nil {
            map["RepoInstanceId"] = self.repoInstanceId!
        }
        if self.repoName != nil {
            map["RepoName"] = self.repoName!
        }
        if self.repoNamespace != nil {
            map["RepoNamespace"] = self.repoNamespace!
        }
        if self.repoRegionId != nil {
            map["RepoRegionId"] = self.repoRegionId!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("FuzzyMaliciousName") && dict["FuzzyMaliciousName"] != nil {
            self.fuzzyMaliciousName = dict["FuzzyMaliciousName"] as! String
        }
        if dict.keys.contains("ImageDigest") && dict["ImageDigest"] != nil {
            self.imageDigest = dict["ImageDigest"] as! String
        }
        if dict.keys.contains("ImageLayer") && dict["ImageLayer"] != nil {
            self.imageLayer = dict["ImageLayer"] as! String
        }
        if dict.keys.contains("ImageTag") && dict["ImageTag"] != nil {
            self.imageTag = dict["ImageTag"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Levels") && dict["Levels"] != nil {
            self.levels = dict["Levels"] as! String
        }
        if dict.keys.contains("MaliciousMd5") && dict["MaliciousMd5"] != nil {
            self.maliciousMd5 = dict["MaliciousMd5"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
            self.repoId = dict["RepoId"] as! String
        }
        if dict.keys.contains("RepoInstanceId") && dict["RepoInstanceId"] != nil {
            self.repoInstanceId = dict["RepoInstanceId"] as! String
        }
        if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
            self.repoName = dict["RepoName"] as! String
        }
        if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
            self.repoNamespace = dict["RepoNamespace"] as! String
        }
        if dict.keys.contains("RepoRegionId") && dict["RepoRegionId"] != nil {
            self.repoRegionId = dict["RepoRegionId"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
    }
}

public class DescribeGroupedMaliciousFilesResponseBody : Tea.TeaModel {
    public class GroupedMaliciousFileResponse : Tea.TeaModel {
        public var firstScanTimestamp: Int64?

        public var imageCount: Int64?

        public var latestScanTimestamp: Int64?

        public var level: String?

        public var maliciousMd5: String?

        public var maliciousName: String?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.firstScanTimestamp != nil {
                map["FirstScanTimestamp"] = self.firstScanTimestamp!
            }
            if self.imageCount != nil {
                map["ImageCount"] = self.imageCount!
            }
            if self.latestScanTimestamp != nil {
                map["LatestScanTimestamp"] = self.latestScanTimestamp!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.maliciousMd5 != nil {
                map["MaliciousMd5"] = self.maliciousMd5!
            }
            if self.maliciousName != nil {
                map["MaliciousName"] = self.maliciousName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FirstScanTimestamp") && dict["FirstScanTimestamp"] != nil {
                self.firstScanTimestamp = dict["FirstScanTimestamp"] as! Int64
            }
            if dict.keys.contains("ImageCount") && dict["ImageCount"] != nil {
                self.imageCount = dict["ImageCount"] as! Int64
            }
            if dict.keys.contains("LatestScanTimestamp") && dict["LatestScanTimestamp"] != nil {
                self.latestScanTimestamp = dict["LatestScanTimestamp"] as! Int64
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("MaliciousMd5") && dict["MaliciousMd5"] != nil {
                self.maliciousMd5 = dict["MaliciousMd5"] as! String
            }
            if dict.keys.contains("MaliciousName") && dict["MaliciousName"] != nil {
                self.maliciousName = dict["MaliciousName"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var groupedMaliciousFileResponse: [DescribeGroupedMaliciousFilesResponseBody.GroupedMaliciousFileResponse]?

    public var pageInfo: DescribeGroupedMaliciousFilesResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupedMaliciousFileResponse != nil {
            var tmp : [Any] = []
            for k in self.groupedMaliciousFileResponse! {
                tmp.append(k.toMap())
            }
            map["GroupedMaliciousFileResponse"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupedMaliciousFileResponse") && dict["GroupedMaliciousFileResponse"] != nil {
            var tmp : [DescribeGroupedMaliciousFilesResponseBody.GroupedMaliciousFileResponse] = []
            for v in dict["GroupedMaliciousFileResponse"] as! [Any] {
                var model = DescribeGroupedMaliciousFilesResponseBody.GroupedMaliciousFileResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groupedMaliciousFileResponse = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeGroupedMaliciousFilesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeGroupedMaliciousFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupedMaliciousFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeGroupedMaliciousFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupedTagsRequest : Tea.TeaModel {
    public var machineTypes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.machineTypes != nil {
            map["MachineTypes"] = self.machineTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MachineTypes") && dict["MachineTypes"] != nil {
            self.machineTypes = dict["MachineTypes"] as! String
        }
    }
}

public class DescribeGroupedTagsResponseBody : Tea.TeaModel {
    public class GroupedFileds : Tea.TeaModel {
        public var count: String?

        public var name: String?

        public var tagId: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.tagId != nil {
                map["TagId"] = self.tagId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TagId") && dict["TagId"] != nil {
                self.tagId = dict["TagId"] as! Int32
            }
        }
    }
    public var count: Int32?

    public var groupedFileds: [DescribeGroupedTagsResponseBody.GroupedFileds]?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.groupedFileds != nil {
            var tmp : [Any] = []
            for k in self.groupedFileds! {
                tmp.append(k.toMap())
            }
            map["GroupedFileds"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("GroupedFileds") && dict["GroupedFileds"] != nil {
            var tmp : [DescribeGroupedTagsResponseBody.GroupedFileds] = []
            for v in dict["GroupedFileds"] as! [Any] {
                var model = DescribeGroupedTagsResponseBody.GroupedFileds()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groupedFileds = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeGroupedTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupedTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeGroupedTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGroupedVulRequest : Tea.TeaModel {
    public var aliasName: String?

    public var assetType: String?

    public var attachTypes: String?

    public var containerFieldName: String?

    public var currentPage: Int32?

    public var dealed: String?

    public var groupId: String?

    public var lang: String?

    public var necessity: String?

    public var pageSize: Int32?

    public var resourceDirectoryAccountId: Int64?

    public var searchTags: String?

    public var targetType: String?

    public var type: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliasName != nil {
            map["AliasName"] = self.aliasName!
        }
        if self.assetType != nil {
            map["AssetType"] = self.assetType!
        }
        if self.attachTypes != nil {
            map["AttachTypes"] = self.attachTypes!
        }
        if self.containerFieldName != nil {
            map["ContainerFieldName"] = self.containerFieldName!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.necessity != nil {
            map["Necessity"] = self.necessity!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.searchTags != nil {
            map["SearchTags"] = self.searchTags!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
            self.aliasName = dict["AliasName"] as! String
        }
        if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
            self.assetType = dict["AssetType"] as! String
        }
        if dict.keys.contains("AttachTypes") && dict["AttachTypes"] != nil {
            self.attachTypes = dict["AttachTypes"] as! String
        }
        if dict.keys.contains("ContainerFieldName") && dict["ContainerFieldName"] != nil {
            self.containerFieldName = dict["ContainerFieldName"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
            self.necessity = dict["Necessity"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! Int64
        }
        if dict.keys.contains("SearchTags") && dict["SearchTags"] != nil {
            self.searchTags = dict["SearchTags"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeGroupedVulResponseBody : Tea.TeaModel {
    public class GroupedVulItems : Tea.TeaModel {
        public var aliasName: String?

        public var asapCount: Int32?

        public var gmtLast: Int64?

        public var handledCount: Int32?

        public var laterCount: Int32?

        public var name: String?

        public var nntfCount: Int32?

        public var raspDefend: Int32?

        public var related: String?

        public var tags: String?

        public var totalFixCount: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.asapCount != nil {
                map["AsapCount"] = self.asapCount!
            }
            if self.gmtLast != nil {
                map["GmtLast"] = self.gmtLast!
            }
            if self.handledCount != nil {
                map["HandledCount"] = self.handledCount!
            }
            if self.laterCount != nil {
                map["LaterCount"] = self.laterCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nntfCount != nil {
                map["NntfCount"] = self.nntfCount!
            }
            if self.raspDefend != nil {
                map["RaspDefend"] = self.raspDefend!
            }
            if self.related != nil {
                map["Related"] = self.related!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.totalFixCount != nil {
                map["TotalFixCount"] = self.totalFixCount!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                self.aliasName = dict["AliasName"] as! String
            }
            if dict.keys.contains("AsapCount") && dict["AsapCount"] != nil {
                self.asapCount = dict["AsapCount"] as! Int32
            }
            if dict.keys.contains("GmtLast") && dict["GmtLast"] != nil {
                self.gmtLast = dict["GmtLast"] as! Int64
            }
            if dict.keys.contains("HandledCount") && dict["HandledCount"] != nil {
                self.handledCount = dict["HandledCount"] as! Int32
            }
            if dict.keys.contains("LaterCount") && dict["LaterCount"] != nil {
                self.laterCount = dict["LaterCount"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NntfCount") && dict["NntfCount"] != nil {
                self.nntfCount = dict["NntfCount"] as! Int32
            }
            if dict.keys.contains("RaspDefend") && dict["RaspDefend"] != nil {
                self.raspDefend = dict["RaspDefend"] as! Int32
            }
            if dict.keys.contains("Related") && dict["Related"] != nil {
                self.related = dict["Related"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("TotalFixCount") && dict["TotalFixCount"] != nil {
                self.totalFixCount = dict["TotalFixCount"] as! Int64
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var groupedVulItems: [DescribeGroupedVulResponseBody.GroupedVulItems]?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.groupedVulItems != nil {
            var tmp : [Any] = []
            for k in self.groupedVulItems! {
                tmp.append(k.toMap())
            }
            map["GroupedVulItems"] = tmp
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("GroupedVulItems") && dict["GroupedVulItems"] != nil {
            var tmp : [DescribeGroupedVulResponseBody.GroupedVulItems] = []
            for v in dict["GroupedVulItems"] as! [Any] {
                var model = DescribeGroupedVulResponseBody.GroupedVulItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groupedVulItems = tmp
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeGroupedVulResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGroupedVulResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeGroupedVulResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHcExportInfoRequest : Tea.TeaModel {
    public var exportId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exportId != nil {
            map["ExportId"] = self.exportId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExportId") && dict["ExportId"] != nil {
            self.exportId = dict["ExportId"] as! Int64
        }
    }
}

public class DescribeHcExportInfoResponseBody : Tea.TeaModel {
    public var currentCount: Int32?

    public var fileName: String?

    public var gmtCreate: Int64?

    public var id: Int64?

    public var link: String?

    public var progress: Int32?

    public var requestId: String?

    public var resultStatus: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentCount != nil {
            map["CurrentCount"] = self.currentCount!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.link != nil {
            map["Link"] = self.link!
        }
        if self.progress != nil {
            map["Progress"] = self.progress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultStatus != nil {
            map["ResultStatus"] = self.resultStatus!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentCount") && dict["CurrentCount"] != nil {
            self.currentCount = dict["CurrentCount"] as! Int32
        }
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Link") && dict["Link"] != nil {
            self.link = dict["Link"] as! String
        }
        if dict.keys.contains("Progress") && dict["Progress"] != nil {
            self.progress = dict["Progress"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultStatus") && dict["ResultStatus"] != nil {
            self.resultStatus = dict["ResultStatus"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeHcExportInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHcExportInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeHcExportInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHoneyPotAuthRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeHoneyPotAuthResponseBody : Tea.TeaModel {
    public var honeyPotAuthCount: Int64?

    public var honeyPotCount: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeyPotAuthCount != nil {
            map["HoneyPotAuthCount"] = self.honeyPotAuthCount!
        }
        if self.honeyPotCount != nil {
            map["HoneyPotCount"] = self.honeyPotCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneyPotAuthCount") && dict["HoneyPotAuthCount"] != nil {
            self.honeyPotAuthCount = dict["HoneyPotAuthCount"] as! Int64
        }
        if dict.keys.contains("HoneyPotCount") && dict["HoneyPotCount"] != nil {
            self.honeyPotCount = dict["HoneyPotCount"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeHoneyPotAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHoneyPotAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeHoneyPotAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHoneyPotSuspStatisticsRequest : Tea.TeaModel {
    public var from: String?

    public var lang: String?

    public var statisticsDays: Int32?

    public var statisticsKeyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.statisticsDays != nil {
            map["StatisticsDays"] = self.statisticsDays!
        }
        if self.statisticsKeyType != nil {
            map["StatisticsKeyType"] = self.statisticsKeyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StatisticsDays") && dict["StatisticsDays"] != nil {
            self.statisticsDays = dict["StatisticsDays"] as! Int32
        }
        if dict.keys.contains("StatisticsKeyType") && dict["StatisticsKeyType"] != nil {
            self.statisticsKeyType = dict["StatisticsKeyType"] as! String
        }
    }
}

public class DescribeHoneyPotSuspStatisticsResponseBody : Tea.TeaModel {
    public class SuspHoneyPotStatisticsResponse : Tea.TeaModel {
        public var count: Int32?

        public var instanceId: String?

        public var instanceName: String?

        public var type: String?

        public var vpcId: String?

        public var vpcName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vpcName != nil {
                map["VpcName"] = self.vpcName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("VpcName") && dict["VpcName"] != nil {
                self.vpcName = dict["VpcName"] as! String
            }
        }
    }
    public var requestId: String?

    public var suspHoneyPotStatisticsResponse: [DescribeHoneyPotSuspStatisticsResponseBody.SuspHoneyPotStatisticsResponse]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.suspHoneyPotStatisticsResponse != nil {
            var tmp : [Any] = []
            for k in self.suspHoneyPotStatisticsResponse! {
                tmp.append(k.toMap())
            }
            map["SuspHoneyPotStatisticsResponse"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuspHoneyPotStatisticsResponse") && dict["SuspHoneyPotStatisticsResponse"] != nil {
            var tmp : [DescribeHoneyPotSuspStatisticsResponseBody.SuspHoneyPotStatisticsResponse] = []
            for v in dict["SuspHoneyPotStatisticsResponse"] as! [Any] {
                var model = DescribeHoneyPotSuspStatisticsResponseBody.SuspHoneyPotStatisticsResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.suspHoneyPotStatisticsResponse = tmp
        }
    }
}

public class DescribeHoneyPotSuspStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHoneyPotSuspStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeHoneyPotSuspStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageRequest : Tea.TeaModel {
    public var imageInstanceId: String?

    public var imageRegionId: String?

    public var imageRepoId: String?

    public var imageTag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageInstanceId != nil {
            map["ImageInstanceId"] = self.imageInstanceId!
        }
        if self.imageRegionId != nil {
            map["ImageRegionId"] = self.imageRegionId!
        }
        if self.imageRepoId != nil {
            map["ImageRepoId"] = self.imageRepoId!
        }
        if self.imageTag != nil {
            map["ImageTag"] = self.imageTag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageInstanceId") && dict["ImageInstanceId"] != nil {
            self.imageInstanceId = dict["ImageInstanceId"] as! String
        }
        if dict.keys.contains("ImageRegionId") && dict["ImageRegionId"] != nil {
            self.imageRegionId = dict["ImageRegionId"] as! String
        }
        if dict.keys.contains("ImageRepoId") && dict["ImageRepoId"] != nil {
            self.imageRepoId = dict["ImageRepoId"] as! String
        }
        if dict.keys.contains("ImageTag") && dict["ImageTag"] != nil {
            self.imageTag = dict["ImageTag"] as! String
        }
    }
}

public class DescribeImageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var digest: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.digest != nil {
                map["Digest"] = self.digest!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Digest") && dict["Digest"] != nil {
                self.digest = dict["Digest"] as! String
            }
        }
    }
    public var data: DescribeImageResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeImageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageBaselineCheckResultRequest : Tea.TeaModel {
    public var criteria: String?

    public var criteriaType: String?

    public var currentPage: Int32?

    public var imageUuid: String?

    public var lang: String?

    public var pageSize: Int32?

    public var riskLevel: String?

    public var scanRange: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.criteriaType != nil {
            map["CriteriaType"] = self.criteriaType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.imageUuid != nil {
            map["ImageUuid"] = self.imageUuid!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CriteriaType") && dict["CriteriaType"] != nil {
            self.criteriaType = dict["CriteriaType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
            self.imageUuid = dict["ImageUuid"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
            self.riskLevel = dict["RiskLevel"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
    }
}

public class DescribeImageBaselineCheckResultResponseBody : Tea.TeaModel {
    public class BaselineResult : Tea.TeaModel {
        public var baselineClassAlias: String?

        public var baselineItemCount: Int32?

        public var baselineNameAlias: String?

        public var baselineNameKey: String?

        public var baselineNameLevel: String?

        public var firstScanTime: Int64?

        public var highRiskItemCount: Int32?

        public var lastScanTime: Int64?

        public var lowRiskItemCount: Int32?

        public var middleRiskItemCount: Int32?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineClassAlias != nil {
                map["BaselineClassAlias"] = self.baselineClassAlias!
            }
            if self.baselineItemCount != nil {
                map["BaselineItemCount"] = self.baselineItemCount!
            }
            if self.baselineNameAlias != nil {
                map["BaselineNameAlias"] = self.baselineNameAlias!
            }
            if self.baselineNameKey != nil {
                map["BaselineNameKey"] = self.baselineNameKey!
            }
            if self.baselineNameLevel != nil {
                map["BaselineNameLevel"] = self.baselineNameLevel!
            }
            if self.firstScanTime != nil {
                map["FirstScanTime"] = self.firstScanTime!
            }
            if self.highRiskItemCount != nil {
                map["HighRiskItemCount"] = self.highRiskItemCount!
            }
            if self.lastScanTime != nil {
                map["LastScanTime"] = self.lastScanTime!
            }
            if self.lowRiskItemCount != nil {
                map["LowRiskItemCount"] = self.lowRiskItemCount!
            }
            if self.middleRiskItemCount != nil {
                map["MiddleRiskItemCount"] = self.middleRiskItemCount!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineClassAlias") && dict["BaselineClassAlias"] != nil {
                self.baselineClassAlias = dict["BaselineClassAlias"] as! String
            }
            if dict.keys.contains("BaselineItemCount") && dict["BaselineItemCount"] != nil {
                self.baselineItemCount = dict["BaselineItemCount"] as! Int32
            }
            if dict.keys.contains("BaselineNameAlias") && dict["BaselineNameAlias"] != nil {
                self.baselineNameAlias = dict["BaselineNameAlias"] as! String
            }
            if dict.keys.contains("BaselineNameKey") && dict["BaselineNameKey"] != nil {
                self.baselineNameKey = dict["BaselineNameKey"] as! String
            }
            if dict.keys.contains("BaselineNameLevel") && dict["BaselineNameLevel"] != nil {
                self.baselineNameLevel = dict["BaselineNameLevel"] as! String
            }
            if dict.keys.contains("FirstScanTime") && dict["FirstScanTime"] != nil {
                self.firstScanTime = dict["FirstScanTime"] as! Int64
            }
            if dict.keys.contains("HighRiskItemCount") && dict["HighRiskItemCount"] != nil {
                self.highRiskItemCount = dict["HighRiskItemCount"] as! Int32
            }
            if dict.keys.contains("LastScanTime") && dict["LastScanTime"] != nil {
                self.lastScanTime = dict["LastScanTime"] as! Int64
            }
            if dict.keys.contains("LowRiskItemCount") && dict["LowRiskItemCount"] != nil {
                self.lowRiskItemCount = dict["LowRiskItemCount"] as! Int32
            }
            if dict.keys.contains("MiddleRiskItemCount") && dict["MiddleRiskItemCount"] != nil {
                self.middleRiskItemCount = dict["MiddleRiskItemCount"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var baselineResult: [DescribeImageBaselineCheckResultResponseBody.BaselineResult]?

    public var pageInfo: DescribeImageBaselineCheckResultResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineResult != nil {
            var tmp : [Any] = []
            for k in self.baselineResult! {
                tmp.append(k.toMap())
            }
            map["BaselineResult"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineResult") && dict["BaselineResult"] != nil {
            var tmp : [DescribeImageBaselineCheckResultResponseBody.BaselineResult] = []
            for v in dict["BaselineResult"] as! [Any] {
                var model = DescribeImageBaselineCheckResultResponseBody.BaselineResult()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.baselineResult = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageBaselineCheckResultResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageBaselineCheckResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageBaselineCheckResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageBaselineCheckResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageBaselineCheckSummaryRequest : Tea.TeaModel {
    public var clusterId: String?

    public var criteria: String?

    public var criteriaType: String?

    public var currentPage: Int32?

    public var lang: String?

    public var pageSize: Int32?

    public var riskLevel: String?

    public var scanRange: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.criteriaType != nil {
            map["CriteriaType"] = self.criteriaType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CriteriaType") && dict["CriteriaType"] != nil {
            self.criteriaType = dict["CriteriaType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
            self.riskLevel = dict["RiskLevel"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
    }
}

public class DescribeImageBaselineCheckSummaryResponseBody : Tea.TeaModel {
    public class BaselineResultSummary : Tea.TeaModel {
        public var baselineClassAlias: String?

        public var baselineClassKey: String?

        public var baselineNameAlias: String?

        public var baselineNameKey: String?

        public var baselineNameLevel: String?

        public var firstScanTime: Int64?

        public var highRiskImage: Int32?

        public var lastScanTime: Int64?

        public var lowRiskImage: Int32?

        public var middleRiskImage: Int32?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineClassAlias != nil {
                map["BaselineClassAlias"] = self.baselineClassAlias!
            }
            if self.baselineClassKey != nil {
                map["BaselineClassKey"] = self.baselineClassKey!
            }
            if self.baselineNameAlias != nil {
                map["BaselineNameAlias"] = self.baselineNameAlias!
            }
            if self.baselineNameKey != nil {
                map["BaselineNameKey"] = self.baselineNameKey!
            }
            if self.baselineNameLevel != nil {
                map["BaselineNameLevel"] = self.baselineNameLevel!
            }
            if self.firstScanTime != nil {
                map["FirstScanTime"] = self.firstScanTime!
            }
            if self.highRiskImage != nil {
                map["HighRiskImage"] = self.highRiskImage!
            }
            if self.lastScanTime != nil {
                map["LastScanTime"] = self.lastScanTime!
            }
            if self.lowRiskImage != nil {
                map["LowRiskImage"] = self.lowRiskImage!
            }
            if self.middleRiskImage != nil {
                map["MiddleRiskImage"] = self.middleRiskImage!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineClassAlias") && dict["BaselineClassAlias"] != nil {
                self.baselineClassAlias = dict["BaselineClassAlias"] as! String
            }
            if dict.keys.contains("BaselineClassKey") && dict["BaselineClassKey"] != nil {
                self.baselineClassKey = dict["BaselineClassKey"] as! String
            }
            if dict.keys.contains("BaselineNameAlias") && dict["BaselineNameAlias"] != nil {
                self.baselineNameAlias = dict["BaselineNameAlias"] as! String
            }
            if dict.keys.contains("BaselineNameKey") && dict["BaselineNameKey"] != nil {
                self.baselineNameKey = dict["BaselineNameKey"] as! String
            }
            if dict.keys.contains("BaselineNameLevel") && dict["BaselineNameLevel"] != nil {
                self.baselineNameLevel = dict["BaselineNameLevel"] as! String
            }
            if dict.keys.contains("FirstScanTime") && dict["FirstScanTime"] != nil {
                self.firstScanTime = dict["FirstScanTime"] as! Int64
            }
            if dict.keys.contains("HighRiskImage") && dict["HighRiskImage"] != nil {
                self.highRiskImage = dict["HighRiskImage"] as! Int32
            }
            if dict.keys.contains("LastScanTime") && dict["LastScanTime"] != nil {
                self.lastScanTime = dict["LastScanTime"] as! Int64
            }
            if dict.keys.contains("LowRiskImage") && dict["LowRiskImage"] != nil {
                self.lowRiskImage = dict["LowRiskImage"] as! Int32
            }
            if dict.keys.contains("MiddleRiskImage") && dict["MiddleRiskImage"] != nil {
                self.middleRiskImage = dict["MiddleRiskImage"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var baselineResultSummary: [DescribeImageBaselineCheckSummaryResponseBody.BaselineResultSummary]?

    public var pageInfo: DescribeImageBaselineCheckSummaryResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineResultSummary != nil {
            var tmp : [Any] = []
            for k in self.baselineResultSummary! {
                tmp.append(k.toMap())
            }
            map["BaselineResultSummary"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineResultSummary") && dict["BaselineResultSummary"] != nil {
            var tmp : [DescribeImageBaselineCheckSummaryResponseBody.BaselineResultSummary] = []
            for v in dict["BaselineResultSummary"] as! [Any] {
                var model = DescribeImageBaselineCheckSummaryResponseBody.BaselineResultSummary()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.baselineResultSummary = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageBaselineCheckSummaryResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageBaselineCheckSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageBaselineCheckSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageBaselineCheckSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageBaselineDetailRequest : Tea.TeaModel {
    public var baselineItemKey: String?

    public var imageUuid: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineItemKey != nil {
            map["BaselineItemKey"] = self.baselineItemKey!
        }
        if self.imageUuid != nil {
            map["ImageUuid"] = self.imageUuid!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineItemKey") && dict["BaselineItemKey"] != nil {
            self.baselineItemKey = dict["BaselineItemKey"] as! String
        }
        if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
            self.imageUuid = dict["ImageUuid"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeImageBaselineDetailResponseBody : Tea.TeaModel {
    public class BaselineDetail : Tea.TeaModel {
        public var advice: String?

        public var baselineClassAlias: String?

        public var baselineItemAlias: String?

        public var baselineItemKey: String?

        public var baselineNameAlias: String?

        public var description_: String?

        public var level: String?

        public var prompt: String?

        public var resultId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advice != nil {
                map["Advice"] = self.advice!
            }
            if self.baselineClassAlias != nil {
                map["BaselineClassAlias"] = self.baselineClassAlias!
            }
            if self.baselineItemAlias != nil {
                map["BaselineItemAlias"] = self.baselineItemAlias!
            }
            if self.baselineItemKey != nil {
                map["BaselineItemKey"] = self.baselineItemKey!
            }
            if self.baselineNameAlias != nil {
                map["BaselineNameAlias"] = self.baselineNameAlias!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.prompt != nil {
                map["Prompt"] = self.prompt!
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Advice") && dict["Advice"] != nil {
                self.advice = dict["Advice"] as! String
            }
            if dict.keys.contains("BaselineClassAlias") && dict["BaselineClassAlias"] != nil {
                self.baselineClassAlias = dict["BaselineClassAlias"] as! String
            }
            if dict.keys.contains("BaselineItemAlias") && dict["BaselineItemAlias"] != nil {
                self.baselineItemAlias = dict["BaselineItemAlias"] as! String
            }
            if dict.keys.contains("BaselineItemKey") && dict["BaselineItemKey"] != nil {
                self.baselineItemKey = dict["BaselineItemKey"] as! String
            }
            if dict.keys.contains("BaselineNameAlias") && dict["BaselineNameAlias"] != nil {
                self.baselineNameAlias = dict["BaselineNameAlias"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Prompt") && dict["Prompt"] != nil {
                self.prompt = dict["Prompt"] as! String
            }
            if dict.keys.contains("ResultId") && dict["ResultId"] != nil {
                self.resultId = dict["ResultId"] as! String
            }
        }
    }
    public var baselineDetail: DescribeImageBaselineDetailResponseBody.BaselineDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.baselineDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineDetail != nil {
            map["BaselineDetail"] = self.baselineDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineDetail") && dict["BaselineDetail"] != nil {
            var model = DescribeImageBaselineDetailResponseBody.BaselineDetail()
            model.fromMap(dict["BaselineDetail"] as! [String: Any])
            self.baselineDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageBaselineDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageBaselineDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageBaselineDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageBaselineItemListRequest : Tea.TeaModel {
    public var baselineClassKey: String?

    public var baselineNameKey: String?

    public var currentPage: Int32?

    public var imageUuid: String?

    public var lang: String?

    public var pageSize: Int32?

    public var scanRange: [String]?

    public var status: String?

    public var uuids: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineClassKey != nil {
            map["BaselineClassKey"] = self.baselineClassKey!
        }
        if self.baselineNameKey != nil {
            map["BaselineNameKey"] = self.baselineNameKey!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.imageUuid != nil {
            map["ImageUuid"] = self.imageUuid!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineClassKey") && dict["BaselineClassKey"] != nil {
            self.baselineClassKey = dict["BaselineClassKey"] as! String
        }
        if dict.keys.contains("BaselineNameKey") && dict["BaselineNameKey"] != nil {
            self.baselineNameKey = dict["BaselineNameKey"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
            self.imageUuid = dict["ImageUuid"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! [String]
        }
    }
}

public class DescribeImageBaselineItemListResponseBody : Tea.TeaModel {
    public class BaselineItemInfos : Tea.TeaModel {
        public var baselineClassAlias: String?

        public var baselineClassKey: String?

        public var baselineItemAlias: String?

        public var baselineItemKey: String?

        public var baselineNameAlias: String?

        public var baselineNameKey: String?

        public var status: Int32?

        public var whiteList: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineClassAlias != nil {
                map["BaselineClassAlias"] = self.baselineClassAlias!
            }
            if self.baselineClassKey != nil {
                map["BaselineClassKey"] = self.baselineClassKey!
            }
            if self.baselineItemAlias != nil {
                map["BaselineItemAlias"] = self.baselineItemAlias!
            }
            if self.baselineItemKey != nil {
                map["BaselineItemKey"] = self.baselineItemKey!
            }
            if self.baselineNameAlias != nil {
                map["BaselineNameAlias"] = self.baselineNameAlias!
            }
            if self.baselineNameKey != nil {
                map["BaselineNameKey"] = self.baselineNameKey!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.whiteList != nil {
                map["WhiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineClassAlias") && dict["BaselineClassAlias"] != nil {
                self.baselineClassAlias = dict["BaselineClassAlias"] as! String
            }
            if dict.keys.contains("BaselineClassKey") && dict["BaselineClassKey"] != nil {
                self.baselineClassKey = dict["BaselineClassKey"] as! String
            }
            if dict.keys.contains("BaselineItemAlias") && dict["BaselineItemAlias"] != nil {
                self.baselineItemAlias = dict["BaselineItemAlias"] as! String
            }
            if dict.keys.contains("BaselineItemKey") && dict["BaselineItemKey"] != nil {
                self.baselineItemKey = dict["BaselineItemKey"] as! String
            }
            if dict.keys.contains("BaselineNameAlias") && dict["BaselineNameAlias"] != nil {
                self.baselineNameAlias = dict["BaselineNameAlias"] as! String
            }
            if dict.keys.contains("BaselineNameKey") && dict["BaselineNameKey"] != nil {
                self.baselineNameKey = dict["BaselineNameKey"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                self.whiteList = dict["WhiteList"] as! Int32
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var baselineItemInfos: [DescribeImageBaselineItemListResponseBody.BaselineItemInfos]?

    public var pageInfo: DescribeImageBaselineItemListResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineItemInfos != nil {
            var tmp : [Any] = []
            for k in self.baselineItemInfos! {
                tmp.append(k.toMap())
            }
            map["BaselineItemInfos"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineItemInfos") && dict["BaselineItemInfos"] != nil {
            var tmp : [DescribeImageBaselineItemListResponseBody.BaselineItemInfos] = []
            for v in dict["BaselineItemInfos"] as! [Any] {
                var model = DescribeImageBaselineItemListResponseBody.BaselineItemInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.baselineItemInfos = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageBaselineItemListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageBaselineItemListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageBaselineItemListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageBaselineItemListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageBaselineStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var source: String?

    public var strategyId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
            self.strategyId = dict["StrategyId"] as! Int64
        }
    }
}

public class DescribeImageBaselineStrategyResponseBody : Tea.TeaModel {
    public class Strategy : Tea.TeaModel {
        public class BaselineItemList : Tea.TeaModel {
            public var classKey: String?

            public var itemKey: String?

            public var nameKey: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.classKey != nil {
                    map["ClassKey"] = self.classKey!
                }
                if self.itemKey != nil {
                    map["ItemKey"] = self.itemKey!
                }
                if self.nameKey != nil {
                    map["NameKey"] = self.nameKey!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClassKey") && dict["ClassKey"] != nil {
                    self.classKey = dict["ClassKey"] as! String
                }
                if dict.keys.contains("ItemKey") && dict["ItemKey"] != nil {
                    self.itemKey = dict["ItemKey"] as! String
                }
                if dict.keys.contains("NameKey") && dict["NameKey"] != nil {
                    self.nameKey = dict["NameKey"] as! String
                }
            }
        }
        public var baselineItem: String?

        public var baselineItemList: [DescribeImageBaselineStrategyResponseBody.Strategy.BaselineItemList]?

        public var selectedItemCount: Int32?

        public var strategyId: Int64?

        public var strategyName: String?

        public var totalItemCount: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineItem != nil {
                map["BaselineItem"] = self.baselineItem!
            }
            if self.baselineItemList != nil {
                var tmp : [Any] = []
                for k in self.baselineItemList! {
                    tmp.append(k.toMap())
                }
                map["BaselineItemList"] = tmp
            }
            if self.selectedItemCount != nil {
                map["SelectedItemCount"] = self.selectedItemCount!
            }
            if self.strategyId != nil {
                map["StrategyId"] = self.strategyId!
            }
            if self.strategyName != nil {
                map["StrategyName"] = self.strategyName!
            }
            if self.totalItemCount != nil {
                map["TotalItemCount"] = self.totalItemCount!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineItem") && dict["BaselineItem"] != nil {
                self.baselineItem = dict["BaselineItem"] as! String
            }
            if dict.keys.contains("BaselineItemList") && dict["BaselineItemList"] != nil {
                var tmp : [DescribeImageBaselineStrategyResponseBody.Strategy.BaselineItemList] = []
                for v in dict["BaselineItemList"] as! [Any] {
                    var model = DescribeImageBaselineStrategyResponseBody.Strategy.BaselineItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.baselineItemList = tmp
            }
            if dict.keys.contains("SelectedItemCount") && dict["SelectedItemCount"] != nil {
                self.selectedItemCount = dict["SelectedItemCount"] as! Int32
            }
            if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
                self.strategyId = dict["StrategyId"] as! Int64
            }
            if dict.keys.contains("StrategyName") && dict["StrategyName"] != nil {
                self.strategyName = dict["StrategyName"] as! String
            }
            if dict.keys.contains("TotalItemCount") && dict["TotalItemCount"] != nil {
                self.totalItemCount = dict["TotalItemCount"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var strategy: DescribeImageBaselineStrategyResponseBody.Strategy?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.strategy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Strategy") && dict["Strategy"] != nil {
            var model = DescribeImageBaselineStrategyResponseBody.Strategy()
            model.fromMap(dict["Strategy"] as! [String: Any])
            self.strategy = model
        }
    }
}

public class DescribeImageBaselineStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageBaselineStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageBaselineStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageCriteriaRequest : Tea.TeaModel {
    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Value") && dict["Value"] != nil {
            self.value = dict["Value"] as! String
        }
    }
}

public class DescribeImageCriteriaResponseBody : Tea.TeaModel {
    public class CriteriaList : Tea.TeaModel {
        public var name: String?

        public var type: String?

        public var values: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Values") && dict["Values"] != nil {
                self.values = dict["Values"] as! String
            }
        }
    }
    public var criteriaList: [DescribeImageCriteriaResponseBody.CriteriaList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteriaList != nil {
            var tmp : [Any] = []
            for k in self.criteriaList! {
                tmp.append(k.toMap())
            }
            map["CriteriaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CriteriaList") && dict["CriteriaList"] != nil {
            var tmp : [DescribeImageCriteriaResponseBody.CriteriaList] = []
            for v in dict["CriteriaList"] as! [Any] {
                var model = DescribeImageCriteriaResponseBody.CriteriaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.criteriaList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageCriteriaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageCriteriaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageCriteriaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageFixCycleConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var imageFixCycle: Int32?

        public var imageFixSwitch: String?

        public var imageFixTarget: String?

        public var imageTimeRange: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageFixCycle != nil {
                map["ImageFixCycle"] = self.imageFixCycle!
            }
            if self.imageFixSwitch != nil {
                map["ImageFixSwitch"] = self.imageFixSwitch!
            }
            if self.imageFixTarget != nil {
                map["ImageFixTarget"] = self.imageFixTarget!
            }
            if self.imageTimeRange != nil {
                map["ImageTimeRange"] = self.imageTimeRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageFixCycle") && dict["ImageFixCycle"] != nil {
                self.imageFixCycle = dict["ImageFixCycle"] as! Int32
            }
            if dict.keys.contains("ImageFixSwitch") && dict["ImageFixSwitch"] != nil {
                self.imageFixSwitch = dict["ImageFixSwitch"] as! String
            }
            if dict.keys.contains("ImageFixTarget") && dict["ImageFixTarget"] != nil {
                self.imageFixTarget = dict["ImageFixTarget"] as! String
            }
            if dict.keys.contains("ImageTimeRange") && dict["ImageTimeRange"] != nil {
                self.imageTimeRange = dict["ImageTimeRange"] as! Int32
            }
        }
    }
    public var data: DescribeImageFixCycleConfigResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = DescribeImageFixCycleConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageFixCycleConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageFixCycleConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageFixCycleConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageFixTaskRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var endTime: Int64?

    public var pageSize: Int32?

    public var startTime: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeImageFixTaskResponseBody : Tea.TeaModel {
    public class BuildTasks : Tea.TeaModel {
        public var buildTaskId: String?

        public var finishTime: String?

        public var fixTime: String?

        public var newTag: String?

        public var newUuid: String?

        public var oldTag: String?

        public var oldUuid: String?

        public var regionId: String?

        public var repoName: String?

        public var repoNamespace: String?

        public var status: Int32?

        public var taskType: String?

        public var vulAlias: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.buildTaskId != nil {
                map["BuildTaskId"] = self.buildTaskId!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.fixTime != nil {
                map["FixTime"] = self.fixTime!
            }
            if self.newTag != nil {
                map["NewTag"] = self.newTag!
            }
            if self.newUuid != nil {
                map["NewUuid"] = self.newUuid!
            }
            if self.oldTag != nil {
                map["OldTag"] = self.oldTag!
            }
            if self.oldUuid != nil {
                map["OldUuid"] = self.oldUuid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.vulAlias != nil {
                map["VulAlias"] = self.vulAlias!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BuildTaskId") && dict["BuildTaskId"] != nil {
                self.buildTaskId = dict["BuildTaskId"] as! String
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("FixTime") && dict["FixTime"] != nil {
                self.fixTime = dict["FixTime"] as! String
            }
            if dict.keys.contains("NewTag") && dict["NewTag"] != nil {
                self.newTag = dict["NewTag"] as! String
            }
            if dict.keys.contains("NewUuid") && dict["NewUuid"] != nil {
                self.newUuid = dict["NewUuid"] as! String
            }
            if dict.keys.contains("OldTag") && dict["OldTag"] != nil {
                self.oldTag = dict["OldTag"] as! String
            }
            if dict.keys.contains("OldUuid") && dict["OldUuid"] != nil {
                self.oldUuid = dict["OldUuid"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                self.repoNamespace = dict["RepoNamespace"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("VulAlias") && dict["VulAlias"] != nil {
                self.vulAlias = dict["VulAlias"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var buildTasks: [DescribeImageFixTaskResponseBody.BuildTasks]?

    public var pageInfo: DescribeImageFixTaskResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.buildTasks != nil {
            var tmp : [Any] = []
            for k in self.buildTasks! {
                tmp.append(k.toMap())
            }
            map["BuildTasks"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BuildTasks") && dict["BuildTasks"] != nil {
            var tmp : [DescribeImageFixTaskResponseBody.BuildTasks] = []
            for v in dict["BuildTasks"] as! [Any] {
                var model = DescribeImageFixTaskResponseBody.BuildTasks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.buildTasks = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageFixTaskResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageFixTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageFixTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageFixTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageGroupedVulListRequest : Tea.TeaModel {
    public var aliasName: String?

    public var clusterId: String?

    public var currentPage: Int32?

    public var cveId: String?

    public var groupId: String?

    public var imageDigest: String?

    public var imageLayer: String?

    public var imageTag: String?

    public var isLatest: Int32?

    public var lang: String?

    public var name: String?

    public var necessity: String?

    public var pageSize: Int32?

    public var patchId: Int64?

    public var repoId: String?

    public var repoInstanceId: String?

    public var repoName: String?

    public var repoNamespace: String?

    public var repoRegionId: String?

    public var scanRange: [String]?

    public var type: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliasName != nil {
            map["AliasName"] = self.aliasName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.cveId != nil {
            map["CveId"] = self.cveId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.imageDigest != nil {
            map["ImageDigest"] = self.imageDigest!
        }
        if self.imageLayer != nil {
            map["ImageLayer"] = self.imageLayer!
        }
        if self.imageTag != nil {
            map["ImageTag"] = self.imageTag!
        }
        if self.isLatest != nil {
            map["IsLatest"] = self.isLatest!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.necessity != nil {
            map["Necessity"] = self.necessity!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.patchId != nil {
            map["PatchId"] = self.patchId!
        }
        if self.repoId != nil {
            map["RepoId"] = self.repoId!
        }
        if self.repoInstanceId != nil {
            map["RepoInstanceId"] = self.repoInstanceId!
        }
        if self.repoName != nil {
            map["RepoName"] = self.repoName!
        }
        if self.repoNamespace != nil {
            map["RepoNamespace"] = self.repoNamespace!
        }
        if self.repoRegionId != nil {
            map["RepoRegionId"] = self.repoRegionId!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
            self.aliasName = dict["AliasName"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("CveId") && dict["CveId"] != nil {
            self.cveId = dict["CveId"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ImageDigest") && dict["ImageDigest"] != nil {
            self.imageDigest = dict["ImageDigest"] as! String
        }
        if dict.keys.contains("ImageLayer") && dict["ImageLayer"] != nil {
            self.imageLayer = dict["ImageLayer"] as! String
        }
        if dict.keys.contains("ImageTag") && dict["ImageTag"] != nil {
            self.imageTag = dict["ImageTag"] as! String
        }
        if dict.keys.contains("IsLatest") && dict["IsLatest"] != nil {
            self.isLatest = dict["IsLatest"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
            self.necessity = dict["Necessity"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PatchId") && dict["PatchId"] != nil {
            self.patchId = dict["PatchId"] as! Int64
        }
        if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
            self.repoId = dict["RepoId"] as! String
        }
        if dict.keys.contains("RepoInstanceId") && dict["RepoInstanceId"] != nil {
            self.repoInstanceId = dict["RepoInstanceId"] as! String
        }
        if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
            self.repoName = dict["RepoName"] as! String
        }
        if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
            self.repoNamespace = dict["RepoNamespace"] as! String
        }
        if dict.keys.contains("RepoRegionId") && dict["RepoRegionId"] != nil {
            self.repoRegionId = dict["RepoRegionId"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeImageGroupedVulListResponseBody : Tea.TeaModel {
    public class GroupedVulItems : Tea.TeaModel {
        public var aliasName: String?

        public var asapCount: Int32?

        public var canFix: String?

        public var gmtLast: Int64?

        public var lastScanTime: Int64?

        public var laterCount: Int32?

        public var name: String?

        public var nntfCount: Int32?

        public var status: Int32?

        public var tags: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.asapCount != nil {
                map["AsapCount"] = self.asapCount!
            }
            if self.canFix != nil {
                map["CanFix"] = self.canFix!
            }
            if self.gmtLast != nil {
                map["GmtLast"] = self.gmtLast!
            }
            if self.lastScanTime != nil {
                map["LastScanTime"] = self.lastScanTime!
            }
            if self.laterCount != nil {
                map["LaterCount"] = self.laterCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nntfCount != nil {
                map["NntfCount"] = self.nntfCount!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                self.aliasName = dict["AliasName"] as! String
            }
            if dict.keys.contains("AsapCount") && dict["AsapCount"] != nil {
                self.asapCount = dict["AsapCount"] as! Int32
            }
            if dict.keys.contains("CanFix") && dict["CanFix"] != nil {
                self.canFix = dict["CanFix"] as! String
            }
            if dict.keys.contains("GmtLast") && dict["GmtLast"] != nil {
                self.gmtLast = dict["GmtLast"] as! Int64
            }
            if dict.keys.contains("LastScanTime") && dict["LastScanTime"] != nil {
                self.lastScanTime = dict["LastScanTime"] as! Int64
            }
            if dict.keys.contains("LaterCount") && dict["LaterCount"] != nil {
                self.laterCount = dict["LaterCount"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NntfCount") && dict["NntfCount"] != nil {
                self.nntfCount = dict["NntfCount"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                self.tags = dict["Tags"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var groupedVulItems: [DescribeImageGroupedVulListResponseBody.GroupedVulItems]?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.groupedVulItems != nil {
            var tmp : [Any] = []
            for k in self.groupedVulItems! {
                tmp.append(k.toMap())
            }
            map["GroupedVulItems"] = tmp
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("GroupedVulItems") && dict["GroupedVulItems"] != nil {
            var tmp : [DescribeImageGroupedVulListResponseBody.GroupedVulItems] = []
            for v in dict["GroupedVulItems"] as! [Any] {
                var model = DescribeImageGroupedVulListResponseBody.GroupedVulItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.groupedVulItems = tmp
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImageGroupedVulListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageGroupedVulListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageGroupedVulListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageInfoListRequest : Tea.TeaModel {
    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeImageInfoListResponseBody : Tea.TeaModel {
    public class ImageInfos : Tea.TeaModel {
        public var alarmCount: Int32?

        public var alarmStatus: String?

        public var digest: String?

        public var endpoints: String?

        public var imageCreate: Int64?

        public var imageId: String?

        public var imageSize: Int64?

        public var imageUpdate: Int64?

        public var instanceId: String?

        public var regionId: String?

        public var registryType: String?

        public var repoId: String?

        public var repoName: String?

        public var repoNamespace: String?

        public var repoType: String?

        public var riskStatus: String?

        public var status: String?

        public var tag: String?

        public var tagImmutable: Int32?

        public var uuid: String?

        public var vulCount: Int32?

        public var vulStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmCount != nil {
                map["AlarmCount"] = self.alarmCount!
            }
            if self.alarmStatus != nil {
                map["AlarmStatus"] = self.alarmStatus!
            }
            if self.digest != nil {
                map["Digest"] = self.digest!
            }
            if self.endpoints != nil {
                map["Endpoints"] = self.endpoints!
            }
            if self.imageCreate != nil {
                map["ImageCreate"] = self.imageCreate!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageSize != nil {
                map["ImageSize"] = self.imageSize!
            }
            if self.imageUpdate != nil {
                map["ImageUpdate"] = self.imageUpdate!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.repoId != nil {
                map["RepoId"] = self.repoId!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            if self.repoType != nil {
                map["RepoType"] = self.repoType!
            }
            if self.riskStatus != nil {
                map["RiskStatus"] = self.riskStatus!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.tagImmutable != nil {
                map["TagImmutable"] = self.tagImmutable!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vulCount != nil {
                map["VulCount"] = self.vulCount!
            }
            if self.vulStatus != nil {
                map["VulStatus"] = self.vulStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmCount") && dict["AlarmCount"] != nil {
                self.alarmCount = dict["AlarmCount"] as! Int32
            }
            if dict.keys.contains("AlarmStatus") && dict["AlarmStatus"] != nil {
                self.alarmStatus = dict["AlarmStatus"] as! String
            }
            if dict.keys.contains("Digest") && dict["Digest"] != nil {
                self.digest = dict["Digest"] as! String
            }
            if dict.keys.contains("Endpoints") && dict["Endpoints"] != nil {
                self.endpoints = dict["Endpoints"] as! String
            }
            if dict.keys.contains("ImageCreate") && dict["ImageCreate"] != nil {
                self.imageCreate = dict["ImageCreate"] as! Int64
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageSize") && dict["ImageSize"] != nil {
                self.imageSize = dict["ImageSize"] as! Int64
            }
            if dict.keys.contains("ImageUpdate") && dict["ImageUpdate"] != nil {
                self.imageUpdate = dict["ImageUpdate"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
                self.repoId = dict["RepoId"] as! String
            }
            if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                self.repoNamespace = dict["RepoNamespace"] as! String
            }
            if dict.keys.contains("RepoType") && dict["RepoType"] != nil {
                self.repoType = dict["RepoType"] as! String
            }
            if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
                self.riskStatus = dict["RiskStatus"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("TagImmutable") && dict["TagImmutable"] != nil {
                self.tagImmutable = dict["TagImmutable"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VulCount") && dict["VulCount"] != nil {
                self.vulCount = dict["VulCount"] as! Int32
            }
            if dict.keys.contains("VulStatus") && dict["VulStatus"] != nil {
                self.vulStatus = dict["VulStatus"] as! String
            }
        }
    }
    public var imageInfos: [DescribeImageInfoListResponseBody.ImageInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageInfos != nil {
            var tmp : [Any] = []
            for k in self.imageInfos! {
                tmp.append(k.toMap())
            }
            map["ImageInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageInfos") && dict["ImageInfos"] != nil {
            var tmp : [DescribeImageInfoListResponseBody.ImageInfos] = []
            for v in dict["ImageInfos"] as! [Any] {
                var model = DescribeImageInfoListResponseBody.ImageInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageInfos = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageInfoListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageInfoListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageInfoListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageInstancesRequest : Tea.TeaModel {
    public var criteria: String?

    public var currentPage: Int32?

    public var logicalExp: String?

    public var pageSize: Int32?

    public var scanned: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.logicalExp != nil {
            map["LogicalExp"] = self.logicalExp!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scanned != nil {
            map["Scanned"] = self.scanned!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("LogicalExp") && dict["LogicalExp"] != nil {
            self.logicalExp = dict["LogicalExp"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Scanned") && dict["Scanned"] != nil {
            self.scanned = dict["Scanned"] as! Bool
        }
    }
}

public class DescribeImageInstancesResponseBody : Tea.TeaModel {
    public class ImageInstanceList : Tea.TeaModel {
        public var alarmCount: Int32?

        public var alarmStatus: String?

        public var deployed: Int32?

        public var digest: String?

        public var endpoints: String?

        public var hcCount: Int32?

        public var hcStatus: String?

        public var imageCreate: String?

        public var imageId: String?

        public var imageSize: String?

        public var imageUpdate: String?

        public var instanceId: String?

        public var regionId: String?

        public var registryType: String?

        public var repoId: String?

        public var repoName: String?

        public var repoNamespace: String?

        public var repoType: String?

        public var riskStatus: String?

        public var scaProgress: Int32?

        public var scaResult: String?

        public var scaStatus: String?

        public var status: String?

        public var tag: String?

        public var uuid: String?

        public var vulCount: Int32?

        public var vulStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmCount != nil {
                map["AlarmCount"] = self.alarmCount!
            }
            if self.alarmStatus != nil {
                map["AlarmStatus"] = self.alarmStatus!
            }
            if self.deployed != nil {
                map["Deployed"] = self.deployed!
            }
            if self.digest != nil {
                map["Digest"] = self.digest!
            }
            if self.endpoints != nil {
                map["Endpoints"] = self.endpoints!
            }
            if self.hcCount != nil {
                map["HcCount"] = self.hcCount!
            }
            if self.hcStatus != nil {
                map["HcStatus"] = self.hcStatus!
            }
            if self.imageCreate != nil {
                map["ImageCreate"] = self.imageCreate!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageSize != nil {
                map["ImageSize"] = self.imageSize!
            }
            if self.imageUpdate != nil {
                map["ImageUpdate"] = self.imageUpdate!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.repoId != nil {
                map["RepoId"] = self.repoId!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            if self.repoType != nil {
                map["RepoType"] = self.repoType!
            }
            if self.riskStatus != nil {
                map["RiskStatus"] = self.riskStatus!
            }
            if self.scaProgress != nil {
                map["ScaProgress"] = self.scaProgress!
            }
            if self.scaResult != nil {
                map["ScaResult"] = self.scaResult!
            }
            if self.scaStatus != nil {
                map["ScaStatus"] = self.scaStatus!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vulCount != nil {
                map["VulCount"] = self.vulCount!
            }
            if self.vulStatus != nil {
                map["VulStatus"] = self.vulStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmCount") && dict["AlarmCount"] != nil {
                self.alarmCount = dict["AlarmCount"] as! Int32
            }
            if dict.keys.contains("AlarmStatus") && dict["AlarmStatus"] != nil {
                self.alarmStatus = dict["AlarmStatus"] as! String
            }
            if dict.keys.contains("Deployed") && dict["Deployed"] != nil {
                self.deployed = dict["Deployed"] as! Int32
            }
            if dict.keys.contains("Digest") && dict["Digest"] != nil {
                self.digest = dict["Digest"] as! String
            }
            if dict.keys.contains("Endpoints") && dict["Endpoints"] != nil {
                self.endpoints = dict["Endpoints"] as! String
            }
            if dict.keys.contains("HcCount") && dict["HcCount"] != nil {
                self.hcCount = dict["HcCount"] as! Int32
            }
            if dict.keys.contains("HcStatus") && dict["HcStatus"] != nil {
                self.hcStatus = dict["HcStatus"] as! String
            }
            if dict.keys.contains("ImageCreate") && dict["ImageCreate"] != nil {
                self.imageCreate = dict["ImageCreate"] as! String
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageSize") && dict["ImageSize"] != nil {
                self.imageSize = dict["ImageSize"] as! String
            }
            if dict.keys.contains("ImageUpdate") && dict["ImageUpdate"] != nil {
                self.imageUpdate = dict["ImageUpdate"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
                self.repoId = dict["RepoId"] as! String
            }
            if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                self.repoNamespace = dict["RepoNamespace"] as! String
            }
            if dict.keys.contains("RepoType") && dict["RepoType"] != nil {
                self.repoType = dict["RepoType"] as! String
            }
            if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
                self.riskStatus = dict["RiskStatus"] as! String
            }
            if dict.keys.contains("ScaProgress") && dict["ScaProgress"] != nil {
                self.scaProgress = dict["ScaProgress"] as! Int32
            }
            if dict.keys.contains("ScaResult") && dict["ScaResult"] != nil {
                self.scaResult = dict["ScaResult"] as! String
            }
            if dict.keys.contains("ScaStatus") && dict["ScaStatus"] != nil {
                self.scaStatus = dict["ScaStatus"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VulCount") && dict["VulCount"] != nil {
                self.vulCount = dict["VulCount"] as! Int32
            }
            if dict.keys.contains("VulStatus") && dict["VulStatus"] != nil {
                self.vulStatus = dict["VulStatus"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var imageInstanceList: [DescribeImageInstancesResponseBody.ImageInstanceList]?

    public var pageInfo: DescribeImageInstancesResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageInstanceList != nil {
            var tmp : [Any] = []
            for k in self.imageInstanceList! {
                tmp.append(k.toMap())
            }
            map["ImageInstanceList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageInstanceList") && dict["ImageInstanceList"] != nil {
            var tmp : [DescribeImageInstancesResponseBody.ImageInstanceList] = []
            for v in dict["ImageInstanceList"] as! [Any] {
                var model = DescribeImageInstancesResponseBody.ImageInstanceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageInstanceList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageInstancesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageLatestScanTaskRequest : Tea.TeaModel {
    public var digest: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.digest != nil {
            map["Digest"] = self.digest!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Digest") && dict["Digest"] != nil {
            self.digest = dict["Digest"] as! String
        }
    }
}

public class DescribeImageLatestScanTaskResponseBody : Tea.TeaModel {
    public class Task : Tea.TeaModel {
        public var create: String?

        public var finish: Int32?

        public var finishTime: Int64?

        public var id: Int64?

        public var modified: String?

        public var name: String?

        public var source: String?

        public var startTime: Int64?

        public var status: String?

        public var target: String?

        public var targetType: String?

        public var taskId: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.create != nil {
                map["Create"] = self.create!
            }
            if self.finish != nil {
                map["Finish"] = self.finish!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.modified != nil {
                map["Modified"] = self.modified!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Create") && dict["Create"] != nil {
                self.create = dict["Create"] as! String
            }
            if dict.keys.contains("Finish") && dict["Finish"] != nil {
                self.finish = dict["Finish"] as! Int32
            }
            if dict.keys.contains("FinishTime") && dict["FinishTime"] != nil {
                self.finishTime = dict["FinishTime"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Modified") && dict["Modified"] != nil {
                self.modified = dict["Modified"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public var requestId: String?

    public var task: [DescribeImageLatestScanTaskResponseBody.Task]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.task != nil {
            var tmp : [Any] = []
            for k in self.task! {
                tmp.append(k.toMap())
            }
            map["Task"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Task") && dict["Task"] != nil {
            var tmp : [DescribeImageLatestScanTaskResponseBody.Task] = []
            for v in dict["Task"] as! [Any] {
                var model = DescribeImageLatestScanTaskResponseBody.Task()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.task = tmp
        }
    }
}

public class DescribeImageLatestScanTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageLatestScanTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageLatestScanTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageListBySensitiveFileRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var imageDigest: String?

    public var lang: String?

    public var pageSize: Int32?

    public var repoInstanceId: String?

    public var repoName: String?

    public var repoNamespace: String?

    public var riskLevel: String?

    public var scanRange: [String]?

    public var sensitiveFileKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.imageDigest != nil {
            map["ImageDigest"] = self.imageDigest!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.repoInstanceId != nil {
            map["RepoInstanceId"] = self.repoInstanceId!
        }
        if self.repoName != nil {
            map["RepoName"] = self.repoName!
        }
        if self.repoNamespace != nil {
            map["RepoNamespace"] = self.repoNamespace!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        if self.sensitiveFileKey != nil {
            map["SensitiveFileKey"] = self.sensitiveFileKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ImageDigest") && dict["ImageDigest"] != nil {
            self.imageDigest = dict["ImageDigest"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RepoInstanceId") && dict["RepoInstanceId"] != nil {
            self.repoInstanceId = dict["RepoInstanceId"] as! String
        }
        if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
            self.repoName = dict["RepoName"] as! String
        }
        if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
            self.repoNamespace = dict["RepoNamespace"] as! String
        }
        if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
            self.riskLevel = dict["RiskLevel"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
        if dict.keys.contains("SensitiveFileKey") && dict["SensitiveFileKey"] != nil {
            self.sensitiveFileKey = dict["SensitiveFileKey"] as! String
        }
    }
}

public class DescribeImageListBySensitiveFileShrinkRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var imageDigest: String?

    public var lang: String?

    public var pageSize: Int32?

    public var repoInstanceId: String?

    public var repoName: String?

    public var repoNamespace: String?

    public var riskLevel: String?

    public var scanRangeShrink: String?

    public var sensitiveFileKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.imageDigest != nil {
            map["ImageDigest"] = self.imageDigest!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.repoInstanceId != nil {
            map["RepoInstanceId"] = self.repoInstanceId!
        }
        if self.repoName != nil {
            map["RepoName"] = self.repoName!
        }
        if self.repoNamespace != nil {
            map["RepoNamespace"] = self.repoNamespace!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.scanRangeShrink != nil {
            map["ScanRange"] = self.scanRangeShrink!
        }
        if self.sensitiveFileKey != nil {
            map["SensitiveFileKey"] = self.sensitiveFileKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ImageDigest") && dict["ImageDigest"] != nil {
            self.imageDigest = dict["ImageDigest"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RepoInstanceId") && dict["RepoInstanceId"] != nil {
            self.repoInstanceId = dict["RepoInstanceId"] as! String
        }
        if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
            self.repoName = dict["RepoName"] as! String
        }
        if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
            self.repoNamespace = dict["RepoNamespace"] as! String
        }
        if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
            self.riskLevel = dict["RiskLevel"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRangeShrink = dict["ScanRange"] as! String
        }
        if dict.keys.contains("SensitiveFileKey") && dict["SensitiveFileKey"] != nil {
            self.sensitiveFileKey = dict["SensitiveFileKey"] as! String
        }
    }
}

public class DescribeImageListBySensitiveFileResponseBody : Tea.TeaModel {
    public class ImageInfos : Tea.TeaModel {
        public var digest: String?

        public var firstScanTime: Int64?

        public var instanceId: String?

        public var lastScanTime: Int64?

        public var regionId: String?

        public var repoName: String?

        public var repoNamespace: String?

        public var riskLevel: String?

        public var tag: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.digest != nil {
                map["Digest"] = self.digest!
            }
            if self.firstScanTime != nil {
                map["FirstScanTime"] = self.firstScanTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lastScanTime != nil {
                map["LastScanTime"] = self.lastScanTime!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Digest") && dict["Digest"] != nil {
                self.digest = dict["Digest"] as! String
            }
            if dict.keys.contains("FirstScanTime") && dict["FirstScanTime"] != nil {
                self.firstScanTime = dict["FirstScanTime"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("LastScanTime") && dict["LastScanTime"] != nil {
                self.lastScanTime = dict["LastScanTime"] as! Int64
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                self.repoNamespace = dict["RepoNamespace"] as! String
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var lastRowKey: String?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.lastRowKey != nil {
                map["LastRowKey"] = self.lastRowKey!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("LastRowKey") && dict["LastRowKey"] != nil {
                self.lastRowKey = dict["LastRowKey"] as! String
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var imageInfos: [DescribeImageListBySensitiveFileResponseBody.ImageInfos]?

    public var message: String?

    public var pageInfo: DescribeImageListBySensitiveFileResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.imageInfos != nil {
            var tmp : [Any] = []
            for k in self.imageInfos! {
                tmp.append(k.toMap())
            }
            map["ImageInfos"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("ImageInfos") && dict["ImageInfos"] != nil {
            var tmp : [DescribeImageListBySensitiveFileResponseBody.ImageInfos] = []
            for v in dict["ImageInfos"] as! [Any] {
                var model = DescribeImageListBySensitiveFileResponseBody.ImageInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageInfos = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageListBySensitiveFileResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeImageListBySensitiveFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageListBySensitiveFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageListBySensitiveFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageListWithBaselineNameRequest : Tea.TeaModel {
    public var baselineNameKey: String?

    public var clusterId: String?

    public var clusterName: String?

    public var containerId: String?

    public var criteria: String?

    public var criteriaType: String?

    public var currentPage: Int32?

    public var image: String?

    public var imageDigest: String?

    public var lang: String?

    public var namespace: String?

    public var pageSize: Int32?

    public var pod: String?

    public var repoInstanceId: String?

    public var repoName: String?

    public var repoNamespace: String?

    public var scanRange: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineNameKey != nil {
            map["BaselineNameKey"] = self.baselineNameKey!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.criteriaType != nil {
            map["CriteriaType"] = self.criteriaType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.image != nil {
            map["Image"] = self.image!
        }
        if self.imageDigest != nil {
            map["ImageDigest"] = self.imageDigest!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pod != nil {
            map["Pod"] = self.pod!
        }
        if self.repoInstanceId != nil {
            map["RepoInstanceId"] = self.repoInstanceId!
        }
        if self.repoName != nil {
            map["RepoName"] = self.repoName!
        }
        if self.repoNamespace != nil {
            map["RepoNamespace"] = self.repoNamespace!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineNameKey") && dict["BaselineNameKey"] != nil {
            self.baselineNameKey = dict["BaselineNameKey"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
            self.containerId = dict["ContainerId"] as! String
        }
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CriteriaType") && dict["CriteriaType"] != nil {
            self.criteriaType = dict["CriteriaType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Image") && dict["Image"] != nil {
            self.image = dict["Image"] as! String
        }
        if dict.keys.contains("ImageDigest") && dict["ImageDigest"] != nil {
            self.imageDigest = dict["ImageDigest"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Pod") && dict["Pod"] != nil {
            self.pod = dict["Pod"] as! String
        }
        if dict.keys.contains("RepoInstanceId") && dict["RepoInstanceId"] != nil {
            self.repoInstanceId = dict["RepoInstanceId"] as! String
        }
        if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
            self.repoName = dict["RepoName"] as! String
        }
        if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
            self.repoNamespace = dict["RepoNamespace"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
    }
}

public class DescribeImageListWithBaselineNameResponseBody : Tea.TeaModel {
    public class ImageInfos : Tea.TeaModel {
        public var clusterId: String?

        public var clusterName: String?

        public var containerId: String?

        public var digest: String?

        public var highRiskImage: Int32?

        public var image: String?

        public var imageCreate: Int64?

        public var imageId: String?

        public var imageSize: Int32?

        public var imageUpdate: Int64?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var lastScanTime: Int64?

        public var lowRiskImage: Int32?

        public var middleRiskImage: Int32?

        public var namespace: String?

        public var noRiskImage: Int32?

        public var pod: String?

        public var regionId: String?

        public var repoId: String?

        public var repoName: String?

        public var repoNamespace: String?

        public var repoType: String?

        public var riskStatus: String?

        public var tag: String?

        public var targetId: String?

        public var targetName: String?

        public var targetType: String?

        public var totalItemCount: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.containerId != nil {
                map["ContainerId"] = self.containerId!
            }
            if self.digest != nil {
                map["Digest"] = self.digest!
            }
            if self.highRiskImage != nil {
                map["HighRiskImage"] = self.highRiskImage!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imageCreate != nil {
                map["ImageCreate"] = self.imageCreate!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageSize != nil {
                map["ImageSize"] = self.imageSize!
            }
            if self.imageUpdate != nil {
                map["ImageUpdate"] = self.imageUpdate!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.lastScanTime != nil {
                map["LastScanTime"] = self.lastScanTime!
            }
            if self.lowRiskImage != nil {
                map["LowRiskImage"] = self.lowRiskImage!
            }
            if self.middleRiskImage != nil {
                map["MiddleRiskImage"] = self.middleRiskImage!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.noRiskImage != nil {
                map["NoRiskImage"] = self.noRiskImage!
            }
            if self.pod != nil {
                map["Pod"] = self.pod!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.repoId != nil {
                map["RepoId"] = self.repoId!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            if self.repoType != nil {
                map["RepoType"] = self.repoType!
            }
            if self.riskStatus != nil {
                map["RiskStatus"] = self.riskStatus!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.totalItemCount != nil {
                map["TotalItemCount"] = self.totalItemCount!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                self.containerId = dict["ContainerId"] as! String
            }
            if dict.keys.contains("Digest") && dict["Digest"] != nil {
                self.digest = dict["Digest"] as! String
            }
            if dict.keys.contains("HighRiskImage") && dict["HighRiskImage"] != nil {
                self.highRiskImage = dict["HighRiskImage"] as! Int32
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImageCreate") && dict["ImageCreate"] != nil {
                self.imageCreate = dict["ImageCreate"] as! Int64
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageSize") && dict["ImageSize"] != nil {
                self.imageSize = dict["ImageSize"] as! Int32
            }
            if dict.keys.contains("ImageUpdate") && dict["ImageUpdate"] != nil {
                self.imageUpdate = dict["ImageUpdate"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LastScanTime") && dict["LastScanTime"] != nil {
                self.lastScanTime = dict["LastScanTime"] as! Int64
            }
            if dict.keys.contains("LowRiskImage") && dict["LowRiskImage"] != nil {
                self.lowRiskImage = dict["LowRiskImage"] as! Int32
            }
            if dict.keys.contains("MiddleRiskImage") && dict["MiddleRiskImage"] != nil {
                self.middleRiskImage = dict["MiddleRiskImage"] as! Int32
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NoRiskImage") && dict["NoRiskImage"] != nil {
                self.noRiskImage = dict["NoRiskImage"] as! Int32
            }
            if dict.keys.contains("Pod") && dict["Pod"] != nil {
                self.pod = dict["Pod"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
                self.repoId = dict["RepoId"] as! String
            }
            if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                self.repoNamespace = dict["RepoNamespace"] as! String
            }
            if dict.keys.contains("RepoType") && dict["RepoType"] != nil {
                self.repoType = dict["RepoType"] as! String
            }
            if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
                self.riskStatus = dict["RiskStatus"] as! String
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! String
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("TotalItemCount") && dict["TotalItemCount"] != nil {
                self.totalItemCount = dict["TotalItemCount"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var imageInfos: [DescribeImageListWithBaselineNameResponseBody.ImageInfos]?

    public var pageInfo: DescribeImageListWithBaselineNameResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageInfos != nil {
            var tmp : [Any] = []
            for k in self.imageInfos! {
                tmp.append(k.toMap())
            }
            map["ImageInfos"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageInfos") && dict["ImageInfos"] != nil {
            var tmp : [DescribeImageListWithBaselineNameResponseBody.ImageInfos] = []
            for v in dict["ImageInfos"] as! [Any] {
                var model = DescribeImageListWithBaselineNameResponseBody.ImageInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageInfos = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageListWithBaselineNameResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageListWithBaselineNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageListWithBaselineNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageListWithBaselineNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageRepoCriteriaRequest : Tea.TeaModel {
    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Value") && dict["Value"] != nil {
            self.value = dict["Value"] as! String
        }
    }
}

public class DescribeImageRepoCriteriaResponseBody : Tea.TeaModel {
    public class CriteriaList : Tea.TeaModel {
        public var name: String?

        public var type: String?

        public var values: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Values") && dict["Values"] != nil {
                self.values = dict["Values"] as! String
            }
        }
    }
    public var criteriaList: [DescribeImageRepoCriteriaResponseBody.CriteriaList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteriaList != nil {
            var tmp : [Any] = []
            for k in self.criteriaList! {
                tmp.append(k.toMap())
            }
            map["CriteriaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CriteriaList") && dict["CriteriaList"] != nil {
            var tmp : [DescribeImageRepoCriteriaResponseBody.CriteriaList] = []
            for v in dict["CriteriaList"] as! [Any] {
                var model = DescribeImageRepoCriteriaResponseBody.CriteriaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.criteriaList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageRepoCriteriaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageRepoCriteriaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageRepoCriteriaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageRepoDetailListRequest : Tea.TeaModel {
    public var criteria: String?

    public var currentPage: Int32?

    public var logicalExp: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.logicalExp != nil {
            map["LogicalExp"] = self.logicalExp!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("LogicalExp") && dict["LogicalExp"] != nil {
            self.logicalExp = dict["LogicalExp"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeImageRepoDetailListResponseBody : Tea.TeaModel {
    public class ImageRepoResponses : Tea.TeaModel {
        public var alarmCount: Int32?

        public var alarmStatus: String?

        public var endpoints: String?

        public var hcCount: Int32?

        public var hcStatus: String?

        public var imageCount: Int32?

        public var instanceId: String?

        public var regionId: String?

        public var registryType: String?

        public var repoId: String?

        public var repoName: String?

        public var repoNamespace: String?

        public var riskStatus: String?

        public var vulCount: Int32?

        public var vulStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmCount != nil {
                map["AlarmCount"] = self.alarmCount!
            }
            if self.alarmStatus != nil {
                map["AlarmStatus"] = self.alarmStatus!
            }
            if self.endpoints != nil {
                map["Endpoints"] = self.endpoints!
            }
            if self.hcCount != nil {
                map["HcCount"] = self.hcCount!
            }
            if self.hcStatus != nil {
                map["HcStatus"] = self.hcStatus!
            }
            if self.imageCount != nil {
                map["ImageCount"] = self.imageCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.repoId != nil {
                map["RepoId"] = self.repoId!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            if self.riskStatus != nil {
                map["RiskStatus"] = self.riskStatus!
            }
            if self.vulCount != nil {
                map["VulCount"] = self.vulCount!
            }
            if self.vulStatus != nil {
                map["VulStatus"] = self.vulStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmCount") && dict["AlarmCount"] != nil {
                self.alarmCount = dict["AlarmCount"] as! Int32
            }
            if dict.keys.contains("AlarmStatus") && dict["AlarmStatus"] != nil {
                self.alarmStatus = dict["AlarmStatus"] as! String
            }
            if dict.keys.contains("Endpoints") && dict["Endpoints"] != nil {
                self.endpoints = dict["Endpoints"] as! String
            }
            if dict.keys.contains("HcCount") && dict["HcCount"] != nil {
                self.hcCount = dict["HcCount"] as! Int32
            }
            if dict.keys.contains("HcStatus") && dict["HcStatus"] != nil {
                self.hcStatus = dict["HcStatus"] as! String
            }
            if dict.keys.contains("ImageCount") && dict["ImageCount"] != nil {
                self.imageCount = dict["ImageCount"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
                self.repoId = dict["RepoId"] as! String
            }
            if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                self.repoNamespace = dict["RepoNamespace"] as! String
            }
            if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
                self.riskStatus = dict["RiskStatus"] as! String
            }
            if dict.keys.contains("VulCount") && dict["VulCount"] != nil {
                self.vulCount = dict["VulCount"] as! Int32
            }
            if dict.keys.contains("VulStatus") && dict["VulStatus"] != nil {
                self.vulStatus = dict["VulStatus"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var imageRepoResponses: [DescribeImageRepoDetailListResponseBody.ImageRepoResponses]?

    public var pageInfo: DescribeImageRepoDetailListResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageRepoResponses != nil {
            var tmp : [Any] = []
            for k in self.imageRepoResponses! {
                tmp.append(k.toMap())
            }
            map["ImageRepoResponses"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageRepoResponses") && dict["ImageRepoResponses"] != nil {
            var tmp : [DescribeImageRepoDetailListResponseBody.ImageRepoResponses] = []
            for v in dict["ImageRepoResponses"] as! [Any] {
                var model = DescribeImageRepoDetailListResponseBody.ImageRepoResponses()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageRepoResponses = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageRepoDetailListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageRepoDetailListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageRepoDetailListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageRepoDetailListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageRepoListRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var fieldName: String?

    public var fieldValue: String?

    public var operateType: String?

    public var pageSize: Int32?

    public var repoName: String?

    public var repoNamespace: String?

    public var targetType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.fieldName != nil {
            map["FieldName"] = self.fieldName!
        }
        if self.fieldValue != nil {
            map["FieldValue"] = self.fieldValue!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.repoName != nil {
            map["RepoName"] = self.repoName!
        }
        if self.repoNamespace != nil {
            map["RepoNamespace"] = self.repoNamespace!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("FieldName") && dict["FieldName"] != nil {
            self.fieldName = dict["FieldName"] as! String
        }
        if dict.keys.contains("FieldValue") && dict["FieldValue"] != nil {
            self.fieldValue = dict["FieldValue"] as! String
        }
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
            self.repoName = dict["RepoName"] as! String
        }
        if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
            self.repoNamespace = dict["RepoNamespace"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeImageRepoListResponseBody : Tea.TeaModel {
    public class ImageRepoList : Tea.TeaModel {
        public var flag: String?

        public var repoName: String?

        public var repoNamespace: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flag != nil {
                map["Flag"] = self.flag!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Flag") && dict["Flag"] != nil {
                self.flag = dict["Flag"] as! String
            }
            if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                self.repoNamespace = dict["RepoNamespace"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var addTargetCount: Int32?

    public var allTargetCount: Int32?

    public var delTargetCount: Int32?

    public var imageRepoList: [DescribeImageRepoListResponseBody.ImageRepoList]?

    public var pageInfo: DescribeImageRepoListResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addTargetCount != nil {
            map["AddTargetCount"] = self.addTargetCount!
        }
        if self.allTargetCount != nil {
            map["AllTargetCount"] = self.allTargetCount!
        }
        if self.delTargetCount != nil {
            map["DelTargetCount"] = self.delTargetCount!
        }
        if self.imageRepoList != nil {
            var tmp : [Any] = []
            for k in self.imageRepoList! {
                tmp.append(k.toMap())
            }
            map["ImageRepoList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddTargetCount") && dict["AddTargetCount"] != nil {
            self.addTargetCount = dict["AddTargetCount"] as! Int32
        }
        if dict.keys.contains("AllTargetCount") && dict["AllTargetCount"] != nil {
            self.allTargetCount = dict["AllTargetCount"] as! Int32
        }
        if dict.keys.contains("DelTargetCount") && dict["DelTargetCount"] != nil {
            self.delTargetCount = dict["DelTargetCount"] as! Int32
        }
        if dict.keys.contains("ImageRepoList") && dict["ImageRepoList"] != nil {
            var tmp : [DescribeImageRepoListResponseBody.ImageRepoList] = []
            for v in dict["ImageRepoList"] as! [Any] {
                var model = DescribeImageRepoListResponseBody.ImageRepoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageRepoList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageRepoListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageRepoListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageRepoListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageRepoListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageScanAuthCountResponseBody : Tea.TeaModel {
    public class ImageScan : Tea.TeaModel {
        public var imageScanCapacity: Int64?

        public var instanceId: String?

        public var scanCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageScanCapacity != nil {
                map["ImageScanCapacity"] = self.imageScanCapacity!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.scanCount != nil {
                map["ScanCount"] = self.scanCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageScanCapacity") && dict["ImageScanCapacity"] != nil {
                self.imageScanCapacity = dict["ImageScanCapacity"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("ScanCount") && dict["ScanCount"] != nil {
                self.scanCount = dict["ScanCount"] as! Int64
            }
        }
    }
    public var imageScan: DescribeImageScanAuthCountResponseBody.ImageScan?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageScan?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageScan != nil {
            map["ImageScan"] = self.imageScan?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageScan") && dict["ImageScan"] != nil {
            var model = DescribeImageScanAuthCountResponseBody.ImageScan()
            model.fromMap(dict["ImageScan"] as! [String: Any])
            self.imageScan = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageScanAuthCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageScanAuthCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageScanAuthCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageScanAuthorizationResponseBody : Tea.TeaModel {
    public class AuthStatus : Tea.TeaModel {
        public var status: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Bool
            }
        }
    }
    public var authStatus: DescribeImageScanAuthorizationResponseBody.AuthStatus?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authStatus != nil {
            map["AuthStatus"] = self.authStatus?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthStatus") && dict["AuthStatus"] != nil {
            var model = DescribeImageScanAuthorizationResponseBody.AuthStatus()
            model.fromMap(dict["AuthStatus"] as! [String: Any])
            self.authStatus = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageScanAuthorizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageScanAuthorizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageScanAuthorizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageSensitiveFileByKeyRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var imageUuid: String?

    public var lang: String?

    public var pageSize: Int32?

    public var scanRange: [String]?

    public var sensitiveFileKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.imageUuid != nil {
            map["ImageUuid"] = self.imageUuid!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        if self.sensitiveFileKey != nil {
            map["SensitiveFileKey"] = self.sensitiveFileKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
            self.imageUuid = dict["ImageUuid"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
        if dict.keys.contains("SensitiveFileKey") && dict["SensitiveFileKey"] != nil {
            self.sensitiveFileKey = dict["SensitiveFileKey"] as! String
        }
    }
}

public class DescribeImageSensitiveFileByKeyShrinkRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var imageUuid: String?

    public var lang: String?

    public var pageSize: Int32?

    public var scanRangeShrink: String?

    public var sensitiveFileKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.imageUuid != nil {
            map["ImageUuid"] = self.imageUuid!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scanRangeShrink != nil {
            map["ScanRange"] = self.scanRangeShrink!
        }
        if self.sensitiveFileKey != nil {
            map["SensitiveFileKey"] = self.sensitiveFileKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
            self.imageUuid = dict["ImageUuid"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRangeShrink = dict["ScanRange"] as! String
        }
        if dict.keys.contains("SensitiveFileKey") && dict["SensitiveFileKey"] != nil {
            self.sensitiveFileKey = dict["SensitiveFileKey"] as! String
        }
    }
}

public class DescribeImageSensitiveFileByKeyResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var lastRowKey: String?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.lastRowKey != nil {
                map["LastRowKey"] = self.lastRowKey!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("LastRowKey") && dict["LastRowKey"] != nil {
                self.lastRowKey = dict["LastRowKey"] as! String
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class SensitiveFileList : Tea.TeaModel {
        public var advice: String?

        public var filePath: String?

        public var firstScanTime: Int64?

        public var lastScanTime: Int64?

        public var layerDigest: String?

        public var promt: String?

        public var riskLevel: String?

        public var sensitiveFileKey: String?

        public var sensitiveFileName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advice != nil {
                map["Advice"] = self.advice!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.firstScanTime != nil {
                map["FirstScanTime"] = self.firstScanTime!
            }
            if self.lastScanTime != nil {
                map["LastScanTime"] = self.lastScanTime!
            }
            if self.layerDigest != nil {
                map["LayerDigest"] = self.layerDigest!
            }
            if self.promt != nil {
                map["Promt"] = self.promt!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.sensitiveFileKey != nil {
                map["SensitiveFileKey"] = self.sensitiveFileKey!
            }
            if self.sensitiveFileName != nil {
                map["SensitiveFileName"] = self.sensitiveFileName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Advice") && dict["Advice"] != nil {
                self.advice = dict["Advice"] as! String
            }
            if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("FirstScanTime") && dict["FirstScanTime"] != nil {
                self.firstScanTime = dict["FirstScanTime"] as! Int64
            }
            if dict.keys.contains("LastScanTime") && dict["LastScanTime"] != nil {
                self.lastScanTime = dict["LastScanTime"] as! Int64
            }
            if dict.keys.contains("LayerDigest") && dict["LayerDigest"] != nil {
                self.layerDigest = dict["LayerDigest"] as! String
            }
            if dict.keys.contains("Promt") && dict["Promt"] != nil {
                self.promt = dict["Promt"] as! String
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("SensitiveFileKey") && dict["SensitiveFileKey"] != nil {
                self.sensitiveFileKey = dict["SensitiveFileKey"] as! String
            }
            if dict.keys.contains("SensitiveFileName") && dict["SensitiveFileName"] != nil {
                self.sensitiveFileName = dict["SensitiveFileName"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pageInfo: DescribeImageSensitiveFileByKeyResponseBody.PageInfo?

    public var requestId: String?

    public var sensitiveFileList: [DescribeImageSensitiveFileByKeyResponseBody.SensitiveFileList]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitiveFileList != nil {
            var tmp : [Any] = []
            for k in self.sensitiveFileList! {
                tmp.append(k.toMap())
            }
            map["SensitiveFileList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageSensitiveFileByKeyResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SensitiveFileList") && dict["SensitiveFileList"] != nil {
            var tmp : [DescribeImageSensitiveFileByKeyResponseBody.SensitiveFileList] = []
            for v in dict["SensitiveFileList"] as! [Any] {
                var model = DescribeImageSensitiveFileByKeyResponseBody.SensitiveFileList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sensitiveFileList = tmp
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeImageSensitiveFileByKeyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageSensitiveFileByKeyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageSensitiveFileByKeyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageSensitiveFileListRequest : Tea.TeaModel {
    public var criteria: String?

    public var criteriaType: String?

    public var currentPage: Int32?

    public var imageUuid: String?

    public var lang: String?

    public var pageSize: Int32?

    public var riskLevel: String?

    public var scanRange: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.criteriaType != nil {
            map["CriteriaType"] = self.criteriaType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.imageUuid != nil {
            map["ImageUuid"] = self.imageUuid!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CriteriaType") && dict["CriteriaType"] != nil {
            self.criteriaType = dict["CriteriaType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
            self.imageUuid = dict["ImageUuid"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
            self.riskLevel = dict["RiskLevel"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
    }
}

public class DescribeImageSensitiveFileListShrinkRequest : Tea.TeaModel {
    public var criteria: String?

    public var criteriaType: String?

    public var currentPage: Int32?

    public var imageUuid: String?

    public var lang: String?

    public var pageSize: Int32?

    public var riskLevel: String?

    public var scanRangeShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.criteriaType != nil {
            map["CriteriaType"] = self.criteriaType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.imageUuid != nil {
            map["ImageUuid"] = self.imageUuid!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.scanRangeShrink != nil {
            map["ScanRange"] = self.scanRangeShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CriteriaType") && dict["CriteriaType"] != nil {
            self.criteriaType = dict["CriteriaType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
            self.imageUuid = dict["ImageUuid"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
            self.riskLevel = dict["RiskLevel"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRangeShrink = dict["ScanRange"] as! String
        }
    }
}

public class DescribeImageSensitiveFileListResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var lastRowKey: String?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.lastRowKey != nil {
                map["LastRowKey"] = self.lastRowKey!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("LastRowKey") && dict["LastRowKey"] != nil {
                self.lastRowKey = dict["LastRowKey"] as! String
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class SensitiveFileList : Tea.TeaModel {
        public var count: Int32?

        public var firstScanTime: Int64?

        public var lastScanTime: Int64?

        public var riskLevel: String?

        public var sensitiveFileKey: String?

        public var sensitiveFileName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.firstScanTime != nil {
                map["FirstScanTime"] = self.firstScanTime!
            }
            if self.lastScanTime != nil {
                map["LastScanTime"] = self.lastScanTime!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.sensitiveFileKey != nil {
                map["SensitiveFileKey"] = self.sensitiveFileKey!
            }
            if self.sensitiveFileName != nil {
                map["SensitiveFileName"] = self.sensitiveFileName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("FirstScanTime") && dict["FirstScanTime"] != nil {
                self.firstScanTime = dict["FirstScanTime"] as! Int64
            }
            if dict.keys.contains("LastScanTime") && dict["LastScanTime"] != nil {
                self.lastScanTime = dict["LastScanTime"] as! Int64
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("SensitiveFileKey") && dict["SensitiveFileKey"] != nil {
                self.sensitiveFileKey = dict["SensitiveFileKey"] as! String
            }
            if dict.keys.contains("SensitiveFileName") && dict["SensitiveFileName"] != nil {
                self.sensitiveFileName = dict["SensitiveFileName"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pageInfo: DescribeImageSensitiveFileListResponseBody.PageInfo?

    public var requestId: String?

    public var sensitiveFileList: [DescribeImageSensitiveFileListResponseBody.SensitiveFileList]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sensitiveFileList != nil {
            var tmp : [Any] = []
            for k in self.sensitiveFileList! {
                tmp.append(k.toMap())
            }
            map["SensitiveFileList"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageSensitiveFileListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SensitiveFileList") && dict["SensitiveFileList"] != nil {
            var tmp : [DescribeImageSensitiveFileListResponseBody.SensitiveFileList] = []
            for v in dict["SensitiveFileList"] as! [Any] {
                var model = DescribeImageSensitiveFileListResponseBody.SensitiveFileList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sensitiveFileList = tmp
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeImageSensitiveFileListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageSensitiveFileListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageSensitiveFileListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageStatisticsResponseBody : Tea.TeaModel {
    public var instanceCount: Int32?

    public var requestId: String?

    public var riskInstanceCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.riskInstanceCount != nil {
            map["RiskInstanceCount"] = self.riskInstanceCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
            self.instanceCount = dict["InstanceCount"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RiskInstanceCount") && dict["RiskInstanceCount"] != nil {
            self.riskInstanceCount = dict["RiskInstanceCount"] as! Int32
        }
    }
}

public class DescribeImageStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageVulListRequest : Tea.TeaModel {
    public var aliasName: String?

    public var clusterId: String?

    public var clusterName: String?

    public var containerId: String?

    public var currentPage: Int32?

    public var dealed: String?

    public var digest: String?

    public var image: String?

    public var instanceId: String?

    public var lang: String?

    public var name: String?

    public var namespace: String?

    public var necessity: String?

    public var pageSize: Int32?

    public var pod: String?

    public var regionId: String?

    public var repoId: String?

    public var repoInstanceId: String?

    public var repoName: String?

    public var repoNamespace: String?

    public var repoRegionId: String?

    public var scanRange: [String]?

    public var statusList: String?

    public var tag: String?

    public var type: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliasName != nil {
            map["AliasName"] = self.aliasName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.digest != nil {
            map["Digest"] = self.digest!
        }
        if self.image != nil {
            map["Image"] = self.image!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.necessity != nil {
            map["Necessity"] = self.necessity!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pod != nil {
            map["Pod"] = self.pod!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repoId != nil {
            map["RepoId"] = self.repoId!
        }
        if self.repoInstanceId != nil {
            map["RepoInstanceId"] = self.repoInstanceId!
        }
        if self.repoName != nil {
            map["RepoName"] = self.repoName!
        }
        if self.repoNamespace != nil {
            map["RepoNamespace"] = self.repoNamespace!
        }
        if self.repoRegionId != nil {
            map["RepoRegionId"] = self.repoRegionId!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
            self.aliasName = dict["AliasName"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
            self.containerId = dict["ContainerId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("Digest") && dict["Digest"] != nil {
            self.digest = dict["Digest"] as! String
        }
        if dict.keys.contains("Image") && dict["Image"] != nil {
            self.image = dict["Image"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
            self.necessity = dict["Necessity"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Pod") && dict["Pod"] != nil {
            self.pod = dict["Pod"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
            self.repoId = dict["RepoId"] as! String
        }
        if dict.keys.contains("RepoInstanceId") && dict["RepoInstanceId"] != nil {
            self.repoInstanceId = dict["RepoInstanceId"] as! String
        }
        if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
            self.repoName = dict["RepoName"] as! String
        }
        if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
            self.repoNamespace = dict["RepoNamespace"] as! String
        }
        if dict.keys.contains("RepoRegionId") && dict["RepoRegionId"] != nil {
            self.repoRegionId = dict["RepoRegionId"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeImageVulListResponseBody : Tea.TeaModel {
    public class VulRecords : Tea.TeaModel {
        public class ExtendContentJson : Tea.TeaModel {
            public class RpmEntityList : Tea.TeaModel {
                public var fullVersion: String?

                public var layer: String?

                public var matchDetail: String?

                public var matchList: [String]?

                public var name: String?

                public var path: String?

                public var updateCmd: String?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fullVersion != nil {
                        map["FullVersion"] = self.fullVersion!
                    }
                    if self.layer != nil {
                        map["Layer"] = self.layer!
                    }
                    if self.matchDetail != nil {
                        map["MatchDetail"] = self.matchDetail!
                    }
                    if self.matchList != nil {
                        map["MatchList"] = self.matchList!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.updateCmd != nil {
                        map["UpdateCmd"] = self.updateCmd!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FullVersion") && dict["FullVersion"] != nil {
                        self.fullVersion = dict["FullVersion"] as! String
                    }
                    if dict.keys.contains("Layer") && dict["Layer"] != nil {
                        self.layer = dict["Layer"] as! String
                    }
                    if dict.keys.contains("MatchDetail") && dict["MatchDetail"] != nil {
                        self.matchDetail = dict["MatchDetail"] as! String
                    }
                    if dict.keys.contains("MatchList") && dict["MatchList"] != nil {
                        self.matchList = dict["MatchList"] as! [String]
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("UpdateCmd") && dict["UpdateCmd"] != nil {
                        self.updateCmd = dict["UpdateCmd"] as! String
                    }
                    if dict.keys.contains("Version") && dict["Version"] != nil {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public var os: String?

            public var osRelease: String?

            public var rpmEntityList: [DescribeImageVulListResponseBody.VulRecords.ExtendContentJson.RpmEntityList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.os != nil {
                    map["Os"] = self.os!
                }
                if self.osRelease != nil {
                    map["OsRelease"] = self.osRelease!
                }
                if self.rpmEntityList != nil {
                    var tmp : [Any] = []
                    for k in self.rpmEntityList! {
                        tmp.append(k.toMap())
                    }
                    map["RpmEntityList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Os") && dict["Os"] != nil {
                    self.os = dict["Os"] as! String
                }
                if dict.keys.contains("OsRelease") && dict["OsRelease"] != nil {
                    self.osRelease = dict["OsRelease"] as! String
                }
                if dict.keys.contains("RpmEntityList") && dict["RpmEntityList"] != nil {
                    var tmp : [DescribeImageVulListResponseBody.VulRecords.ExtendContentJson.RpmEntityList] = []
                    for v in dict["RpmEntityList"] as! [Any] {
                        var model = DescribeImageVulListResponseBody.VulRecords.ExtendContentJson.RpmEntityList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rpmEntityList = tmp
                }
            }
        }
        public var aliasName: String?

        public var canFix: String?

        public var canUpdate: Bool?

        public var clusterId: String?

        public var clusterName: String?

        public var containerId: String?

        public var extendContentJson: DescribeImageVulListResponseBody.VulRecords.ExtendContentJson?

        public var firstTs: Int64?

        public var image: String?

        public var imageDigest: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var lastTs: Int64?

        public var layers: [String]?

        public var maliciousSource: String?

        public var modifyTs: Int64?

        public var name: String?

        public var namespace: String?

        public var necessity: String?

        public var pod: String?

        public var primaryId: Int64?

        public var related: String?

        public var repoName: String?

        public var repoNamespace: String?

        public var scanTime: Int64?

        public var status: Int32?

        public var tag: String?

        public var targetId: String?

        public var targetName: String?

        public var targetType: String?

        public var type: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.extendContentJson?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.canFix != nil {
                map["CanFix"] = self.canFix!
            }
            if self.canUpdate != nil {
                map["CanUpdate"] = self.canUpdate!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.containerId != nil {
                map["ContainerId"] = self.containerId!
            }
            if self.extendContentJson != nil {
                map["ExtendContentJson"] = self.extendContentJson?.toMap()
            }
            if self.firstTs != nil {
                map["FirstTs"] = self.firstTs!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imageDigest != nil {
                map["ImageDigest"] = self.imageDigest!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.lastTs != nil {
                map["LastTs"] = self.lastTs!
            }
            if self.layers != nil {
                map["Layers"] = self.layers!
            }
            if self.maliciousSource != nil {
                map["MaliciousSource"] = self.maliciousSource!
            }
            if self.modifyTs != nil {
                map["ModifyTs"] = self.modifyTs!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.necessity != nil {
                map["Necessity"] = self.necessity!
            }
            if self.pod != nil {
                map["Pod"] = self.pod!
            }
            if self.primaryId != nil {
                map["PrimaryId"] = self.primaryId!
            }
            if self.related != nil {
                map["Related"] = self.related!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            if self.scanTime != nil {
                map["ScanTime"] = self.scanTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                self.aliasName = dict["AliasName"] as! String
            }
            if dict.keys.contains("CanFix") && dict["CanFix"] != nil {
                self.canFix = dict["CanFix"] as! String
            }
            if dict.keys.contains("CanUpdate") && dict["CanUpdate"] != nil {
                self.canUpdate = dict["CanUpdate"] as! Bool
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                self.containerId = dict["ContainerId"] as! String
            }
            if dict.keys.contains("ExtendContentJson") && dict["ExtendContentJson"] != nil {
                var model = DescribeImageVulListResponseBody.VulRecords.ExtendContentJson()
                model.fromMap(dict["ExtendContentJson"] as! [String: Any])
                self.extendContentJson = model
            }
            if dict.keys.contains("FirstTs") && dict["FirstTs"] != nil {
                self.firstTs = dict["FirstTs"] as! Int64
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImageDigest") && dict["ImageDigest"] != nil {
                self.imageDigest = dict["ImageDigest"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LastTs") && dict["LastTs"] != nil {
                self.lastTs = dict["LastTs"] as! Int64
            }
            if dict.keys.contains("Layers") && dict["Layers"] != nil {
                self.layers = dict["Layers"] as! [String]
            }
            if dict.keys.contains("MaliciousSource") && dict["MaliciousSource"] != nil {
                self.maliciousSource = dict["MaliciousSource"] as! String
            }
            if dict.keys.contains("ModifyTs") && dict["ModifyTs"] != nil {
                self.modifyTs = dict["ModifyTs"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
                self.necessity = dict["Necessity"] as! String
            }
            if dict.keys.contains("Pod") && dict["Pod"] != nil {
                self.pod = dict["Pod"] as! String
            }
            if dict.keys.contains("PrimaryId") && dict["PrimaryId"] != nil {
                self.primaryId = dict["PrimaryId"] as! Int64
            }
            if dict.keys.contains("Related") && dict["Related"] != nil {
                self.related = dict["Related"] as! String
            }
            if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                self.repoNamespace = dict["RepoNamespace"] as! String
            }
            if dict.keys.contains("ScanTime") && dict["ScanTime"] != nil {
                self.scanTime = dict["ScanTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! String
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vulRecords: [DescribeImageVulListResponseBody.VulRecords]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vulRecords != nil {
            var tmp : [Any] = []
            for k in self.vulRecords! {
                tmp.append(k.toMap())
            }
            map["VulRecords"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VulRecords") && dict["VulRecords"] != nil {
            var tmp : [DescribeImageVulListResponseBody.VulRecords] = []
            for v in dict["VulRecords"] as! [Any] {
                var model = DescribeImageVulListResponseBody.VulRecords()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vulRecords = tmp
        }
    }
}

public class DescribeImageVulListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageVulListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageVulListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageVulWhiteListRequest : Tea.TeaModel {
    public var aliasName: String?

    public var currentPage: Int32?

    public var lang: String?

    public var pageSize: Int32?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliasName != nil {
            map["AliasName"] = self.aliasName!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
            self.aliasName = dict["AliasName"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class DescribeImageVulWhiteListResponseBody : Tea.TeaModel {
    public class ImageVulWhitelist : Tea.TeaModel {
        public var aliasName: String?

        public var id: Int64?

        public var name: String?

        public var reason: String?

        public var target: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                self.aliasName = dict["AliasName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var imageVulWhitelist: [DescribeImageVulWhiteListResponseBody.ImageVulWhitelist]?

    public var message: String?

    public var pageInfo: DescribeImageVulWhiteListResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public var timeCost: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.imageVulWhitelist != nil {
            var tmp : [Any] = []
            for k in self.imageVulWhitelist! {
                tmp.append(k.toMap())
            }
            map["ImageVulWhitelist"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeCost != nil {
            map["TimeCost"] = self.timeCost!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("ImageVulWhitelist") && dict["ImageVulWhitelist"] != nil {
            var tmp : [DescribeImageVulWhiteListResponseBody.ImageVulWhitelist] = []
            for v in dict["ImageVulWhitelist"] as! [Any] {
                var model = DescribeImageVulWhiteListResponseBody.ImageVulWhitelist()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageVulWhitelist = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeImageVulWhiteListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeCost") && dict["TimeCost"] != nil {
            self.timeCost = dict["TimeCost"] as! Int64
        }
    }
}

public class DescribeImageVulWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageVulWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeImageVulWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstallCaptchaRequest : Tea.TeaModel {
    public var deadline: String?

    public var lang: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deadline != nil {
            map["Deadline"] = self.deadline!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Deadline") && dict["Deadline"] != nil {
            self.deadline = dict["Deadline"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeInstallCaptchaResponseBody : Tea.TeaModel {
    public var captchaCode: String?

    public var deadline: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.captchaCode != nil {
            map["CaptchaCode"] = self.captchaCode!
        }
        if self.deadline != nil {
            map["Deadline"] = self.deadline!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CaptchaCode") && dict["CaptchaCode"] != nil {
            self.captchaCode = dict["CaptchaCode"] as! String
        }
        if dict.keys.contains("Deadline") && dict["Deadline"] != nil {
            self.deadline = dict["Deadline"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstallCaptchaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstallCaptchaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstallCaptchaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstallCodeResponseBody : Tea.TeaModel {
    public var code: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstallCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstallCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstallCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstallCodesResponseBody : Tea.TeaModel {
    public class InstallCodes : Tea.TeaModel {
        public var captchaCode: String?

        public var expiredDate: Int64?

        public var groupId: Int64?

        public var groupName: String?

        public var onlyImage: Bool?

        public var os: String?

        public var proxyCluster: String?

        public var vendorName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.captchaCode != nil {
                map["CaptchaCode"] = self.captchaCode!
            }
            if self.expiredDate != nil {
                map["ExpiredDate"] = self.expiredDate!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.onlyImage != nil {
                map["OnlyImage"] = self.onlyImage!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.proxyCluster != nil {
                map["ProxyCluster"] = self.proxyCluster!
            }
            if self.vendorName != nil {
                map["VendorName"] = self.vendorName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CaptchaCode") && dict["CaptchaCode"] != nil {
                self.captchaCode = dict["CaptchaCode"] as! String
            }
            if dict.keys.contains("ExpiredDate") && dict["ExpiredDate"] != nil {
                self.expiredDate = dict["ExpiredDate"] as! Int64
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int64
            }
            if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("OnlyImage") && dict["OnlyImage"] != nil {
                self.onlyImage = dict["OnlyImage"] as! Bool
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("ProxyCluster") && dict["ProxyCluster"] != nil {
                self.proxyCluster = dict["ProxyCluster"] as! String
            }
            if dict.keys.contains("VendorName") && dict["VendorName"] != nil {
                self.vendorName = dict["VendorName"] as! String
            }
        }
    }
    public var installCodes: [DescribeInstallCodesResponseBody.InstallCodes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.installCodes != nil {
            var tmp : [Any] = []
            for k in self.installCodes! {
                tmp.append(k.toMap())
            }
            map["InstallCodes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstallCodes") && dict["InstallCodes"] != nil {
            var tmp : [DescribeInstallCodesResponseBody.InstallCodes] = []
            for v in dict["InstallCodes"] as! [Any] {
                var model = DescribeInstallCodesResponseBody.InstallCodes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.installCodes = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstallCodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstallCodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstallCodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceAntiBruteForceRulesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class DescribeInstanceAntiBruteForceRulesResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class Rules : Tea.TeaModel {
        public var id: Int64?

        public var name: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var pageInfo: DescribeInstanceAntiBruteForceRulesResponseBody.PageInfo?

    public var requestId: String?

    public var rules: [DescribeInstanceAntiBruteForceRulesResponseBody.Rules]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rules != nil {
            var tmp : [Any] = []
            for k in self.rules! {
                tmp.append(k.toMap())
            }
            map["Rules"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeInstanceAntiBruteForceRulesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Rules") && dict["Rules"] != nil {
            var tmp : [DescribeInstanceAntiBruteForceRulesResponseBody.Rules] = []
            for v in dict["Rules"] as! [Any] {
                var model = DescribeInstanceAntiBruteForceRulesResponseBody.Rules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.rules = tmp
        }
    }
}

public class DescribeInstanceAntiBruteForceRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceAntiBruteForceRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceAntiBruteForceRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceRebootStatusRequest : Tea.TeaModel {
    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeInstanceRebootStatusResponseBody : Tea.TeaModel {
    public class RebootStatuses : Tea.TeaModel {
        public var code: String?

        public var msg: String?

        public var rebootStatus: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.rebootStatus != nil {
                map["RebootStatus"] = self.rebootStatus!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Msg") && dict["Msg"] != nil {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("RebootStatus") && dict["RebootStatus"] != nil {
                self.rebootStatus = dict["RebootStatus"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var rebootStatuses: [DescribeInstanceRebootStatusResponseBody.RebootStatuses]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rebootStatuses != nil {
            var tmp : [Any] = []
            for k in self.rebootStatuses! {
                tmp.append(k.toMap())
            }
            map["RebootStatuses"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RebootStatuses") && dict["RebootStatuses"] != nil {
            var tmp : [DescribeInstanceRebootStatusResponseBody.RebootStatuses] = []
            for v in dict["RebootStatuses"] as! [Any] {
                var model = DescribeInstanceRebootStatusResponseBody.RebootStatuses()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.rebootStatuses = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceRebootStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceRebootStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceRebootStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceStatisticsRequest : Tea.TeaModel {
    public var from: String?

    public var lang: String?

    public var sourceIp: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeInstanceStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var account: Int32?

        public var agentlessAll: Int32?

        public var agentlessBaseline: Int32?

        public var agentlessMalicious: Int32?

        public var agentlessVulCve: Int32?

        public var agentlessVulSca: Int32?

        public var agentlessVulSys: Int32?

        public var appNum: Int32?

        public var cmsNum: Int32?

        public var cspmNum: Int32?

        public var cveNum: Int32?

        public var emgNum: Int32?

        public var health: Int32?

        public var scaNum: Int32?

        public var suspicious: Int32?

        public var sysNum: Int32?

        public var trojan: Int32?

        public var uuid: String?

        public var vul: Int32?

        public var weakPWNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                map["Account"] = self.account!
            }
            if self.agentlessAll != nil {
                map["AgentlessAll"] = self.agentlessAll!
            }
            if self.agentlessBaseline != nil {
                map["AgentlessBaseline"] = self.agentlessBaseline!
            }
            if self.agentlessMalicious != nil {
                map["AgentlessMalicious"] = self.agentlessMalicious!
            }
            if self.agentlessVulCve != nil {
                map["AgentlessVulCve"] = self.agentlessVulCve!
            }
            if self.agentlessVulSca != nil {
                map["AgentlessVulSca"] = self.agentlessVulSca!
            }
            if self.agentlessVulSys != nil {
                map["AgentlessVulSys"] = self.agentlessVulSys!
            }
            if self.appNum != nil {
                map["AppNum"] = self.appNum!
            }
            if self.cmsNum != nil {
                map["CmsNum"] = self.cmsNum!
            }
            if self.cspmNum != nil {
                map["CspmNum"] = self.cspmNum!
            }
            if self.cveNum != nil {
                map["CveNum"] = self.cveNum!
            }
            if self.emgNum != nil {
                map["EmgNum"] = self.emgNum!
            }
            if self.health != nil {
                map["Health"] = self.health!
            }
            if self.scaNum != nil {
                map["ScaNum"] = self.scaNum!
            }
            if self.suspicious != nil {
                map["Suspicious"] = self.suspicious!
            }
            if self.sysNum != nil {
                map["SysNum"] = self.sysNum!
            }
            if self.trojan != nil {
                map["Trojan"] = self.trojan!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vul != nil {
                map["Vul"] = self.vul!
            }
            if self.weakPWNum != nil {
                map["WeakPWNum"] = self.weakPWNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Account") && dict["Account"] != nil {
                self.account = dict["Account"] as! Int32
            }
            if dict.keys.contains("AgentlessAll") && dict["AgentlessAll"] != nil {
                self.agentlessAll = dict["AgentlessAll"] as! Int32
            }
            if dict.keys.contains("AgentlessBaseline") && dict["AgentlessBaseline"] != nil {
                self.agentlessBaseline = dict["AgentlessBaseline"] as! Int32
            }
            if dict.keys.contains("AgentlessMalicious") && dict["AgentlessMalicious"] != nil {
                self.agentlessMalicious = dict["AgentlessMalicious"] as! Int32
            }
            if dict.keys.contains("AgentlessVulCve") && dict["AgentlessVulCve"] != nil {
                self.agentlessVulCve = dict["AgentlessVulCve"] as! Int32
            }
            if dict.keys.contains("AgentlessVulSca") && dict["AgentlessVulSca"] != nil {
                self.agentlessVulSca = dict["AgentlessVulSca"] as! Int32
            }
            if dict.keys.contains("AgentlessVulSys") && dict["AgentlessVulSys"] != nil {
                self.agentlessVulSys = dict["AgentlessVulSys"] as! Int32
            }
            if dict.keys.contains("AppNum") && dict["AppNum"] != nil {
                self.appNum = dict["AppNum"] as! Int32
            }
            if dict.keys.contains("CmsNum") && dict["CmsNum"] != nil {
                self.cmsNum = dict["CmsNum"] as! Int32
            }
            if dict.keys.contains("CspmNum") && dict["CspmNum"] != nil {
                self.cspmNum = dict["CspmNum"] as! Int32
            }
            if dict.keys.contains("CveNum") && dict["CveNum"] != nil {
                self.cveNum = dict["CveNum"] as! Int32
            }
            if dict.keys.contains("EmgNum") && dict["EmgNum"] != nil {
                self.emgNum = dict["EmgNum"] as! Int32
            }
            if dict.keys.contains("Health") && dict["Health"] != nil {
                self.health = dict["Health"] as! Int32
            }
            if dict.keys.contains("ScaNum") && dict["ScaNum"] != nil {
                self.scaNum = dict["ScaNum"] as! Int32
            }
            if dict.keys.contains("Suspicious") && dict["Suspicious"] != nil {
                self.suspicious = dict["Suspicious"] as! Int32
            }
            if dict.keys.contains("SysNum") && dict["SysNum"] != nil {
                self.sysNum = dict["SysNum"] as! Int32
            }
            if dict.keys.contains("Trojan") && dict["Trojan"] != nil {
                self.trojan = dict["Trojan"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("Vul") && dict["Vul"] != nil {
                self.vul = dict["Vul"] as! Int32
            }
            if dict.keys.contains("WeakPWNum") && dict["WeakPWNum"] != nil {
                self.weakPWNum = dict["WeakPWNum"] as! Int32
            }
        }
    }
    public var data: [DescribeInstanceStatisticsResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeInstanceStatisticsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeInstanceStatisticsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeInstanceStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIpTagsRequest : Tea.TeaModel {
    public var ip: String?

    public var securityEventId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.securityEventId != nil {
            map["SecurityEventId"] = self.securityEventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ip") && dict["Ip"] != nil {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("SecurityEventId") && dict["SecurityEventId"] != nil {
            self.securityEventId = dict["SecurityEventId"] as! String
        }
    }
}

public class DescribeIpTagsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class DescribeIpTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeIpTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLatestScanTaskResponseBody : Tea.TeaModel {
    public var lastCheckTime: Int64?

    public var requestId: String?

    public var riskNum: Int32?

    public var targetInfo: String?

    public var uuids: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lastCheckTime != nil {
            map["LastCheckTime"] = self.lastCheckTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.riskNum != nil {
            map["RiskNum"] = self.riskNum!
        }
        if self.targetInfo != nil {
            map["TargetInfo"] = self.targetInfo!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LastCheckTime") && dict["LastCheckTime"] != nil {
            self.lastCheckTime = dict["LastCheckTime"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RiskNum") && dict["RiskNum"] != nil {
            self.riskNum = dict["RiskNum"] as! Int32
        }
        if dict.keys.contains("TargetInfo") && dict["TargetInfo"] != nil {
            self.targetInfo = dict["TargetInfo"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! [String]
        }
    }
}

public class DescribeLatestScanTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLatestScanTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLatestScanTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLogMetaRequest : Tea.TeaModel {
    public var from: String?

    public var lang: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeLogMetaResponseBody : Tea.TeaModel {
    public class LogMetaList : Tea.TeaModel {
        public var category: String?

        public var hotTtl: Int32?

        public var logDesc: String?

        public var logStore: String?

        public var project: String?

        public var status: String?

        public var topic: String?

        public var ttl: Int32?

        public var userLogStore: String?

        public var userProject: String?

        public var userRegion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.hotTtl != nil {
                map["HotTtl"] = self.hotTtl!
            }
            if self.logDesc != nil {
                map["LogDesc"] = self.logDesc!
            }
            if self.logStore != nil {
                map["LogStore"] = self.logStore!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            if self.ttl != nil {
                map["Ttl"] = self.ttl!
            }
            if self.userLogStore != nil {
                map["UserLogStore"] = self.userLogStore!
            }
            if self.userProject != nil {
                map["UserProject"] = self.userProject!
            }
            if self.userRegion != nil {
                map["UserRegion"] = self.userRegion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("HotTtl") && dict["HotTtl"] != nil {
                self.hotTtl = dict["HotTtl"] as! Int32
            }
            if dict.keys.contains("LogDesc") && dict["LogDesc"] != nil {
                self.logDesc = dict["LogDesc"] as! String
            }
            if dict.keys.contains("LogStore") && dict["LogStore"] != nil {
                self.logStore = dict["LogStore"] as! String
            }
            if dict.keys.contains("Project") && dict["Project"] != nil {
                self.project = dict["Project"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Topic") && dict["Topic"] != nil {
                self.topic = dict["Topic"] as! String
            }
            if dict.keys.contains("Ttl") && dict["Ttl"] != nil {
                self.ttl = dict["Ttl"] as! Int32
            }
            if dict.keys.contains("UserLogStore") && dict["UserLogStore"] != nil {
                self.userLogStore = dict["UserLogStore"] as! String
            }
            if dict.keys.contains("UserProject") && dict["UserProject"] != nil {
                self.userProject = dict["UserProject"] as! String
            }
            if dict.keys.contains("UserRegion") && dict["UserRegion"] != nil {
                self.userRegion = dict["UserRegion"] as! String
            }
        }
    }
    public var logMetaList: [DescribeLogMetaResponseBody.LogMetaList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logMetaList != nil {
            var tmp : [Any] = []
            for k in self.logMetaList! {
                tmp.append(k.toMap())
            }
            map["LogMetaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogMetaList") && dict["LogMetaList"] != nil {
            var tmp : [DescribeLogMetaResponseBody.LogMetaList] = []
            for v in dict["LogMetaList"] as! [Any] {
                var model = DescribeLogMetaResponseBody.LogMetaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.logMetaList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLogMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLogMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLogMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLogShipperStatusRequest : Tea.TeaModel {
    public var from: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
    }
}

public class DescribeLogShipperStatusResponseBody : Tea.TeaModel {
    public class LogShipperStatus : Tea.TeaModel {
        public var authStatus: String?

        public var buyStatus: String?

        public var openStatus: String?

        public var postPaidOpenStatus: String?

        public var postPaidSupportStatus: String?

        public var slsProjectStatus: String?

        public var slsServiceStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authStatus != nil {
                map["AuthStatus"] = self.authStatus!
            }
            if self.buyStatus != nil {
                map["BuyStatus"] = self.buyStatus!
            }
            if self.openStatus != nil {
                map["OpenStatus"] = self.openStatus!
            }
            if self.postPaidOpenStatus != nil {
                map["PostPaidOpenStatus"] = self.postPaidOpenStatus!
            }
            if self.postPaidSupportStatus != nil {
                map["PostPaidSupportStatus"] = self.postPaidSupportStatus!
            }
            if self.slsProjectStatus != nil {
                map["SlsProjectStatus"] = self.slsProjectStatus!
            }
            if self.slsServiceStatus != nil {
                map["SlsServiceStatus"] = self.slsServiceStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthStatus") && dict["AuthStatus"] != nil {
                self.authStatus = dict["AuthStatus"] as! String
            }
            if dict.keys.contains("BuyStatus") && dict["BuyStatus"] != nil {
                self.buyStatus = dict["BuyStatus"] as! String
            }
            if dict.keys.contains("OpenStatus") && dict["OpenStatus"] != nil {
                self.openStatus = dict["OpenStatus"] as! String
            }
            if dict.keys.contains("PostPaidOpenStatus") && dict["PostPaidOpenStatus"] != nil {
                self.postPaidOpenStatus = dict["PostPaidOpenStatus"] as! String
            }
            if dict.keys.contains("PostPaidSupportStatus") && dict["PostPaidSupportStatus"] != nil {
                self.postPaidSupportStatus = dict["PostPaidSupportStatus"] as! String
            }
            if dict.keys.contains("SlsProjectStatus") && dict["SlsProjectStatus"] != nil {
                self.slsProjectStatus = dict["SlsProjectStatus"] as! String
            }
            if dict.keys.contains("SlsServiceStatus") && dict["SlsServiceStatus"] != nil {
                self.slsServiceStatus = dict["SlsServiceStatus"] as! String
            }
        }
    }
    public var logShipperStatus: DescribeLogShipperStatusResponseBody.LogShipperStatus?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logShipperStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logShipperStatus != nil {
            map["LogShipperStatus"] = self.logShipperStatus?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogShipperStatus") && dict["LogShipperStatus"] != nil {
            var model = DescribeLogShipperStatusResponseBody.LogShipperStatus()
            model.fromMap(dict["LogShipperStatus"] as! [String: Any])
            self.logShipperStatus = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLogShipperStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLogShipperStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLogShipperStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoginBaseConfigsRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var target: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeLoginBaseConfigsResponseBody : Tea.TeaModel {
    public class BaseConfigs : Tea.TeaModel {
        public class TargetList : Tea.TeaModel {
            public var target: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.target != nil {
                    map["Target"] = self.target!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Target") && dict["Target"] != nil {
                    self.target = dict["Target"] as! String
                }
                if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                    self.targetType = dict["TargetType"] as! String
                }
            }
        }
        public var account: String?

        public var endTime: String?

        public var ip: String?

        public var location: String?

        public var remark: String?

        public var startTime: String?

        public var targetList: [DescribeLoginBaseConfigsResponseBody.BaseConfigs.TargetList]?

        public var totalCount: Int32?

        public var uuidCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                map["Account"] = self.account!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.location != nil {
                map["Location"] = self.location!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.targetList != nil {
                var tmp : [Any] = []
                for k in self.targetList! {
                    tmp.append(k.toMap())
                }
                map["TargetList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.uuidCount != nil {
                map["UuidCount"] = self.uuidCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Account") && dict["Account"] != nil {
                self.account = dict["Account"] as! String
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Location") && dict["Location"] != nil {
                self.location = dict["Location"] as! String
            }
            if dict.keys.contains("Remark") && dict["Remark"] != nil {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("TargetList") && dict["TargetList"] != nil {
                var tmp : [DescribeLoginBaseConfigsResponseBody.BaseConfigs.TargetList] = []
                for v in dict["TargetList"] as! [Any] {
                    var model = DescribeLoginBaseConfigsResponseBody.BaseConfigs.TargetList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.targetList = tmp
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("UuidCount") && dict["UuidCount"] != nil {
                self.uuidCount = dict["UuidCount"] as! Int32
            }
        }
    }
    public var baseConfigs: [DescribeLoginBaseConfigsResponseBody.BaseConfigs]?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseConfigs != nil {
            var tmp : [Any] = []
            for k in self.baseConfigs! {
                tmp.append(k.toMap())
            }
            map["BaseConfigs"] = tmp
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaseConfigs") && dict["BaseConfigs"] != nil {
            var tmp : [DescribeLoginBaseConfigsResponseBody.BaseConfigs] = []
            for v in dict["BaseConfigs"] as! [Any] {
                var model = DescribeLoginBaseConfigsResponseBody.BaseConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.baseConfigs = tmp
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLoginBaseConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoginBaseConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLoginBaseConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLoginSwitchConfigsResponseBody : Tea.TeaModel {
    public class ConfigList : Tea.TeaModel {
        public var item: String?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                map["Item"] = self.item!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                self.item = dict["Item"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var configList: [DescribeLoginSwitchConfigsResponseBody.ConfigList]?

    public var count: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configList != nil {
            var tmp : [Any] = []
            for k in self.configList! {
                tmp.append(k.toMap())
            }
            map["ConfigList"] = tmp
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigList") && dict["ConfigList"] != nil {
            var tmp : [DescribeLoginSwitchConfigsResponseBody.ConfigList] = []
            for v in dict["ConfigList"] as! [Any] {
                var model = DescribeLoginSwitchConfigsResponseBody.ConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configList = tmp
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLoginSwitchConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLoginSwitchConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLoginSwitchConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLogstoreStorageRequest : Tea.TeaModel {
    public var from: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeLogstoreStorageResponseBody : Tea.TeaModel {
    public var logstore: String?

    public var preserve: Int64?

    public var requestId: String?

    public var ttl: Int32?

    public var used: Int64?

    public var userProject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.preserve != nil {
            map["Preserve"] = self.preserve!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ttl != nil {
            map["Ttl"] = self.ttl!
        }
        if self.used != nil {
            map["Used"] = self.used!
        }
        if self.userProject != nil {
            map["UserProject"] = self.userProject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logstore") && dict["Logstore"] != nil {
            self.logstore = dict["Logstore"] as! String
        }
        if dict.keys.contains("Preserve") && dict["Preserve"] != nil {
            self.preserve = dict["Preserve"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Ttl") && dict["Ttl"] != nil {
            self.ttl = dict["Ttl"] as! Int32
        }
        if dict.keys.contains("Used") && dict["Used"] != nil {
            self.used = dict["Used"] as! Int64
        }
        if dict.keys.contains("UserProject") && dict["UserProject"] != nil {
            self.userProject = dict["UserProject"] as! String
        }
    }
}

public class DescribeLogstoreStorageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLogstoreStorageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLogstoreStorageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMachineCanRebootRequest : Tea.TeaModel {
    public var type: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeMachineCanRebootResponseBody : Tea.TeaModel {
    public var canReboot: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.canReboot != nil {
            map["CanReboot"] = self.canReboot!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CanReboot") && dict["CanReboot"] != nil {
            self.canReboot = dict["CanReboot"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMachineCanRebootResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMachineCanRebootResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMachineCanRebootResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeModuleConfigResponseBody : Tea.TeaModel {
    public class ModuleConfigList : Tea.TeaModel {
        public class Items : Tea.TeaModel {
            public var groupId: Int32?

            public var instanceId: String?

            public var instanceName: String?

            public var ip: String?

            public var region: String?

            public var uuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.uuid != nil {
                    map["Uuid"] = self.uuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! Int32
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                    self.uuid = dict["Uuid"] as! String
                }
            }
        }
        public var configName: String?

        public var items: [DescribeModuleConfigResponseBody.ModuleConfigList.Items]?

        public var moduleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configName != nil {
                map["ConfigName"] = self.configName!
            }
            if self.items != nil {
                var tmp : [Any] = []
                for k in self.items! {
                    tmp.append(k.toMap())
                }
                map["Items"] = tmp
            }
            if self.moduleName != nil {
                map["ModuleName"] = self.moduleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigName") && dict["ConfigName"] != nil {
                self.configName = dict["ConfigName"] as! String
            }
            if dict.keys.contains("Items") && dict["Items"] != nil {
                var tmp : [DescribeModuleConfigResponseBody.ModuleConfigList.Items] = []
                for v in dict["Items"] as! [Any] {
                    var model = DescribeModuleConfigResponseBody.ModuleConfigList.Items()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.items = tmp
            }
            if dict.keys.contains("ModuleName") && dict["ModuleName"] != nil {
                self.moduleName = dict["ModuleName"] as! String
            }
        }
    }
    public var count: Int32?

    public var httpStatusCode: Int32?

    public var moduleConfigList: [DescribeModuleConfigResponseBody.ModuleConfigList]?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.moduleConfigList != nil {
            var tmp : [Any] = []
            for k in self.moduleConfigList! {
                tmp.append(k.toMap())
            }
            map["ModuleConfigList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("ModuleConfigList") && dict["ModuleConfigList"] != nil {
            var tmp : [DescribeModuleConfigResponseBody.ModuleConfigList] = []
            for v in dict["ModuleConfigList"] as! [Any] {
                var model = DescribeModuleConfigResponseBody.ModuleConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.moduleConfigList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeModuleConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeModuleConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeModuleConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMonitorAccountsResponseBody : Tea.TeaModel {
    public var accountIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountIds != nil {
            map["AccountIds"] = self.accountIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountIds") && dict["AccountIds"] != nil {
            self.accountIds = dict["AccountIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMonitorAccountsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMonitorAccountsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeMonitorAccountsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNoticeConfigRequest : Tea.TeaModel {
    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeNoticeConfigResponseBody : Tea.TeaModel {
    public class NoticeConfigList : Tea.TeaModel {
        public var aliUid: Int64?

        public var currentPage: Int32?

        public var project: String?

        public var route: Int32?

        public var timeLimit: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            if self.route != nil {
                map["Route"] = self.route!
            }
            if self.timeLimit != nil {
                map["TimeLimit"] = self.timeLimit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliUid") && dict["AliUid"] != nil {
                self.aliUid = dict["AliUid"] as! Int64
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("Project") && dict["Project"] != nil {
                self.project = dict["Project"] as! String
            }
            if dict.keys.contains("Route") && dict["Route"] != nil {
                self.route = dict["Route"] as! Int32
            }
            if dict.keys.contains("TimeLimit") && dict["TimeLimit"] != nil {
                self.timeLimit = dict["TimeLimit"] as! Int32
            }
        }
    }
    public var noticeConfigList: [DescribeNoticeConfigResponseBody.NoticeConfigList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.noticeConfigList != nil {
            var tmp : [Any] = []
            for k in self.noticeConfigList! {
                tmp.append(k.toMap())
            }
            map["NoticeConfigList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NoticeConfigList") && dict["NoticeConfigList"] != nil {
            var tmp : [DescribeNoticeConfigResponseBody.NoticeConfigList] = []
            for v in dict["NoticeConfigList"] as! [Any] {
                var model = DescribeNoticeConfigResponseBody.NoticeConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.noticeConfigList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNoticeConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNoticeConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeNoticeConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNsasSuspEventTypeRequest : Tea.TeaModel {
    public var containerFieldName: String?

    public var containerFieldValue: String?

    public var from: String?

    public var lang: String?

    public var name: String?

    public var remark: String?

    public var sourceIp: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containerFieldName != nil {
            map["ContainerFieldName"] = self.containerFieldName!
        }
        if self.containerFieldValue != nil {
            map["ContainerFieldValue"] = self.containerFieldValue!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContainerFieldName") && dict["ContainerFieldName"] != nil {
            self.containerFieldName = dict["ContainerFieldName"] as! String
        }
        if dict.keys.contains("ContainerFieldValue") && dict["ContainerFieldValue"] != nil {
            self.containerFieldValue = dict["ContainerFieldValue"] as! String
        }
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeNsasSuspEventTypeResponseBody : Tea.TeaModel {
    public class EventTypes : Tea.TeaModel {
        public var name: String?

        public var suspEventCount: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.suspEventCount != nil {
                map["SuspEventCount"] = self.suspEventCount!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SuspEventCount") && dict["SuspEventCount"] != nil {
                self.suspEventCount = dict["SuspEventCount"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var eventTypes: [DescribeNsasSuspEventTypeResponseBody.EventTypes]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventTypes != nil {
            var tmp : [Any] = []
            for k in self.eventTypes! {
                tmp.append(k.toMap())
            }
            map["EventTypes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventTypes") && dict["EventTypes"] != nil {
            var tmp : [DescribeNsasSuspEventTypeResponseBody.EventTypes] = []
            for v in dict["EventTypes"] as! [Any] {
                var model = DescribeNsasSuspEventTypeResponseBody.EventTypes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.eventTypes = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNsasSuspEventTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNsasSuspEventTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeNsasSuspEventTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOfflineMachinesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var os: String?

    public var pageSize: Int32?

    public var regionIdStr: String?

    public var regionNo: String?

    public var remark: String?

    public var sourceIp: String?

    public var vendor: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionIdStr != nil {
            map["RegionIdStr"] = self.regionIdStr!
        }
        if self.regionNo != nil {
            map["RegionNo"] = self.regionNo!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.vendor != nil {
            map["Vendor"] = self.vendor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Os") && dict["Os"] != nil {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionIdStr") && dict["RegionIdStr"] != nil {
            self.regionIdStr = dict["RegionIdStr"] as! String
        }
        if dict.keys.contains("RegionNo") && dict["RegionNo"] != nil {
            self.regionNo = dict["RegionNo"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
            self.vendor = dict["Vendor"] as! Int32
        }
    }
}

public class DescribeOfflineMachinesResponseBody : Tea.TeaModel {
    public class MachineList : Tea.TeaModel {
        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var machineRegion: String?

        public var os: String?

        public var regionId: String?

        public var uuid: String?

        public var vendor: Int32?

        public var vendorName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.machineRegion != nil {
                map["MachineRegion"] = self.machineRegion!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vendor != nil {
                map["Vendor"] = self.vendor!
            }
            if self.vendorName != nil {
                map["VendorName"] = self.vendorName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("MachineRegion") && dict["MachineRegion"] != nil {
                self.machineRegion = dict["MachineRegion"] as! String
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                self.vendor = dict["Vendor"] as! Int32
            }
            if dict.keys.contains("VendorName") && dict["VendorName"] != nil {
                self.vendorName = dict["VendorName"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var machineList: [DescribeOfflineMachinesResponseBody.MachineList]?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.machineList != nil {
            var tmp : [Any] = []
            for k in self.machineList! {
                tmp.append(k.toMap())
            }
            map["MachineList"] = tmp
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("MachineList") && dict["MachineList"] != nil {
            var tmp : [DescribeOfflineMachinesResponseBody.MachineList] = []
            for v in dict["MachineList"] as! [Any] {
                var model = DescribeOfflineMachinesResponseBody.MachineList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.machineList = tmp
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeOfflineMachinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOfflineMachinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeOfflineMachinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOnceTaskRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var endTimeQuery: Int64?

    public var pageSize: Int32?

    public var rootTaskId: String?

    public var startTimeQuery: Int64?

    public var taskId: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTimeQuery != nil {
            map["EndTimeQuery"] = self.endTimeQuery!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.rootTaskId != nil {
            map["RootTaskId"] = self.rootTaskId!
        }
        if self.startTimeQuery != nil {
            map["StartTimeQuery"] = self.startTimeQuery!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTimeQuery") && dict["EndTimeQuery"] != nil {
            self.endTimeQuery = dict["EndTimeQuery"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RootTaskId") && dict["RootTaskId"] != nil {
            self.rootTaskId = dict["RootTaskId"] as! String
        }
        if dict.keys.contains("StartTimeQuery") && dict["StartTimeQuery"] != nil {
            self.startTimeQuery = dict["StartTimeQuery"] as! Int64
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class DescribeOnceTaskResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class TaskManageResponseList : Tea.TeaModel {
        public var detailData: String?

        public var failCount: Int32?

        public var progress: String?

        public var resultInfo: String?

        public var successCount: Int32?

        public var taskEndTime: Int64?

        public var taskId: String?

        public var taskName: String?

        public var taskStartTime: Int64?

        public var taskStatus: Int32?

        public var taskStatusText: String?

        public var taskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detailData != nil {
                map["DetailData"] = self.detailData!
            }
            if self.failCount != nil {
                map["FailCount"] = self.failCount!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.resultInfo != nil {
                map["ResultInfo"] = self.resultInfo!
            }
            if self.successCount != nil {
                map["SuccessCount"] = self.successCount!
            }
            if self.taskEndTime != nil {
                map["TaskEndTime"] = self.taskEndTime!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskStartTime != nil {
                map["TaskStartTime"] = self.taskStartTime!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            if self.taskStatusText != nil {
                map["TaskStatusText"] = self.taskStatusText!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DetailData") && dict["DetailData"] != nil {
                self.detailData = dict["DetailData"] as! String
            }
            if dict.keys.contains("FailCount") && dict["FailCount"] != nil {
                self.failCount = dict["FailCount"] as! Int32
            }
            if dict.keys.contains("Progress") && dict["Progress"] != nil {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("ResultInfo") && dict["ResultInfo"] != nil {
                self.resultInfo = dict["ResultInfo"] as! String
            }
            if dict.keys.contains("SuccessCount") && dict["SuccessCount"] != nil {
                self.successCount = dict["SuccessCount"] as! Int32
            }
            if dict.keys.contains("TaskEndTime") && dict["TaskEndTime"] != nil {
                self.taskEndTime = dict["TaskEndTime"] as! Int64
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TaskStartTime") && dict["TaskStartTime"] != nil {
                self.taskStartTime = dict["TaskStartTime"] as! Int64
            }
            if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                self.taskStatus = dict["TaskStatus"] as! Int32
            }
            if dict.keys.contains("TaskStatusText") && dict["TaskStatusText"] != nil {
                self.taskStatusText = dict["TaskStatusText"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
        }
    }
    public var pageInfo: DescribeOnceTaskResponseBody.PageInfo?

    public var requestId: String?

    public var taskManageResponseList: [DescribeOnceTaskResponseBody.TaskManageResponseList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskManageResponseList != nil {
            var tmp : [Any] = []
            for k in self.taskManageResponseList! {
                tmp.append(k.toMap())
            }
            map["TaskManageResponseList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeOnceTaskResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskManageResponseList") && dict["TaskManageResponseList"] != nil {
            var tmp : [DescribeOnceTaskResponseBody.TaskManageResponseList] = []
            for v in dict["TaskManageResponseList"] as! [Any] {
                var model = DescribeOnceTaskResponseBody.TaskManageResponseList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.taskManageResponseList = tmp
        }
    }
}

public class DescribeOnceTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOnceTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeOnceTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOnceTaskLeafRecordPageRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var endTime: Int64?

    public var pageSize: Int32?

    public var relateInfo: Bool?

    public var source: String?

    public var startTime: Int64?

    public var statusList: [String]?

    public var taskId: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.relateInfo != nil {
            map["RelateInfo"] = self.relateInfo!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RelateInfo") && dict["RelateInfo"] != nil {
            self.relateInfo = dict["RelateInfo"] as! Bool
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! [String]
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class DescribeOnceTaskLeafRecordPageResponseBody : Tea.TeaModel {
    public class OnceTasks : Tea.TeaModel {
        public class TaskImageInfo : Tea.TeaModel {
            public var appName: String?

            public var clusterId: String?

            public var clusterName: String?

            public var costTimeInfo: String?

            public var digest: String?

            public var image: String?

            public var nodeInstanceId: String?

            public var nodeIp: String?

            public var nodeName: String?

            public var pod: String?

            public var regionId: String?

            public var repoId: String?

            public var repoName: String?

            public var repoNamespace: String?

            public var repoRegionId: String?

            public var tag: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.costTimeInfo != nil {
                    map["CostTimeInfo"] = self.costTimeInfo!
                }
                if self.digest != nil {
                    map["Digest"] = self.digest!
                }
                if self.image != nil {
                    map["Image"] = self.image!
                }
                if self.nodeInstanceId != nil {
                    map["NodeInstanceId"] = self.nodeInstanceId!
                }
                if self.nodeIp != nil {
                    map["NodeIp"] = self.nodeIp!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.pod != nil {
                    map["Pod"] = self.pod!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.repoId != nil {
                    map["RepoId"] = self.repoId!
                }
                if self.repoName != nil {
                    map["RepoName"] = self.repoName!
                }
                if self.repoNamespace != nil {
                    map["RepoNamespace"] = self.repoNamespace!
                }
                if self.repoRegionId != nil {
                    map["RepoRegionId"] = self.repoRegionId!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("CostTimeInfo") && dict["CostTimeInfo"] != nil {
                    self.costTimeInfo = dict["CostTimeInfo"] as! String
                }
                if dict.keys.contains("Digest") && dict["Digest"] != nil {
                    self.digest = dict["Digest"] as! String
                }
                if dict.keys.contains("Image") && dict["Image"] != nil {
                    self.image = dict["Image"] as! String
                }
                if dict.keys.contains("NodeInstanceId") && dict["NodeInstanceId"] != nil {
                    self.nodeInstanceId = dict["NodeInstanceId"] as! String
                }
                if dict.keys.contains("NodeIp") && dict["NodeIp"] != nil {
                    self.nodeIp = dict["NodeIp"] as! String
                }
                if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Pod") && dict["Pod"] != nil {
                    self.pod = dict["Pod"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
                    self.repoId = dict["RepoId"] as! String
                }
                if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                    self.repoName = dict["RepoName"] as! String
                }
                if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                    self.repoNamespace = dict["RepoNamespace"] as! String
                }
                if dict.keys.contains("RepoRegionId") && dict["RepoRegionId"] != nil {
                    self.repoRegionId = dict["RepoRegionId"] as! String
                }
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    self.tag = dict["Tag"] as! String
                }
            }
        }
        public var endTime: Int64?

        public var finish: Int32?

        public var finishCount: String?

        public var progress: Int64?

        public var realRunTime: Int64?

        public var resultInfo: String?

        public var startTime: Int64?

        public var status: String?

        public var statusText: String?

        public var target: String?

        public var targetType: String?

        public var taskId: String?

        public var taskImageInfo: DescribeOnceTaskLeafRecordPageResponseBody.OnceTasks.TaskImageInfo?

        public var taskName: String?

        public var taskType: String?

        public var totalCount: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.taskImageInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.finish != nil {
                map["Finish"] = self.finish!
            }
            if self.finishCount != nil {
                map["FinishCount"] = self.finishCount!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.realRunTime != nil {
                map["RealRunTime"] = self.realRunTime!
            }
            if self.resultInfo != nil {
                map["ResultInfo"] = self.resultInfo!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusText != nil {
                map["StatusText"] = self.statusText!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskImageInfo != nil {
                map["TaskImageInfo"] = self.taskImageInfo?.toMap()
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("Finish") && dict["Finish"] != nil {
                self.finish = dict["Finish"] as! Int32
            }
            if dict.keys.contains("FinishCount") && dict["FinishCount"] != nil {
                self.finishCount = dict["FinishCount"] as! String
            }
            if dict.keys.contains("Progress") && dict["Progress"] != nil {
                self.progress = dict["Progress"] as! Int64
            }
            if dict.keys.contains("RealRunTime") && dict["RealRunTime"] != nil {
                self.realRunTime = dict["RealRunTime"] as! Int64
            }
            if dict.keys.contains("ResultInfo") && dict["ResultInfo"] != nil {
                self.resultInfo = dict["ResultInfo"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StatusText") && dict["StatusText"] != nil {
                self.statusText = dict["StatusText"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskImageInfo") && dict["TaskImageInfo"] != nil {
                var model = DescribeOnceTaskLeafRecordPageResponseBody.OnceTasks.TaskImageInfo()
                model.fromMap(dict["TaskImageInfo"] as! [String: Any])
                self.taskImageInfo = model
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var onceTasks: [DescribeOnceTaskLeafRecordPageResponseBody.OnceTasks]?

    public var pageInfo: DescribeOnceTaskLeafRecordPageResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.onceTasks != nil {
            var tmp : [Any] = []
            for k in self.onceTasks! {
                tmp.append(k.toMap())
            }
            map["OnceTasks"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OnceTasks") && dict["OnceTasks"] != nil {
            var tmp : [DescribeOnceTaskLeafRecordPageResponseBody.OnceTasks] = []
            for v in dict["OnceTasks"] as! [Any] {
                var model = DescribeOnceTaskLeafRecordPageResponseBody.OnceTasks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.onceTasks = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeOnceTaskLeafRecordPageResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeOnceTaskLeafRecordPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOnceTaskLeafRecordPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeOnceTaskLeafRecordPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyCountRequest : Tea.TeaModel {
    public var type: String?

    public var uuidList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! String
        }
    }
}

public class DescribePropertyCountResponseBody : Tea.TeaModel {
    public var autorun: Int32?

    public var cron: Int32?

    public var database: Int32?

    public var lkm: Int32?

    public var port: Int32?

    public var process: Int32?

    public var requestId: String?

    public var sca: Int32?

    public var software: Int32?

    public var user: Int32?

    public var web: Int32?

    public var webserver: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autorun != nil {
            map["Autorun"] = self.autorun!
        }
        if self.cron != nil {
            map["Cron"] = self.cron!
        }
        if self.database != nil {
            map["Database"] = self.database!
        }
        if self.lkm != nil {
            map["Lkm"] = self.lkm!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.process != nil {
            map["Process"] = self.process!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sca != nil {
            map["Sca"] = self.sca!
        }
        if self.software != nil {
            map["Software"] = self.software!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        if self.web != nil {
            map["Web"] = self.web!
        }
        if self.webserver != nil {
            map["Webserver"] = self.webserver!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Autorun") && dict["Autorun"] != nil {
            self.autorun = dict["Autorun"] as! Int32
        }
        if dict.keys.contains("Cron") && dict["Cron"] != nil {
            self.cron = dict["Cron"] as! Int32
        }
        if dict.keys.contains("Database") && dict["Database"] != nil {
            self.database = dict["Database"] as! Int32
        }
        if dict.keys.contains("Lkm") && dict["Lkm"] != nil {
            self.lkm = dict["Lkm"] as! Int32
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Process") && dict["Process"] != nil {
            self.process = dict["Process"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Sca") && dict["Sca"] != nil {
            self.sca = dict["Sca"] as! Int32
        }
        if dict.keys.contains("Software") && dict["Software"] != nil {
            self.software = dict["Software"] as! Int32
        }
        if dict.keys.contains("User") && dict["User"] != nil {
            self.user = dict["User"] as! Int32
        }
        if dict.keys.contains("Web") && dict["Web"] != nil {
            self.web = dict["Web"] as! Int32
        }
        if dict.keys.contains("Webserver") && dict["Webserver"] != nil {
            self.webserver = dict["Webserver"] as! Int32
        }
    }
}

public class DescribePropertyCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyCronDetailRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var extend: String?

    public var pageSize: Int32?

    public var remark: String?

    public var source: String?

    public var user: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.extend != nil {
            map["Extend"] = self.extend!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Extend") && dict["Extend"] != nil {
            self.extend = dict["Extend"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("User") && dict["User"] != nil {
            self.user = dict["User"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribePropertyCronDetailResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class Propertys : Tea.TeaModel {
        public var cmd: String?

        public var createTimestamp: Int64?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var md5: String?

        public var period: String?

        public var source: String?

        public var user: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cmd != nil {
                map["Cmd"] = self.cmd!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cmd") && dict["Cmd"] != nil {
                self.cmd = dict["Cmd"] as! String
            }
            if dict.keys.contains("CreateTimestamp") && dict["CreateTimestamp"] != nil {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Md5") && dict["Md5"] != nil {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("User") && dict["User"] != nil {
                self.user = dict["User"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertyCronDetailResponseBody.PageInfo?

    public var propertys: [DescribePropertyCronDetailResponseBody.Propertys]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertys != nil {
            var tmp : [Any] = []
            for k in self.propertys! {
                tmp.append(k.toMap())
            }
            map["Propertys"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertyCronDetailResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("Propertys") && dict["Propertys"] != nil {
            var tmp : [DescribePropertyCronDetailResponseBody.Propertys] = []
            for v in dict["Propertys"] as! [Any] {
                var model = DescribePropertyCronDetailResponseBody.Propertys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertys = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyCronDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyCronDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyCronDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyCronItemRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var forceFlush: Bool?

    public var pageSize: Int32?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.forceFlush != nil {
            map["ForceFlush"] = self.forceFlush!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ForceFlush") && dict["ForceFlush"] != nil {
            self.forceFlush = dict["ForceFlush"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class DescribePropertyCronItemResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class PropertyItems : Tea.TeaModel {
        public var count: Int32?

        public var source: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertyCronItemResponseBody.PageInfo?

    public var propertyItems: [DescribePropertyCronItemResponseBody.PropertyItems]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertyItems != nil {
            var tmp : [Any] = []
            for k in self.propertyItems! {
                tmp.append(k.toMap())
            }
            map["PropertyItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertyCronItemResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("PropertyItems") && dict["PropertyItems"] != nil {
            var tmp : [DescribePropertyCronItemResponseBody.PropertyItems] = []
            for v in dict["PropertyItems"] as! [Any] {
                var model = DescribePropertyCronItemResponseBody.PropertyItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertyItems = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyCronItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyCronItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyCronItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyPortDetailRequest : Tea.TeaModel {
    public var bindIp: String?

    public var currentPage: Int32?

    public var extend: String?

    public var pageSize: Int32?

    public var port: String?

    public var procName: String?

    public var remark: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bindIp != nil {
            map["BindIp"] = self.bindIp!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.extend != nil {
            map["Extend"] = self.extend!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.procName != nil {
            map["ProcName"] = self.procName!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BindIp") && dict["BindIp"] != nil {
            self.bindIp = dict["BindIp"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Extend") && dict["Extend"] != nil {
            self.extend = dict["Extend"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("ProcName") && dict["ProcName"] != nil {
            self.procName = dict["ProcName"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribePropertyPortDetailResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class Propertys : Tea.TeaModel {
        public var bindIp: String?

        public var createTimestamp: Int64?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var pid: String?

        public var port: String?

        public var procName: String?

        public var proto: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindIp != nil {
                map["BindIp"] = self.bindIp!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.procName != nil {
                map["ProcName"] = self.procName!
            }
            if self.proto != nil {
                map["Proto"] = self.proto!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindIp") && dict["BindIp"] != nil {
                self.bindIp = dict["BindIp"] as! String
            }
            if dict.keys.contains("CreateTimestamp") && dict["CreateTimestamp"] != nil {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Pid") && dict["Pid"] != nil {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("ProcName") && dict["ProcName"] != nil {
                self.procName = dict["ProcName"] as! String
            }
            if dict.keys.contains("Proto") && dict["Proto"] != nil {
                self.proto = dict["Proto"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertyPortDetailResponseBody.PageInfo?

    public var propertys: [DescribePropertyPortDetailResponseBody.Propertys]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertys != nil {
            var tmp : [Any] = []
            for k in self.propertys! {
                tmp.append(k.toMap())
            }
            map["Propertys"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertyPortDetailResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("Propertys") && dict["Propertys"] != nil {
            var tmp : [DescribePropertyPortDetailResponseBody.Propertys] = []
            for v in dict["Propertys"] as! [Any] {
                var model = DescribePropertyPortDetailResponseBody.Propertys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertys = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyPortDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyPortDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyPortDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyPortItemRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var forceFlush: Bool?

    public var pageSize: Int32?

    public var port: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.forceFlush != nil {
            map["ForceFlush"] = self.forceFlush!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ForceFlush") && dict["ForceFlush"] != nil {
            self.forceFlush = dict["ForceFlush"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! String
        }
    }
}

public class DescribePropertyPortItemResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class PropertyItems : Tea.TeaModel {
        public var count: Int32?

        public var port: String?

        public var proto: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.proto != nil {
                map["Proto"] = self.proto!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Proto") && dict["Proto"] != nil {
                self.proto = dict["Proto"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertyPortItemResponseBody.PageInfo?

    public var propertyItems: [DescribePropertyPortItemResponseBody.PropertyItems]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertyItems != nil {
            var tmp : [Any] = []
            for k in self.propertyItems! {
                tmp.append(k.toMap())
            }
            map["PropertyItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertyPortItemResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("PropertyItems") && dict["PropertyItems"] != nil {
            var tmp : [DescribePropertyPortItemResponseBody.PropertyItems] = []
            for v in dict["PropertyItems"] as! [Any] {
                var model = DescribePropertyPortItemResponseBody.PropertyItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertyItems = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyPortItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyPortItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyPortItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyProcDetailRequest : Tea.TeaModel {
    public var cmdline: String?

    public var currentPage: Int32?

    public var extend: String?

    public var name: String?

    public var pageSize: Int32?

    public var procTimeEnd: Int64?

    public var procTimeStart: Int64?

    public var remark: String?

    public var user: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cmdline != nil {
            map["Cmdline"] = self.cmdline!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.extend != nil {
            map["Extend"] = self.extend!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.procTimeEnd != nil {
            map["ProcTimeEnd"] = self.procTimeEnd!
        }
        if self.procTimeStart != nil {
            map["ProcTimeStart"] = self.procTimeStart!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cmdline") && dict["Cmdline"] != nil {
            self.cmdline = dict["Cmdline"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Extend") && dict["Extend"] != nil {
            self.extend = dict["Extend"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcTimeEnd") && dict["ProcTimeEnd"] != nil {
            self.procTimeEnd = dict["ProcTimeEnd"] as! Int64
        }
        if dict.keys.contains("ProcTimeStart") && dict["ProcTimeStart"] != nil {
            self.procTimeStart = dict["ProcTimeStart"] as! Int64
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("User") && dict["User"] != nil {
            self.user = dict["User"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribePropertyProcDetailResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class Propertys : Tea.TeaModel {
        public var cmdline: String?

        public var createTimestamp: Int64?

        public var euidName: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var isPackage: Int32?

        public var md5: String?

        public var name: String?

        public var path: String?

        public var pid: String?

        public var pname: String?

        public var startTime: String?

        public var startTimeDt: Int64?

        public var state: String?

        public var user: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cmdline != nil {
                map["Cmdline"] = self.cmdline!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.euidName != nil {
                map["EuidName"] = self.euidName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.isPackage != nil {
                map["IsPackage"] = self.isPackage!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.pname != nil {
                map["Pname"] = self.pname!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.startTimeDt != nil {
                map["StartTimeDt"] = self.startTimeDt!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cmdline") && dict["Cmdline"] != nil {
                self.cmdline = dict["Cmdline"] as! String
            }
            if dict.keys.contains("CreateTimestamp") && dict["CreateTimestamp"] != nil {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("EuidName") && dict["EuidName"] != nil {
                self.euidName = dict["EuidName"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("IsPackage") && dict["IsPackage"] != nil {
                self.isPackage = dict["IsPackage"] as! Int32
            }
            if dict.keys.contains("Md5") && dict["Md5"] != nil {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Pid") && dict["Pid"] != nil {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("Pname") && dict["Pname"] != nil {
                self.pname = dict["Pname"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("StartTimeDt") && dict["StartTimeDt"] != nil {
                self.startTimeDt = dict["StartTimeDt"] as! Int64
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("User") && dict["User"] != nil {
                self.user = dict["User"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertyProcDetailResponseBody.PageInfo?

    public var propertys: [DescribePropertyProcDetailResponseBody.Propertys]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertys != nil {
            var tmp : [Any] = []
            for k in self.propertys! {
                tmp.append(k.toMap())
            }
            map["Propertys"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertyProcDetailResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("Propertys") && dict["Propertys"] != nil {
            var tmp : [DescribePropertyProcDetailResponseBody.Propertys] = []
            for v in dict["Propertys"] as! [Any] {
                var model = DescribePropertyProcDetailResponseBody.Propertys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertys = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyProcDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyProcDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyProcDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyProcItemRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var forceFlush: Bool?

    public var name: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.forceFlush != nil {
            map["ForceFlush"] = self.forceFlush!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ForceFlush") && dict["ForceFlush"] != nil {
            self.forceFlush = dict["ForceFlush"] as! Bool
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribePropertyProcItemResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class PropertyItems : Tea.TeaModel {
        public var count: Int32?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertyProcItemResponseBody.PageInfo?

    public var propertyItems: [DescribePropertyProcItemResponseBody.PropertyItems]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertyItems != nil {
            var tmp : [Any] = []
            for k in self.propertyItems! {
                tmp.append(k.toMap())
            }
            map["PropertyItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertyProcItemResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("PropertyItems") && dict["PropertyItems"] != nil {
            var tmp : [DescribePropertyProcItemResponseBody.PropertyItems] = []
            for v in dict["PropertyItems"] as! [Any] {
                var model = DescribePropertyProcItemResponseBody.PropertyItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertyItems = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyProcItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyProcItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyProcItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyScaDetailRequest : Tea.TeaModel {
    public var biz: String?

    public var bizType: String?

    public var currentPage: Int32?

    public var lang: String?

    public var name: Int64?

    public var pageSize: Int32?

    public var pid: String?

    public var port: String?

    public var processStartedEnd: Int64?

    public var processStartedStart: Int64?

    public var remark: String?

    public var scaName: String?

    public var scaNamePattern: String?

    public var scaVersion: String?

    public var searchInfo: String?

    public var searchInfoSub: String?

    public var searchItem: String?

    public var searchItemSub: String?

    public var user: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.biz != nil {
            map["Biz"] = self.biz!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pid != nil {
            map["Pid"] = self.pid!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.processStartedEnd != nil {
            map["ProcessStartedEnd"] = self.processStartedEnd!
        }
        if self.processStartedStart != nil {
            map["ProcessStartedStart"] = self.processStartedStart!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.scaName != nil {
            map["ScaName"] = self.scaName!
        }
        if self.scaNamePattern != nil {
            map["ScaNamePattern"] = self.scaNamePattern!
        }
        if self.scaVersion != nil {
            map["ScaVersion"] = self.scaVersion!
        }
        if self.searchInfo != nil {
            map["SearchInfo"] = self.searchInfo!
        }
        if self.searchInfoSub != nil {
            map["SearchInfoSub"] = self.searchInfoSub!
        }
        if self.searchItem != nil {
            map["SearchItem"] = self.searchItem!
        }
        if self.searchItemSub != nil {
            map["SearchItemSub"] = self.searchItemSub!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Biz") && dict["Biz"] != nil {
            self.biz = dict["Biz"] as! String
        }
        if dict.keys.contains("BizType") && dict["BizType"] != nil {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Pid") && dict["Pid"] != nil {
            self.pid = dict["Pid"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("ProcessStartedEnd") && dict["ProcessStartedEnd"] != nil {
            self.processStartedEnd = dict["ProcessStartedEnd"] as! Int64
        }
        if dict.keys.contains("ProcessStartedStart") && dict["ProcessStartedStart"] != nil {
            self.processStartedStart = dict["ProcessStartedStart"] as! Int64
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("ScaName") && dict["ScaName"] != nil {
            self.scaName = dict["ScaName"] as! String
        }
        if dict.keys.contains("ScaNamePattern") && dict["ScaNamePattern"] != nil {
            self.scaNamePattern = dict["ScaNamePattern"] as! String
        }
        if dict.keys.contains("ScaVersion") && dict["ScaVersion"] != nil {
            self.scaVersion = dict["ScaVersion"] as! String
        }
        if dict.keys.contains("SearchInfo") && dict["SearchInfo"] != nil {
            self.searchInfo = dict["SearchInfo"] as! String
        }
        if dict.keys.contains("SearchInfoSub") && dict["SearchInfoSub"] != nil {
            self.searchInfoSub = dict["SearchInfoSub"] as! String
        }
        if dict.keys.contains("SearchItem") && dict["SearchItem"] != nil {
            self.searchItem = dict["SearchItem"] as! String
        }
        if dict.keys.contains("SearchItemSub") && dict["SearchItemSub"] != nil {
            self.searchItemSub = dict["SearchItemSub"] as! String
        }
        if dict.keys.contains("User") && dict["User"] != nil {
            self.user = dict["User"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribePropertyScaDetailResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class Propertys : Tea.TeaModel {
        public var bizType: String?

        public var bizTypeDispaly: String?

        public var cmdline: String?

        public var configPath: String?

        public var containerName: String?

        public var createTimestamp: Int64?

        public var imageName: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var listenIp: String?

        public var listenProtocol: String?

        public var listenStatus: String?

        public var name: String?

        public var path: String?

        public var pid: String?

        public var port: String?

        public var ppid: String?

        public var processStarted: Int64?

        public var processUser: String?

        public var proof: String?

        public var runtimeEnvVersion: String?

        public var type: String?

        public var uuid: String?

        public var version: String?

        public var webPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizType != nil {
                map["BizType"] = self.bizType!
            }
            if self.bizTypeDispaly != nil {
                map["BizTypeDispaly"] = self.bizTypeDispaly!
            }
            if self.cmdline != nil {
                map["Cmdline"] = self.cmdline!
            }
            if self.configPath != nil {
                map["ConfigPath"] = self.configPath!
            }
            if self.containerName != nil {
                map["ContainerName"] = self.containerName!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.listenIp != nil {
                map["ListenIp"] = self.listenIp!
            }
            if self.listenProtocol != nil {
                map["ListenProtocol"] = self.listenProtocol!
            }
            if self.listenStatus != nil {
                map["ListenStatus"] = self.listenStatus!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.ppid != nil {
                map["Ppid"] = self.ppid!
            }
            if self.processStarted != nil {
                map["ProcessStarted"] = self.processStarted!
            }
            if self.processUser != nil {
                map["ProcessUser"] = self.processUser!
            }
            if self.proof != nil {
                map["Proof"] = self.proof!
            }
            if self.runtimeEnvVersion != nil {
                map["RuntimeEnvVersion"] = self.runtimeEnvVersion!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.webPath != nil {
                map["WebPath"] = self.webPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizType") && dict["BizType"] != nil {
                self.bizType = dict["BizType"] as! String
            }
            if dict.keys.contains("BizTypeDispaly") && dict["BizTypeDispaly"] != nil {
                self.bizTypeDispaly = dict["BizTypeDispaly"] as! String
            }
            if dict.keys.contains("Cmdline") && dict["Cmdline"] != nil {
                self.cmdline = dict["Cmdline"] as! String
            }
            if dict.keys.contains("ConfigPath") && dict["ConfigPath"] != nil {
                self.configPath = dict["ConfigPath"] as! String
            }
            if dict.keys.contains("ContainerName") && dict["ContainerName"] != nil {
                self.containerName = dict["ContainerName"] as! String
            }
            if dict.keys.contains("CreateTimestamp") && dict["CreateTimestamp"] != nil {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("ListenIp") && dict["ListenIp"] != nil {
                self.listenIp = dict["ListenIp"] as! String
            }
            if dict.keys.contains("ListenProtocol") && dict["ListenProtocol"] != nil {
                self.listenProtocol = dict["ListenProtocol"] as! String
            }
            if dict.keys.contains("ListenStatus") && dict["ListenStatus"] != nil {
                self.listenStatus = dict["ListenStatus"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Pid") && dict["Pid"] != nil {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Ppid") && dict["Ppid"] != nil {
                self.ppid = dict["Ppid"] as! String
            }
            if dict.keys.contains("ProcessStarted") && dict["ProcessStarted"] != nil {
                self.processStarted = dict["ProcessStarted"] as! Int64
            }
            if dict.keys.contains("ProcessUser") && dict["ProcessUser"] != nil {
                self.processUser = dict["ProcessUser"] as! String
            }
            if dict.keys.contains("Proof") && dict["Proof"] != nil {
                self.proof = dict["Proof"] as! String
            }
            if dict.keys.contains("RuntimeEnvVersion") && dict["RuntimeEnvVersion"] != nil {
                self.runtimeEnvVersion = dict["RuntimeEnvVersion"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("WebPath") && dict["WebPath"] != nil {
                self.webPath = dict["WebPath"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertyScaDetailResponseBody.PageInfo?

    public var propertys: [DescribePropertyScaDetailResponseBody.Propertys]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertys != nil {
            var tmp : [Any] = []
            for k in self.propertys! {
                tmp.append(k.toMap())
            }
            map["Propertys"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertyScaDetailResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("Propertys") && dict["Propertys"] != nil {
            var tmp : [DescribePropertyScaDetailResponseBody.Propertys] = []
            for v in dict["Propertys"] as! [Any] {
                var model = DescribePropertyScaDetailResponseBody.Propertys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertys = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyScaDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyScaDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyScaDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyScaItemRequest : Tea.TeaModel {
    public var biz: String?

    public var currentPage: Int32?

    public var forceFlush: Bool?

    public var lang: String?

    public var pageSize: Int32?

    public var searchInfo: String?

    public var searchItem: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.biz != nil {
            map["Biz"] = self.biz!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.forceFlush != nil {
            map["ForceFlush"] = self.forceFlush!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchInfo != nil {
            map["SearchInfo"] = self.searchInfo!
        }
        if self.searchItem != nil {
            map["SearchItem"] = self.searchItem!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Biz") && dict["Biz"] != nil {
            self.biz = dict["Biz"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ForceFlush") && dict["ForceFlush"] != nil {
            self.forceFlush = dict["ForceFlush"] as! Bool
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchInfo") && dict["SearchInfo"] != nil {
            self.searchInfo = dict["SearchInfo"] as! String
        }
        if dict.keys.contains("SearchItem") && dict["SearchItem"] != nil {
            self.searchItem = dict["SearchItem"] as! String
        }
    }
}

public class DescribePropertyScaItemResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class PropertyItems : Tea.TeaModel {
        public var bizType: String?

        public var count: Int32?

        public var name: String?

        public var typeDisplay: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizType != nil {
                map["BizType"] = self.bizType!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.typeDisplay != nil {
                map["TypeDisplay"] = self.typeDisplay!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizType") && dict["BizType"] != nil {
                self.bizType = dict["BizType"] as! String
            }
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TypeDisplay") && dict["TypeDisplay"] != nil {
                self.typeDisplay = dict["TypeDisplay"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertyScaItemResponseBody.PageInfo?

    public var propertyItems: [DescribePropertyScaItemResponseBody.PropertyItems]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertyItems != nil {
            var tmp : [Any] = []
            for k in self.propertyItems! {
                tmp.append(k.toMap())
            }
            map["PropertyItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertyScaItemResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("PropertyItems") && dict["PropertyItems"] != nil {
            var tmp : [DescribePropertyScaItemResponseBody.PropertyItems] = []
            for v in dict["PropertyItems"] as! [Any] {
                var model = DescribePropertyScaItemResponseBody.PropertyItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertyItems = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyScaItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyScaItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyScaItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyScheduleConfigRequest : Tea.TeaModel {
    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribePropertyScheduleConfigResponseBody : Tea.TeaModel {
    public var config: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyScheduleConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyScheduleConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyScheduleConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertySoftwareDetailRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var extend: String?

    public var installTimeEnd: Int64?

    public var installTimeStart: Int64?

    public var name: String?

    public var pageSize: Int32?

    public var path: String?

    public var remark: String?

    public var softwareVersion: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.extend != nil {
            map["Extend"] = self.extend!
        }
        if self.installTimeEnd != nil {
            map["InstallTimeEnd"] = self.installTimeEnd!
        }
        if self.installTimeStart != nil {
            map["InstallTimeStart"] = self.installTimeStart!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.softwareVersion != nil {
            map["SoftwareVersion"] = self.softwareVersion!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Extend") && dict["Extend"] != nil {
            self.extend = dict["Extend"] as! String
        }
        if dict.keys.contains("InstallTimeEnd") && dict["InstallTimeEnd"] != nil {
            self.installTimeEnd = dict["InstallTimeEnd"] as! Int64
        }
        if dict.keys.contains("InstallTimeStart") && dict["InstallTimeStart"] != nil {
            self.installTimeStart = dict["InstallTimeStart"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SoftwareVersion") && dict["SoftwareVersion"] != nil {
            self.softwareVersion = dict["SoftwareVersion"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribePropertySoftwareDetailResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class Propertys : Tea.TeaModel {
        public var createTimestamp: Int64?

        public var installTime: String?

        public var installTimeDt: Int64?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var name: String?

        public var path: String?

        public var uuid: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.installTime != nil {
                map["InstallTime"] = self.installTime!
            }
            if self.installTimeDt != nil {
                map["InstallTimeDt"] = self.installTimeDt!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTimestamp") && dict["CreateTimestamp"] != nil {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("InstallTime") && dict["InstallTime"] != nil {
                self.installTime = dict["InstallTime"] as! String
            }
            if dict.keys.contains("InstallTimeDt") && dict["InstallTimeDt"] != nil {
                self.installTimeDt = dict["InstallTimeDt"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("Version") && dict["Version"] != nil {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertySoftwareDetailResponseBody.PageInfo?

    public var propertys: [DescribePropertySoftwareDetailResponseBody.Propertys]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertys != nil {
            var tmp : [Any] = []
            for k in self.propertys! {
                tmp.append(k.toMap())
            }
            map["Propertys"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertySoftwareDetailResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("Propertys") && dict["Propertys"] != nil {
            var tmp : [DescribePropertySoftwareDetailResponseBody.Propertys] = []
            for v in dict["Propertys"] as! [Any] {
                var model = DescribePropertySoftwareDetailResponseBody.Propertys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertys = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertySoftwareDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertySoftwareDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertySoftwareDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertySoftwareItemRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var forceFlush: Bool?

    public var name: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.forceFlush != nil {
            map["ForceFlush"] = self.forceFlush!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ForceFlush") && dict["ForceFlush"] != nil {
            self.forceFlush = dict["ForceFlush"] as! Bool
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribePropertySoftwareItemResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class PropertyItems : Tea.TeaModel {
        public var count: Int32?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertySoftwareItemResponseBody.PageInfo?

    public var propertyItems: [DescribePropertySoftwareItemResponseBody.PropertyItems]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertyItems != nil {
            var tmp : [Any] = []
            for k in self.propertyItems! {
                tmp.append(k.toMap())
            }
            map["PropertyItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertySoftwareItemResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("PropertyItems") && dict["PropertyItems"] != nil {
            var tmp : [DescribePropertySoftwareItemResponseBody.PropertyItems] = []
            for v in dict["PropertyItems"] as! [Any] {
                var model = DescribePropertySoftwareItemResponseBody.PropertyItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertyItems = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertySoftwareItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertySoftwareItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertySoftwareItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyTypeScaItemRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var lang: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribePropertyTypeScaItemResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class PropertyTypeItems : Tea.TeaModel {
        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertyTypeScaItemResponseBody.PageInfo?

    public var propertyTypeItems: [DescribePropertyTypeScaItemResponseBody.PropertyTypeItems]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertyTypeItems != nil {
            var tmp : [Any] = []
            for k in self.propertyTypeItems! {
                tmp.append(k.toMap())
            }
            map["PropertyTypeItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertyTypeScaItemResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("PropertyTypeItems") && dict["PropertyTypeItems"] != nil {
            var tmp : [DescribePropertyTypeScaItemResponseBody.PropertyTypeItems] = []
            for v in dict["PropertyTypeItems"] as! [Any] {
                var model = DescribePropertyTypeScaItemResponseBody.PropertyTypeItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertyTypeItems = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyTypeScaItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyTypeScaItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyTypeScaItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyUsageNewestRequest : Tea.TeaModel {
    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribePropertyUsageNewestResponseBody : Tea.TeaModel {
    public class NewestStatisticItems : Tea.TeaModel {
        public var create: Int64?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.create != nil {
                map["Create"] = self.create!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Create") && dict["Create"] != nil {
                self.create = dict["Create"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var itemCount: Int32?

    public var newestStatisticItems: [DescribePropertyUsageNewestResponseBody.NewestStatisticItems]?

    public var requestId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemCount != nil {
            map["ItemCount"] = self.itemCount!
        }
        if self.newestStatisticItems != nil {
            var tmp : [Any] = []
            for k in self.newestStatisticItems! {
                tmp.append(k.toMap())
            }
            map["NewestStatisticItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ItemCount") && dict["ItemCount"] != nil {
            self.itemCount = dict["ItemCount"] as! Int32
        }
        if dict.keys.contains("NewestStatisticItems") && dict["NewestStatisticItems"] != nil {
            var tmp : [DescribePropertyUsageNewestResponseBody.NewestStatisticItems] = []
            for v in dict["NewestStatisticItems"] as! [Any] {
                var model = DescribePropertyUsageNewestResponseBody.NewestStatisticItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.newestStatisticItems = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribePropertyUsageNewestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyUsageNewestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyUsageNewestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyUserDetailRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var extend: String?

    public var isRoot: String?

    public var lastLoginTimeEnd: Int64?

    public var lastLoginTimeStart: Int64?

    public var pageSize: Int32?

    public var remark: String?

    public var user: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.extend != nil {
            map["Extend"] = self.extend!
        }
        if self.isRoot != nil {
            map["IsRoot"] = self.isRoot!
        }
        if self.lastLoginTimeEnd != nil {
            map["LastLoginTimeEnd"] = self.lastLoginTimeEnd!
        }
        if self.lastLoginTimeStart != nil {
            map["LastLoginTimeStart"] = self.lastLoginTimeStart!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Extend") && dict["Extend"] != nil {
            self.extend = dict["Extend"] as! String
        }
        if dict.keys.contains("IsRoot") && dict["IsRoot"] != nil {
            self.isRoot = dict["IsRoot"] as! String
        }
        if dict.keys.contains("LastLoginTimeEnd") && dict["LastLoginTimeEnd"] != nil {
            self.lastLoginTimeEnd = dict["LastLoginTimeEnd"] as! Int64
        }
        if dict.keys.contains("LastLoginTimeStart") && dict["LastLoginTimeStart"] != nil {
            self.lastLoginTimeStart = dict["LastLoginTimeStart"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("User") && dict["User"] != nil {
            self.user = dict["User"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribePropertyUserDetailResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class Propertys : Tea.TeaModel {
        public var accountsExpirationDate: String?

        public var createTimestamp: Int64?

        public var groupNames: [String]?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var isCouldLogin: Int32?

        public var isPasswdExpired: Int32?

        public var isPasswdLocked: Int32?

        public var isRoot: String?

        public var isSudoer: Int32?

        public var isUserExpired: Int32?

        public var lastLoginIp: String?

        public var lastLoginTime: String?

        public var lastLoginTimeDt: Int64?

        public var lastLoginTimestamp: Int64?

        public var passwordExpirationDate: String?

        public var status: String?

        public var user: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountsExpirationDate != nil {
                map["AccountsExpirationDate"] = self.accountsExpirationDate!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.groupNames != nil {
                map["GroupNames"] = self.groupNames!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.isCouldLogin != nil {
                map["IsCouldLogin"] = self.isCouldLogin!
            }
            if self.isPasswdExpired != nil {
                map["IsPasswdExpired"] = self.isPasswdExpired!
            }
            if self.isPasswdLocked != nil {
                map["IsPasswdLocked"] = self.isPasswdLocked!
            }
            if self.isRoot != nil {
                map["IsRoot"] = self.isRoot!
            }
            if self.isSudoer != nil {
                map["IsSudoer"] = self.isSudoer!
            }
            if self.isUserExpired != nil {
                map["IsUserExpired"] = self.isUserExpired!
            }
            if self.lastLoginIp != nil {
                map["LastLoginIp"] = self.lastLoginIp!
            }
            if self.lastLoginTime != nil {
                map["LastLoginTime"] = self.lastLoginTime!
            }
            if self.lastLoginTimeDt != nil {
                map["LastLoginTimeDt"] = self.lastLoginTimeDt!
            }
            if self.lastLoginTimestamp != nil {
                map["LastLoginTimestamp"] = self.lastLoginTimestamp!
            }
            if self.passwordExpirationDate != nil {
                map["PasswordExpirationDate"] = self.passwordExpirationDate!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountsExpirationDate") && dict["AccountsExpirationDate"] != nil {
                self.accountsExpirationDate = dict["AccountsExpirationDate"] as! String
            }
            if dict.keys.contains("CreateTimestamp") && dict["CreateTimestamp"] != nil {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("GroupNames") && dict["GroupNames"] != nil {
                self.groupNames = dict["GroupNames"] as! [String]
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("IsCouldLogin") && dict["IsCouldLogin"] != nil {
                self.isCouldLogin = dict["IsCouldLogin"] as! Int32
            }
            if dict.keys.contains("IsPasswdExpired") && dict["IsPasswdExpired"] != nil {
                self.isPasswdExpired = dict["IsPasswdExpired"] as! Int32
            }
            if dict.keys.contains("IsPasswdLocked") && dict["IsPasswdLocked"] != nil {
                self.isPasswdLocked = dict["IsPasswdLocked"] as! Int32
            }
            if dict.keys.contains("IsRoot") && dict["IsRoot"] != nil {
                self.isRoot = dict["IsRoot"] as! String
            }
            if dict.keys.contains("IsSudoer") && dict["IsSudoer"] != nil {
                self.isSudoer = dict["IsSudoer"] as! Int32
            }
            if dict.keys.contains("IsUserExpired") && dict["IsUserExpired"] != nil {
                self.isUserExpired = dict["IsUserExpired"] as! Int32
            }
            if dict.keys.contains("LastLoginIp") && dict["LastLoginIp"] != nil {
                self.lastLoginIp = dict["LastLoginIp"] as! String
            }
            if dict.keys.contains("LastLoginTime") && dict["LastLoginTime"] != nil {
                self.lastLoginTime = dict["LastLoginTime"] as! String
            }
            if dict.keys.contains("LastLoginTimeDt") && dict["LastLoginTimeDt"] != nil {
                self.lastLoginTimeDt = dict["LastLoginTimeDt"] as! Int64
            }
            if dict.keys.contains("LastLoginTimestamp") && dict["LastLoginTimestamp"] != nil {
                self.lastLoginTimestamp = dict["LastLoginTimestamp"] as! Int64
            }
            if dict.keys.contains("PasswordExpirationDate") && dict["PasswordExpirationDate"] != nil {
                self.passwordExpirationDate = dict["PasswordExpirationDate"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("User") && dict["User"] != nil {
                self.user = dict["User"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertyUserDetailResponseBody.PageInfo?

    public var propertys: [DescribePropertyUserDetailResponseBody.Propertys]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertys != nil {
            var tmp : [Any] = []
            for k in self.propertys! {
                tmp.append(k.toMap())
            }
            map["Propertys"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertyUserDetailResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("Propertys") && dict["Propertys"] != nil {
            var tmp : [DescribePropertyUserDetailResponseBody.Propertys] = []
            for v in dict["Propertys"] as! [Any] {
                var model = DescribePropertyUserDetailResponseBody.Propertys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertys = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyUserDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyUserDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyUserDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePropertyUserItemRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var forceFlush: Bool?

    public var pageSize: Int32?

    public var user: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.forceFlush != nil {
            map["ForceFlush"] = self.forceFlush!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ForceFlush") && dict["ForceFlush"] != nil {
            self.forceFlush = dict["ForceFlush"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("User") && dict["User"] != nil {
            self.user = dict["User"] as! String
        }
    }
}

public class DescribePropertyUserItemResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class PropertyItems : Tea.TeaModel {
        public var count: Int32?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("User") && dict["User"] != nil {
                self.user = dict["User"] as! String
            }
        }
    }
    public var pageInfo: DescribePropertyUserItemResponseBody.PageInfo?

    public var propertyItems: [DescribePropertyUserItemResponseBody.PropertyItems]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertyItems != nil {
            var tmp : [Any] = []
            for k in self.propertyItems! {
                tmp.append(k.toMap())
            }
            map["PropertyItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribePropertyUserItemResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("PropertyItems") && dict["PropertyItems"] != nil {
            var tmp : [DescribePropertyUserItemResponseBody.PropertyItems] = []
            for v in dict["PropertyItems"] as! [Any] {
                var model = DescribePropertyUserItemResponseBody.PropertyItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertyItems = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePropertyUserItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePropertyUserItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribePropertyUserItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeQuaraFileDownloadInfoRequest : Tea.TeaModel {
    public var from: String?

    public var quaraFileId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.quaraFileId != nil {
            map["QuaraFileId"] = self.quaraFileId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("QuaraFileId") && dict["QuaraFileId"] != nil {
            self.quaraFileId = dict["QuaraFileId"] as! Int32
        }
    }
}

public class DescribeQuaraFileDownloadInfoResponseBody : Tea.TeaModel {
    public var downloadUrl: String?

    public var md5: String?

    public var path: String?

    public var quaraFileId: Int32?

    public var requestId: String?

    public var tag: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadUrl != nil {
            map["DownloadUrl"] = self.downloadUrl!
        }
        if self.md5 != nil {
            map["Md5"] = self.md5!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.quaraFileId != nil {
            map["QuaraFileId"] = self.quaraFileId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
            self.downloadUrl = dict["DownloadUrl"] as! String
        }
        if dict.keys.contains("Md5") && dict["Md5"] != nil {
            self.md5 = dict["Md5"] as! String
        }
        if dict.keys.contains("Path") && dict["Path"] != nil {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("QuaraFileId") && dict["QuaraFileId"] != nil {
            self.quaraFileId = dict["QuaraFileId"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeQuaraFileDownloadInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeQuaraFileDownloadInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeQuaraFileDownloadInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRestoreJobsRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var machineRemark: String?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.machineRemark != nil {
            map["MachineRemark"] = self.machineRemark!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("MachineRemark") && dict["MachineRemark"] != nil {
            self.machineRemark = dict["MachineRemark"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeRestoreJobsResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class RestoreJobs : Tea.TeaModel {
        public var actualBytes: Int64?

        public var bytesDone: Int64?

        public var bytesTotal: Int64?

        public var clientId: String?

        public var completeTime: Int64?

        public var createdTime: Int64?

        public var duration: Int64?

        public var errorCount: Int64?

        public var errorFile: String?

        public var errorFileUrl: String?

        public var errorType: String?

        public var eta: Int64?

        public var excludes: String?

        public var exitCode: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var includes: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var itemsDone: Int64?

        public var itemsTotal: Int64?

        public var message: String?

        public var percentage: Int32?

        public var requestId: String?

        public var restoreId: String?

        public var restoreName: String?

        public var restoreType: String?

        public var snapshotHash: String?

        public var snapshotId: String?

        public var snapshotVersion: String?

        public var source: String?

        public var sourceClientId: String?

        public var speed: Int64?

        public var status: String?

        public var target: String?

        public var updatedTime: Int64?

        public var uuid: String?

        public var vaultId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualBytes != nil {
                map["ActualBytes"] = self.actualBytes!
            }
            if self.bytesDone != nil {
                map["BytesDone"] = self.bytesDone!
            }
            if self.bytesTotal != nil {
                map["BytesTotal"] = self.bytesTotal!
            }
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.completeTime != nil {
                map["CompleteTime"] = self.completeTime!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.errorCount != nil {
                map["ErrorCount"] = self.errorCount!
            }
            if self.errorFile != nil {
                map["ErrorFile"] = self.errorFile!
            }
            if self.errorFileUrl != nil {
                map["ErrorFileUrl"] = self.errorFileUrl!
            }
            if self.errorType != nil {
                map["ErrorType"] = self.errorType!
            }
            if self.eta != nil {
                map["Eta"] = self.eta!
            }
            if self.excludes != nil {
                map["Excludes"] = self.excludes!
            }
            if self.exitCode != nil {
                map["ExitCode"] = self.exitCode!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.includes != nil {
                map["Includes"] = self.includes!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.itemsDone != nil {
                map["ItemsDone"] = self.itemsDone!
            }
            if self.itemsTotal != nil {
                map["ItemsTotal"] = self.itemsTotal!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.percentage != nil {
                map["Percentage"] = self.percentage!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.restoreId != nil {
                map["RestoreId"] = self.restoreId!
            }
            if self.restoreName != nil {
                map["RestoreName"] = self.restoreName!
            }
            if self.restoreType != nil {
                map["RestoreType"] = self.restoreType!
            }
            if self.snapshotHash != nil {
                map["SnapshotHash"] = self.snapshotHash!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            if self.snapshotVersion != nil {
                map["SnapshotVersion"] = self.snapshotVersion!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.sourceClientId != nil {
                map["SourceClientId"] = self.sourceClientId!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vaultId != nil {
                map["VaultId"] = self.vaultId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActualBytes") && dict["ActualBytes"] != nil {
                self.actualBytes = dict["ActualBytes"] as! Int64
            }
            if dict.keys.contains("BytesDone") && dict["BytesDone"] != nil {
                self.bytesDone = dict["BytesDone"] as! Int64
            }
            if dict.keys.contains("BytesTotal") && dict["BytesTotal"] != nil {
                self.bytesTotal = dict["BytesTotal"] as! Int64
            }
            if dict.keys.contains("ClientId") && dict["ClientId"] != nil {
                self.clientId = dict["ClientId"] as! String
            }
            if dict.keys.contains("CompleteTime") && dict["CompleteTime"] != nil {
                self.completeTime = dict["CompleteTime"] as! Int64
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("ErrorCount") && dict["ErrorCount"] != nil {
                self.errorCount = dict["ErrorCount"] as! Int64
            }
            if dict.keys.contains("ErrorFile") && dict["ErrorFile"] != nil {
                self.errorFile = dict["ErrorFile"] as! String
            }
            if dict.keys.contains("ErrorFileUrl") && dict["ErrorFileUrl"] != nil {
                self.errorFileUrl = dict["ErrorFileUrl"] as! String
            }
            if dict.keys.contains("ErrorType") && dict["ErrorType"] != nil {
                self.errorType = dict["ErrorType"] as! String
            }
            if dict.keys.contains("Eta") && dict["Eta"] != nil {
                self.eta = dict["Eta"] as! Int64
            }
            if dict.keys.contains("Excludes") && dict["Excludes"] != nil {
                self.excludes = dict["Excludes"] as! String
            }
            if dict.keys.contains("ExitCode") && dict["ExitCode"] != nil {
                self.exitCode = dict["ExitCode"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Includes") && dict["Includes"] != nil {
                self.includes = dict["Includes"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("ItemsDone") && dict["ItemsDone"] != nil {
                self.itemsDone = dict["ItemsDone"] as! Int64
            }
            if dict.keys.contains("ItemsTotal") && dict["ItemsTotal"] != nil {
                self.itemsTotal = dict["ItemsTotal"] as! Int64
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Percentage") && dict["Percentage"] != nil {
                self.percentage = dict["Percentage"] as! Int32
            }
            if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("RestoreId") && dict["RestoreId"] != nil {
                self.restoreId = dict["RestoreId"] as! String
            }
            if dict.keys.contains("RestoreName") && dict["RestoreName"] != nil {
                self.restoreName = dict["RestoreName"] as! String
            }
            if dict.keys.contains("RestoreType") && dict["RestoreType"] != nil {
                self.restoreType = dict["RestoreType"] as! String
            }
            if dict.keys.contains("SnapshotHash") && dict["SnapshotHash"] != nil {
                self.snapshotHash = dict["SnapshotHash"] as! String
            }
            if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
                self.snapshotId = dict["SnapshotId"] as! String
            }
            if dict.keys.contains("SnapshotVersion") && dict["SnapshotVersion"] != nil {
                self.snapshotVersion = dict["SnapshotVersion"] as! String
            }
            if dict.keys.contains("Source") && dict["Source"] != nil {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("SourceClientId") && dict["SourceClientId"] != nil {
                self.sourceClientId = dict["SourceClientId"] as! String
            }
            if dict.keys.contains("Speed") && dict["Speed"] != nil {
                self.speed = dict["Speed"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                self.updatedTime = dict["UpdatedTime"] as! Int64
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VaultId") && dict["VaultId"] != nil {
                self.vaultId = dict["VaultId"] as! String
            }
        }
    }
    public var pageInfo: DescribeRestoreJobsResponseBody.PageInfo?

    public var requestId: String?

    public var restoreJobs: [DescribeRestoreJobsResponseBody.RestoreJobs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.restoreJobs != nil {
            var tmp : [Any] = []
            for k in self.restoreJobs! {
                tmp.append(k.toMap())
            }
            map["RestoreJobs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeRestoreJobsResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RestoreJobs") && dict["RestoreJobs"] != nil {
            var tmp : [DescribeRestoreJobsResponseBody.RestoreJobs] = []
            for v in dict["RestoreJobs"] as! [Any] {
                var model = DescribeRestoreJobsResponseBody.RestoreJobs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.restoreJobs = tmp
        }
    }
}

public class DescribeRestoreJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRestoreJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRestoreJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRestorePlansRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var instanceName: String?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeRestorePlansResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class RestorePlans : Tea.TeaModel {
        public var createdTime: Int64?

        public var databaseName: String?

        public var instanceName: String?

        public var policyId: Int64?

        public var policyName: String?

        public var restorePoint: Int64?

        public var status: String?

        public var targetDatabaseName: String?

        public var targetInstanceId: String?

        public var targetInstanceName: String?

        public var updatedTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.policyId != nil {
                map["PolicyId"] = self.policyId!
            }
            if self.policyName != nil {
                map["PolicyName"] = self.policyName!
            }
            if self.restorePoint != nil {
                map["RestorePoint"] = self.restorePoint!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.targetDatabaseName != nil {
                map["TargetDatabaseName"] = self.targetDatabaseName!
            }
            if self.targetInstanceId != nil {
                map["TargetInstanceId"] = self.targetInstanceId!
            }
            if self.targetInstanceName != nil {
                map["TargetInstanceName"] = self.targetInstanceName!
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("DatabaseName") && dict["DatabaseName"] != nil {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
                self.policyId = dict["PolicyId"] as! Int64
            }
            if dict.keys.contains("PolicyName") && dict["PolicyName"] != nil {
                self.policyName = dict["PolicyName"] as! String
            }
            if dict.keys.contains("RestorePoint") && dict["RestorePoint"] != nil {
                self.restorePoint = dict["RestorePoint"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TargetDatabaseName") && dict["TargetDatabaseName"] != nil {
                self.targetDatabaseName = dict["TargetDatabaseName"] as! String
            }
            if dict.keys.contains("TargetInstanceId") && dict["TargetInstanceId"] != nil {
                self.targetInstanceId = dict["TargetInstanceId"] as! String
            }
            if dict.keys.contains("TargetInstanceName") && dict["TargetInstanceName"] != nil {
                self.targetInstanceName = dict["TargetInstanceName"] as! String
            }
            if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                self.updatedTime = dict["UpdatedTime"] as! Int64
            }
        }
    }
    public var pageInfo: DescribeRestorePlansResponseBody.PageInfo?

    public var requestId: String?

    public var restorePlans: [DescribeRestorePlansResponseBody.RestorePlans]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.restorePlans != nil {
            var tmp : [Any] = []
            for k in self.restorePlans! {
                tmp.append(k.toMap())
            }
            map["RestorePlans"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeRestorePlansResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RestorePlans") && dict["RestorePlans"] != nil {
            var tmp : [DescribeRestorePlansResponseBody.RestorePlans] = []
            for v in dict["RestorePlans"] as! [Any] {
                var model = DescribeRestorePlansResponseBody.RestorePlans()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.restorePlans = tmp
        }
    }
}

public class DescribeRestorePlansResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRestorePlansResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRestorePlansResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRiskCheckItemResultRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var itemId: Int64?

    public var lang: String?

    public var pageSize: Int32?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeRiskCheckItemResultResponseBody : Tea.TeaModel {
    public class PageContentResource : Tea.TeaModel {
        public var contentResource: [String: Any]?

        public var count: Int32?

        public var currentPage: Int32?

        public var pageCount: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentResource != nil {
                map["ContentResource"] = self.contentResource!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageCount != nil {
                map["PageCount"] = self.pageCount!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentResource") && dict["ContentResource"] != nil {
                self.contentResource = dict["ContentResource"] as! [String: Any]
            }
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageCount") && dict["PageCount"] != nil {
                self.pageCount = dict["PageCount"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var pageContentResource: DescribeRiskCheckItemResultResponseBody.PageContentResource?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageContentResource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageContentResource != nil {
            map["PageContentResource"] = self.pageContentResource?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageContentResource") && dict["PageContentResource"] != nil {
            var model = DescribeRiskCheckItemResultResponseBody.PageContentResource()
            model.fromMap(dict["PageContentResource"] as! [String: Any])
            self.pageContentResource = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRiskCheckItemResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRiskCheckItemResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRiskCheckItemResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRiskCheckResultRequest : Tea.TeaModel {
    public var assetType: String?

    public var currentPage: Int32?

    public var groupId: Int64?

    public var itemIds: [String]?

    public var lang: String?

    public var name: String?

    public var pageSize: Int32?

    public var queryFlag: String?

    public var resourceOwnerId: Int64?

    public var riskLevel: String?

    public var sourceIp: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetType != nil {
            map["AssetType"] = self.assetType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryFlag != nil {
            map["QueryFlag"] = self.queryFlag!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.riskLevel != nil {
            map["RiskLevel"] = self.riskLevel!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
            self.assetType = dict["AssetType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIds = dict["ItemIds"] as! [String]
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QueryFlag") && dict["QueryFlag"] != nil {
            self.queryFlag = dict["QueryFlag"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
            self.riskLevel = dict["RiskLevel"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeRiskCheckResultResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public class RiskItemResources : Tea.TeaModel {
            public var contentResource: [String: Any]?

            public var resourceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentResource != nil {
                    map["ContentResource"] = self.contentResource!
                }
                if self.resourceName != nil {
                    map["ResourceName"] = self.resourceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentResource") && dict["ContentResource"] != nil {
                    self.contentResource = dict["ContentResource"] as! [String: Any]
                }
                if dict.keys.contains("ResourceName") && dict["ResourceName"] != nil {
                    self.resourceName = dict["ResourceName"] as! String
                }
            }
        }
        public var affectedCount: Int32?

        public var checkTime: Int64?

        public var itemId: Int64?

        public var remainingTime: Int32?

        public var repairStatus: String?

        public var riskAssertType: String?

        public var riskItemResources: [DescribeRiskCheckResultResponseBody.List.RiskItemResources]?

        public var riskLevel: String?

        public var sort: Int32?

        public var startStatus: String?

        public var status: String?

        public var taskId: Int64?

        public var title: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectedCount != nil {
                map["AffectedCount"] = self.affectedCount!
            }
            if self.checkTime != nil {
                map["CheckTime"] = self.checkTime!
            }
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.remainingTime != nil {
                map["RemainingTime"] = self.remainingTime!
            }
            if self.repairStatus != nil {
                map["RepairStatus"] = self.repairStatus!
            }
            if self.riskAssertType != nil {
                map["RiskAssertType"] = self.riskAssertType!
            }
            if self.riskItemResources != nil {
                var tmp : [Any] = []
                for k in self.riskItemResources! {
                    tmp.append(k.toMap())
                }
                map["RiskItemResources"] = tmp
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.sort != nil {
                map["Sort"] = self.sort!
            }
            if self.startStatus != nil {
                map["StartStatus"] = self.startStatus!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AffectedCount") && dict["AffectedCount"] != nil {
                self.affectedCount = dict["AffectedCount"] as! Int32
            }
            if dict.keys.contains("CheckTime") && dict["CheckTime"] != nil {
                self.checkTime = dict["CheckTime"] as! Int64
            }
            if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
                self.itemId = dict["ItemId"] as! Int64
            }
            if dict.keys.contains("RemainingTime") && dict["RemainingTime"] != nil {
                self.remainingTime = dict["RemainingTime"] as! Int32
            }
            if dict.keys.contains("RepairStatus") && dict["RepairStatus"] != nil {
                self.repairStatus = dict["RepairStatus"] as! String
            }
            if dict.keys.contains("RiskAssertType") && dict["RiskAssertType"] != nil {
                self.riskAssertType = dict["RiskAssertType"] as! String
            }
            if dict.keys.contains("RiskItemResources") && dict["RiskItemResources"] != nil {
                var tmp : [DescribeRiskCheckResultResponseBody.List.RiskItemResources] = []
                for v in dict["RiskItemResources"] as! [Any] {
                    var model = DescribeRiskCheckResultResponseBody.List.RiskItemResources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.riskItemResources = tmp
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("Sort") && dict["Sort"] != nil {
                self.sort = dict["Sort"] as! Int32
            }
            if dict.keys.contains("StartStatus") && dict["StartStatus"] != nil {
                self.startStatus = dict["StartStatus"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! Int64
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var count: Int32?

    public var currentPage: Int32?

    public var list: [DescribeRiskCheckResultResponseBody.List]?

    public var pageCount: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageCount != nil {
            map["PageCount"] = self.pageCount!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [DescribeRiskCheckResultResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = DescribeRiskCheckResultResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageCount") && dict["PageCount"] != nil {
            self.pageCount = dict["PageCount"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeRiskCheckResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRiskCheckResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRiskCheckResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRiskCheckSummaryRequest : Tea.TeaModel {
    public var lang: String?

    public var resourceDirectoryAccountId: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeRiskCheckSummaryResponseBody : Tea.TeaModel {
    public class RiskCheckSummary : Tea.TeaModel {
        public class Groups : Tea.TeaModel {
            public class CountByStatus : Tea.TeaModel {
                public var count: Int32?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") && dict["Count"] != nil {
                        self.count = dict["Count"] as! Int32
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public var countByStatus: [DescribeRiskCheckSummaryResponseBody.RiskCheckSummary.Groups.CountByStatus]?

            public var id: Int64?

            public var remainingTime: Int32?

            public var sort: Int32?

            public var status: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.countByStatus != nil {
                    var tmp : [Any] = []
                    for k in self.countByStatus! {
                        tmp.append(k.toMap())
                    }
                    map["CountByStatus"] = tmp
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.remainingTime != nil {
                    map["RemainingTime"] = self.remainingTime!
                }
                if self.sort != nil {
                    map["Sort"] = self.sort!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CountByStatus") && dict["CountByStatus"] != nil {
                    var tmp : [DescribeRiskCheckSummaryResponseBody.RiskCheckSummary.Groups.CountByStatus] = []
                    for v in dict["CountByStatus"] as! [Any] {
                        var model = DescribeRiskCheckSummaryResponseBody.RiskCheckSummary.Groups.CountByStatus()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.countByStatus = tmp
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("RemainingTime") && dict["RemainingTime"] != nil {
                    self.remainingTime = dict["RemainingTime"] as! Int32
                }
                if dict.keys.contains("Sort") && dict["Sort"] != nil {
                    self.sort = dict["Sort"] as! Int32
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public class RiskLevelCount : Tea.TeaModel {
            public var count: Int32?

            public var key: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") && dict["Count"] != nil {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
            }
        }
        public var affectedAssetCount: Int32?

        public var disabledRiskCount: Int32?

        public var enabledRiskCount: Int32?

        public var groups: [DescribeRiskCheckSummaryResponseBody.RiskCheckSummary.Groups]?

        public var itemCount: Int32?

        public var previousCount: Int32?

        public var previousTime: Int64?

        public var riskCount: Int32?

        public var riskLevelCount: [DescribeRiskCheckSummaryResponseBody.RiskCheckSummary.RiskLevelCount]?

        public var riskRate: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.affectedAssetCount != nil {
                map["AffectedAssetCount"] = self.affectedAssetCount!
            }
            if self.disabledRiskCount != nil {
                map["DisabledRiskCount"] = self.disabledRiskCount!
            }
            if self.enabledRiskCount != nil {
                map["EnabledRiskCount"] = self.enabledRiskCount!
            }
            if self.groups != nil {
                var tmp : [Any] = []
                for k in self.groups! {
                    tmp.append(k.toMap())
                }
                map["Groups"] = tmp
            }
            if self.itemCount != nil {
                map["ItemCount"] = self.itemCount!
            }
            if self.previousCount != nil {
                map["PreviousCount"] = self.previousCount!
            }
            if self.previousTime != nil {
                map["PreviousTime"] = self.previousTime!
            }
            if self.riskCount != nil {
                map["RiskCount"] = self.riskCount!
            }
            if self.riskLevelCount != nil {
                var tmp : [Any] = []
                for k in self.riskLevelCount! {
                    tmp.append(k.toMap())
                }
                map["RiskLevelCount"] = tmp
            }
            if self.riskRate != nil {
                map["RiskRate"] = self.riskRate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AffectedAssetCount") && dict["AffectedAssetCount"] != nil {
                self.affectedAssetCount = dict["AffectedAssetCount"] as! Int32
            }
            if dict.keys.contains("DisabledRiskCount") && dict["DisabledRiskCount"] != nil {
                self.disabledRiskCount = dict["DisabledRiskCount"] as! Int32
            }
            if dict.keys.contains("EnabledRiskCount") && dict["EnabledRiskCount"] != nil {
                self.enabledRiskCount = dict["EnabledRiskCount"] as! Int32
            }
            if dict.keys.contains("Groups") && dict["Groups"] != nil {
                var tmp : [DescribeRiskCheckSummaryResponseBody.RiskCheckSummary.Groups] = []
                for v in dict["Groups"] as! [Any] {
                    var model = DescribeRiskCheckSummaryResponseBody.RiskCheckSummary.Groups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.groups = tmp
            }
            if dict.keys.contains("ItemCount") && dict["ItemCount"] != nil {
                self.itemCount = dict["ItemCount"] as! Int32
            }
            if dict.keys.contains("PreviousCount") && dict["PreviousCount"] != nil {
                self.previousCount = dict["PreviousCount"] as! Int32
            }
            if dict.keys.contains("PreviousTime") && dict["PreviousTime"] != nil {
                self.previousTime = dict["PreviousTime"] as! Int64
            }
            if dict.keys.contains("RiskCount") && dict["RiskCount"] != nil {
                self.riskCount = dict["RiskCount"] as! Int32
            }
            if dict.keys.contains("RiskLevelCount") && dict["RiskLevelCount"] != nil {
                var tmp : [DescribeRiskCheckSummaryResponseBody.RiskCheckSummary.RiskLevelCount] = []
                for v in dict["RiskLevelCount"] as! [Any] {
                    var model = DescribeRiskCheckSummaryResponseBody.RiskCheckSummary.RiskLevelCount()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.riskLevelCount = tmp
            }
            if dict.keys.contains("RiskRate") && dict["RiskRate"] != nil {
                self.riskRate = dict["RiskRate"] as! Double
            }
        }
    }
    public var requestId: String?

    public var riskCheckSummary: DescribeRiskCheckSummaryResponseBody.RiskCheckSummary?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.riskCheckSummary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.riskCheckSummary != nil {
            map["RiskCheckSummary"] = self.riskCheckSummary?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RiskCheckSummary") && dict["RiskCheckSummary"] != nil {
            var model = DescribeRiskCheckSummaryResponseBody.RiskCheckSummary()
            model.fromMap(dict["RiskCheckSummary"] as! [String: Any])
            self.riskCheckSummary = model
        }
    }
}

public class DescribeRiskCheckSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRiskCheckSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRiskCheckSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRiskItemTypeRequest : Tea.TeaModel {
    public var lang: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeRiskItemTypeResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var id: Int64?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var list: [DescribeRiskItemTypeResponseBody.List]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [DescribeRiskItemTypeResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = DescribeRiskItemTypeResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRiskItemTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRiskItemTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRiskItemTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRiskListCheckResultRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var instanceIds: [String]?

    public var lang: String?

    public var pageSize: Int32?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeRiskListCheckResultResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var instanceId: String?

        public var riskCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.riskCount != nil {
                map["riskCount"] = self.riskCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("riskCount") && dict["riskCount"] != nil {
                self.riskCount = dict["riskCount"] as! Int64
            }
        }
    }
    public var list: [DescribeRiskListCheckResultResponseBody.List]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [DescribeRiskListCheckResultResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = DescribeRiskListCheckResultResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRiskListCheckResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRiskListCheckResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRiskListCheckResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRiskTypeRequest : Tea.TeaModel {
    public var lang: String?

    public var source: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeRiskTypeResponseBody : Tea.TeaModel {
    public class RiskTypes : Tea.TeaModel {
        public class SubTypes : Tea.TeaModel {
            public class CheckDetails : Tea.TeaModel {
                public class Rules : Tea.TeaModel {
                    public class ParamList : Tea.TeaModel {
                        public var enumValue: String?

                        public var maxValue: Int32?

                        public var minValue: Int32?

                        public var paramDefaultValue: String?

                        public var paramDesc: String?

                        public var paramName: String?

                        public var paramType: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.enumValue != nil {
                                map["EnumValue"] = self.enumValue!
                            }
                            if self.maxValue != nil {
                                map["MaxValue"] = self.maxValue!
                            }
                            if self.minValue != nil {
                                map["MinValue"] = self.minValue!
                            }
                            if self.paramDefaultValue != nil {
                                map["ParamDefaultValue"] = self.paramDefaultValue!
                            }
                            if self.paramDesc != nil {
                                map["ParamDesc"] = self.paramDesc!
                            }
                            if self.paramName != nil {
                                map["ParamName"] = self.paramName!
                            }
                            if self.paramType != nil {
                                map["ParamType"] = self.paramType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("EnumValue") && dict["EnumValue"] != nil {
                                self.enumValue = dict["EnumValue"] as! String
                            }
                            if dict.keys.contains("MaxValue") && dict["MaxValue"] != nil {
                                self.maxValue = dict["MaxValue"] as! Int32
                            }
                            if dict.keys.contains("MinValue") && dict["MinValue"] != nil {
                                self.minValue = dict["MinValue"] as! Int32
                            }
                            if dict.keys.contains("ParamDefaultValue") && dict["ParamDefaultValue"] != nil {
                                self.paramDefaultValue = dict["ParamDefaultValue"] as! String
                            }
                            if dict.keys.contains("ParamDesc") && dict["ParamDesc"] != nil {
                                self.paramDesc = dict["ParamDesc"] as! String
                            }
                            if dict.keys.contains("ParamName") && dict["ParamName"] != nil {
                                self.paramName = dict["ParamName"] as! String
                            }
                            if dict.keys.contains("ParamType") && dict["ParamType"] != nil {
                                self.paramType = dict["ParamType"] as! Int32
                            }
                        }
                    }
                    public var optional_: Int32?

                    public var paramList: [DescribeRiskTypeResponseBody.RiskTypes.SubTypes.CheckDetails.Rules.ParamList]?

                    public var ruleDesc: String?

                    public var ruleId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.optional_ != nil {
                            map["Optional"] = self.optional_!
                        }
                        if self.paramList != nil {
                            var tmp : [Any] = []
                            for k in self.paramList! {
                                tmp.append(k.toMap())
                            }
                            map["ParamList"] = tmp
                        }
                        if self.ruleDesc != nil {
                            map["RuleDesc"] = self.ruleDesc!
                        }
                        if self.ruleId != nil {
                            map["RuleId"] = self.ruleId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Optional") && dict["Optional"] != nil {
                            self.optional_ = dict["Optional"] as! Int32
                        }
                        if dict.keys.contains("ParamList") && dict["ParamList"] != nil {
                            var tmp : [DescribeRiskTypeResponseBody.RiskTypes.SubTypes.CheckDetails.Rules.ParamList] = []
                            for v in dict["ParamList"] as! [Any] {
                                var model = DescribeRiskTypeResponseBody.RiskTypes.SubTypes.CheckDetails.Rules.ParamList()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.paramList = tmp
                        }
                        if dict.keys.contains("RuleDesc") && dict["RuleDesc"] != nil {
                            self.ruleDesc = dict["RuleDesc"] as! String
                        }
                        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                            self.ruleId = dict["RuleId"] as! String
                        }
                    }
                }
                public var checkDesc: String?

                public var checkId: Int64?

                public var checkItem: String?

                public var rules: [DescribeRiskTypeResponseBody.RiskTypes.SubTypes.CheckDetails.Rules]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.checkDesc != nil {
                        map["CheckDesc"] = self.checkDesc!
                    }
                    if self.checkId != nil {
                        map["CheckId"] = self.checkId!
                    }
                    if self.checkItem != nil {
                        map["CheckItem"] = self.checkItem!
                    }
                    if self.rules != nil {
                        var tmp : [Any] = []
                        for k in self.rules! {
                            tmp.append(k.toMap())
                        }
                        map["Rules"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CheckDesc") && dict["CheckDesc"] != nil {
                        self.checkDesc = dict["CheckDesc"] as! String
                    }
                    if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                        self.checkId = dict["CheckId"] as! Int64
                    }
                    if dict.keys.contains("CheckItem") && dict["CheckItem"] != nil {
                        self.checkItem = dict["CheckItem"] as! String
                    }
                    if dict.keys.contains("Rules") && dict["Rules"] != nil {
                        var tmp : [DescribeRiskTypeResponseBody.RiskTypes.SubTypes.CheckDetails.Rules] = []
                        for v in dict["Rules"] as! [Any] {
                            var model = DescribeRiskTypeResponseBody.RiskTypes.SubTypes.CheckDetails.Rules()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.rules = tmp
                    }
                }
            }
            public var alias: String?

            public var checkDetails: [DescribeRiskTypeResponseBody.RiskTypes.SubTypes.CheckDetails]?

            public var typeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.checkDetails != nil {
                    var tmp : [Any] = []
                    for k in self.checkDetails! {
                        tmp.append(k.toMap())
                    }
                    map["CheckDetails"] = tmp
                }
                if self.typeName != nil {
                    map["TypeName"] = self.typeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("CheckDetails") && dict["CheckDetails"] != nil {
                    var tmp : [DescribeRiskTypeResponseBody.RiskTypes.SubTypes.CheckDetails] = []
                    for v in dict["CheckDetails"] as! [Any] {
                        var model = DescribeRiskTypeResponseBody.RiskTypes.SubTypes.CheckDetails()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.checkDetails = tmp
                }
                if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
                    self.typeName = dict["TypeName"] as! String
                }
            }
        }
        public var alias: String?

        public var subTypes: [DescribeRiskTypeResponseBody.RiskTypes.SubTypes]?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.subTypes != nil {
                var tmp : [Any] = []
                for k in self.subTypes! {
                    tmp.append(k.toMap())
                }
                map["SubTypes"] = tmp
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") && dict["Alias"] != nil {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("SubTypes") && dict["SubTypes"] != nil {
                var tmp : [DescribeRiskTypeResponseBody.RiskTypes.SubTypes] = []
                for v in dict["SubTypes"] as! [Any] {
                    var model = DescribeRiskTypeResponseBody.RiskTypes.SubTypes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.subTypes = tmp
            }
            if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var requestId: String?

    public var riskTypes: [DescribeRiskTypeResponseBody.RiskTypes]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.riskTypes != nil {
            var tmp : [Any] = []
            for k in self.riskTypes! {
                tmp.append(k.toMap())
            }
            map["RiskTypes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RiskTypes") && dict["RiskTypes"] != nil {
            var tmp : [DescribeRiskTypeResponseBody.RiskTypes] = []
            for v in dict["RiskTypes"] as! [Any] {
                var model = DescribeRiskTypeResponseBody.RiskTypes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.riskTypes = tmp
        }
    }
}

public class DescribeRiskTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRiskTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRiskTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRisksRequest : Tea.TeaModel {
    public var lang: String?

    public var limit: Int32?

    public var riskId: Int64?

    public var riskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.riskId != nil {
            map["RiskId"] = self.riskId!
        }
        if self.riskName != nil {
            map["RiskName"] = self.riskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Limit") && dict["Limit"] != nil {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
            self.riskId = dict["RiskId"] as! Int64
        }
        if dict.keys.contains("RiskName") && dict["RiskName"] != nil {
            self.riskName = dict["RiskName"] as! String
        }
    }
}

public class DescribeRisksResponseBody : Tea.TeaModel {
    public class Risks : Tea.TeaModel {
        public var riskDetail: String?

        public var riskId: Int64?

        public var riskName: String?

        public var riskType: String?

        public var subRiskType: String?

        public var subTypeAlias: String?

        public var typeAlias_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.riskDetail != nil {
                map["RiskDetail"] = self.riskDetail!
            }
            if self.riskId != nil {
                map["RiskId"] = self.riskId!
            }
            if self.riskName != nil {
                map["RiskName"] = self.riskName!
            }
            if self.riskType != nil {
                map["RiskType"] = self.riskType!
            }
            if self.subRiskType != nil {
                map["SubRiskType"] = self.subRiskType!
            }
            if self.subTypeAlias != nil {
                map["SubTypeAlias"] = self.subTypeAlias!
            }
            if self.typeAlias_ != nil {
                map["TypeAlias"] = self.typeAlias_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RiskDetail") && dict["RiskDetail"] != nil {
                self.riskDetail = dict["RiskDetail"] as! String
            }
            if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
                self.riskId = dict["RiskId"] as! Int64
            }
            if dict.keys.contains("RiskName") && dict["RiskName"] != nil {
                self.riskName = dict["RiskName"] as! String
            }
            if dict.keys.contains("RiskType") && dict["RiskType"] != nil {
                self.riskType = dict["RiskType"] as! String
            }
            if dict.keys.contains("SubRiskType") && dict["SubRiskType"] != nil {
                self.subRiskType = dict["SubRiskType"] as! String
            }
            if dict.keys.contains("SubTypeAlias") && dict["SubTypeAlias"] != nil {
                self.subTypeAlias = dict["SubTypeAlias"] as! String
            }
            if dict.keys.contains("TypeAlias") && dict["TypeAlias"] != nil {
                self.typeAlias_ = dict["TypeAlias"] as! String
            }
        }
    }
    public var requestId: String?

    public var risks: [DescribeRisksResponseBody.Risks]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.risks != nil {
            var tmp : [Any] = []
            for k in self.risks! {
                tmp.append(k.toMap())
            }
            map["Risks"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Risks") && dict["Risks"] != nil {
            var tmp : [DescribeRisksResponseBody.Risks] = []
            for v in dict["Risks"] as! [Any] {
                var model = DescribeRisksResponseBody.Risks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.risks = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeRisksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRisksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRisksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSasPmAgentListRequest : Tea.TeaModel {
    public var lang: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeSasPmAgentListResponseBody : Tea.TeaModel {
    public class SasPmAgentList : Tea.TeaModel {
        public var aliyunAssistId: String?

        public var aliyunMonitorId: String?

        public var assistInstallResult: Int32?

        public var assistInstallStatus: Int32?

        public var monitorInstallResult: Int32?

        public var monitorInstallStatus: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunAssistId != nil {
                map["AliyunAssistId"] = self.aliyunAssistId!
            }
            if self.aliyunMonitorId != nil {
                map["AliyunMonitorId"] = self.aliyunMonitorId!
            }
            if self.assistInstallResult != nil {
                map["AssistInstallResult"] = self.assistInstallResult!
            }
            if self.assistInstallStatus != nil {
                map["AssistInstallStatus"] = self.assistInstallStatus!
            }
            if self.monitorInstallResult != nil {
                map["MonitorInstallResult"] = self.monitorInstallResult!
            }
            if self.monitorInstallStatus != nil {
                map["MonitorInstallStatus"] = self.monitorInstallStatus!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliyunAssistId") && dict["AliyunAssistId"] != nil {
                self.aliyunAssistId = dict["AliyunAssistId"] as! String
            }
            if dict.keys.contains("AliyunMonitorId") && dict["AliyunMonitorId"] != nil {
                self.aliyunMonitorId = dict["AliyunMonitorId"] as! String
            }
            if dict.keys.contains("AssistInstallResult") && dict["AssistInstallResult"] != nil {
                self.assistInstallResult = dict["AssistInstallResult"] as! Int32
            }
            if dict.keys.contains("AssistInstallStatus") && dict["AssistInstallStatus"] != nil {
                self.assistInstallStatus = dict["AssistInstallStatus"] as! Int32
            }
            if dict.keys.contains("MonitorInstallResult") && dict["MonitorInstallResult"] != nil {
                self.monitorInstallResult = dict["MonitorInstallResult"] as! Int32
            }
            if dict.keys.contains("MonitorInstallStatus") && dict["MonitorInstallStatus"] != nil {
                self.monitorInstallStatus = dict["MonitorInstallStatus"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var requestId: String?

    public var sasPmAgentList: [DescribeSasPmAgentListResponseBody.SasPmAgentList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sasPmAgentList != nil {
            var tmp : [Any] = []
            for k in self.sasPmAgentList! {
                tmp.append(k.toMap())
            }
            map["SasPmAgentList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SasPmAgentList") && dict["SasPmAgentList"] != nil {
            var tmp : [DescribeSasPmAgentListResponseBody.SasPmAgentList] = []
            for v in dict["SasPmAgentList"] as! [Any] {
                var model = DescribeSasPmAgentListResponseBody.SasPmAgentList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sasPmAgentList = tmp
        }
    }
}

public class DescribeSasPmAgentListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSasPmAgentListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSasPmAgentListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScanTaskProgressRequest : Tea.TeaModel {
    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class DescribeScanTaskProgressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scanTaskProgress: String?

    public var targetInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scanTaskProgress != nil {
            map["ScanTaskProgress"] = self.scanTaskProgress!
        }
        if self.targetInfo != nil {
            map["TargetInfo"] = self.targetInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScanTaskProgress") && dict["ScanTaskProgress"] != nil {
            self.scanTaskProgress = dict["ScanTaskProgress"] as! String
        }
        if dict.keys.contains("TargetInfo") && dict["TargetInfo"] != nil {
            self.targetInfo = dict["TargetInfo"] as! String
        }
    }
}

public class DescribeScanTaskProgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScanTaskProgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScanTaskProgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScanTaskStatisticsRequest : Tea.TeaModel {
    public var levels: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.levels != nil {
            map["Levels"] = self.levels!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Levels") && dict["Levels"] != nil {
            self.levels = dict["Levels"] as! String
        }
    }
}

public class DescribeScanTaskStatisticsResponseBody : Tea.TeaModel {
    public var dealedRiskNum: Int32?

    public var personalTaskNum: Int64?

    public var requestId: String?

    public var totalTaskNum: Int64?

    public var userNum: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dealedRiskNum != nil {
            map["DealedRiskNum"] = self.dealedRiskNum!
        }
        if self.personalTaskNum != nil {
            map["PersonalTaskNum"] = self.personalTaskNum!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalTaskNum != nil {
            map["TotalTaskNum"] = self.totalTaskNum!
        }
        if self.userNum != nil {
            map["UserNum"] = self.userNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DealedRiskNum") && dict["DealedRiskNum"] != nil {
            self.dealedRiskNum = dict["DealedRiskNum"] as! Int32
        }
        if dict.keys.contains("PersonalTaskNum") && dict["PersonalTaskNum"] != nil {
            self.personalTaskNum = dict["PersonalTaskNum"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalTaskNum") && dict["TotalTaskNum"] != nil {
            self.totalTaskNum = dict["TotalTaskNum"] as! Int64
        }
        if dict.keys.contains("UserNum") && dict["UserNum"] != nil {
            self.userNum = dict["UserNum"] as! Int64
        }
    }
}

public class DescribeScanTaskStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScanTaskStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScanTaskStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSearchConditionRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeSearchConditionResponseBody : Tea.TeaModel {
    public class ConditionList : Tea.TeaModel {
        public var conditionType: String?

        public var filterConditions: String?

        public var name: String?

        public var nameKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conditionType != nil {
                map["ConditionType"] = self.conditionType!
            }
            if self.filterConditions != nil {
                map["FilterConditions"] = self.filterConditions!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nameKey != nil {
                map["NameKey"] = self.nameKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConditionType") && dict["ConditionType"] != nil {
                self.conditionType = dict["ConditionType"] as! String
            }
            if dict.keys.contains("FilterConditions") && dict["FilterConditions"] != nil {
                self.filterConditions = dict["FilterConditions"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NameKey") && dict["NameKey"] != nil {
                self.nameKey = dict["NameKey"] as! String
            }
        }
    }
    public var conditionList: [DescribeSearchConditionResponseBody.ConditionList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditionList != nil {
            var tmp : [Any] = []
            for k in self.conditionList! {
                tmp.append(k.toMap())
            }
            map["ConditionList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConditionList") && dict["ConditionList"] != nil {
            var tmp : [DescribeSearchConditionResponseBody.ConditionList] = []
            for v in dict["ConditionList"] as! [Any] {
                var model = DescribeSearchConditionResponseBody.ConditionList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.conditionList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSearchConditionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSearchConditionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSearchConditionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecureSuggestionRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeSecureSuggestionResponseBody : Tea.TeaModel {
    public class Suggestions : Tea.TeaModel {
        public class Detail : Tea.TeaModel {
            public var description_: String?

            public var subType: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.subType != nil {
                    map["SubType"] = self.subType!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("SubType") && dict["SubType"] != nil {
                    self.subType = dict["SubType"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var detail: [DescribeSecureSuggestionResponseBody.Suggestions.Detail]?

        public var points: Int32?

        public var suggestType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detail != nil {
                var tmp : [Any] = []
                for k in self.detail! {
                    tmp.append(k.toMap())
                }
                map["Detail"] = tmp
            }
            if self.points != nil {
                map["Points"] = self.points!
            }
            if self.suggestType != nil {
                map["SuggestType"] = self.suggestType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Detail") && dict["Detail"] != nil {
                var tmp : [DescribeSecureSuggestionResponseBody.Suggestions.Detail] = []
                for v in dict["Detail"] as! [Any] {
                    var model = DescribeSecureSuggestionResponseBody.Suggestions.Detail()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.detail = tmp
            }
            if dict.keys.contains("Points") && dict["Points"] != nil {
                self.points = dict["Points"] as! Int32
            }
            if dict.keys.contains("SuggestType") && dict["SuggestType"] != nil {
                self.suggestType = dict["SuggestType"] as! String
            }
        }
    }
    public var requestId: String?

    public var suggestions: [DescribeSecureSuggestionResponseBody.Suggestions]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.suggestions != nil {
            var tmp : [Any] = []
            for k in self.suggestions! {
                tmp.append(k.toMap())
            }
            map["Suggestions"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Suggestions") && dict["Suggestions"] != nil {
            var tmp : [DescribeSecureSuggestionResponseBody.Suggestions] = []
            for v in dict["Suggestions"] as! [Any] {
                var model = DescribeSecureSuggestionResponseBody.Suggestions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.suggestions = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSecureSuggestionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecureSuggestionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSecureSuggestionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityCheckScheduleConfigRequest : Tea.TeaModel {
    public var lang: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeSecurityCheckScheduleConfigResponseBody : Tea.TeaModel {
    public class RiskCheckJobConfig : Tea.TeaModel {
        public var daysOfWeek: String?

        public var endTime: Int32?

        public var startTime: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.daysOfWeek != nil {
                map["DaysOfWeek"] = self.daysOfWeek!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
                self.daysOfWeek = dict["DaysOfWeek"] as! String
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int32
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var riskCheckJobConfig: DescribeSecurityCheckScheduleConfigResponseBody.RiskCheckJobConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.riskCheckJobConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.riskCheckJobConfig != nil {
            map["RiskCheckJobConfig"] = self.riskCheckJobConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RiskCheckJobConfig") && dict["RiskCheckJobConfig"] != nil {
            var model = DescribeSecurityCheckScheduleConfigResponseBody.RiskCheckJobConfig()
            model.fromMap(dict["RiskCheckJobConfig"] as! [String: Any])
            self.riskCheckJobConfig = model
        }
    }
}

public class DescribeSecurityCheckScheduleConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityCheckScheduleConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSecurityCheckScheduleConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityEventMarkMissListRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var eventName: String?

    public var pageSize: Int32?

    public var remark: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.eventName != nil {
            map["EventName"] = self.eventName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EventName") && dict["EventName"] != nil {
            self.eventName = dict["EventName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeSecurityEventMarkMissListResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var aliUid: Int64?

        public var eventName: String?

        public var eventNameOriginal: String?

        public var eventType: String?

        public var eventTypeOriginal: String?

        public var field: String?

        public var fieldValue: String?

        public var filedAliasName: String?

        public var id: Int64?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var operate: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.eventName != nil {
                map["EventName"] = self.eventName!
            }
            if self.eventNameOriginal != nil {
                map["EventNameOriginal"] = self.eventNameOriginal!
            }
            if self.eventType != nil {
                map["EventType"] = self.eventType!
            }
            if self.eventTypeOriginal != nil {
                map["EventTypeOriginal"] = self.eventTypeOriginal!
            }
            if self.field != nil {
                map["Field"] = self.field!
            }
            if self.fieldValue != nil {
                map["FieldValue"] = self.fieldValue!
            }
            if self.filedAliasName != nil {
                map["FiledAliasName"] = self.filedAliasName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.operate != nil {
                map["Operate"] = self.operate!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliUid") && dict["AliUid"] != nil {
                self.aliUid = dict["AliUid"] as! Int64
            }
            if dict.keys.contains("EventName") && dict["EventName"] != nil {
                self.eventName = dict["EventName"] as! String
            }
            if dict.keys.contains("EventNameOriginal") && dict["EventNameOriginal"] != nil {
                self.eventNameOriginal = dict["EventNameOriginal"] as! String
            }
            if dict.keys.contains("EventType") && dict["EventType"] != nil {
                self.eventType = dict["EventType"] as! String
            }
            if dict.keys.contains("EventTypeOriginal") && dict["EventTypeOriginal"] != nil {
                self.eventTypeOriginal = dict["EventTypeOriginal"] as! String
            }
            if dict.keys.contains("Field") && dict["Field"] != nil {
                self.field = dict["Field"] as! String
            }
            if dict.keys.contains("FieldValue") && dict["FieldValue"] != nil {
                self.fieldValue = dict["FieldValue"] as! String
            }
            if dict.keys.contains("FiledAliasName") && dict["FiledAliasName"] != nil {
                self.filedAliasName = dict["FiledAliasName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Operate") && dict["Operate"] != nil {
                self.operate = dict["Operate"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var list: [DescribeSecurityEventMarkMissListResponseBody.List]?

    public var pageInfo: DescribeSecurityEventMarkMissListResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [DescribeSecurityEventMarkMissListResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = DescribeSecurityEventMarkMissListResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeSecurityEventMarkMissListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSecurityEventMarkMissListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityEventMarkMissListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSecurityEventMarkMissListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityEventOperationStatusRequest : Tea.TeaModel {
    public var resourceOwnerId: Int64?

    public var securityEventIds: [String]?

    public var sourceIp: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEventIds != nil {
            map["SecurityEventIds"] = self.securityEventIds!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEventIds") && dict["SecurityEventIds"] != nil {
            self.securityEventIds = dict["SecurityEventIds"] as! [String]
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class DescribeSecurityEventOperationStatusResponseBody : Tea.TeaModel {
    public class SecurityEventOperationStatusResponse : Tea.TeaModel {
        public class SecurityEventOperationStatuses : Tea.TeaModel {
            public var errorCode: String?

            public var securityEventId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.securityEventId != nil {
                    map["SecurityEventId"] = self.securityEventId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("SecurityEventId") && dict["SecurityEventId"] != nil {
                    self.securityEventId = dict["SecurityEventId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var securityEventOperationStatuses: [DescribeSecurityEventOperationStatusResponseBody.SecurityEventOperationStatusResponse.SecurityEventOperationStatuses]?

        public var taskStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityEventOperationStatuses != nil {
                var tmp : [Any] = []
                for k in self.securityEventOperationStatuses! {
                    tmp.append(k.toMap())
                }
                map["SecurityEventOperationStatuses"] = tmp
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityEventOperationStatuses") && dict["SecurityEventOperationStatuses"] != nil {
                var tmp : [DescribeSecurityEventOperationStatusResponseBody.SecurityEventOperationStatusResponse.SecurityEventOperationStatuses] = []
                for v in dict["SecurityEventOperationStatuses"] as! [Any] {
                    var model = DescribeSecurityEventOperationStatusResponseBody.SecurityEventOperationStatusResponse.SecurityEventOperationStatuses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityEventOperationStatuses = tmp
            }
            if dict.keys.contains("TaskStatus") && dict["TaskStatus"] != nil {
                self.taskStatus = dict["TaskStatus"] as! String
            }
        }
    }
    public var requestId: String?

    public var securityEventOperationStatusResponse: DescribeSecurityEventOperationStatusResponseBody.SecurityEventOperationStatusResponse?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityEventOperationStatusResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityEventOperationStatusResponse != nil {
            map["SecurityEventOperationStatusResponse"] = self.securityEventOperationStatusResponse?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityEventOperationStatusResponse") && dict["SecurityEventOperationStatusResponse"] != nil {
            var model = DescribeSecurityEventOperationStatusResponseBody.SecurityEventOperationStatusResponse()
            model.fromMap(dict["SecurityEventOperationStatusResponse"] as! [String: Any])
            self.securityEventOperationStatusResponse = model
        }
    }
}

public class DescribeSecurityEventOperationStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityEventOperationStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSecurityEventOperationStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityEventOperationsRequest : Tea.TeaModel {
    public var lang: String?

    public var resourceOwnerId: Int64?

    public var securityEventId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEventId != nil {
            map["SecurityEventId"] = self.securityEventId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEventId") && dict["SecurityEventId"] != nil {
            self.securityEventId = dict["SecurityEventId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeSecurityEventOperationsResponseBody : Tea.TeaModel {
    public class SecurityEventOperationsResponse : Tea.TeaModel {
        public class MarkField : Tea.TeaModel {
            public var filedAliasName: String?

            public var filedName: String?

            public var markMisType: String?

            public var markMisValue: String?

            public var supportedMisType: [String]?

            public var uuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.filedAliasName != nil {
                    map["FiledAliasName"] = self.filedAliasName!
                }
                if self.filedName != nil {
                    map["FiledName"] = self.filedName!
                }
                if self.markMisType != nil {
                    map["MarkMisType"] = self.markMisType!
                }
                if self.markMisValue != nil {
                    map["MarkMisValue"] = self.markMisValue!
                }
                if self.supportedMisType != nil {
                    map["SupportedMisType"] = self.supportedMisType!
                }
                if self.uuid != nil {
                    map["Uuid"] = self.uuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FiledAliasName") && dict["FiledAliasName"] != nil {
                    self.filedAliasName = dict["FiledAliasName"] as! String
                }
                if dict.keys.contains("FiledName") && dict["FiledName"] != nil {
                    self.filedName = dict["FiledName"] as! String
                }
                if dict.keys.contains("MarkMisType") && dict["MarkMisType"] != nil {
                    self.markMisType = dict["MarkMisType"] as! String
                }
                if dict.keys.contains("MarkMisValue") && dict["MarkMisValue"] != nil {
                    self.markMisValue = dict["MarkMisValue"] as! String
                }
                if dict.keys.contains("SupportedMisType") && dict["SupportedMisType"] != nil {
                    self.supportedMisType = dict["SupportedMisType"] as! [String]
                }
                if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                    self.uuid = dict["Uuid"] as! String
                }
            }
        }
        public class MarkFieldsSource : Tea.TeaModel {
            public var filedAliasName: String?

            public var filedName: String?

            public var markMisValue: String?

            public var supportedMisType: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.filedAliasName != nil {
                    map["FiledAliasName"] = self.filedAliasName!
                }
                if self.filedName != nil {
                    map["FiledName"] = self.filedName!
                }
                if self.markMisValue != nil {
                    map["MarkMisValue"] = self.markMisValue!
                }
                if self.supportedMisType != nil {
                    map["SupportedMisType"] = self.supportedMisType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FiledAliasName") && dict["FiledAliasName"] != nil {
                    self.filedAliasName = dict["FiledAliasName"] as! String
                }
                if dict.keys.contains("FiledName") && dict["FiledName"] != nil {
                    self.filedName = dict["FiledName"] as! String
                }
                if dict.keys.contains("MarkMisValue") && dict["MarkMisValue"] != nil {
                    self.markMisValue = dict["MarkMisValue"] as! String
                }
                if dict.keys.contains("SupportedMisType") && dict["SupportedMisType"] != nil {
                    self.supportedMisType = dict["SupportedMisType"] as! [String]
                }
            }
        }
        public var markField: [DescribeSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkField]?

        public var markFieldsSource: [DescribeSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkFieldsSource]?

        public var operationCode: String?

        public var operationParams: String?

        public var userCanOperate: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.markField != nil {
                var tmp : [Any] = []
                for k in self.markField! {
                    tmp.append(k.toMap())
                }
                map["MarkField"] = tmp
            }
            if self.markFieldsSource != nil {
                var tmp : [Any] = []
                for k in self.markFieldsSource! {
                    tmp.append(k.toMap())
                }
                map["MarkFieldsSource"] = tmp
            }
            if self.operationCode != nil {
                map["OperationCode"] = self.operationCode!
            }
            if self.operationParams != nil {
                map["OperationParams"] = self.operationParams!
            }
            if self.userCanOperate != nil {
                map["UserCanOperate"] = self.userCanOperate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MarkField") && dict["MarkField"] != nil {
                var tmp : [DescribeSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkField] = []
                for v in dict["MarkField"] as! [Any] {
                    var model = DescribeSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkField()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.markField = tmp
            }
            if dict.keys.contains("MarkFieldsSource") && dict["MarkFieldsSource"] != nil {
                var tmp : [DescribeSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkFieldsSource] = []
                for v in dict["MarkFieldsSource"] as! [Any] {
                    var model = DescribeSecurityEventOperationsResponseBody.SecurityEventOperationsResponse.MarkFieldsSource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.markFieldsSource = tmp
            }
            if dict.keys.contains("OperationCode") && dict["OperationCode"] != nil {
                self.operationCode = dict["OperationCode"] as! String
            }
            if dict.keys.contains("OperationParams") && dict["OperationParams"] != nil {
                self.operationParams = dict["OperationParams"] as! String
            }
            if dict.keys.contains("UserCanOperate") && dict["UserCanOperate"] != nil {
                self.userCanOperate = dict["UserCanOperate"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var securityEventOperationsResponse: [DescribeSecurityEventOperationsResponseBody.SecurityEventOperationsResponse]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityEventOperationsResponse != nil {
            var tmp : [Any] = []
            for k in self.securityEventOperationsResponse! {
                tmp.append(k.toMap())
            }
            map["SecurityEventOperationsResponse"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityEventOperationsResponse") && dict["SecurityEventOperationsResponse"] != nil {
            var tmp : [DescribeSecurityEventOperationsResponseBody.SecurityEventOperationsResponse] = []
            for v in dict["SecurityEventOperationsResponse"] as! [Any] {
                var model = DescribeSecurityEventOperationsResponseBody.SecurityEventOperationsResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityEventOperationsResponse = tmp
        }
    }
}

public class DescribeSecurityEventOperationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityEventOperationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSecurityEventOperationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityStatInfoRequest : Tea.TeaModel {
    public var lang: String?

    public var resourceDirectoryAccountId: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeSecurityStatInfoResponseBody : Tea.TeaModel {
    public class AttackEvent : Tea.TeaModel {
        public var dateArray: [String]?

        public var totalCount: Int32?

        public var valueArray: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dateArray != nil {
                map["DateArray"] = self.dateArray!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.valueArray != nil {
                map["ValueArray"] = self.valueArray!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DateArray") && dict["DateArray"] != nil {
                self.dateArray = dict["DateArray"] as! [String]
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("ValueArray") && dict["ValueArray"] != nil {
                self.valueArray = dict["ValueArray"] as! [String]
            }
        }
    }
    public class HealthCheck : Tea.TeaModel {
        public var dateArray: [String]?

        public var highCount: Int32?

        public var highList: [String]?

        public var levelsOn: [String]?

        public var lowCount: Int32?

        public var lowList: [String]?

        public var mediumCount: Int32?

        public var mediumList: [String]?

        public var timeArray: [String]?

        public var totalCount: Int32?

        public var valueArray: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dateArray != nil {
                map["DateArray"] = self.dateArray!
            }
            if self.highCount != nil {
                map["HighCount"] = self.highCount!
            }
            if self.highList != nil {
                map["HighList"] = self.highList!
            }
            if self.levelsOn != nil {
                map["LevelsOn"] = self.levelsOn!
            }
            if self.lowCount != nil {
                map["LowCount"] = self.lowCount!
            }
            if self.lowList != nil {
                map["LowList"] = self.lowList!
            }
            if self.mediumCount != nil {
                map["MediumCount"] = self.mediumCount!
            }
            if self.mediumList != nil {
                map["MediumList"] = self.mediumList!
            }
            if self.timeArray != nil {
                map["TimeArray"] = self.timeArray!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.valueArray != nil {
                map["ValueArray"] = self.valueArray!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DateArray") && dict["DateArray"] != nil {
                self.dateArray = dict["DateArray"] as! [String]
            }
            if dict.keys.contains("HighCount") && dict["HighCount"] != nil {
                self.highCount = dict["HighCount"] as! Int32
            }
            if dict.keys.contains("HighList") && dict["HighList"] != nil {
                self.highList = dict["HighList"] as! [String]
            }
            if dict.keys.contains("LevelsOn") && dict["LevelsOn"] != nil {
                self.levelsOn = dict["LevelsOn"] as! [String]
            }
            if dict.keys.contains("LowCount") && dict["LowCount"] != nil {
                self.lowCount = dict["LowCount"] as! Int32
            }
            if dict.keys.contains("LowList") && dict["LowList"] != nil {
                self.lowList = dict["LowList"] as! [String]
            }
            if dict.keys.contains("MediumCount") && dict["MediumCount"] != nil {
                self.mediumCount = dict["MediumCount"] as! Int32
            }
            if dict.keys.contains("MediumList") && dict["MediumList"] != nil {
                self.mediumList = dict["MediumList"] as! [String]
            }
            if dict.keys.contains("TimeArray") && dict["TimeArray"] != nil {
                self.timeArray = dict["TimeArray"] as! [String]
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("ValueArray") && dict["ValueArray"] != nil {
                self.valueArray = dict["ValueArray"] as! [String]
            }
        }
    }
    public class SecurityEvent : Tea.TeaModel {
        public var dateArray: [String]?

        public var levelsOn: [String]?

        public var remindCount: Int32?

        public var remindList: [String]?

        public var seriousCount: Int32?

        public var seriousList: [String]?

        public var suspiciousCount: Int32?

        public var suspiciousList: [String]?

        public var timeArray: [String]?

        public var totalCount: Int32?

        public var valueArray: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dateArray != nil {
                map["DateArray"] = self.dateArray!
            }
            if self.levelsOn != nil {
                map["LevelsOn"] = self.levelsOn!
            }
            if self.remindCount != nil {
                map["RemindCount"] = self.remindCount!
            }
            if self.remindList != nil {
                map["RemindList"] = self.remindList!
            }
            if self.seriousCount != nil {
                map["SeriousCount"] = self.seriousCount!
            }
            if self.seriousList != nil {
                map["SeriousList"] = self.seriousList!
            }
            if self.suspiciousCount != nil {
                map["SuspiciousCount"] = self.suspiciousCount!
            }
            if self.suspiciousList != nil {
                map["SuspiciousList"] = self.suspiciousList!
            }
            if self.timeArray != nil {
                map["TimeArray"] = self.timeArray!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.valueArray != nil {
                map["ValueArray"] = self.valueArray!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DateArray") && dict["DateArray"] != nil {
                self.dateArray = dict["DateArray"] as! [String]
            }
            if dict.keys.contains("LevelsOn") && dict["LevelsOn"] != nil {
                self.levelsOn = dict["LevelsOn"] as! [String]
            }
            if dict.keys.contains("RemindCount") && dict["RemindCount"] != nil {
                self.remindCount = dict["RemindCount"] as! Int32
            }
            if dict.keys.contains("RemindList") && dict["RemindList"] != nil {
                self.remindList = dict["RemindList"] as! [String]
            }
            if dict.keys.contains("SeriousCount") && dict["SeriousCount"] != nil {
                self.seriousCount = dict["SeriousCount"] as! Int32
            }
            if dict.keys.contains("SeriousList") && dict["SeriousList"] != nil {
                self.seriousList = dict["SeriousList"] as! [String]
            }
            if dict.keys.contains("SuspiciousCount") && dict["SuspiciousCount"] != nil {
                self.suspiciousCount = dict["SuspiciousCount"] as! Int32
            }
            if dict.keys.contains("SuspiciousList") && dict["SuspiciousList"] != nil {
                self.suspiciousList = dict["SuspiciousList"] as! [String]
            }
            if dict.keys.contains("TimeArray") && dict["TimeArray"] != nil {
                self.timeArray = dict["TimeArray"] as! [String]
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("ValueArray") && dict["ValueArray"] != nil {
                self.valueArray = dict["ValueArray"] as! [String]
            }
        }
    }
    public class Vulnerability : Tea.TeaModel {
        public var asapCount: Int32?

        public var asapList: [String]?

        public var dateArray: [String]?

        public var laterCount: Int32?

        public var laterList: [String]?

        public var levelsOn: [String]?

        public var nntfCount: Int32?

        public var nntfList: [String]?

        public var timeArray: [String]?

        public var totalCount: Int32?

        public var valueArray: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.asapCount != nil {
                map["AsapCount"] = self.asapCount!
            }
            if self.asapList != nil {
                map["AsapList"] = self.asapList!
            }
            if self.dateArray != nil {
                map["DateArray"] = self.dateArray!
            }
            if self.laterCount != nil {
                map["LaterCount"] = self.laterCount!
            }
            if self.laterList != nil {
                map["LaterList"] = self.laterList!
            }
            if self.levelsOn != nil {
                map["LevelsOn"] = self.levelsOn!
            }
            if self.nntfCount != nil {
                map["NntfCount"] = self.nntfCount!
            }
            if self.nntfList != nil {
                map["NntfList"] = self.nntfList!
            }
            if self.timeArray != nil {
                map["TimeArray"] = self.timeArray!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.valueArray != nil {
                map["ValueArray"] = self.valueArray!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AsapCount") && dict["AsapCount"] != nil {
                self.asapCount = dict["AsapCount"] as! Int32
            }
            if dict.keys.contains("AsapList") && dict["AsapList"] != nil {
                self.asapList = dict["AsapList"] as! [String]
            }
            if dict.keys.contains("DateArray") && dict["DateArray"] != nil {
                self.dateArray = dict["DateArray"] as! [String]
            }
            if dict.keys.contains("LaterCount") && dict["LaterCount"] != nil {
                self.laterCount = dict["LaterCount"] as! Int32
            }
            if dict.keys.contains("LaterList") && dict["LaterList"] != nil {
                self.laterList = dict["LaterList"] as! [String]
            }
            if dict.keys.contains("LevelsOn") && dict["LevelsOn"] != nil {
                self.levelsOn = dict["LevelsOn"] as! [String]
            }
            if dict.keys.contains("NntfCount") && dict["NntfCount"] != nil {
                self.nntfCount = dict["NntfCount"] as! Int32
            }
            if dict.keys.contains("NntfList") && dict["NntfList"] != nil {
                self.nntfList = dict["NntfList"] as! [String]
            }
            if dict.keys.contains("TimeArray") && dict["TimeArray"] != nil {
                self.timeArray = dict["TimeArray"] as! [String]
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("ValueArray") && dict["ValueArray"] != nil {
                self.valueArray = dict["ValueArray"] as! [String]
            }
        }
    }
    public var attackEvent: DescribeSecurityStatInfoResponseBody.AttackEvent?

    public var healthCheck: DescribeSecurityStatInfoResponseBody.HealthCheck?

    public var requestId: String?

    public var securityEvent: DescribeSecurityStatInfoResponseBody.SecurityEvent?

    public var success: Bool?

    public var vulnerability: DescribeSecurityStatInfoResponseBody.Vulnerability?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.attackEvent?.validate()
        try self.healthCheck?.validate()
        try self.securityEvent?.validate()
        try self.vulnerability?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attackEvent != nil {
            map["AttackEvent"] = self.attackEvent?.toMap()
        }
        if self.healthCheck != nil {
            map["HealthCheck"] = self.healthCheck?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityEvent != nil {
            map["SecurityEvent"] = self.securityEvent?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.vulnerability != nil {
            map["Vulnerability"] = self.vulnerability?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttackEvent") && dict["AttackEvent"] != nil {
            var model = DescribeSecurityStatInfoResponseBody.AttackEvent()
            model.fromMap(dict["AttackEvent"] as! [String: Any])
            self.attackEvent = model
        }
        if dict.keys.contains("HealthCheck") && dict["HealthCheck"] != nil {
            var model = DescribeSecurityStatInfoResponseBody.HealthCheck()
            model.fromMap(dict["HealthCheck"] as! [String: Any])
            self.healthCheck = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityEvent") && dict["SecurityEvent"] != nil {
            var model = DescribeSecurityStatInfoResponseBody.SecurityEvent()
            model.fromMap(dict["SecurityEvent"] as! [String: Any])
            self.securityEvent = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("Vulnerability") && dict["Vulnerability"] != nil {
            var model = DescribeSecurityStatInfoResponseBody.Vulnerability()
            model.fromMap(dict["Vulnerability"] as! [String: Any])
            self.vulnerability = model
        }
    }
}

public class DescribeSecurityStatInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityStatInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSecurityStatInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeServiceLinkedRoleStatusRequest : Tea.TeaModel {
    public var serviceLinkedRole: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.serviceLinkedRole != nil {
            map["ServiceLinkedRole"] = self.serviceLinkedRole!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ServiceLinkedRole") && dict["ServiceLinkedRole"] != nil {
            self.serviceLinkedRole = dict["ServiceLinkedRole"] as! String
        }
    }
}

public class DescribeServiceLinkedRoleStatusResponseBody : Tea.TeaModel {
    public class RoleStatus : Tea.TeaModel {
        public var status: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var roleStatus: DescribeServiceLinkedRoleStatusResponseBody.RoleStatus?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.roleStatus?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.roleStatus != nil {
            map["RoleStatus"] = self.roleStatus?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RoleStatus") && dict["RoleStatus"] != nil {
            var model = DescribeServiceLinkedRoleStatusResponseBody.RoleStatus()
            model.fromMap(dict["RoleStatus"] as! [String: Any])
            self.roleStatus = model
        }
    }
}

public class DescribeServiceLinkedRoleStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeServiceLinkedRoleStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeServiceLinkedRoleStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSimilarEventScenariosRequest : Tea.TeaModel {
    public var resourceOwnerId: Int64?

    public var securityEventId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEventId != nil {
            map["SecurityEventId"] = self.securityEventId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEventId") && dict["SecurityEventId"] != nil {
            self.securityEventId = dict["SecurityEventId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeSimilarEventScenariosResponseBody : Tea.TeaModel {
    public class Scenarios : Tea.TeaModel {
        public var code: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
        }
    }
    public var requestId: String?

    public var scenarios: [DescribeSimilarEventScenariosResponseBody.Scenarios]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scenarios != nil {
            var tmp : [Any] = []
            for k in self.scenarios! {
                tmp.append(k.toMap())
            }
            map["Scenarios"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Scenarios") && dict["Scenarios"] != nil {
            var tmp : [DescribeSimilarEventScenariosResponseBody.Scenarios] = []
            for v in dict["Scenarios"] as! [Any] {
                var model = DescribeSimilarEventScenariosResponseBody.Scenarios()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.scenarios = tmp
        }
    }
}

public class DescribeSimilarEventScenariosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSimilarEventScenariosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSimilarEventScenariosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSimilarSecurityEventsRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var lang: String?

    public var pageSize: Int32?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class DescribeSimilarSecurityEventsResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class SecurityEventsResponse : Tea.TeaModel {
        public var eventName: String?

        public var eventType: String?

        public var lastTime: Int64?

        public var occurrenceTime: Int64?

        public var securityEventId: Int64?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventName != nil {
                map["EventName"] = self.eventName!
            }
            if self.eventType != nil {
                map["EventType"] = self.eventType!
            }
            if self.lastTime != nil {
                map["LastTime"] = self.lastTime!
            }
            if self.occurrenceTime != nil {
                map["OccurrenceTime"] = self.occurrenceTime!
            }
            if self.securityEventId != nil {
                map["SecurityEventId"] = self.securityEventId!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventName") && dict["EventName"] != nil {
                self.eventName = dict["EventName"] as! String
            }
            if dict.keys.contains("EventType") && dict["EventType"] != nil {
                self.eventType = dict["EventType"] as! String
            }
            if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
                self.lastTime = dict["LastTime"] as! Int64
            }
            if dict.keys.contains("OccurrenceTime") && dict["OccurrenceTime"] != nil {
                self.occurrenceTime = dict["OccurrenceTime"] as! Int64
            }
            if dict.keys.contains("SecurityEventId") && dict["SecurityEventId"] != nil {
                self.securityEventId = dict["SecurityEventId"] as! Int64
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var pageInfo: DescribeSimilarSecurityEventsResponseBody.PageInfo?

    public var requestId: String?

    public var securityEventsResponse: [DescribeSimilarSecurityEventsResponseBody.SecurityEventsResponse]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityEventsResponse != nil {
            var tmp : [Any] = []
            for k in self.securityEventsResponse! {
                tmp.append(k.toMap())
            }
            map["SecurityEventsResponse"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeSimilarSecurityEventsResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityEventsResponse") && dict["SecurityEventsResponse"] != nil {
            var tmp : [DescribeSimilarSecurityEventsResponseBody.SecurityEventsResponse] = []
            for v in dict["SecurityEventsResponse"] as! [Any] {
                var model = DescribeSimilarSecurityEventsResponseBody.SecurityEventsResponse()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityEventsResponse = tmp
        }
    }
}

public class DescribeSimilarSecurityEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSimilarSecurityEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSimilarSecurityEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnapshotsRequest : Tea.TeaModel {
    public var apiVersion: String?

    public var currentPage: Int32?

    public var isAliYunEcs: String?

    public var machineRegion: String?

    public var machineRemark: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public var statusList: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiVersion != nil {
            map["ApiVersion"] = self.apiVersion!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.isAliYunEcs != nil {
            map["IsAliYunEcs"] = self.isAliYunEcs!
        }
        if self.machineRegion != nil {
            map["MachineRegion"] = self.machineRegion!
        }
        if self.machineRemark != nil {
            map["MachineRemark"] = self.machineRemark!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiVersion") && dict["ApiVersion"] != nil {
            self.apiVersion = dict["ApiVersion"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("IsAliYunEcs") && dict["IsAliYunEcs"] != nil {
            self.isAliYunEcs = dict["IsAliYunEcs"] as! String
        }
        if dict.keys.contains("MachineRegion") && dict["MachineRegion"] != nil {
            self.machineRegion = dict["MachineRegion"] as! String
        }
        if dict.keys.contains("MachineRemark") && dict["MachineRemark"] != nil {
            self.machineRemark = dict["MachineRemark"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeSnapshotsResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var nextToken: String?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class Snapshots : Tea.TeaModel {
        public var actualBytes: Int64?

        public var actualItems: Int64?

        public var bytesDone: Int64?

        public var bytesTotal: Int64?

        public var clientId: String?

        public var clientVersion: String?

        public var createdTime: Int64?

        public var errorFile: String?

        public var instanceId: String?

        public var itemsDone: Int64?

        public var itemsTotal: Int64?

        public var jobId: String?

        public var parentSnapshotHash: String?

        public var path: String?

        public var paths: [String]?

        public var planId: String?

        public var regionId: String?

        public var retention: Int64?

        public var snapshotHash: String?

        public var snapshotId: String?

        public var sourceType: String?

        public var status: String?

        public var uuid: String?

        public var vaultId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualBytes != nil {
                map["ActualBytes"] = self.actualBytes!
            }
            if self.actualItems != nil {
                map["ActualItems"] = self.actualItems!
            }
            if self.bytesDone != nil {
                map["BytesDone"] = self.bytesDone!
            }
            if self.bytesTotal != nil {
                map["BytesTotal"] = self.bytesTotal!
            }
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.clientVersion != nil {
                map["ClientVersion"] = self.clientVersion!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.errorFile != nil {
                map["ErrorFile"] = self.errorFile!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.itemsDone != nil {
                map["ItemsDone"] = self.itemsDone!
            }
            if self.itemsTotal != nil {
                map["ItemsTotal"] = self.itemsTotal!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.parentSnapshotHash != nil {
                map["ParentSnapshotHash"] = self.parentSnapshotHash!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.paths != nil {
                map["Paths"] = self.paths!
            }
            if self.planId != nil {
                map["PlanId"] = self.planId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.retention != nil {
                map["Retention"] = self.retention!
            }
            if self.snapshotHash != nil {
                map["SnapshotHash"] = self.snapshotHash!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vaultId != nil {
                map["VaultId"] = self.vaultId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActualBytes") && dict["ActualBytes"] != nil {
                self.actualBytes = dict["ActualBytes"] as! Int64
            }
            if dict.keys.contains("ActualItems") && dict["ActualItems"] != nil {
                self.actualItems = dict["ActualItems"] as! Int64
            }
            if dict.keys.contains("BytesDone") && dict["BytesDone"] != nil {
                self.bytesDone = dict["BytesDone"] as! Int64
            }
            if dict.keys.contains("BytesTotal") && dict["BytesTotal"] != nil {
                self.bytesTotal = dict["BytesTotal"] as! Int64
            }
            if dict.keys.contains("ClientId") && dict["ClientId"] != nil {
                self.clientId = dict["ClientId"] as! String
            }
            if dict.keys.contains("ClientVersion") && dict["ClientVersion"] != nil {
                self.clientVersion = dict["ClientVersion"] as! String
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("ErrorFile") && dict["ErrorFile"] != nil {
                self.errorFile = dict["ErrorFile"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("ItemsDone") && dict["ItemsDone"] != nil {
                self.itemsDone = dict["ItemsDone"] as! Int64
            }
            if dict.keys.contains("ItemsTotal") && dict["ItemsTotal"] != nil {
                self.itemsTotal = dict["ItemsTotal"] as! Int64
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("ParentSnapshotHash") && dict["ParentSnapshotHash"] != nil {
                self.parentSnapshotHash = dict["ParentSnapshotHash"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Paths") && dict["Paths"] != nil {
                self.paths = dict["Paths"] as! [String]
            }
            if dict.keys.contains("PlanId") && dict["PlanId"] != nil {
                self.planId = dict["PlanId"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Retention") && dict["Retention"] != nil {
                self.retention = dict["Retention"] as! Int64
            }
            if dict.keys.contains("SnapshotHash") && dict["SnapshotHash"] != nil {
                self.snapshotHash = dict["SnapshotHash"] as! String
            }
            if dict.keys.contains("SnapshotId") && dict["SnapshotId"] != nil {
                self.snapshotId = dict["SnapshotId"] as! String
            }
            if dict.keys.contains("SourceType") && dict["SourceType"] != nil {
                self.sourceType = dict["SourceType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VaultId") && dict["VaultId"] != nil {
                self.vaultId = dict["VaultId"] as! String
            }
        }
    }
    public var pageInfo: DescribeSnapshotsResponseBody.PageInfo?

    public var requestId: String?

    public var snapshots: [DescribeSnapshotsResponseBody.Snapshots]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshots != nil {
            var tmp : [Any] = []
            for k in self.snapshots! {
                tmp.append(k.toMap())
            }
            map["Snapshots"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeSnapshotsResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Snapshots") && dict["Snapshots"] != nil {
            var tmp : [DescribeSnapshotsResponseBody.Snapshots] = []
            for v in dict["Snapshots"] as! [Any] {
                var model = DescribeSnapshotsResponseBody.Snapshots()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.snapshots = tmp
        }
    }
}

public class DescribeSnapshotsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSnapshotsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStrategyRequest : Tea.TeaModel {
    public var customType: String?

    public var lang: String?

    public var sourceIp: String?

    public var strategyIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customType != nil {
            map["CustomType"] = self.customType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.strategyIds != nil {
            map["StrategyIds"] = self.strategyIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomType") && dict["CustomType"] != nil {
            self.customType = dict["CustomType"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("StrategyIds") && dict["StrategyIds"] != nil {
            self.strategyIds = dict["StrategyIds"] as! String
        }
    }
}

public class DescribeStrategyResponseBody : Tea.TeaModel {
    public class Strategies : Tea.TeaModel {
        public class ConfigTargets : Tea.TeaModel {
            public var flag: String?

            public var target: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.flag != nil {
                    map["Flag"] = self.flag!
                }
                if self.target != nil {
                    map["Target"] = self.target!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Flag") && dict["Flag"] != nil {
                    self.flag = dict["Flag"] as! String
                }
                if dict.keys.contains("Target") && dict["Target"] != nil {
                    self.target = dict["Target"] as! String
                }
                if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                    self.targetType = dict["TargetType"] as! String
                }
            }
        }
        public var configTargets: [DescribeStrategyResponseBody.Strategies.ConfigTargets]?

        public var customType: String?

        public var cycleDays: Int32?

        public var cycleStartTime: Int32?

        public var ecsCount: Int32?

        public var endTime: String?

        public var execStatus: Int32?

        public var id: Int32?

        public var name: String?

        public var passRate: Int32?

        public var processRate: Int32?

        public var riskCount: Int32?

        public var startTime: String?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configTargets != nil {
                var tmp : [Any] = []
                for k in self.configTargets! {
                    tmp.append(k.toMap())
                }
                map["ConfigTargets"] = tmp
            }
            if self.customType != nil {
                map["CustomType"] = self.customType!
            }
            if self.cycleDays != nil {
                map["CycleDays"] = self.cycleDays!
            }
            if self.cycleStartTime != nil {
                map["CycleStartTime"] = self.cycleStartTime!
            }
            if self.ecsCount != nil {
                map["EcsCount"] = self.ecsCount!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.execStatus != nil {
                map["ExecStatus"] = self.execStatus!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.passRate != nil {
                map["PassRate"] = self.passRate!
            }
            if self.processRate != nil {
                map["ProcessRate"] = self.processRate!
            }
            if self.riskCount != nil {
                map["RiskCount"] = self.riskCount!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigTargets") && dict["ConfigTargets"] != nil {
                var tmp : [DescribeStrategyResponseBody.Strategies.ConfigTargets] = []
                for v in dict["ConfigTargets"] as! [Any] {
                    var model = DescribeStrategyResponseBody.Strategies.ConfigTargets()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configTargets = tmp
            }
            if dict.keys.contains("CustomType") && dict["CustomType"] != nil {
                self.customType = dict["CustomType"] as! String
            }
            if dict.keys.contains("CycleDays") && dict["CycleDays"] != nil {
                self.cycleDays = dict["CycleDays"] as! Int32
            }
            if dict.keys.contains("CycleStartTime") && dict["CycleStartTime"] != nil {
                self.cycleStartTime = dict["CycleStartTime"] as! Int32
            }
            if dict.keys.contains("EcsCount") && dict["EcsCount"] != nil {
                self.ecsCount = dict["EcsCount"] as! Int32
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("ExecStatus") && dict["ExecStatus"] != nil {
                self.execStatus = dict["ExecStatus"] as! Int32
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PassRate") && dict["PassRate"] != nil {
                self.passRate = dict["PassRate"] as! Int32
            }
            if dict.keys.contains("ProcessRate") && dict["ProcessRate"] != nil {
                self.processRate = dict["ProcessRate"] as! Int32
            }
            if dict.keys.contains("RiskCount") && dict["RiskCount"] != nil {
                self.riskCount = dict["RiskCount"] as! Int32
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var strategies: [DescribeStrategyResponseBody.Strategies]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategies != nil {
            var tmp : [Any] = []
            for k in self.strategies! {
                tmp.append(k.toMap())
            }
            map["Strategies"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Strategies") && dict["Strategies"] != nil {
            var tmp : [DescribeStrategyResponseBody.Strategies] = []
            for v in dict["Strategies"] as! [Any] {
                var model = DescribeStrategyResponseBody.Strategies()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.strategies = tmp
        }
    }
}

public class DescribeStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStrategyDetailRequest : Tea.TeaModel {
    public var id: String?

    public var lang: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeStrategyDetailResponseBody : Tea.TeaModel {
    public class Strategy : Tea.TeaModel {
        public class RiskTypeWhiteListQueryResultList : Tea.TeaModel {
            public class SubTypes : Tea.TeaModel {
                public class CheckDetails : Tea.TeaModel {
                    public class Rules : Tea.TeaModel {
                        public class ParamList : Tea.TeaModel {
                            public var enumValue: String?

                            public var maxValue: Int32?

                            public var minValue: Int32?

                            public var paramDefaultValue: String?

                            public var paramDesc: String?

                            public var paramName: String?

                            public var paramType: Int32?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.enumValue != nil {
                                    map["EnumValue"] = self.enumValue!
                                }
                                if self.maxValue != nil {
                                    map["MaxValue"] = self.maxValue!
                                }
                                if self.minValue != nil {
                                    map["MinValue"] = self.minValue!
                                }
                                if self.paramDefaultValue != nil {
                                    map["ParamDefaultValue"] = self.paramDefaultValue!
                                }
                                if self.paramDesc != nil {
                                    map["ParamDesc"] = self.paramDesc!
                                }
                                if self.paramName != nil {
                                    map["ParamName"] = self.paramName!
                                }
                                if self.paramType != nil {
                                    map["ParamType"] = self.paramType!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("EnumValue") && dict["EnumValue"] != nil {
                                    self.enumValue = dict["EnumValue"] as! String
                                }
                                if dict.keys.contains("MaxValue") && dict["MaxValue"] != nil {
                                    self.maxValue = dict["MaxValue"] as! Int32
                                }
                                if dict.keys.contains("MinValue") && dict["MinValue"] != nil {
                                    self.minValue = dict["MinValue"] as! Int32
                                }
                                if dict.keys.contains("ParamDefaultValue") && dict["ParamDefaultValue"] != nil {
                                    self.paramDefaultValue = dict["ParamDefaultValue"] as! String
                                }
                                if dict.keys.contains("ParamDesc") && dict["ParamDesc"] != nil {
                                    self.paramDesc = dict["ParamDesc"] as! String
                                }
                                if dict.keys.contains("ParamName") && dict["ParamName"] != nil {
                                    self.paramName = dict["ParamName"] as! String
                                }
                                if dict.keys.contains("ParamType") && dict["ParamType"] != nil {
                                    self.paramType = dict["ParamType"] as! Int32
                                }
                                if dict.keys.contains("Value") && dict["Value"] != nil {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public var defaultValue: Int32?

                        public var optional_: Int32?

                        public var paramList: [DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes.CheckDetails.Rules.ParamList]?

                        public var ruleDesc: String?

                        public var ruleId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.defaultValue != nil {
                                map["DefaultValue"] = self.defaultValue!
                            }
                            if self.optional_ != nil {
                                map["Optional"] = self.optional_!
                            }
                            if self.paramList != nil {
                                var tmp : [Any] = []
                                for k in self.paramList! {
                                    tmp.append(k.toMap())
                                }
                                map["ParamList"] = tmp
                            }
                            if self.ruleDesc != nil {
                                map["RuleDesc"] = self.ruleDesc!
                            }
                            if self.ruleId != nil {
                                map["RuleId"] = self.ruleId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                                self.defaultValue = dict["DefaultValue"] as! Int32
                            }
                            if dict.keys.contains("Optional") && dict["Optional"] != nil {
                                self.optional_ = dict["Optional"] as! Int32
                            }
                            if dict.keys.contains("ParamList") && dict["ParamList"] != nil {
                                var tmp : [DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes.CheckDetails.Rules.ParamList] = []
                                for v in dict["ParamList"] as! [Any] {
                                    var model = DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes.CheckDetails.Rules.ParamList()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.paramList = tmp
                            }
                            if dict.keys.contains("RuleDesc") && dict["RuleDesc"] != nil {
                                self.ruleDesc = dict["RuleDesc"] as! String
                            }
                            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                                self.ruleId = dict["RuleId"] as! String
                            }
                        }
                    }
                    public var checkDesc: String?

                    public var checkId: Int64?

                    public var checkItem: String?

                    public var rules: [DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes.CheckDetails.Rules]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.checkDesc != nil {
                            map["CheckDesc"] = self.checkDesc!
                        }
                        if self.checkId != nil {
                            map["CheckId"] = self.checkId!
                        }
                        if self.checkItem != nil {
                            map["CheckItem"] = self.checkItem!
                        }
                        if self.rules != nil {
                            var tmp : [Any] = []
                            for k in self.rules! {
                                tmp.append(k.toMap())
                            }
                            map["Rules"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CheckDesc") && dict["CheckDesc"] != nil {
                            self.checkDesc = dict["CheckDesc"] as! String
                        }
                        if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                            self.checkId = dict["CheckId"] as! Int64
                        }
                        if dict.keys.contains("CheckItem") && dict["CheckItem"] != nil {
                            self.checkItem = dict["CheckItem"] as! String
                        }
                        if dict.keys.contains("Rules") && dict["Rules"] != nil {
                            var tmp : [DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes.CheckDetails.Rules] = []
                            for v in dict["Rules"] as! [Any] {
                                var model = DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes.CheckDetails.Rules()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.rules = tmp
                        }
                    }
                }
                public var alias: String?

                public var checkDetails: [DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes.CheckDetails]?

                public var on: Bool?

                public var typeName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alias != nil {
                        map["Alias"] = self.alias!
                    }
                    if self.checkDetails != nil {
                        var tmp : [Any] = []
                        for k in self.checkDetails! {
                            tmp.append(k.toMap())
                        }
                        map["CheckDetails"] = tmp
                    }
                    if self.on != nil {
                        map["On"] = self.on!
                    }
                    if self.typeName != nil {
                        map["TypeName"] = self.typeName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Alias") && dict["Alias"] != nil {
                        self.alias = dict["Alias"] as! String
                    }
                    if dict.keys.contains("CheckDetails") && dict["CheckDetails"] != nil {
                        var tmp : [DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes.CheckDetails] = []
                        for v in dict["CheckDetails"] as! [Any] {
                            var model = DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes.CheckDetails()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.checkDetails = tmp
                    }
                    if dict.keys.contains("On") && dict["On"] != nil {
                        self.on = dict["On"] as! Bool
                    }
                    if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
                        self.typeName = dict["TypeName"] as! String
                    }
                }
            }
            public var alias: String?

            public var on: Bool?

            public var subTypes: [DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes]?

            public var typeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.on != nil {
                    map["On"] = self.on!
                }
                if self.subTypes != nil {
                    var tmp : [Any] = []
                    for k in self.subTypes! {
                        tmp.append(k.toMap())
                    }
                    map["SubTypes"] = tmp
                }
                if self.typeName != nil {
                    map["TypeName"] = self.typeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("On") && dict["On"] != nil {
                    self.on = dict["On"] as! Bool
                }
                if dict.keys.contains("SubTypes") && dict["SubTypes"] != nil {
                    var tmp : [DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes] = []
                    for v in dict["SubTypes"] as! [Any] {
                        var model = DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList.SubTypes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subTypes = tmp
                }
                if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
                    self.typeName = dict["TypeName"] as! String
                }
            }
        }
        public var customType: String?

        public var cycleDays: Int32?

        public var cycleStartTime: Int32?

        public var endTime: String?

        public var id: Int32?

        public var name: String?

        public var riskSubTypeName: String?

        public var riskTypeWhiteListQueryResultList: [DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList]?

        public var startTime: String?

        public var targetType: String?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customType != nil {
                map["CustomType"] = self.customType!
            }
            if self.cycleDays != nil {
                map["CycleDays"] = self.cycleDays!
            }
            if self.cycleStartTime != nil {
                map["CycleStartTime"] = self.cycleStartTime!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.riskSubTypeName != nil {
                map["RiskSubTypeName"] = self.riskSubTypeName!
            }
            if self.riskTypeWhiteListQueryResultList != nil {
                var tmp : [Any] = []
                for k in self.riskTypeWhiteListQueryResultList! {
                    tmp.append(k.toMap())
                }
                map["RiskTypeWhiteListQueryResultList"] = tmp
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomType") && dict["CustomType"] != nil {
                self.customType = dict["CustomType"] as! String
            }
            if dict.keys.contains("CycleDays") && dict["CycleDays"] != nil {
                self.cycleDays = dict["CycleDays"] as! Int32
            }
            if dict.keys.contains("CycleStartTime") && dict["CycleStartTime"] != nil {
                self.cycleStartTime = dict["CycleStartTime"] as! Int32
            }
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RiskSubTypeName") && dict["RiskSubTypeName"] != nil {
                self.riskSubTypeName = dict["RiskSubTypeName"] as! String
            }
            if dict.keys.contains("RiskTypeWhiteListQueryResultList") && dict["RiskTypeWhiteListQueryResultList"] != nil {
                var tmp : [DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList] = []
                for v in dict["RiskTypeWhiteListQueryResultList"] as! [Any] {
                    var model = DescribeStrategyDetailResponseBody.Strategy.RiskTypeWhiteListQueryResultList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.riskTypeWhiteListQueryResultList = tmp
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var strategy: DescribeStrategyDetailResponseBody.Strategy?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.strategy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Strategy") && dict["Strategy"] != nil {
            var model = DescribeStrategyDetailResponseBody.Strategy()
            model.fromMap(dict["Strategy"] as! [String: Any])
            self.strategy = model
        }
    }
}

public class DescribeStrategyDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStrategyDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeStrategyDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStrategyExecDetailRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var sourceIp: String?

    public var strategyId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
            self.strategyId = dict["StrategyId"] as! Int32
        }
    }
}

public class DescribeStrategyExecDetailResponseBody : Tea.TeaModel {
    public class FailedEcsList : Tea.TeaModel {
        public var IP: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var reason: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IP") && dict["IP"] != nil {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
        }
    }
    public var endTime: String?

    public var failCount: Int32?

    public var failedEcsList: [DescribeStrategyExecDetailResponseBody.FailedEcsList]?

    public var inProcessCount: Int32?

    public var percent: String?

    public var requestId: String?

    public var source: String?

    public var startTime: String?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.failCount != nil {
            map["FailCount"] = self.failCount!
        }
        if self.failedEcsList != nil {
            var tmp : [Any] = []
            for k in self.failedEcsList! {
                tmp.append(k.toMap())
            }
            map["FailedEcsList"] = tmp
        }
        if self.inProcessCount != nil {
            map["InProcessCount"] = self.inProcessCount!
        }
        if self.percent != nil {
            map["Percent"] = self.percent!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FailCount") && dict["FailCount"] != nil {
            self.failCount = dict["FailCount"] as! Int32
        }
        if dict.keys.contains("FailedEcsList") && dict["FailedEcsList"] != nil {
            var tmp : [DescribeStrategyExecDetailResponseBody.FailedEcsList] = []
            for v in dict["FailedEcsList"] as! [Any] {
                var model = DescribeStrategyExecDetailResponseBody.FailedEcsList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.failedEcsList = tmp
        }
        if dict.keys.contains("InProcessCount") && dict["InProcessCount"] != nil {
            self.inProcessCount = dict["InProcessCount"] as! Int32
        }
        if dict.keys.contains("Percent") && dict["Percent"] != nil {
            self.percent = dict["Percent"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("SuccessCount") && dict["SuccessCount"] != nil {
            self.successCount = dict["SuccessCount"] as! Int32
        }
    }
}

public class DescribeStrategyExecDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStrategyExecDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeStrategyExecDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStrategyTargetRequest : Tea.TeaModel {
    public var config: String?

    public var sourceIp: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeStrategyTargetResponseBody : Tea.TeaModel {
    public class StrategyTargets : Tea.TeaModel {
        public var bindUuidCount: Int32?

        public var flag: String?

        public var target: String?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindUuidCount != nil {
                map["BindUuidCount"] = self.bindUuidCount!
            }
            if self.flag != nil {
                map["Flag"] = self.flag!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindUuidCount") && dict["BindUuidCount"] != nil {
                self.bindUuidCount = dict["BindUuidCount"] as! Int32
            }
            if dict.keys.contains("Flag") && dict["Flag"] != nil {
                self.flag = dict["Flag"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
        }
    }
    public var requestId: String?

    public var strategyTargets: [DescribeStrategyTargetResponseBody.StrategyTargets]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.strategyTargets != nil {
            var tmp : [Any] = []
            for k in self.strategyTargets! {
                tmp.append(k.toMap())
            }
            map["StrategyTargets"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StrategyTargets") && dict["StrategyTargets"] != nil {
            var tmp : [DescribeStrategyTargetResponseBody.StrategyTargets] = []
            for v in dict["StrategyTargets"] as! [Any] {
                var model = DescribeStrategyTargetResponseBody.StrategyTargets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.strategyTargets = tmp
        }
    }
}

public class DescribeStrategyTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStrategyTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeStrategyTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSummaryInfoRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeSummaryInfoResponseBody : Tea.TeaModel {
    public var aegisClientOfflineCount: Int32?

    public var aegisClientOnlineCount: Int32?

    public var requestId: String?

    public var securityScore: Int32?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aegisClientOfflineCount != nil {
            map["AegisClientOfflineCount"] = self.aegisClientOfflineCount!
        }
        if self.aegisClientOnlineCount != nil {
            map["AegisClientOnlineCount"] = self.aegisClientOnlineCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityScore != nil {
            map["SecurityScore"] = self.securityScore!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AegisClientOfflineCount") && dict["AegisClientOfflineCount"] != nil {
            self.aegisClientOfflineCount = dict["AegisClientOfflineCount"] as! Int32
        }
        if dict.keys.contains("AegisClientOnlineCount") && dict["AegisClientOnlineCount"] != nil {
            self.aegisClientOnlineCount = dict["AegisClientOnlineCount"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityScore") && dict["SecurityScore"] != nil {
            self.securityScore = dict["SecurityScore"] as! Int32
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeSummaryInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSummaryInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSummaryInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSupportRegionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var supportRegion: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportRegion != nil {
            map["SupportRegion"] = self.supportRegion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportRegion") && dict["SupportRegion"] != nil {
            self.supportRegion = dict["SupportRegion"] as! [String]
        }
    }
}

public class DescribeSupportRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSupportRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSupportRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSuspEventDetailRequest : Tea.TeaModel {
    public var from: String?

    public var lang: String?

    public var resourceDirectoryAccountId: Int64?

    public var sourceIp: String?

    public var suspiciousEventId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.suspiciousEventId != nil {
            map["SuspiciousEventId"] = self.suspiciousEventId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("SuspiciousEventId") && dict["SuspiciousEventId"] != nil {
            self.suspiciousEventId = dict["SuspiciousEventId"] as! Int32
        }
    }
}

public class DescribeSuspEventDetailResponseBody : Tea.TeaModel {
    public class Details : Tea.TeaModel {
        public var nameDisplay: String?

        public var type: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nameDisplay != nil {
                map["NameDisplay"] = self.nameDisplay!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NameDisplay") && dict["NameDisplay"] != nil {
                self.nameDisplay = dict["NameDisplay"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var canBeDealOnLine: Bool?

    public var dataSource: String?

    public var details: [DescribeSuspEventDetailResponseBody.Details]?

    public var eventDesc: String?

    public var eventName: String?

    public var eventStatus: String?

    public var eventTypeDesc: String?

    public var id: Int32?

    public var instanceName: String?

    public var internetIp: String?

    public var intranetIp: String?

    public var lastTime: String?

    public var level: String?

    public var operateErrorCode: String?

    public var operateMsg: String?

    public var requestId: String?

    public var saleVersion: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.canBeDealOnLine != nil {
            map["CanBeDealOnLine"] = self.canBeDealOnLine!
        }
        if self.dataSource != nil {
            map["DataSource"] = self.dataSource!
        }
        if self.details != nil {
            var tmp : [Any] = []
            for k in self.details! {
                tmp.append(k.toMap())
            }
            map["Details"] = tmp
        }
        if self.eventDesc != nil {
            map["EventDesc"] = self.eventDesc!
        }
        if self.eventName != nil {
            map["EventName"] = self.eventName!
        }
        if self.eventStatus != nil {
            map["EventStatus"] = self.eventStatus!
        }
        if self.eventTypeDesc != nil {
            map["EventTypeDesc"] = self.eventTypeDesc!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.intranetIp != nil {
            map["IntranetIp"] = self.intranetIp!
        }
        if self.lastTime != nil {
            map["LastTime"] = self.lastTime!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.operateErrorCode != nil {
            map["OperateErrorCode"] = self.operateErrorCode!
        }
        if self.operateMsg != nil {
            map["OperateMsg"] = self.operateMsg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.saleVersion != nil {
            map["SaleVersion"] = self.saleVersion!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CanBeDealOnLine") && dict["CanBeDealOnLine"] != nil {
            self.canBeDealOnLine = dict["CanBeDealOnLine"] as! Bool
        }
        if dict.keys.contains("DataSource") && dict["DataSource"] != nil {
            self.dataSource = dict["DataSource"] as! String
        }
        if dict.keys.contains("Details") && dict["Details"] != nil {
            var tmp : [DescribeSuspEventDetailResponseBody.Details] = []
            for v in dict["Details"] as! [Any] {
                var model = DescribeSuspEventDetailResponseBody.Details()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.details = tmp
        }
        if dict.keys.contains("EventDesc") && dict["EventDesc"] != nil {
            self.eventDesc = dict["EventDesc"] as! String
        }
        if dict.keys.contains("EventName") && dict["EventName"] != nil {
            self.eventName = dict["EventName"] as! String
        }
        if dict.keys.contains("EventStatus") && dict["EventStatus"] != nil {
            self.eventStatus = dict["EventStatus"] as! String
        }
        if dict.keys.contains("EventTypeDesc") && dict["EventTypeDesc"] != nil {
            self.eventTypeDesc = dict["EventTypeDesc"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int32
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
            self.internetIp = dict["InternetIp"] as! String
        }
        if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
            self.intranetIp = dict["IntranetIp"] as! String
        }
        if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
            self.lastTime = dict["LastTime"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("OperateErrorCode") && dict["OperateErrorCode"] != nil {
            self.operateErrorCode = dict["OperateErrorCode"] as! String
        }
        if dict.keys.contains("OperateMsg") && dict["OperateMsg"] != nil {
            self.operateMsg = dict["OperateMsg"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SaleVersion") && dict["SaleVersion"] != nil {
            self.saleVersion = dict["SaleVersion"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeSuspEventDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSuspEventDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSuspEventDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSuspEventExportInfoRequest : Tea.TeaModel {
    public var exportId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exportId != nil {
            map["ExportId"] = self.exportId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExportId") && dict["ExportId"] != nil {
            self.exportId = dict["ExportId"] as! Int32
        }
    }
}

public class DescribeSuspEventExportInfoResponseBody : Tea.TeaModel {
    public var exportStatus: String?

    public var fileName: String?

    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var id: Int32?

    public var link: String?

    public var progress: Int32?

    public var properties: String?

    public var requestId: String?

    public var totalCount: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exportStatus != nil {
            map["ExportStatus"] = self.exportStatus!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.link != nil {
            map["Link"] = self.link!
        }
        if self.progress != nil {
            map["Progress"] = self.progress!
        }
        if self.properties != nil {
            map["Properties"] = self.properties!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExportStatus") && dict["ExportStatus"] != nil {
            self.exportStatus = dict["ExportStatus"] as! String
        }
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! Int64
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int32
        }
        if dict.keys.contains("Link") && dict["Link"] != nil {
            self.link = dict["Link"] as! String
        }
        if dict.keys.contains("Progress") && dict["Progress"] != nil {
            self.progress = dict["Progress"] as! Int32
        }
        if dict.keys.contains("Properties") && dict["Properties"] != nil {
            self.properties = dict["Properties"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeSuspEventExportInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSuspEventExportInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSuspEventExportInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSuspEventQuaraFilesRequest : Tea.TeaModel {
    public var currentPage: String?

    public var from: String?

    public var groupId: String?

    public var groupingId: Int64?

    public var pageSize: String?

    public var quaraTag: String?

    public var sourceIp: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupingId != nil {
            map["GroupingId"] = self.groupingId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.quaraTag != nil {
            map["QuaraTag"] = self.quaraTag!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! String
        }
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupingId") && dict["GroupingId"] != nil {
            self.groupingId = dict["GroupingId"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("QuaraTag") && dict["QuaraTag"] != nil {
            self.quaraTag = dict["QuaraTag"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeSuspEventQuaraFilesResponseBody : Tea.TeaModel {
    public class QuaraFiles : Tea.TeaModel {
        public var eventName: String?

        public var eventType: String?

        public var id: Int32?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var link: String?

        public var md5: String?

        public var modifyTime: String?

        public var path: String?

        public var status: String?

        public var tag: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventName != nil {
                map["EventName"] = self.eventName!
            }
            if self.eventType != nil {
                map["EventType"] = self.eventType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.link != nil {
                map["Link"] = self.link!
            }
            if self.md5 != nil {
                map["Md5"] = self.md5!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventName") && dict["EventName"] != nil {
                self.eventName = dict["EventName"] as! String
            }
            if dict.keys.contains("EventType") && dict["EventType"] != nil {
                self.eventType = dict["EventType"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Link") && dict["Link"] != nil {
                self.link = dict["Link"] as! String
            }
            if dict.keys.contains("Md5") && dict["Md5"] != nil {
                self.md5 = dict["Md5"] as! String
            }
            if dict.keys.contains("ModifyTime") && dict["ModifyTime"] != nil {
                self.modifyTime = dict["ModifyTime"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var count: Int32?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var quaraFiles: [DescribeSuspEventQuaraFilesResponseBody.QuaraFiles]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.quaraFiles != nil {
            var tmp : [Any] = []
            for k in self.quaraFiles! {
                tmp.append(k.toMap())
            }
            map["QuaraFiles"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QuaraFiles") && dict["QuaraFiles"] != nil {
            var tmp : [DescribeSuspEventQuaraFilesResponseBody.QuaraFiles] = []
            for v in dict["QuaraFiles"] as! [Any] {
                var model = DescribeSuspEventQuaraFilesResponseBody.QuaraFiles()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.quaraFiles = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSuspEventQuaraFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSuspEventQuaraFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSuspEventQuaraFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSuspEventUserSettingRequest : Tea.TeaModel {
    public var from: String?

    public var id: Int32?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int32
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeSuspEventUserSettingResponseBody : Tea.TeaModel {
    public var levelsOn: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.levelsOn != nil {
            map["LevelsOn"] = self.levelsOn!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LevelsOn") && dict["LevelsOn"] != nil {
            self.levelsOn = dict["LevelsOn"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSuspEventUserSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSuspEventUserSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSuspEventUserSettingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSuspEventsRequest : Tea.TeaModel {
    public var alarmUniqueInfo: String?

    public var assetsTypeList: [String]?

    public var clusterId: String?

    public var containerFieldName: String?

    public var containerFieldValue: String?

    public var currentPage: String?

    public var dealed: String?

    public var eventNames: String?

    public var from: String?

    public var groupId: Int64?

    public var id: Int64?

    public var lang: String?

    public var levels: String?

    public var name: String?

    public var operateErrorCodeList: [String]?

    public var operateTimeEnd: String?

    public var operateTimeStart: String?

    public var pageSize: String?

    public var parentEventTypes: String?

    public var remark: String?

    public var resourceDirectoryAccountId: Int64?

    public var sortColumn: String?

    public var sortType: String?

    public var source: String?

    public var sourceIp: String?

    public var status: String?

    public var tacticId: String?

    public var targetType: String?

    public var timeEnd: String?

    public var timeStart: String?

    public var uniqueInfo: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmUniqueInfo != nil {
            map["AlarmUniqueInfo"] = self.alarmUniqueInfo!
        }
        if self.assetsTypeList != nil {
            map["AssetsTypeList"] = self.assetsTypeList!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.containerFieldName != nil {
            map["ContainerFieldName"] = self.containerFieldName!
        }
        if self.containerFieldValue != nil {
            map["ContainerFieldValue"] = self.containerFieldValue!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.eventNames != nil {
            map["EventNames"] = self.eventNames!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.levels != nil {
            map["Levels"] = self.levels!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.operateErrorCodeList != nil {
            map["OperateErrorCodeList"] = self.operateErrorCodeList!
        }
        if self.operateTimeEnd != nil {
            map["OperateTimeEnd"] = self.operateTimeEnd!
        }
        if self.operateTimeStart != nil {
            map["OperateTimeStart"] = self.operateTimeStart!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentEventTypes != nil {
            map["ParentEventTypes"] = self.parentEventTypes!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.sortColumn != nil {
            map["SortColumn"] = self.sortColumn!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tacticId != nil {
            map["TacticId"] = self.tacticId!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.timeEnd != nil {
            map["TimeEnd"] = self.timeEnd!
        }
        if self.timeStart != nil {
            map["TimeStart"] = self.timeStart!
        }
        if self.uniqueInfo != nil {
            map["UniqueInfo"] = self.uniqueInfo!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmUniqueInfo") && dict["AlarmUniqueInfo"] != nil {
            self.alarmUniqueInfo = dict["AlarmUniqueInfo"] as! String
        }
        if dict.keys.contains("AssetsTypeList") && dict["AssetsTypeList"] != nil {
            self.assetsTypeList = dict["AssetsTypeList"] as! [String]
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ContainerFieldName") && dict["ContainerFieldName"] != nil {
            self.containerFieldName = dict["ContainerFieldName"] as! String
        }
        if dict.keys.contains("ContainerFieldValue") && dict["ContainerFieldValue"] != nil {
            self.containerFieldValue = dict["ContainerFieldValue"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! String
        }
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("EventNames") && dict["EventNames"] != nil {
            self.eventNames = dict["EventNames"] as! String
        }
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Levels") && dict["Levels"] != nil {
            self.levels = dict["Levels"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OperateErrorCodeList") && dict["OperateErrorCodeList"] != nil {
            self.operateErrorCodeList = dict["OperateErrorCodeList"] as! [String]
        }
        if dict.keys.contains("OperateTimeEnd") && dict["OperateTimeEnd"] != nil {
            self.operateTimeEnd = dict["OperateTimeEnd"] as! String
        }
        if dict.keys.contains("OperateTimeStart") && dict["OperateTimeStart"] != nil {
            self.operateTimeStart = dict["OperateTimeStart"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("ParentEventTypes") && dict["ParentEventTypes"] != nil {
            self.parentEventTypes = dict["ParentEventTypes"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! Int64
        }
        if dict.keys.contains("SortColumn") && dict["SortColumn"] != nil {
            self.sortColumn = dict["SortColumn"] as! String
        }
        if dict.keys.contains("SortType") && dict["SortType"] != nil {
            self.sortType = dict["SortType"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TacticId") && dict["TacticId"] != nil {
            self.tacticId = dict["TacticId"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("TimeEnd") && dict["TimeEnd"] != nil {
            self.timeEnd = dict["TimeEnd"] as! String
        }
        if dict.keys.contains("TimeStart") && dict["TimeStart"] != nil {
            self.timeStart = dict["TimeStart"] as! String
        }
        if dict.keys.contains("UniqueInfo") && dict["UniqueInfo"] != nil {
            self.uniqueInfo = dict["UniqueInfo"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeSuspEventsResponseBody : Tea.TeaModel {
    public class SuspEvents : Tea.TeaModel {
        public class Details : Tea.TeaModel {
            public var nameDisplay: String?

            public var type: String?

            public var value: String?

            public var valueDisplay: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.nameDisplay != nil {
                    map["NameDisplay"] = self.nameDisplay!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                if self.valueDisplay != nil {
                    map["ValueDisplay"] = self.valueDisplay!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NameDisplay") && dict["NameDisplay"] != nil {
                    self.nameDisplay = dict["NameDisplay"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
                if dict.keys.contains("ValueDisplay") && dict["ValueDisplay"] != nil {
                    self.valueDisplay = dict["ValueDisplay"] as! String
                }
            }
        }
        public class EventNotes : Tea.TeaModel {
            public var note: String?

            public var noteId: Int64?

            public var noteTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.note != nil {
                    map["Note"] = self.note!
                }
                if self.noteId != nil {
                    map["NoteId"] = self.noteId!
                }
                if self.noteTime != nil {
                    map["NoteTime"] = self.noteTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Note") && dict["Note"] != nil {
                    self.note = dict["Note"] as! String
                }
                if dict.keys.contains("NoteId") && dict["NoteId"] != nil {
                    self.noteId = dict["NoteId"] as! Int64
                }
                if dict.keys.contains("NoteTime") && dict["NoteTime"] != nil {
                    self.noteTime = dict["NoteTime"] as! String
                }
            }
        }
        public class TacticItems : Tea.TeaModel {
            public var tacticDisplayName: String?

            public var tacticId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tacticDisplayName != nil {
                    map["TacticDisplayName"] = self.tacticDisplayName!
                }
                if self.tacticId != nil {
                    map["TacticId"] = self.tacticId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TacticDisplayName") && dict["TacticDisplayName"] != nil {
                    self.tacticDisplayName = dict["TacticDisplayName"] as! String
                }
                if dict.keys.contains("TacticId") && dict["TacticId"] != nil {
                    self.tacticId = dict["TacticId"] as! String
                }
            }
        }
        public var advanced: Bool?

        public var alarmEventName: String?

        public var alarmEventNameDisplay: String?

        public var alarmEventType: String?

        public var alarmEventTypeDisplay: String?

        public var alarmUniqueInfo: String?

        public var appName: String?

        public var autoBreaking: Bool?

        public var canBeDealOnLine: Bool?

        public var canCancelFault: Bool?

        public var containHwMode: Bool?

        public var containerId: String?

        public var containerImageId: String?

        public var containerImageName: String?

        public var dataSource: String?

        public var desc: String?

        public var details: [DescribeSuspEventsResponseBody.SuspEvents.Details]?

        public var displaySandboxResult: Bool?

        public var eventNotes: [DescribeSuspEventsResponseBody.SuspEvents.EventNotes]?

        public var eventStatus: Int32?

        public var eventSubType: String?

        public var hasTraceInfo: Bool?

        public var id: Int64?

        public var imageUuid: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var k8sClusterId: String?

        public var k8sClusterName: String?

        public var k8sNamespace: String?

        public var k8sNodeId: String?

        public var k8sNodeName: String?

        public var k8sPodName: String?

        public var largeModel: Bool?

        public var lastTime: String?

        public var lastTimeStamp: Int64?

        public var level: String?

        public var maliciousRuleStatus: String?

        public var markMisRules: String?

        public var name: String?

        public var occurrenceTime: String?

        public var occurrenceTimeStamp: Int64?

        public var operateErrorCode: String?

        public var operateMsg: String?

        public var operateTime: Int64?

        public var saleVersion: String?

        public var securityEventIds: String?

        public var stages: String?

        public var tacticItems: [DescribeSuspEventsResponseBody.SuspEvents.TacticItems]?

        public var uniqueInfo: String?

        public var uuid: String?

        public var clusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advanced != nil {
                map["Advanced"] = self.advanced!
            }
            if self.alarmEventName != nil {
                map["AlarmEventName"] = self.alarmEventName!
            }
            if self.alarmEventNameDisplay != nil {
                map["AlarmEventNameDisplay"] = self.alarmEventNameDisplay!
            }
            if self.alarmEventType != nil {
                map["AlarmEventType"] = self.alarmEventType!
            }
            if self.alarmEventTypeDisplay != nil {
                map["AlarmEventTypeDisplay"] = self.alarmEventTypeDisplay!
            }
            if self.alarmUniqueInfo != nil {
                map["AlarmUniqueInfo"] = self.alarmUniqueInfo!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.autoBreaking != nil {
                map["AutoBreaking"] = self.autoBreaking!
            }
            if self.canBeDealOnLine != nil {
                map["CanBeDealOnLine"] = self.canBeDealOnLine!
            }
            if self.canCancelFault != nil {
                map["CanCancelFault"] = self.canCancelFault!
            }
            if self.containHwMode != nil {
                map["ContainHwMode"] = self.containHwMode!
            }
            if self.containerId != nil {
                map["ContainerId"] = self.containerId!
            }
            if self.containerImageId != nil {
                map["ContainerImageId"] = self.containerImageId!
            }
            if self.containerImageName != nil {
                map["ContainerImageName"] = self.containerImageName!
            }
            if self.dataSource != nil {
                map["DataSource"] = self.dataSource!
            }
            if self.desc != nil {
                map["Desc"] = self.desc!
            }
            if self.details != nil {
                var tmp : [Any] = []
                for k in self.details! {
                    tmp.append(k.toMap())
                }
                map["Details"] = tmp
            }
            if self.displaySandboxResult != nil {
                map["DisplaySandboxResult"] = self.displaySandboxResult!
            }
            if self.eventNotes != nil {
                var tmp : [Any] = []
                for k in self.eventNotes! {
                    tmp.append(k.toMap())
                }
                map["EventNotes"] = tmp
            }
            if self.eventStatus != nil {
                map["EventStatus"] = self.eventStatus!
            }
            if self.eventSubType != nil {
                map["EventSubType"] = self.eventSubType!
            }
            if self.hasTraceInfo != nil {
                map["HasTraceInfo"] = self.hasTraceInfo!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.imageUuid != nil {
                map["ImageUuid"] = self.imageUuid!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.k8sClusterId != nil {
                map["K8sClusterId"] = self.k8sClusterId!
            }
            if self.k8sClusterName != nil {
                map["K8sClusterName"] = self.k8sClusterName!
            }
            if self.k8sNamespace != nil {
                map["K8sNamespace"] = self.k8sNamespace!
            }
            if self.k8sNodeId != nil {
                map["K8sNodeId"] = self.k8sNodeId!
            }
            if self.k8sNodeName != nil {
                map["K8sNodeName"] = self.k8sNodeName!
            }
            if self.k8sPodName != nil {
                map["K8sPodName"] = self.k8sPodName!
            }
            if self.largeModel != nil {
                map["LargeModel"] = self.largeModel!
            }
            if self.lastTime != nil {
                map["LastTime"] = self.lastTime!
            }
            if self.lastTimeStamp != nil {
                map["LastTimeStamp"] = self.lastTimeStamp!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.maliciousRuleStatus != nil {
                map["MaliciousRuleStatus"] = self.maliciousRuleStatus!
            }
            if self.markMisRules != nil {
                map["MarkMisRules"] = self.markMisRules!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.occurrenceTime != nil {
                map["OccurrenceTime"] = self.occurrenceTime!
            }
            if self.occurrenceTimeStamp != nil {
                map["OccurrenceTimeStamp"] = self.occurrenceTimeStamp!
            }
            if self.operateErrorCode != nil {
                map["OperateErrorCode"] = self.operateErrorCode!
            }
            if self.operateMsg != nil {
                map["OperateMsg"] = self.operateMsg!
            }
            if self.operateTime != nil {
                map["OperateTime"] = self.operateTime!
            }
            if self.saleVersion != nil {
                map["SaleVersion"] = self.saleVersion!
            }
            if self.securityEventIds != nil {
                map["SecurityEventIds"] = self.securityEventIds!
            }
            if self.stages != nil {
                map["Stages"] = self.stages!
            }
            if self.tacticItems != nil {
                var tmp : [Any] = []
                for k in self.tacticItems! {
                    tmp.append(k.toMap())
                }
                map["TacticItems"] = tmp
            }
            if self.uniqueInfo != nil {
                map["UniqueInfo"] = self.uniqueInfo!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.clusterId != nil {
                map["clusterId"] = self.clusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Advanced") && dict["Advanced"] != nil {
                self.advanced = dict["Advanced"] as! Bool
            }
            if dict.keys.contains("AlarmEventName") && dict["AlarmEventName"] != nil {
                self.alarmEventName = dict["AlarmEventName"] as! String
            }
            if dict.keys.contains("AlarmEventNameDisplay") && dict["AlarmEventNameDisplay"] != nil {
                self.alarmEventNameDisplay = dict["AlarmEventNameDisplay"] as! String
            }
            if dict.keys.contains("AlarmEventType") && dict["AlarmEventType"] != nil {
                self.alarmEventType = dict["AlarmEventType"] as! String
            }
            if dict.keys.contains("AlarmEventTypeDisplay") && dict["AlarmEventTypeDisplay"] != nil {
                self.alarmEventTypeDisplay = dict["AlarmEventTypeDisplay"] as! String
            }
            if dict.keys.contains("AlarmUniqueInfo") && dict["AlarmUniqueInfo"] != nil {
                self.alarmUniqueInfo = dict["AlarmUniqueInfo"] as! String
            }
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("AutoBreaking") && dict["AutoBreaking"] != nil {
                self.autoBreaking = dict["AutoBreaking"] as! Bool
            }
            if dict.keys.contains("CanBeDealOnLine") && dict["CanBeDealOnLine"] != nil {
                self.canBeDealOnLine = dict["CanBeDealOnLine"] as! Bool
            }
            if dict.keys.contains("CanCancelFault") && dict["CanCancelFault"] != nil {
                self.canCancelFault = dict["CanCancelFault"] as! Bool
            }
            if dict.keys.contains("ContainHwMode") && dict["ContainHwMode"] != nil {
                self.containHwMode = dict["ContainHwMode"] as! Bool
            }
            if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                self.containerId = dict["ContainerId"] as! String
            }
            if dict.keys.contains("ContainerImageId") && dict["ContainerImageId"] != nil {
                self.containerImageId = dict["ContainerImageId"] as! String
            }
            if dict.keys.contains("ContainerImageName") && dict["ContainerImageName"] != nil {
                self.containerImageName = dict["ContainerImageName"] as! String
            }
            if dict.keys.contains("DataSource") && dict["DataSource"] != nil {
                self.dataSource = dict["DataSource"] as! String
            }
            if dict.keys.contains("Desc") && dict["Desc"] != nil {
                self.desc = dict["Desc"] as! String
            }
            if dict.keys.contains("Details") && dict["Details"] != nil {
                var tmp : [DescribeSuspEventsResponseBody.SuspEvents.Details] = []
                for v in dict["Details"] as! [Any] {
                    var model = DescribeSuspEventsResponseBody.SuspEvents.Details()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.details = tmp
            }
            if dict.keys.contains("DisplaySandboxResult") && dict["DisplaySandboxResult"] != nil {
                self.displaySandboxResult = dict["DisplaySandboxResult"] as! Bool
            }
            if dict.keys.contains("EventNotes") && dict["EventNotes"] != nil {
                var tmp : [DescribeSuspEventsResponseBody.SuspEvents.EventNotes] = []
                for v in dict["EventNotes"] as! [Any] {
                    var model = DescribeSuspEventsResponseBody.SuspEvents.EventNotes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eventNotes = tmp
            }
            if dict.keys.contains("EventStatus") && dict["EventStatus"] != nil {
                self.eventStatus = dict["EventStatus"] as! Int32
            }
            if dict.keys.contains("EventSubType") && dict["EventSubType"] != nil {
                self.eventSubType = dict["EventSubType"] as! String
            }
            if dict.keys.contains("HasTraceInfo") && dict["HasTraceInfo"] != nil {
                self.hasTraceInfo = dict["HasTraceInfo"] as! Bool
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
                self.imageUuid = dict["ImageUuid"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("K8sClusterId") && dict["K8sClusterId"] != nil {
                self.k8sClusterId = dict["K8sClusterId"] as! String
            }
            if dict.keys.contains("K8sClusterName") && dict["K8sClusterName"] != nil {
                self.k8sClusterName = dict["K8sClusterName"] as! String
            }
            if dict.keys.contains("K8sNamespace") && dict["K8sNamespace"] != nil {
                self.k8sNamespace = dict["K8sNamespace"] as! String
            }
            if dict.keys.contains("K8sNodeId") && dict["K8sNodeId"] != nil {
                self.k8sNodeId = dict["K8sNodeId"] as! String
            }
            if dict.keys.contains("K8sNodeName") && dict["K8sNodeName"] != nil {
                self.k8sNodeName = dict["K8sNodeName"] as! String
            }
            if dict.keys.contains("K8sPodName") && dict["K8sPodName"] != nil {
                self.k8sPodName = dict["K8sPodName"] as! String
            }
            if dict.keys.contains("LargeModel") && dict["LargeModel"] != nil {
                self.largeModel = dict["LargeModel"] as! Bool
            }
            if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
                self.lastTime = dict["LastTime"] as! String
            }
            if dict.keys.contains("LastTimeStamp") && dict["LastTimeStamp"] != nil {
                self.lastTimeStamp = dict["LastTimeStamp"] as! Int64
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("MaliciousRuleStatus") && dict["MaliciousRuleStatus"] != nil {
                self.maliciousRuleStatus = dict["MaliciousRuleStatus"] as! String
            }
            if dict.keys.contains("MarkMisRules") && dict["MarkMisRules"] != nil {
                self.markMisRules = dict["MarkMisRules"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OccurrenceTime") && dict["OccurrenceTime"] != nil {
                self.occurrenceTime = dict["OccurrenceTime"] as! String
            }
            if dict.keys.contains("OccurrenceTimeStamp") && dict["OccurrenceTimeStamp"] != nil {
                self.occurrenceTimeStamp = dict["OccurrenceTimeStamp"] as! Int64
            }
            if dict.keys.contains("OperateErrorCode") && dict["OperateErrorCode"] != nil {
                self.operateErrorCode = dict["OperateErrorCode"] as! String
            }
            if dict.keys.contains("OperateMsg") && dict["OperateMsg"] != nil {
                self.operateMsg = dict["OperateMsg"] as! String
            }
            if dict.keys.contains("OperateTime") && dict["OperateTime"] != nil {
                self.operateTime = dict["OperateTime"] as! Int64
            }
            if dict.keys.contains("SaleVersion") && dict["SaleVersion"] != nil {
                self.saleVersion = dict["SaleVersion"] as! String
            }
            if dict.keys.contains("SecurityEventIds") && dict["SecurityEventIds"] != nil {
                self.securityEventIds = dict["SecurityEventIds"] as! String
            }
            if dict.keys.contains("Stages") && dict["Stages"] != nil {
                self.stages = dict["Stages"] as! String
            }
            if dict.keys.contains("TacticItems") && dict["TacticItems"] != nil {
                var tmp : [DescribeSuspEventsResponseBody.SuspEvents.TacticItems] = []
                for v in dict["TacticItems"] as! [Any] {
                    var model = DescribeSuspEventsResponseBody.SuspEvents.TacticItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tacticItems = tmp
            }
            if dict.keys.contains("UniqueInfo") && dict["UniqueInfo"] != nil {
                self.uniqueInfo = dict["UniqueInfo"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("clusterId") && dict["clusterId"] != nil {
                self.clusterId = dict["clusterId"] as! String
            }
        }
    }
    public var count: Int32?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var suspEvents: [DescribeSuspEventsResponseBody.SuspEvents]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.suspEvents != nil {
            var tmp : [Any] = []
            for k in self.suspEvents! {
                tmp.append(k.toMap())
            }
            map["SuspEvents"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuspEvents") && dict["SuspEvents"] != nil {
            var tmp : [DescribeSuspEventsResponseBody.SuspEvents] = []
            for v in dict["SuspEvents"] as! [Any] {
                var model = DescribeSuspEventsResponseBody.SuspEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.suspEvents = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSuspEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSuspEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSuspEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSuspiciousOverallConfigRequest : Tea.TeaModel {
    public var sourceIp: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeSuspiciousOverallConfigResponseBody : Tea.TeaModel {
    public class OverallConfig : Tea.TeaModel {
        public var config: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var overallConfig: DescribeSuspiciousOverallConfigResponseBody.OverallConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.overallConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.overallConfig != nil {
            map["OverallConfig"] = self.overallConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OverallConfig") && dict["OverallConfig"] != nil {
            var model = DescribeSuspiciousOverallConfigResponseBody.OverallConfig()
            model.fromMap(dict["OverallConfig"] as! [String: Any])
            self.overallConfig = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSuspiciousOverallConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSuspiciousOverallConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSuspiciousOverallConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSuspiciousUUIDConfigRequest : Tea.TeaModel {
    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeSuspiciousUUIDConfigResponseBody : Tea.TeaModel {
    public var count: Int32?

    public var requestId: String?

    public var UUIDList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.UUIDList != nil {
            map["UUIDList"] = self.UUIDList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UUIDList") && dict["UUIDList"] != nil {
            self.UUIDList = dict["UUIDList"] as! [String]
        }
    }
}

public class DescribeSuspiciousUUIDConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSuspiciousUUIDConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeSuspiciousUUIDConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTargetRequest : Tea.TeaModel {
    public var config: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeTargetResponseBody : Tea.TeaModel {
    public class Targets : Tea.TeaModel {
        public var flag: String?

        public var target: String?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flag != nil {
                map["Flag"] = self.flag!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Flag") && dict["Flag"] != nil {
                self.flag = dict["Flag"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
        }
    }
    public var requestId: String?

    public var targets: [DescribeTargetResponseBody.Targets]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.targets != nil {
            var tmp : [Any] = []
            for k in self.targets! {
                tmp.append(k.toMap())
            }
            map["Targets"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Targets") && dict["Targets"] != nil {
            var tmp : [DescribeTargetResponseBody.Targets] = []
            for v in dict["Targets"] as! [Any] {
                var model = DescribeTargetResponseBody.Targets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.targets = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTaskErrorLogRequest : Tea.TeaModel {
    public var buildTaskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.buildTaskId != nil {
            map["BuildTaskId"] = self.buildTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BuildTaskId") && dict["BuildTaskId"] != nil {
            self.buildTaskId = dict["BuildTaskId"] as! String
        }
    }
}

public class DescribeTaskErrorLogResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public var text: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.text != nil {
                map["Text"] = self.text!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Text") && dict["Text"] != nil {
                self.text = dict["Text"] as! String
            }
        }
    }
    public var logs: [DescribeTaskErrorLogResponseBody.Logs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logs != nil {
            var tmp : [Any] = []
            for k in self.logs! {
                tmp.append(k.toMap())
            }
            map["Logs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logs") && dict["Logs"] != nil {
            var tmp : [DescribeTaskErrorLogResponseBody.Logs] = []
            for v in dict["Logs"] as! [Any] {
                var model = DescribeTaskErrorLogResponseBody.Logs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.logs = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeTaskErrorLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTaskErrorLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeTaskErrorLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTotalStatisticsRequest : Tea.TeaModel {
    public var from: String?

    public var groupId: Int64?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class DescribeTotalStatisticsResponseBody : Tea.TeaModel {
    public var account: Int32?

    public var health: Int32?

    public var healthTotal: Int32?

    public var healthdealedTotal: Int32?

    public var healthhighTotal: Int32?

    public var healthlowTotal: Int32?

    public var healthmediumTotal: Int32?

    public var healthseriousTotal: Int32?

    public var newsuspicious: Int32?

    public var online: Bool?

    public var patch: Int32?

    public var requestId: String?

    public var suspicious: Int32?

    public var suspiciousTotal: Int32?

    public var suspiciousdealedTotal: Int32?

    public var suspicioushighTotal: Int32?

    public var suspiciouslowTotal: Int32?

    public var suspiciousmediumTotal: Int32?

    public var suspiciousseriousTotal: Int32?

    public var trojan: Int32?

    public var vul: Int32?

    public var vulAsapSum: Int32?

    public var vulDealedTotal: Int32?

    public var vulLaterSum: Int32?

    public var vulNntfSum: Int32?

    public var vulTotal: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.health != nil {
            map["Health"] = self.health!
        }
        if self.healthTotal != nil {
            map["HealthTotal"] = self.healthTotal!
        }
        if self.healthdealedTotal != nil {
            map["HealthdealedTotal"] = self.healthdealedTotal!
        }
        if self.healthhighTotal != nil {
            map["HealthhighTotal"] = self.healthhighTotal!
        }
        if self.healthlowTotal != nil {
            map["HealthlowTotal"] = self.healthlowTotal!
        }
        if self.healthmediumTotal != nil {
            map["HealthmediumTotal"] = self.healthmediumTotal!
        }
        if self.healthseriousTotal != nil {
            map["HealthseriousTotal"] = self.healthseriousTotal!
        }
        if self.newsuspicious != nil {
            map["Newsuspicious"] = self.newsuspicious!
        }
        if self.online != nil {
            map["Online"] = self.online!
        }
        if self.patch != nil {
            map["Patch"] = self.patch!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.suspicious != nil {
            map["Suspicious"] = self.suspicious!
        }
        if self.suspiciousTotal != nil {
            map["SuspiciousTotal"] = self.suspiciousTotal!
        }
        if self.suspiciousdealedTotal != nil {
            map["SuspiciousdealedTotal"] = self.suspiciousdealedTotal!
        }
        if self.suspicioushighTotal != nil {
            map["SuspicioushighTotal"] = self.suspicioushighTotal!
        }
        if self.suspiciouslowTotal != nil {
            map["SuspiciouslowTotal"] = self.suspiciouslowTotal!
        }
        if self.suspiciousmediumTotal != nil {
            map["SuspiciousmediumTotal"] = self.suspiciousmediumTotal!
        }
        if self.suspiciousseriousTotal != nil {
            map["SuspiciousseriousTotal"] = self.suspiciousseriousTotal!
        }
        if self.trojan != nil {
            map["Trojan"] = self.trojan!
        }
        if self.vul != nil {
            map["Vul"] = self.vul!
        }
        if self.vulAsapSum != nil {
            map["VulAsapSum"] = self.vulAsapSum!
        }
        if self.vulDealedTotal != nil {
            map["VulDealedTotal"] = self.vulDealedTotal!
        }
        if self.vulLaterSum != nil {
            map["VulLaterSum"] = self.vulLaterSum!
        }
        if self.vulNntfSum != nil {
            map["VulNntfSum"] = self.vulNntfSum!
        }
        if self.vulTotal != nil {
            map["VulTotal"] = self.vulTotal!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") && dict["Account"] != nil {
            self.account = dict["Account"] as! Int32
        }
        if dict.keys.contains("Health") && dict["Health"] != nil {
            self.health = dict["Health"] as! Int32
        }
        if dict.keys.contains("HealthTotal") && dict["HealthTotal"] != nil {
            self.healthTotal = dict["HealthTotal"] as! Int32
        }
        if dict.keys.contains("HealthdealedTotal") && dict["HealthdealedTotal"] != nil {
            self.healthdealedTotal = dict["HealthdealedTotal"] as! Int32
        }
        if dict.keys.contains("HealthhighTotal") && dict["HealthhighTotal"] != nil {
            self.healthhighTotal = dict["HealthhighTotal"] as! Int32
        }
        if dict.keys.contains("HealthlowTotal") && dict["HealthlowTotal"] != nil {
            self.healthlowTotal = dict["HealthlowTotal"] as! Int32
        }
        if dict.keys.contains("HealthmediumTotal") && dict["HealthmediumTotal"] != nil {
            self.healthmediumTotal = dict["HealthmediumTotal"] as! Int32
        }
        if dict.keys.contains("HealthseriousTotal") && dict["HealthseriousTotal"] != nil {
            self.healthseriousTotal = dict["HealthseriousTotal"] as! Int32
        }
        if dict.keys.contains("Newsuspicious") && dict["Newsuspicious"] != nil {
            self.newsuspicious = dict["Newsuspicious"] as! Int32
        }
        if dict.keys.contains("Online") && dict["Online"] != nil {
            self.online = dict["Online"] as! Bool
        }
        if dict.keys.contains("Patch") && dict["Patch"] != nil {
            self.patch = dict["Patch"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Suspicious") && dict["Suspicious"] != nil {
            self.suspicious = dict["Suspicious"] as! Int32
        }
        if dict.keys.contains("SuspiciousTotal") && dict["SuspiciousTotal"] != nil {
            self.suspiciousTotal = dict["SuspiciousTotal"] as! Int32
        }
        if dict.keys.contains("SuspiciousdealedTotal") && dict["SuspiciousdealedTotal"] != nil {
            self.suspiciousdealedTotal = dict["SuspiciousdealedTotal"] as! Int32
        }
        if dict.keys.contains("SuspicioushighTotal") && dict["SuspicioushighTotal"] != nil {
            self.suspicioushighTotal = dict["SuspicioushighTotal"] as! Int32
        }
        if dict.keys.contains("SuspiciouslowTotal") && dict["SuspiciouslowTotal"] != nil {
            self.suspiciouslowTotal = dict["SuspiciouslowTotal"] as! Int32
        }
        if dict.keys.contains("SuspiciousmediumTotal") && dict["SuspiciousmediumTotal"] != nil {
            self.suspiciousmediumTotal = dict["SuspiciousmediumTotal"] as! Int32
        }
        if dict.keys.contains("SuspiciousseriousTotal") && dict["SuspiciousseriousTotal"] != nil {
            self.suspiciousseriousTotal = dict["SuspiciousseriousTotal"] as! Int32
        }
        if dict.keys.contains("Trojan") && dict["Trojan"] != nil {
            self.trojan = dict["Trojan"] as! Int32
        }
        if dict.keys.contains("Vul") && dict["Vul"] != nil {
            self.vul = dict["Vul"] as! Int32
        }
        if dict.keys.contains("VulAsapSum") && dict["VulAsapSum"] != nil {
            self.vulAsapSum = dict["VulAsapSum"] as! Int32
        }
        if dict.keys.contains("VulDealedTotal") && dict["VulDealedTotal"] != nil {
            self.vulDealedTotal = dict["VulDealedTotal"] as! Int32
        }
        if dict.keys.contains("VulLaterSum") && dict["VulLaterSum"] != nil {
            self.vulLaterSum = dict["VulLaterSum"] as! Int32
        }
        if dict.keys.contains("VulNntfSum") && dict["VulNntfSum"] != nil {
            self.vulNntfSum = dict["VulNntfSum"] as! Int32
        }
        if dict.keys.contains("VulTotal") && dict["VulTotal"] != nil {
            self.vulTotal = dict["VulTotal"] as! Int32
        }
    }
}

public class DescribeTotalStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTotalStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeTotalStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTraceInfoDetailRequest : Tea.TeaModel {
    public var from: String?

    public var incidentTime: Int64?

    public var lang: String?

    public var sourceIp: String?

    public var type: String?

    public var uuid: String?

    public var vertexId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.incidentTime != nil {
            map["IncidentTime"] = self.incidentTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.vertexId != nil {
            map["VertexId"] = self.vertexId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("IncidentTime") && dict["IncidentTime"] != nil {
            self.incidentTime = dict["IncidentTime"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("VertexId") && dict["VertexId"] != nil {
            self.vertexId = dict["VertexId"] as! String
        }
    }
}

public class DescribeTraceInfoDetailResponseBody : Tea.TeaModel {
    public class TraceInfoDetail : Tea.TeaModel {
        public class EdgeList : Tea.TeaModel {
            public var count: Int32?

            public var endId: String?

            public var startId: String?

            public var time: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.endId != nil {
                    map["EndId"] = self.endId!
                }
                if self.startId != nil {
                    map["StartId"] = self.startId!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") && dict["Count"] != nil {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("EndId") && dict["EndId"] != nil {
                    self.endId = dict["EndId"] as! String
                }
                if dict.keys.contains("StartId") && dict["StartId"] != nil {
                    self.startId = dict["StartId"] as! String
                }
                if dict.keys.contains("Time") && dict["Time"] != nil {
                    self.time = dict["Time"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class EntityTypeList : Tea.TeaModel {
            public var dbId: Int32?

            public var displayColor: String?

            public var displayIcon: String?

            public var displayTemplate: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var id: String?

            public var limit: Int32?

            public var name: String?

            public var namespace: String?

            public var offset: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbId != nil {
                    map["DbId"] = self.dbId!
                }
                if self.displayColor != nil {
                    map["DisplayColor"] = self.displayColor!
                }
                if self.displayIcon != nil {
                    map["DisplayIcon"] = self.displayIcon!
                }
                if self.displayTemplate != nil {
                    map["DisplayTemplate"] = self.displayTemplate!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.limit != nil {
                    map["Limit"] = self.limit!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.offset != nil {
                    map["Offset"] = self.offset!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbId") && dict["DbId"] != nil {
                    self.dbId = dict["DbId"] as! Int32
                }
                if dict.keys.contains("DisplayColor") && dict["DisplayColor"] != nil {
                    self.displayColor = dict["DisplayColor"] as! String
                }
                if dict.keys.contains("DisplayIcon") && dict["DisplayIcon"] != nil {
                    self.displayIcon = dict["DisplayIcon"] as! String
                }
                if dict.keys.contains("DisplayTemplate") && dict["DisplayTemplate"] != nil {
                    self.displayTemplate = dict["DisplayTemplate"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Limit") && dict["Limit"] != nil {
                    self.limit = dict["Limit"] as! Int32
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Offset") && dict["Offset"] != nil {
                    self.offset = dict["Offset"] as! Int32
                }
            }
        }
        public class RelationTypeList : Tea.TeaModel {
            public var directed: Int32?

            public var displayColor: String?

            public var name: String?

            public var relationTypeId: String?

            public var showType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.directed != nil {
                    map["Directed"] = self.directed!
                }
                if self.displayColor != nil {
                    map["DisplayColor"] = self.displayColor!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.relationTypeId != nil {
                    map["RelationTypeId"] = self.relationTypeId!
                }
                if self.showType != nil {
                    map["ShowType"] = self.showType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Directed") && dict["Directed"] != nil {
                    self.directed = dict["Directed"] as! Int32
                }
                if dict.keys.contains("DisplayColor") && dict["DisplayColor"] != nil {
                    self.displayColor = dict["DisplayColor"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RelationTypeId") && dict["RelationTypeId"] != nil {
                    self.relationTypeId = dict["RelationTypeId"] as! String
                }
                if dict.keys.contains("ShowType") && dict["ShowType"] != nil {
                    self.showType = dict["ShowType"] as! String
                }
            }
        }
        public class VertexList : Tea.TeaModel {
            public class NeighborList : Tea.TeaModel {
                public var count: Int32?

                public var hasMore: Bool?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.hasMore != nil {
                        map["HasMore"] = self.hasMore!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") && dict["Count"] != nil {
                        self.count = dict["Count"] as! Int32
                    }
                    if dict.keys.contains("HasMore") && dict["HasMore"] != nil {
                        self.hasMore = dict["HasMore"] as! Bool
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var count: Int32?

            public var id: String?

            public var name: String?

            public var neighborList: [DescribeTraceInfoDetailResponseBody.TraceInfoDetail.VertexList.NeighborList]?

            public var time: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.neighborList != nil {
                    var tmp : [Any] = []
                    for k in self.neighborList! {
                        tmp.append(k.toMap())
                    }
                    map["NeighborList"] = tmp
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") && dict["Count"] != nil {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NeighborList") && dict["NeighborList"] != nil {
                    var tmp : [DescribeTraceInfoDetailResponseBody.TraceInfoDetail.VertexList.NeighborList] = []
                    for v in dict["NeighborList"] as! [Any] {
                        var model = DescribeTraceInfoDetailResponseBody.TraceInfoDetail.VertexList.NeighborList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.neighborList = tmp
                }
                if dict.keys.contains("Time") && dict["Time"] != nil {
                    self.time = dict["Time"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var edgeList: [DescribeTraceInfoDetailResponseBody.TraceInfoDetail.EdgeList]?

        public var entityTypeList: [DescribeTraceInfoDetailResponseBody.TraceInfoDetail.EntityTypeList]?

        public var relationTypeList: [DescribeTraceInfoDetailResponseBody.TraceInfoDetail.RelationTypeList]?

        public var vertexList: [DescribeTraceInfoDetailResponseBody.TraceInfoDetail.VertexList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edgeList != nil {
                var tmp : [Any] = []
                for k in self.edgeList! {
                    tmp.append(k.toMap())
                }
                map["EdgeList"] = tmp
            }
            if self.entityTypeList != nil {
                var tmp : [Any] = []
                for k in self.entityTypeList! {
                    tmp.append(k.toMap())
                }
                map["EntityTypeList"] = tmp
            }
            if self.relationTypeList != nil {
                var tmp : [Any] = []
                for k in self.relationTypeList! {
                    tmp.append(k.toMap())
                }
                map["RelationTypeList"] = tmp
            }
            if self.vertexList != nil {
                var tmp : [Any] = []
                for k in self.vertexList! {
                    tmp.append(k.toMap())
                }
                map["VertexList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EdgeList") && dict["EdgeList"] != nil {
                var tmp : [DescribeTraceInfoDetailResponseBody.TraceInfoDetail.EdgeList] = []
                for v in dict["EdgeList"] as! [Any] {
                    var model = DescribeTraceInfoDetailResponseBody.TraceInfoDetail.EdgeList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.edgeList = tmp
            }
            if dict.keys.contains("EntityTypeList") && dict["EntityTypeList"] != nil {
                var tmp : [DescribeTraceInfoDetailResponseBody.TraceInfoDetail.EntityTypeList] = []
                for v in dict["EntityTypeList"] as! [Any] {
                    var model = DescribeTraceInfoDetailResponseBody.TraceInfoDetail.EntityTypeList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.entityTypeList = tmp
            }
            if dict.keys.contains("RelationTypeList") && dict["RelationTypeList"] != nil {
                var tmp : [DescribeTraceInfoDetailResponseBody.TraceInfoDetail.RelationTypeList] = []
                for v in dict["RelationTypeList"] as! [Any] {
                    var model = DescribeTraceInfoDetailResponseBody.TraceInfoDetail.RelationTypeList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.relationTypeList = tmp
            }
            if dict.keys.contains("VertexList") && dict["VertexList"] != nil {
                var tmp : [DescribeTraceInfoDetailResponseBody.TraceInfoDetail.VertexList] = []
                for v in dict["VertexList"] as! [Any] {
                    var model = DescribeTraceInfoDetailResponseBody.TraceInfoDetail.VertexList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vertexList = tmp
            }
        }
    }
    public var requestId: String?

    public var success: Bool?

    public var traceInfoDetail: DescribeTraceInfoDetailResponseBody.TraceInfoDetail?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.traceInfoDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceInfoDetail != nil {
            map["TraceInfoDetail"] = self.traceInfoDetail?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceInfoDetail") && dict["TraceInfoDetail"] != nil {
            var model = DescribeTraceInfoDetailResponseBody.TraceInfoDetail()
            model.fromMap(dict["TraceInfoDetail"] as! [String: Any])
            self.traceInfoDetail = model
        }
    }
}

public class DescribeTraceInfoDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTraceInfoDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeTraceInfoDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTraceInfoNodeRequest : Tea.TeaModel {
    public var eventName: String?

    public var from: String?

    public var incidentTime: Int64?

    public var lang: String?

    public var sourceIp: String?

    public var type: String?

    public var uuid: String?

    public var vertexId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventName != nil {
            map["EventName"] = self.eventName!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.incidentTime != nil {
            map["IncidentTime"] = self.incidentTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.vertexId != nil {
            map["VertexId"] = self.vertexId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventName") && dict["EventName"] != nil {
            self.eventName = dict["EventName"] as! String
        }
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("IncidentTime") && dict["IncidentTime"] != nil {
            self.incidentTime = dict["IncidentTime"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("VertexId") && dict["VertexId"] != nil {
            self.vertexId = dict["VertexId"] as! String
        }
    }
}

public class DescribeTraceInfoNodeResponseBody : Tea.TeaModel {
    public class Node : Tea.TeaModel {
        public class PropertyList : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var name: String?

        public var propertyList: [DescribeTraceInfoNodeResponseBody.Node.PropertyList]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.propertyList != nil {
                var tmp : [Any] = []
                for k in self.propertyList! {
                    tmp.append(k.toMap())
                }
                map["PropertyList"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PropertyList") && dict["PropertyList"] != nil {
                var tmp : [DescribeTraceInfoNodeResponseBody.Node.PropertyList] = []
                for v in dict["PropertyList"] as! [Any] {
                    var model = DescribeTraceInfoNodeResponseBody.Node.PropertyList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.propertyList = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var node: DescribeTraceInfoNodeResponseBody.Node?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.node?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.node != nil {
            map["Node"] = self.node?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Node") && dict["Node"] != nil {
            var model = DescribeTraceInfoNodeResponseBody.Node()
            model.fromMap(dict["Node"] as! [String: Any])
            self.node = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeTraceInfoNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTraceInfoNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeTraceInfoNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUniBackupDatabaseRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var databaseType: String?

    public var instanceName: String?

    public var pageSize: Int32?

    public var queryType: String?

    public var uniRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.databaseType != nil {
            map["DatabaseType"] = self.databaseType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryType != nil {
            map["QueryType"] = self.queryType!
        }
        if self.uniRegionId != nil {
            map["UniRegionId"] = self.uniRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("DatabaseType") && dict["DatabaseType"] != nil {
            self.databaseType = dict["DatabaseType"] as! String
        }
        if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QueryType") && dict["QueryType"] != nil {
            self.queryType = dict["QueryType"] as! String
        }
        if dict.keys.contains("UniRegionId") && dict["UniRegionId"] != nil {
            self.uniRegionId = dict["UniRegionId"] as! String
        }
    }
}

public class DescribeUniBackupDatabaseResponseBody : Tea.TeaModel {
    public class DatabaseList : Tea.TeaModel {
        public var agentStatus: String?

        public var createdByProduct: String?

        public var databaseName: String?

        public var databaseType: String?

        public var databaseVersion: String?

        public var instanceId: String?

        public var instanceName: String?

        public var instanceUuid: String?

        public var policyId: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentStatus != nil {
                map["AgentStatus"] = self.agentStatus!
            }
            if self.createdByProduct != nil {
                map["CreatedByProduct"] = self.createdByProduct!
            }
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.databaseVersion != nil {
                map["DatabaseVersion"] = self.databaseVersion!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instanceUuid != nil {
                map["InstanceUuid"] = self.instanceUuid!
            }
            if self.policyId != nil {
                map["PolicyId"] = self.policyId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentStatus") && dict["AgentStatus"] != nil {
                self.agentStatus = dict["AgentStatus"] as! String
            }
            if dict.keys.contains("CreatedByProduct") && dict["CreatedByProduct"] != nil {
                self.createdByProduct = dict["CreatedByProduct"] as! String
            }
            if dict.keys.contains("DatabaseName") && dict["DatabaseName"] != nil {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("DatabaseType") && dict["DatabaseType"] != nil {
                self.databaseType = dict["DatabaseType"] as! String
            }
            if dict.keys.contains("DatabaseVersion") && dict["DatabaseVersion"] != nil {
                self.databaseVersion = dict["DatabaseVersion"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InstanceUuid") && dict["InstanceUuid"] != nil {
                self.instanceUuid = dict["InstanceUuid"] as! String
            }
            if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
                self.policyId = dict["PolicyId"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var databaseList: [DescribeUniBackupDatabaseResponseBody.DatabaseList]?

    public var pageInfo: DescribeUniBackupDatabaseResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseList != nil {
            var tmp : [Any] = []
            for k in self.databaseList! {
                tmp.append(k.toMap())
            }
            map["DatabaseList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseList") && dict["DatabaseList"] != nil {
            var tmp : [DescribeUniBackupDatabaseResponseBody.DatabaseList] = []
            for v in dict["DatabaseList"] as! [Any] {
                var model = DescribeUniBackupDatabaseResponseBody.DatabaseList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.databaseList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeUniBackupDatabaseResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUniBackupDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUniBackupDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUniBackupDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUniBackupPoliciesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var policyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.policyName != nil {
            map["PolicyName"] = self.policyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PolicyName") && dict["PolicyName"] != nil {
            self.policyName = dict["PolicyName"] as! String
        }
    }
}

public class DescribeUniBackupPoliciesResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class UniBackupPolicies : Tea.TeaModel {
        public var agentErrorMessage: String?

        public var agentStatus: String?

        public var databaseName: String?

        public var databaseType: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var instanceId: String?

        public var instanceName: String?

        public var instanceStatus: String?

        public var instanceUuid: String?

        public var latestBackResult: String?

        public var latestBackupTime: String?

        public var planStatus: String?

        public var policyId: Int64?

        public var policyName: String?

        public var policyStatus: String?

        public var uniRegionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentErrorMessage != nil {
                map["AgentErrorMessage"] = self.agentErrorMessage!
            }
            if self.agentStatus != nil {
                map["AgentStatus"] = self.agentStatus!
            }
            if self.databaseName != nil {
                map["DatabaseName"] = self.databaseName!
            }
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instanceStatus != nil {
                map["InstanceStatus"] = self.instanceStatus!
            }
            if self.instanceUuid != nil {
                map["InstanceUuid"] = self.instanceUuid!
            }
            if self.latestBackResult != nil {
                map["LatestBackResult"] = self.latestBackResult!
            }
            if self.latestBackupTime != nil {
                map["LatestBackupTime"] = self.latestBackupTime!
            }
            if self.planStatus != nil {
                map["PlanStatus"] = self.planStatus!
            }
            if self.policyId != nil {
                map["PolicyId"] = self.policyId!
            }
            if self.policyName != nil {
                map["PolicyName"] = self.policyName!
            }
            if self.policyStatus != nil {
                map["PolicyStatus"] = self.policyStatus!
            }
            if self.uniRegionId != nil {
                map["UniRegionId"] = self.uniRegionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentErrorMessage") && dict["AgentErrorMessage"] != nil {
                self.agentErrorMessage = dict["AgentErrorMessage"] as! String
            }
            if dict.keys.contains("AgentStatus") && dict["AgentStatus"] != nil {
                self.agentStatus = dict["AgentStatus"] as! String
            }
            if dict.keys.contains("DatabaseName") && dict["DatabaseName"] != nil {
                self.databaseName = dict["DatabaseName"] as! String
            }
            if dict.keys.contains("DatabaseType") && dict["DatabaseType"] != nil {
                self.databaseType = dict["DatabaseType"] as! String
            }
            if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") && dict["ErrorMessage"] != nil {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InstanceStatus") && dict["InstanceStatus"] != nil {
                self.instanceStatus = dict["InstanceStatus"] as! String
            }
            if dict.keys.contains("InstanceUuid") && dict["InstanceUuid"] != nil {
                self.instanceUuid = dict["InstanceUuid"] as! String
            }
            if dict.keys.contains("LatestBackResult") && dict["LatestBackResult"] != nil {
                self.latestBackResult = dict["LatestBackResult"] as! String
            }
            if dict.keys.contains("LatestBackupTime") && dict["LatestBackupTime"] != nil {
                self.latestBackupTime = dict["LatestBackupTime"] as! String
            }
            if dict.keys.contains("PlanStatus") && dict["PlanStatus"] != nil {
                self.planStatus = dict["PlanStatus"] as! String
            }
            if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
                self.policyId = dict["PolicyId"] as! Int64
            }
            if dict.keys.contains("PolicyName") && dict["PolicyName"] != nil {
                self.policyName = dict["PolicyName"] as! String
            }
            if dict.keys.contains("PolicyStatus") && dict["PolicyStatus"] != nil {
                self.policyStatus = dict["PolicyStatus"] as! String
            }
            if dict.keys.contains("UniRegionId") && dict["UniRegionId"] != nil {
                self.uniRegionId = dict["UniRegionId"] as! String
            }
        }
    }
    public var pageInfo: DescribeUniBackupPoliciesResponseBody.PageInfo?

    public var requestId: String?

    public var uniBackupPolicies: [DescribeUniBackupPoliciesResponseBody.UniBackupPolicies]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uniBackupPolicies != nil {
            var tmp : [Any] = []
            for k in self.uniBackupPolicies! {
                tmp.append(k.toMap())
            }
            map["UniBackupPolicies"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeUniBackupPoliciesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UniBackupPolicies") && dict["UniBackupPolicies"] != nil {
            var tmp : [DescribeUniBackupPoliciesResponseBody.UniBackupPolicies] = []
            for v in dict["UniBackupPolicies"] as! [Any] {
                var model = DescribeUniBackupPoliciesResponseBody.UniBackupPolicies()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.uniBackupPolicies = tmp
        }
    }
}

public class DescribeUniBackupPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUniBackupPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUniBackupPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUniBackupPolicyDetailRequest : Tea.TeaModel {
    public var policyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! String
        }
    }
}

public class DescribeUniBackupPolicyDetailResponseBody : Tea.TeaModel {
    public class UniBackupPolicyDTO : Tea.TeaModel {
        public class FullPlan : Tea.TeaModel {
            public var days: [String]?

            public var interval: Int32?

            public var planType: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.days != nil {
                    map["Days"] = self.days!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.planType != nil {
                    map["PlanType"] = self.planType!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Days") && dict["Days"] != nil {
                    self.days = dict["Days"] as! [String]
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("PlanType") && dict["PlanType"] != nil {
                    self.planType = dict["PlanType"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public class IncPlan : Tea.TeaModel {
            public var days: [String]?

            public var interval: Int32?

            public var planType: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.days != nil {
                    map["Days"] = self.days!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.planType != nil {
                    map["PlanType"] = self.planType!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Days") && dict["Days"] != nil {
                    self.days = dict["Days"] as! [String]
                }
                if dict.keys.contains("Interval") && dict["Interval"] != nil {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("PlanType") && dict["PlanType"] != nil {
                    self.planType = dict["PlanType"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var accountName: String?

        public var agentStatus: String?

        public var databaseType: String?

        public var fullPlan: DescribeUniBackupPolicyDetailResponseBody.UniBackupPolicyDTO.FullPlan?

        public var incPlan: DescribeUniBackupPolicyDetailResponseBody.UniBackupPolicyDTO.IncPlan?

        public var instanceId: String?

        public var instanceName: String?

        public var policyId: Int64?

        public var policyName: String?

        public var policyStatus: String?

        public var retention: Int32?

        public var speedLimiter: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.fullPlan?.validate()
            try self.incPlan?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountName != nil {
                map["AccountName"] = self.accountName!
            }
            if self.agentStatus != nil {
                map["AgentStatus"] = self.agentStatus!
            }
            if self.databaseType != nil {
                map["DatabaseType"] = self.databaseType!
            }
            if self.fullPlan != nil {
                map["FullPlan"] = self.fullPlan?.toMap()
            }
            if self.incPlan != nil {
                map["IncPlan"] = self.incPlan?.toMap()
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.policyId != nil {
                map["PolicyId"] = self.policyId!
            }
            if self.policyName != nil {
                map["PolicyName"] = self.policyName!
            }
            if self.policyStatus != nil {
                map["PolicyStatus"] = self.policyStatus!
            }
            if self.retention != nil {
                map["Retention"] = self.retention!
            }
            if self.speedLimiter != nil {
                map["SpeedLimiter"] = self.speedLimiter!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountName") && dict["AccountName"] != nil {
                self.accountName = dict["AccountName"] as! String
            }
            if dict.keys.contains("AgentStatus") && dict["AgentStatus"] != nil {
                self.agentStatus = dict["AgentStatus"] as! String
            }
            if dict.keys.contains("DatabaseType") && dict["DatabaseType"] != nil {
                self.databaseType = dict["DatabaseType"] as! String
            }
            if dict.keys.contains("FullPlan") && dict["FullPlan"] != nil {
                var model = DescribeUniBackupPolicyDetailResponseBody.UniBackupPolicyDTO.FullPlan()
                model.fromMap(dict["FullPlan"] as! [String: Any])
                self.fullPlan = model
            }
            if dict.keys.contains("IncPlan") && dict["IncPlan"] != nil {
                var model = DescribeUniBackupPolicyDetailResponseBody.UniBackupPolicyDTO.IncPlan()
                model.fromMap(dict["IncPlan"] as! [String: Any])
                self.incPlan = model
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
                self.policyId = dict["PolicyId"] as! Int64
            }
            if dict.keys.contains("PolicyName") && dict["PolicyName"] != nil {
                self.policyName = dict["PolicyName"] as! String
            }
            if dict.keys.contains("PolicyStatus") && dict["PolicyStatus"] != nil {
                self.policyStatus = dict["PolicyStatus"] as! String
            }
            if dict.keys.contains("Retention") && dict["Retention"] != nil {
                self.retention = dict["Retention"] as! Int32
            }
            if dict.keys.contains("SpeedLimiter") && dict["SpeedLimiter"] != nil {
                self.speedLimiter = dict["SpeedLimiter"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var uniBackupPolicyDTO: DescribeUniBackupPolicyDetailResponseBody.UniBackupPolicyDTO?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.uniBackupPolicyDTO?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uniBackupPolicyDTO != nil {
            map["UniBackupPolicyDTO"] = self.uniBackupPolicyDTO?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UniBackupPolicyDTO") && dict["UniBackupPolicyDTO"] != nil {
            var model = DescribeUniBackupPolicyDetailResponseBody.UniBackupPolicyDTO()
            model.fromMap(dict["UniBackupPolicyDTO"] as! [String: Any])
            self.uniBackupPolicyDTO = model
        }
    }
}

public class DescribeUniBackupPolicyDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUniBackupPolicyDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUniBackupPolicyDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUniRecoverableListRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var database: String?

    public var pageSize: Int32?

    public var policyId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.database != nil {
            map["Database"] = self.database!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Database") && dict["Database"] != nil {
            self.database = dict["Database"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! Int64
        }
    }
}

public class DescribeUniRecoverableListResponseBody : Tea.TeaModel {
    public class RecoverableInfoList : Tea.TeaModel {
        public var firstTime: Int64?

        public var lastTime: Int64?

        public var resetScn: String?

        public var resetTime: Int64?

        public var restoreInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.firstTime != nil {
                map["FirstTime"] = self.firstTime!
            }
            if self.lastTime != nil {
                map["LastTime"] = self.lastTime!
            }
            if self.resetScn != nil {
                map["ResetScn"] = self.resetScn!
            }
            if self.resetTime != nil {
                map["ResetTime"] = self.resetTime!
            }
            if self.restoreInfo != nil {
                map["RestoreInfo"] = self.restoreInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FirstTime") && dict["FirstTime"] != nil {
                self.firstTime = dict["FirstTime"] as! Int64
            }
            if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
                self.lastTime = dict["LastTime"] as! Int64
            }
            if dict.keys.contains("ResetScn") && dict["ResetScn"] != nil {
                self.resetScn = dict["ResetScn"] as! String
            }
            if dict.keys.contains("ResetTime") && dict["ResetTime"] != nil {
                self.resetTime = dict["ResetTime"] as! Int64
            }
            if dict.keys.contains("RestoreInfo") && dict["RestoreInfo"] != nil {
                self.restoreInfo = dict["RestoreInfo"] as! String
            }
        }
    }
    public var count: Int32?

    public var currentPage: Int32?

    public var database: String?

    public var pageSize: Int32?

    public var recoverableInfoList: [DescribeUniRecoverableListResponseBody.RecoverableInfoList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.database != nil {
            map["Database"] = self.database!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recoverableInfoList != nil {
            var tmp : [Any] = []
            for k in self.recoverableInfoList! {
                tmp.append(k.toMap())
            }
            map["RecoverableInfoList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Database") && dict["Database"] != nil {
            self.database = dict["Database"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecoverableInfoList") && dict["RecoverableInfoList"] != nil {
            var tmp : [DescribeUniRecoverableListResponseBody.RecoverableInfoList] = []
            for v in dict["RecoverableInfoList"] as! [Any] {
                var model = DescribeUniRecoverableListResponseBody.RecoverableInfoList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recoverableInfoList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeUniRecoverableListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUniRecoverableListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUniRecoverableListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUniSupportRegionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var uniSupportRegion: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.uniSupportRegion != nil {
            map["UniSupportRegion"] = self.uniSupportRegion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UniSupportRegion") && dict["UniSupportRegion"] != nil {
            self.uniSupportRegion = dict["UniSupportRegion"] as! [String]
        }
    }
}

public class DescribeUniSupportRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUniSupportRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUniSupportRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserBackupMachinesResponseBody : Tea.TeaModel {
    public class Machines : Tea.TeaModel {
        public var id: Int64?

        public var policyName: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.policyName != nil {
                map["PolicyName"] = self.policyName!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("PolicyName") && dict["PolicyName"] != nil {
                self.policyName = dict["PolicyName"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var machines: [DescribeUserBackupMachinesResponseBody.Machines]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.machines != nil {
            var tmp : [Any] = []
            for k in self.machines! {
                tmp.append(k.toMap())
            }
            map["Machines"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Machines") && dict["Machines"] != nil {
            var tmp : [DescribeUserBackupMachinesResponseBody.Machines] = []
            for v in dict["Machines"] as! [Any] {
                var model = DescribeUserBackupMachinesResponseBody.Machines()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.machines = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUserBackupMachinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserBackupMachinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUserBackupMachinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserBaselineAuthorizationRequest : Tea.TeaModel {
    public var lang: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeUserBaselineAuthorizationResponseBody : Tea.TeaModel {
    public class UserBaselineAuthorization : Tea.TeaModel {
        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var userBaselineAuthorization: DescribeUserBaselineAuthorizationResponseBody.UserBaselineAuthorization?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userBaselineAuthorization?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userBaselineAuthorization != nil {
            map["UserBaselineAuthorization"] = self.userBaselineAuthorization?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserBaselineAuthorization") && dict["UserBaselineAuthorization"] != nil {
            var model = DescribeUserBaselineAuthorizationResponseBody.UserBaselineAuthorization()
            model.fromMap(dict["UserBaselineAuthorization"] as! [String: Any])
            self.userBaselineAuthorization = model
        }
    }
}

public class DescribeUserBaselineAuthorizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserBaselineAuthorizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUserBaselineAuthorizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserLayoutAuthorizationRequest : Tea.TeaModel {
    public var lang: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeUserLayoutAuthorizationResponseBody : Tea.TeaModel {
    public var authorized: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorized != nil {
            map["Authorized"] = self.authorized!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Authorized") && dict["Authorized"] != nil {
            self.authorized = dict["Authorized"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUserLayoutAuthorizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserLayoutAuthorizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUserLayoutAuthorizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUuidsByVulNamesRequest : Tea.TeaModel {
    public var dealed: String?

    public var fieldName: String?

    public var fieldValue: String?

    public var groupId: Int64?

    public var lang: String?

    public var level: String?

    public var necessity: String?

    public var remark: String?

    public var searchTags: String?

    public var statusList: String?

    public var tag: String?

    public var targetType: String?

    public var type: String?

    public var vpcInstanceIds: String?

    public var vulNames: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.fieldName != nil {
            map["FieldName"] = self.fieldName!
        }
        if self.fieldValue != nil {
            map["FieldValue"] = self.fieldValue!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.necessity != nil {
            map["Necessity"] = self.necessity!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.searchTags != nil {
            map["SearchTags"] = self.searchTags!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.vpcInstanceIds != nil {
            map["VpcInstanceIds"] = self.vpcInstanceIds!
        }
        if self.vulNames != nil {
            map["VulNames"] = self.vulNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("FieldName") && dict["FieldName"] != nil {
            self.fieldName = dict["FieldName"] as! String
        }
        if dict.keys.contains("FieldValue") && dict["FieldValue"] != nil {
            self.fieldValue = dict["FieldValue"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Level") && dict["Level"] != nil {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
            self.necessity = dict["Necessity"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SearchTags") && dict["SearchTags"] != nil {
            self.searchTags = dict["SearchTags"] as! String
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VpcInstanceIds") && dict["VpcInstanceIds"] != nil {
            self.vpcInstanceIds = dict["VpcInstanceIds"] as! String
        }
        if dict.keys.contains("VulNames") && dict["VulNames"] != nil {
            self.vulNames = dict["VulNames"] as! [String]
        }
    }
}

public class DescribeUuidsByVulNamesResponseBody : Tea.TeaModel {
    public class MachineInfoStatistics : Tea.TeaModel {
        public var machineInstanceId: String?

        public var machineIp: String?

        public var machineName: String?

        public var os: String?

        public var regionId: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.machineInstanceId != nil {
                map["MachineInstanceId"] = self.machineInstanceId!
            }
            if self.machineIp != nil {
                map["MachineIp"] = self.machineIp!
            }
            if self.machineName != nil {
                map["MachineName"] = self.machineName!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MachineInstanceId") && dict["MachineInstanceId"] != nil {
                self.machineInstanceId = dict["MachineInstanceId"] as! String
            }
            if dict.keys.contains("MachineIp") && dict["MachineIp"] != nil {
                self.machineIp = dict["MachineIp"] as! String
            }
            if dict.keys.contains("MachineName") && dict["MachineName"] != nil {
                self.machineName = dict["MachineName"] as! String
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var machineInfoStatistics: [DescribeUuidsByVulNamesResponseBody.MachineInfoStatistics]?

    public var requestId: String?

    public var vulCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.machineInfoStatistics != nil {
            var tmp : [Any] = []
            for k in self.machineInfoStatistics! {
                tmp.append(k.toMap())
            }
            map["MachineInfoStatistics"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vulCount != nil {
            map["VulCount"] = self.vulCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MachineInfoStatistics") && dict["MachineInfoStatistics"] != nil {
            var tmp : [DescribeUuidsByVulNamesResponseBody.MachineInfoStatistics] = []
            for v in dict["MachineInfoStatistics"] as! [Any] {
                var model = DescribeUuidsByVulNamesResponseBody.MachineInfoStatistics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.machineInfoStatistics = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VulCount") && dict["VulCount"] != nil {
            self.vulCount = dict["VulCount"] as! Int32
        }
    }
}

public class DescribeUuidsByVulNamesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUuidsByVulNamesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeUuidsByVulNamesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVendorListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vendorNameList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vendorNameList != nil {
            map["VendorNameList"] = self.vendorNameList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VendorNameList") && dict["VendorNameList"] != nil {
            self.vendorNameList = dict["VendorNameList"] as! [String]
        }
    }
}

public class DescribeVendorListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVendorListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVendorListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVersionConfigRequest : Tea.TeaModel {
    public var resourceDirectoryAccountId: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeVersionConfigResponseBody : Tea.TeaModel {
    public var agentlessCapacity: Int64?

    public var allowPartialBuy: Int32?

    public var appWhiteList: Int32?

    public var appWhiteListAuthCount: Int64?

    public var assetLevel: Int32?

    public var cspmCapacity: Int64?

    public var highestVersion: Int32?

    public var honeypotCapacity: Int64?

    public var imageScanCapacity: Int64?

    public var instanceId: String?

    public var isNewContainerVersion: Bool?

    public var isNewMultiVersion: Bool?

    public var isOverBalance: Bool?

    public var isTrialVersion: Int32?

    public var lastTrailEndTime: Int64?

    public var MVAuthCount: Int32?

    public var MVUnusedAuthCount: Int32?

    public var openTime: Int64?

    public var raspCapacity: Int64?

    public var releaseTime: Int64?

    public var requestId: String?

    public var sasLog: Int32?

    public var sasScreen: Int32?

    public var slsCapacity: Int64?

    public var threatAnalysisCapacity: Int64?

    public var userDefinedAlarms: Int32?

    public var version: Int32?

    public var vmCores: Int32?

    public var vulFixCapacity: Int64?

    public var webLock: Int32?

    public var webLockAuthCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentlessCapacity != nil {
            map["AgentlessCapacity"] = self.agentlessCapacity!
        }
        if self.allowPartialBuy != nil {
            map["AllowPartialBuy"] = self.allowPartialBuy!
        }
        if self.appWhiteList != nil {
            map["AppWhiteList"] = self.appWhiteList!
        }
        if self.appWhiteListAuthCount != nil {
            map["AppWhiteListAuthCount"] = self.appWhiteListAuthCount!
        }
        if self.assetLevel != nil {
            map["AssetLevel"] = self.assetLevel!
        }
        if self.cspmCapacity != nil {
            map["CspmCapacity"] = self.cspmCapacity!
        }
        if self.highestVersion != nil {
            map["HighestVersion"] = self.highestVersion!
        }
        if self.honeypotCapacity != nil {
            map["HoneypotCapacity"] = self.honeypotCapacity!
        }
        if self.imageScanCapacity != nil {
            map["ImageScanCapacity"] = self.imageScanCapacity!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isNewContainerVersion != nil {
            map["IsNewContainerVersion"] = self.isNewContainerVersion!
        }
        if self.isNewMultiVersion != nil {
            map["IsNewMultiVersion"] = self.isNewMultiVersion!
        }
        if self.isOverBalance != nil {
            map["IsOverBalance"] = self.isOverBalance!
        }
        if self.isTrialVersion != nil {
            map["IsTrialVersion"] = self.isTrialVersion!
        }
        if self.lastTrailEndTime != nil {
            map["LastTrailEndTime"] = self.lastTrailEndTime!
        }
        if self.MVAuthCount != nil {
            map["MVAuthCount"] = self.MVAuthCount!
        }
        if self.MVUnusedAuthCount != nil {
            map["MVUnusedAuthCount"] = self.MVUnusedAuthCount!
        }
        if self.openTime != nil {
            map["OpenTime"] = self.openTime!
        }
        if self.raspCapacity != nil {
            map["RaspCapacity"] = self.raspCapacity!
        }
        if self.releaseTime != nil {
            map["ReleaseTime"] = self.releaseTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sasLog != nil {
            map["SasLog"] = self.sasLog!
        }
        if self.sasScreen != nil {
            map["SasScreen"] = self.sasScreen!
        }
        if self.slsCapacity != nil {
            map["SlsCapacity"] = self.slsCapacity!
        }
        if self.threatAnalysisCapacity != nil {
            map["ThreatAnalysisCapacity"] = self.threatAnalysisCapacity!
        }
        if self.userDefinedAlarms != nil {
            map["UserDefinedAlarms"] = self.userDefinedAlarms!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        if self.vmCores != nil {
            map["VmCores"] = self.vmCores!
        }
        if self.vulFixCapacity != nil {
            map["VulFixCapacity"] = self.vulFixCapacity!
        }
        if self.webLock != nil {
            map["WebLock"] = self.webLock!
        }
        if self.webLockAuthCount != nil {
            map["WebLockAuthCount"] = self.webLockAuthCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentlessCapacity") && dict["AgentlessCapacity"] != nil {
            self.agentlessCapacity = dict["AgentlessCapacity"] as! Int64
        }
        if dict.keys.contains("AllowPartialBuy") && dict["AllowPartialBuy"] != nil {
            self.allowPartialBuy = dict["AllowPartialBuy"] as! Int32
        }
        if dict.keys.contains("AppWhiteList") && dict["AppWhiteList"] != nil {
            self.appWhiteList = dict["AppWhiteList"] as! Int32
        }
        if dict.keys.contains("AppWhiteListAuthCount") && dict["AppWhiteListAuthCount"] != nil {
            self.appWhiteListAuthCount = dict["AppWhiteListAuthCount"] as! Int64
        }
        if dict.keys.contains("AssetLevel") && dict["AssetLevel"] != nil {
            self.assetLevel = dict["AssetLevel"] as! Int32
        }
        if dict.keys.contains("CspmCapacity") && dict["CspmCapacity"] != nil {
            self.cspmCapacity = dict["CspmCapacity"] as! Int64
        }
        if dict.keys.contains("HighestVersion") && dict["HighestVersion"] != nil {
            self.highestVersion = dict["HighestVersion"] as! Int32
        }
        if dict.keys.contains("HoneypotCapacity") && dict["HoneypotCapacity"] != nil {
            self.honeypotCapacity = dict["HoneypotCapacity"] as! Int64
        }
        if dict.keys.contains("ImageScanCapacity") && dict["ImageScanCapacity"] != nil {
            self.imageScanCapacity = dict["ImageScanCapacity"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsNewContainerVersion") && dict["IsNewContainerVersion"] != nil {
            self.isNewContainerVersion = dict["IsNewContainerVersion"] as! Bool
        }
        if dict.keys.contains("IsNewMultiVersion") && dict["IsNewMultiVersion"] != nil {
            self.isNewMultiVersion = dict["IsNewMultiVersion"] as! Bool
        }
        if dict.keys.contains("IsOverBalance") && dict["IsOverBalance"] != nil {
            self.isOverBalance = dict["IsOverBalance"] as! Bool
        }
        if dict.keys.contains("IsTrialVersion") && dict["IsTrialVersion"] != nil {
            self.isTrialVersion = dict["IsTrialVersion"] as! Int32
        }
        if dict.keys.contains("LastTrailEndTime") && dict["LastTrailEndTime"] != nil {
            self.lastTrailEndTime = dict["LastTrailEndTime"] as! Int64
        }
        if dict.keys.contains("MVAuthCount") && dict["MVAuthCount"] != nil {
            self.MVAuthCount = dict["MVAuthCount"] as! Int32
        }
        if dict.keys.contains("MVUnusedAuthCount") && dict["MVUnusedAuthCount"] != nil {
            self.MVUnusedAuthCount = dict["MVUnusedAuthCount"] as! Int32
        }
        if dict.keys.contains("OpenTime") && dict["OpenTime"] != nil {
            self.openTime = dict["OpenTime"] as! Int64
        }
        if dict.keys.contains("RaspCapacity") && dict["RaspCapacity"] != nil {
            self.raspCapacity = dict["RaspCapacity"] as! Int64
        }
        if dict.keys.contains("ReleaseTime") && dict["ReleaseTime"] != nil {
            self.releaseTime = dict["ReleaseTime"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SasLog") && dict["SasLog"] != nil {
            self.sasLog = dict["SasLog"] as! Int32
        }
        if dict.keys.contains("SasScreen") && dict["SasScreen"] != nil {
            self.sasScreen = dict["SasScreen"] as! Int32
        }
        if dict.keys.contains("SlsCapacity") && dict["SlsCapacity"] != nil {
            self.slsCapacity = dict["SlsCapacity"] as! Int64
        }
        if dict.keys.contains("ThreatAnalysisCapacity") && dict["ThreatAnalysisCapacity"] != nil {
            self.threatAnalysisCapacity = dict["ThreatAnalysisCapacity"] as! Int64
        }
        if dict.keys.contains("UserDefinedAlarms") && dict["UserDefinedAlarms"] != nil {
            self.userDefinedAlarms = dict["UserDefinedAlarms"] as! Int32
        }
        if dict.keys.contains("Version") && dict["Version"] != nil {
            self.version = dict["Version"] as! Int32
        }
        if dict.keys.contains("VmCores") && dict["VmCores"] != nil {
            self.vmCores = dict["VmCores"] as! Int32
        }
        if dict.keys.contains("VulFixCapacity") && dict["VulFixCapacity"] != nil {
            self.vulFixCapacity = dict["VulFixCapacity"] as! Int64
        }
        if dict.keys.contains("WebLock") && dict["WebLock"] != nil {
            self.webLock = dict["WebLock"] as! Int32
        }
        if dict.keys.contains("WebLockAuthCount") && dict["WebLockAuthCount"] != nil {
            self.webLockAuthCount = dict["WebLockAuthCount"] as! Int64
        }
    }
}

public class DescribeVersionConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVersionConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVersionConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpcHoneyPotCriteriaRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class DescribeVpcHoneyPotCriteriaResponseBody : Tea.TeaModel {
    public class CriteriaList : Tea.TeaModel {
        public var name: String?

        public var type: String?

        public var values: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Values") && dict["Values"] != nil {
                self.values = dict["Values"] as! String
            }
        }
    }
    public var criteriaList: [DescribeVpcHoneyPotCriteriaResponseBody.CriteriaList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteriaList != nil {
            var tmp : [Any] = []
            for k in self.criteriaList! {
                tmp.append(k.toMap())
            }
            map["CriteriaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CriteriaList") && dict["CriteriaList"] != nil {
            var tmp : [DescribeVpcHoneyPotCriteriaResponseBody.CriteriaList] = []
            for v in dict["CriteriaList"] as! [Any] {
                var model = DescribeVpcHoneyPotCriteriaResponseBody.CriteriaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.criteriaList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVpcHoneyPotCriteriaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcHoneyPotCriteriaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVpcHoneyPotCriteriaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpcHoneyPotListRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var honeyPotExistence: Bool?

    public var pageSize: Int32?

    public var vpcId: String?

    public var vpcName: String?

    public var vpcRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.honeyPotExistence != nil {
            map["HoneyPotExistence"] = self.honeyPotExistence!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        if self.vpcRegionId != nil {
            map["VpcRegionId"] = self.vpcRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("HoneyPotExistence") && dict["HoneyPotExistence"] != nil {
            self.honeyPotExistence = dict["HoneyPotExistence"] as! Bool
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpcName") && dict["VpcName"] != nil {
            self.vpcName = dict["VpcName"] as! String
        }
        if dict.keys.contains("VpcRegionId") && dict["VpcRegionId"] != nil {
            self.vpcRegionId = dict["VpcRegionId"] as! String
        }
    }
}

public class DescribeVpcHoneyPotListResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class VpcHoneyPotDTOList : Tea.TeaModel {
        public class VpcSwitchIdList : Tea.TeaModel {
            public var vpcSwitchId: String?

            public var vpcSwitchName: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.vpcSwitchId != nil {
                    map["VpcSwitchId"] = self.vpcSwitchId!
                }
                if self.vpcSwitchName != nil {
                    map["VpcSwitchName"] = self.vpcSwitchName!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("VpcSwitchId") && dict["VpcSwitchId"] != nil {
                    self.vpcSwitchId = dict["VpcSwitchId"] as! String
                }
                if dict.keys.contains("VpcSwitchName") && dict["VpcSwitchName"] != nil {
                    self.vpcSwitchName = dict["VpcSwitchName"] as! String
                }
                if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var cidrBlock: String?

        public var createTime: Int64?

        public var honeyPotEcsInstanceStatus: String?

        public var honeyPotEniInstanceId: String?

        public var honeyPotExistence: Bool?

        public var honeyPotInstanceStatus: String?

        public var honeyPotVpcSwitchId: String?

        public var vpcId: String?

        public var vpcName: String?

        public var vpcRegionId: String?

        public var vpcStatus: String?

        public var vpcSwitchIdList: [DescribeVpcHoneyPotListResponseBody.VpcHoneyPotDTOList.VpcSwitchIdList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidrBlock != nil {
                map["CidrBlock"] = self.cidrBlock!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.honeyPotEcsInstanceStatus != nil {
                map["HoneyPotEcsInstanceStatus"] = self.honeyPotEcsInstanceStatus!
            }
            if self.honeyPotEniInstanceId != nil {
                map["HoneyPotEniInstanceId"] = self.honeyPotEniInstanceId!
            }
            if self.honeyPotExistence != nil {
                map["HoneyPotExistence"] = self.honeyPotExistence!
            }
            if self.honeyPotInstanceStatus != nil {
                map["HoneyPotInstanceStatus"] = self.honeyPotInstanceStatus!
            }
            if self.honeyPotVpcSwitchId != nil {
                map["HoneyPotVpcSwitchId"] = self.honeyPotVpcSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vpcName != nil {
                map["VpcName"] = self.vpcName!
            }
            if self.vpcRegionId != nil {
                map["VpcRegionId"] = self.vpcRegionId!
            }
            if self.vpcStatus != nil {
                map["VpcStatus"] = self.vpcStatus!
            }
            if self.vpcSwitchIdList != nil {
                var tmp : [Any] = []
                for k in self.vpcSwitchIdList! {
                    tmp.append(k.toMap())
                }
                map["VpcSwitchIdList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
                self.cidrBlock = dict["CidrBlock"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("HoneyPotEcsInstanceStatus") && dict["HoneyPotEcsInstanceStatus"] != nil {
                self.honeyPotEcsInstanceStatus = dict["HoneyPotEcsInstanceStatus"] as! String
            }
            if dict.keys.contains("HoneyPotEniInstanceId") && dict["HoneyPotEniInstanceId"] != nil {
                self.honeyPotEniInstanceId = dict["HoneyPotEniInstanceId"] as! String
            }
            if dict.keys.contains("HoneyPotExistence") && dict["HoneyPotExistence"] != nil {
                self.honeyPotExistence = dict["HoneyPotExistence"] as! Bool
            }
            if dict.keys.contains("HoneyPotInstanceStatus") && dict["HoneyPotInstanceStatus"] != nil {
                self.honeyPotInstanceStatus = dict["HoneyPotInstanceStatus"] as! String
            }
            if dict.keys.contains("HoneyPotVpcSwitchId") && dict["HoneyPotVpcSwitchId"] != nil {
                self.honeyPotVpcSwitchId = dict["HoneyPotVpcSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("VpcName") && dict["VpcName"] != nil {
                self.vpcName = dict["VpcName"] as! String
            }
            if dict.keys.contains("VpcRegionId") && dict["VpcRegionId"] != nil {
                self.vpcRegionId = dict["VpcRegionId"] as! String
            }
            if dict.keys.contains("VpcStatus") && dict["VpcStatus"] != nil {
                self.vpcStatus = dict["VpcStatus"] as! String
            }
            if dict.keys.contains("VpcSwitchIdList") && dict["VpcSwitchIdList"] != nil {
                var tmp : [DescribeVpcHoneyPotListResponseBody.VpcHoneyPotDTOList.VpcSwitchIdList] = []
                for v in dict["VpcSwitchIdList"] as! [Any] {
                    var model = DescribeVpcHoneyPotListResponseBody.VpcHoneyPotDTOList.VpcSwitchIdList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vpcSwitchIdList = tmp
            }
        }
    }
    public var pageInfo: DescribeVpcHoneyPotListResponseBody.PageInfo?

    public var requestId: String?

    public var vpcHoneyPotDTOList: [DescribeVpcHoneyPotListResponseBody.VpcHoneyPotDTOList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpcHoneyPotDTOList != nil {
            var tmp : [Any] = []
            for k in self.vpcHoneyPotDTOList! {
                tmp.append(k.toMap())
            }
            map["VpcHoneyPotDTOList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = DescribeVpcHoneyPotListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VpcHoneyPotDTOList") && dict["VpcHoneyPotDTOList"] != nil {
            var tmp : [DescribeVpcHoneyPotListResponseBody.VpcHoneyPotDTOList] = []
            for v in dict["VpcHoneyPotDTOList"] as! [Any] {
                var model = DescribeVpcHoneyPotListResponseBody.VpcHoneyPotDTOList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vpcHoneyPotDTOList = tmp
        }
    }
}

public class DescribeVpcHoneyPotListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcHoneyPotListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVpcHoneyPotListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpcListResponseBody : Tea.TeaModel {
    public class VpcList : Tea.TeaModel {
        public var ecsCount: Int32?

        public var instanceDesc: String?

        public var instanceId: String?

        public var instanceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecsCount != nil {
                map["EcsCount"] = self.ecsCount!
            }
            if self.instanceDesc != nil {
                map["InstanceDesc"] = self.instanceDesc!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EcsCount") && dict["EcsCount"] != nil {
                self.ecsCount = dict["EcsCount"] as! Int32
            }
            if dict.keys.contains("InstanceDesc") && dict["InstanceDesc"] != nil {
                self.instanceDesc = dict["InstanceDesc"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var count: Int32?

    public var requestId: String?

    public var vpcList: [DescribeVpcListResponseBody.VpcList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpcList != nil {
            var tmp : [Any] = []
            for k in self.vpcList! {
                tmp.append(k.toMap())
            }
            map["VpcList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VpcList") && dict["VpcList"] != nil {
            var tmp : [DescribeVpcListResponseBody.VpcList] = []
            for v in dict["VpcList"] as! [Any] {
                var model = DescribeVpcListResponseBody.VpcList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vpcList = tmp
        }
    }
}

public class DescribeVpcListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVpcListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVulCheckTaskStatusDetailRequest : Tea.TeaModel {
    public var taskIds: [String]?

    public var types: [String]?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskIds") && dict["TaskIds"] != nil {
            self.taskIds = dict["TaskIds"] as! [String]
        }
        if dict.keys.contains("Types") && dict["Types"] != nil {
            self.types = dict["Types"] as! [String]
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeVulCheckTaskStatusDetailResponseBody : Tea.TeaModel {
    public class TaskStatuses : Tea.TeaModel {
        public class TaskStatusList : Tea.TeaModel {
            public var code: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var taskId: String?

        public var taskStatusList: [DescribeVulCheckTaskStatusDetailResponseBody.TaskStatuses.TaskStatusList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskStatusList != nil {
                var tmp : [Any] = []
                for k in self.taskStatusList! {
                    tmp.append(k.toMap())
                }
                map["TaskStatusList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskStatusList") && dict["TaskStatusList"] != nil {
                var tmp : [DescribeVulCheckTaskStatusDetailResponseBody.TaskStatuses.TaskStatusList] = []
                for v in dict["TaskStatusList"] as! [Any] {
                    var model = DescribeVulCheckTaskStatusDetailResponseBody.TaskStatuses.TaskStatusList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.taskStatusList = tmp
            }
        }
    }
    public var requestId: String?

    public var taskStatuses: [DescribeVulCheckTaskStatusDetailResponseBody.TaskStatuses]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskStatuses != nil {
            var tmp : [Any] = []
            for k in self.taskStatuses! {
                tmp.append(k.toMap())
            }
            map["TaskStatuses"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskStatuses") && dict["TaskStatuses"] != nil {
            var tmp : [DescribeVulCheckTaskStatusDetailResponseBody.TaskStatuses] = []
            for v in dict["TaskStatuses"] as! [Any] {
                var model = DescribeVulCheckTaskStatusDetailResponseBody.TaskStatuses()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.taskStatuses = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeVulCheckTaskStatusDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVulCheckTaskStatusDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVulCheckTaskStatusDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVulConfigRequest : Tea.TeaModel {
    public var sourceIp: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeVulConfigResponseBody : Tea.TeaModel {
    public class TargetConfigs : Tea.TeaModel {
        public var config: String?

        public var overAllConfig: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.overAllConfig != nil {
                map["OverAllConfig"] = self.overAllConfig!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("OverAllConfig") && dict["OverAllConfig"] != nil {
                self.overAllConfig = dict["OverAllConfig"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var targetConfigs: [DescribeVulConfigResponseBody.TargetConfigs]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.targetConfigs != nil {
            var tmp : [Any] = []
            for k in self.targetConfigs! {
                tmp.append(k.toMap())
            }
            map["TargetConfigs"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TargetConfigs") && dict["TargetConfigs"] != nil {
            var tmp : [DescribeVulConfigResponseBody.TargetConfigs] = []
            for v in dict["TargetConfigs"] as! [Any] {
                var model = DescribeVulConfigResponseBody.TargetConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.targetConfigs = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeVulConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVulConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVulConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVulDetailsRequest : Tea.TeaModel {
    public var aliasName: String?

    public var lang: String?

    public var name: String?

    public var resourceDirectoryAccountId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliasName != nil {
            map["AliasName"] = self.aliasName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
            self.aliasName = dict["AliasName"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! Int64
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeVulDetailsResponseBody : Tea.TeaModel {
    public class Cves : Tea.TeaModel {
        public class Classifys : Tea.TeaModel {
            public var classify: String?

            public var demoVideoUrl: String?

            public var description_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.classify != nil {
                    map["Classify"] = self.classify!
                }
                if self.demoVideoUrl != nil {
                    map["DemoVideoUrl"] = self.demoVideoUrl!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Classify") && dict["Classify"] != nil {
                    self.classify = dict["Classify"] as! String
                }
                if dict.keys.contains("DemoVideoUrl") && dict["DemoVideoUrl"] != nil {
                    self.demoVideoUrl = dict["DemoVideoUrl"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
            }
        }
        public var classify: String?

        public var classifys: [DescribeVulDetailsResponseBody.Cves.Classifys]?

        public var cnvdId: String?

        public var complexity: String?

        public var content: String?

        public var cveId: String?

        public var cvssScore: String?

        public var cvssVector: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var otherId: String?

        public var poc: String?

        public var pocCreateTime: Int64?

        public var pocDisclosureTime: Int64?

        public var product: String?

        public var reference: String?

        public var releaseTime: Int64?

        public var solution: String?

        public var summary: String?

        public var targetId: String?

        public var targetName: String?

        public var title: String?

        public var vendor: String?

        public var vulLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.classify != nil {
                map["Classify"] = self.classify!
            }
            if self.classifys != nil {
                var tmp : [Any] = []
                for k in self.classifys! {
                    tmp.append(k.toMap())
                }
                map["Classifys"] = tmp
            }
            if self.cnvdId != nil {
                map["CnvdId"] = self.cnvdId!
            }
            if self.complexity != nil {
                map["Complexity"] = self.complexity!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.cveId != nil {
                map["CveId"] = self.cveId!
            }
            if self.cvssScore != nil {
                map["CvssScore"] = self.cvssScore!
            }
            if self.cvssVector != nil {
                map["CvssVector"] = self.cvssVector!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.otherId != nil {
                map["OtherId"] = self.otherId!
            }
            if self.poc != nil {
                map["Poc"] = self.poc!
            }
            if self.pocCreateTime != nil {
                map["PocCreateTime"] = self.pocCreateTime!
            }
            if self.pocDisclosureTime != nil {
                map["PocDisclosureTime"] = self.pocDisclosureTime!
            }
            if self.product != nil {
                map["Product"] = self.product!
            }
            if self.reference != nil {
                map["Reference"] = self.reference!
            }
            if self.releaseTime != nil {
                map["ReleaseTime"] = self.releaseTime!
            }
            if self.solution != nil {
                map["Solution"] = self.solution!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.vendor != nil {
                map["Vendor"] = self.vendor!
            }
            if self.vulLevel != nil {
                map["VulLevel"] = self.vulLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Classify") && dict["Classify"] != nil {
                self.classify = dict["Classify"] as! String
            }
            if dict.keys.contains("Classifys") && dict["Classifys"] != nil {
                var tmp : [DescribeVulDetailsResponseBody.Cves.Classifys] = []
                for v in dict["Classifys"] as! [Any] {
                    var model = DescribeVulDetailsResponseBody.Cves.Classifys()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.classifys = tmp
            }
            if dict.keys.contains("CnvdId") && dict["CnvdId"] != nil {
                self.cnvdId = dict["CnvdId"] as! String
            }
            if dict.keys.contains("Complexity") && dict["Complexity"] != nil {
                self.complexity = dict["Complexity"] as! String
            }
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("CveId") && dict["CveId"] != nil {
                self.cveId = dict["CveId"] as! String
            }
            if dict.keys.contains("CvssScore") && dict["CvssScore"] != nil {
                self.cvssScore = dict["CvssScore"] as! String
            }
            if dict.keys.contains("CvssVector") && dict["CvssVector"] != nil {
                self.cvssVector = dict["CvssVector"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("OtherId") && dict["OtherId"] != nil {
                self.otherId = dict["OtherId"] as! String
            }
            if dict.keys.contains("Poc") && dict["Poc"] != nil {
                self.poc = dict["Poc"] as! String
            }
            if dict.keys.contains("PocCreateTime") && dict["PocCreateTime"] != nil {
                self.pocCreateTime = dict["PocCreateTime"] as! Int64
            }
            if dict.keys.contains("PocDisclosureTime") && dict["PocDisclosureTime"] != nil {
                self.pocDisclosureTime = dict["PocDisclosureTime"] as! Int64
            }
            if dict.keys.contains("Product") && dict["Product"] != nil {
                self.product = dict["Product"] as! String
            }
            if dict.keys.contains("Reference") && dict["Reference"] != nil {
                self.reference = dict["Reference"] as! String
            }
            if dict.keys.contains("ReleaseTime") && dict["ReleaseTime"] != nil {
                self.releaseTime = dict["ReleaseTime"] as! Int64
            }
            if dict.keys.contains("Solution") && dict["Solution"] != nil {
                self.solution = dict["Solution"] as! String
            }
            if dict.keys.contains("Summary") && dict["Summary"] != nil {
                self.summary = dict["Summary"] as! String
            }
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! String
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                self.vendor = dict["Vendor"] as! String
            }
            if dict.keys.contains("VulLevel") && dict["VulLevel"] != nil {
                self.vulLevel = dict["VulLevel"] as! String
            }
        }
    }
    public var cves: [DescribeVulDetailsResponseBody.Cves]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cves != nil {
            var tmp : [Any] = []
            for k in self.cves! {
                tmp.append(k.toMap())
            }
            map["Cves"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cves") && dict["Cves"] != nil {
            var tmp : [DescribeVulDetailsResponseBody.Cves] = []
            for v in dict["Cves"] as! [Any] {
                var model = DescribeVulDetailsResponseBody.Cves()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cves = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVulDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVulDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVulDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVulExportInfoRequest : Tea.TeaModel {
    public var exportId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exportId != nil {
            map["ExportId"] = self.exportId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExportId") && dict["ExportId"] != nil {
            self.exportId = dict["ExportId"] as! Int64
        }
    }
}

public class DescribeVulExportInfoResponseBody : Tea.TeaModel {
    public var currentCount: Int32?

    public var exportStatus: String?

    public var fileName: String?

    public var id: Int64?

    public var link: String?

    public var message: String?

    public var progress: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentCount != nil {
            map["CurrentCount"] = self.currentCount!
        }
        if self.exportStatus != nil {
            map["ExportStatus"] = self.exportStatus!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.link != nil {
            map["Link"] = self.link!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.progress != nil {
            map["Progress"] = self.progress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentCount") && dict["CurrentCount"] != nil {
            self.currentCount = dict["CurrentCount"] as! Int32
        }
        if dict.keys.contains("ExportStatus") && dict["ExportStatus"] != nil {
            self.exportStatus = dict["ExportStatus"] as! String
        }
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Link") && dict["Link"] != nil {
            self.link = dict["Link"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Progress") && dict["Progress"] != nil {
            self.progress = dict["Progress"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeVulExportInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVulExportInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVulExportInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVulFixStatisticsResponseBody : Tea.TeaModel {
    public class FixStat : Tea.TeaModel {
        public var fixedTodayNum: Int32?

        public var fixedTotalNum: Int32?

        public var fixingNum: Int32?

        public var needFixNum: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fixedTodayNum != nil {
                map["FixedTodayNum"] = self.fixedTodayNum!
            }
            if self.fixedTotalNum != nil {
                map["FixedTotalNum"] = self.fixedTotalNum!
            }
            if self.fixingNum != nil {
                map["FixingNum"] = self.fixingNum!
            }
            if self.needFixNum != nil {
                map["NeedFixNum"] = self.needFixNum!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FixedTodayNum") && dict["FixedTodayNum"] != nil {
                self.fixedTodayNum = dict["FixedTodayNum"] as! Int32
            }
            if dict.keys.contains("FixedTotalNum") && dict["FixedTotalNum"] != nil {
                self.fixedTotalNum = dict["FixedTotalNum"] as! Int32
            }
            if dict.keys.contains("FixingNum") && dict["FixingNum"] != nil {
                self.fixingNum = dict["FixingNum"] as! Int32
            }
            if dict.keys.contains("NeedFixNum") && dict["NeedFixNum"] != nil {
                self.needFixNum = dict["NeedFixNum"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class FixTotal : Tea.TeaModel {
        public var fixedTodayNum: Int32?

        public var fixedTotalNum: Int32?

        public var fixingNum: Int32?

        public var needFixNum: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fixedTodayNum != nil {
                map["FixedTodayNum"] = self.fixedTodayNum!
            }
            if self.fixedTotalNum != nil {
                map["FixedTotalNum"] = self.fixedTotalNum!
            }
            if self.fixingNum != nil {
                map["FixingNum"] = self.fixingNum!
            }
            if self.needFixNum != nil {
                map["NeedFixNum"] = self.needFixNum!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FixedTodayNum") && dict["FixedTodayNum"] != nil {
                self.fixedTodayNum = dict["FixedTodayNum"] as! Int32
            }
            if dict.keys.contains("FixedTotalNum") && dict["FixedTotalNum"] != nil {
                self.fixedTotalNum = dict["FixedTotalNum"] as! Int32
            }
            if dict.keys.contains("FixingNum") && dict["FixingNum"] != nil {
                self.fixingNum = dict["FixingNum"] as! Int32
            }
            if dict.keys.contains("NeedFixNum") && dict["NeedFixNum"] != nil {
                self.needFixNum = dict["NeedFixNum"] as! Int32
            }
        }
    }
    public var fixStat: [DescribeVulFixStatisticsResponseBody.FixStat]?

    public var fixTotal: DescribeVulFixStatisticsResponseBody.FixTotal?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fixTotal?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fixStat != nil {
            var tmp : [Any] = []
            for k in self.fixStat! {
                tmp.append(k.toMap())
            }
            map["FixStat"] = tmp
        }
        if self.fixTotal != nil {
            map["FixTotal"] = self.fixTotal?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FixStat") && dict["FixStat"] != nil {
            var tmp : [DescribeVulFixStatisticsResponseBody.FixStat] = []
            for v in dict["FixStat"] as! [Any] {
                var model = DescribeVulFixStatisticsResponseBody.FixStat()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fixStat = tmp
        }
        if dict.keys.contains("FixTotal") && dict["FixTotal"] != nil {
            var model = DescribeVulFixStatisticsResponseBody.FixTotal()
            model.fromMap(dict["FixTotal"] as! [String: Any])
            self.fixTotal = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeVulFixStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVulFixStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVulFixStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVulListRequest : Tea.TeaModel {
    public var aliasName: String?

    public var attachTypes: String?

    public var currentPage: Int32?

    public var dealed: String?

    public var groupId: String?

    public var lang: String?

    public var name: String?

    public var necessity: String?

    public var nextToken: String?

    public var pageSize: Int32?

    public var remark: String?

    public var resourceDirectoryAccountId: Int64?

    public var statusList: String?

    public var type: String?

    public var useNextToken: Bool?

    public var uuids: String?

    public var vpcInstanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliasName != nil {
            map["AliasName"] = self.aliasName!
        }
        if self.attachTypes != nil {
            map["AttachTypes"] = self.attachTypes!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.necessity != nil {
            map["Necessity"] = self.necessity!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.useNextToken != nil {
            map["UseNextToken"] = self.useNextToken!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        if self.vpcInstanceIds != nil {
            map["VpcInstanceIds"] = self.vpcInstanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
            self.aliasName = dict["AliasName"] as! String
        }
        if dict.keys.contains("AttachTypes") && dict["AttachTypes"] != nil {
            self.attachTypes = dict["AttachTypes"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
            self.necessity = dict["Necessity"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! Int64
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UseNextToken") && dict["UseNextToken"] != nil {
            self.useNextToken = dict["UseNextToken"] as! Bool
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
        if dict.keys.contains("VpcInstanceIds") && dict["VpcInstanceIds"] != nil {
            self.vpcInstanceIds = dict["VpcInstanceIds"] as! String
        }
    }
}

public class DescribeVulListResponseBody : Tea.TeaModel {
    public class VulRecords : Tea.TeaModel {
        public class ExtendContentJson : Tea.TeaModel {
            public class Necessity : Tea.TeaModel {
                public var assetsFactor: String?

                public var cvssFactor: String?

                public var enviromentFactor: String?

                public var isCalc: String?

                public var status: String?

                public var timeFactor: String?

                public var totalScore: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.assetsFactor != nil {
                        map["Assets_factor"] = self.assetsFactor!
                    }
                    if self.cvssFactor != nil {
                        map["Cvss_factor"] = self.cvssFactor!
                    }
                    if self.enviromentFactor != nil {
                        map["Enviroment_factor"] = self.enviromentFactor!
                    }
                    if self.isCalc != nil {
                        map["Is_calc"] = self.isCalc!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.timeFactor != nil {
                        map["Time_factor"] = self.timeFactor!
                    }
                    if self.totalScore != nil {
                        map["Total_score"] = self.totalScore!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Assets_factor") && dict["Assets_factor"] != nil {
                        self.assetsFactor = dict["Assets_factor"] as! String
                    }
                    if dict.keys.contains("Cvss_factor") && dict["Cvss_factor"] != nil {
                        self.cvssFactor = dict["Cvss_factor"] as! String
                    }
                    if dict.keys.contains("Enviroment_factor") && dict["Enviroment_factor"] != nil {
                        self.enviromentFactor = dict["Enviroment_factor"] as! String
                    }
                    if dict.keys.contains("Is_calc") && dict["Is_calc"] != nil {
                        self.isCalc = dict["Is_calc"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Time_factor") && dict["Time_factor"] != nil {
                        self.timeFactor = dict["Time_factor"] as! String
                    }
                    if dict.keys.contains("Total_score") && dict["Total_score"] != nil {
                        self.totalScore = dict["Total_score"] as! String
                    }
                }
            }
            public class RpmEntityList : Tea.TeaModel {
                public var containerName: String?

                public var fullVersion: String?

                public var imageName: String?

                public var matchDetail: String?

                public var matchList: [String]?

                public var name: String?

                public var path: String?

                public var pid: String?

                public var updateCmd: String?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.containerName != nil {
                        map["ContainerName"] = self.containerName!
                    }
                    if self.fullVersion != nil {
                        map["FullVersion"] = self.fullVersion!
                    }
                    if self.imageName != nil {
                        map["ImageName"] = self.imageName!
                    }
                    if self.matchDetail != nil {
                        map["MatchDetail"] = self.matchDetail!
                    }
                    if self.matchList != nil {
                        map["MatchList"] = self.matchList!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.pid != nil {
                        map["Pid"] = self.pid!
                    }
                    if self.updateCmd != nil {
                        map["UpdateCmd"] = self.updateCmd!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ContainerName") && dict["ContainerName"] != nil {
                        self.containerName = dict["ContainerName"] as! String
                    }
                    if dict.keys.contains("FullVersion") && dict["FullVersion"] != nil {
                        self.fullVersion = dict["FullVersion"] as! String
                    }
                    if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                        self.imageName = dict["ImageName"] as! String
                    }
                    if dict.keys.contains("MatchDetail") && dict["MatchDetail"] != nil {
                        self.matchDetail = dict["MatchDetail"] as! String
                    }
                    if dict.keys.contains("MatchList") && dict["MatchList"] != nil {
                        self.matchList = dict["MatchList"] as! [String]
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                    if dict.keys.contains("Pid") && dict["Pid"] != nil {
                        self.pid = dict["Pid"] as! String
                    }
                    if dict.keys.contains("UpdateCmd") && dict["UpdateCmd"] != nil {
                        self.updateCmd = dict["UpdateCmd"] as! String
                    }
                    if dict.keys.contains("Version") && dict["Version"] != nil {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public var absolutePath: String?

            public var aliasName: String?

            public var description_: String?

            public var ip: String?

            public var lastTs: Int64?

            public var necessity: DescribeVulListResponseBody.VulRecords.ExtendContentJson.Necessity?

            public var os: String?

            public var osRelease: String?

            public var primaryId: Int64?

            public var rpmEntityList: [DescribeVulListResponseBody.VulRecords.ExtendContentJson.RpmEntityList]?

            public var status: String?

            public var tag: String?

            public var cveList: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.necessity?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.absolutePath != nil {
                    map["AbsolutePath"] = self.absolutePath!
                }
                if self.aliasName != nil {
                    map["AliasName"] = self.aliasName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.lastTs != nil {
                    map["LastTs"] = self.lastTs!
                }
                if self.necessity != nil {
                    map["Necessity"] = self.necessity?.toMap()
                }
                if self.os != nil {
                    map["Os"] = self.os!
                }
                if self.osRelease != nil {
                    map["OsRelease"] = self.osRelease!
                }
                if self.primaryId != nil {
                    map["PrimaryId"] = self.primaryId!
                }
                if self.rpmEntityList != nil {
                    var tmp : [Any] = []
                    for k in self.rpmEntityList! {
                        tmp.append(k.toMap())
                    }
                    map["RpmEntityList"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.cveList != nil {
                    map["cveList"] = self.cveList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbsolutePath") && dict["AbsolutePath"] != nil {
                    self.absolutePath = dict["AbsolutePath"] as! String
                }
                if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                    self.aliasName = dict["AliasName"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("LastTs") && dict["LastTs"] != nil {
                    self.lastTs = dict["LastTs"] as! Int64
                }
                if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
                    var model = DescribeVulListResponseBody.VulRecords.ExtendContentJson.Necessity()
                    model.fromMap(dict["Necessity"] as! [String: Any])
                    self.necessity = model
                }
                if dict.keys.contains("Os") && dict["Os"] != nil {
                    self.os = dict["Os"] as! String
                }
                if dict.keys.contains("OsRelease") && dict["OsRelease"] != nil {
                    self.osRelease = dict["OsRelease"] as! String
                }
                if dict.keys.contains("PrimaryId") && dict["PrimaryId"] != nil {
                    self.primaryId = dict["PrimaryId"] as! Int64
                }
                if dict.keys.contains("RpmEntityList") && dict["RpmEntityList"] != nil {
                    var tmp : [DescribeVulListResponseBody.VulRecords.ExtendContentJson.RpmEntityList] = []
                    for v in dict["RpmEntityList"] as! [Any] {
                        var model = DescribeVulListResponseBody.VulRecords.ExtendContentJson.RpmEntityList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rpmEntityList = tmp
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("cveList") && dict["cveList"] != nil {
                    self.cveList = dict["cveList"] as! [String]
                }
            }
        }
        public var aliasName: String?

        public var authVersion: String?

        public var bind: Bool?

        public var extendContentJson: DescribeVulListResponseBody.VulRecords.ExtendContentJson?

        public var firstTs: Int64?

        public var groupId: Int32?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var lastTs: Int64?

        public var modifyTs: Int64?

        public var name: String?

        public var necessity: String?

        public var online: Bool?

        public var osName: String?

        public var osVersion: String?

        public var primaryId: Int64?

        public var raspDefend: Int32?

        public var raspStatus: Int32?

        public var regionId: String?

        public var related: String?

        public var repairTs: Int64?

        public var resultCode: String?

        public var resultMessage: String?

        public var status: Int32?

        public var tag: String?

        public var type: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.extendContentJson?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.authVersion != nil {
                map["AuthVersion"] = self.authVersion!
            }
            if self.bind != nil {
                map["Bind"] = self.bind!
            }
            if self.extendContentJson != nil {
                map["ExtendContentJson"] = self.extendContentJson?.toMap()
            }
            if self.firstTs != nil {
                map["FirstTs"] = self.firstTs!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.lastTs != nil {
                map["LastTs"] = self.lastTs!
            }
            if self.modifyTs != nil {
                map["ModifyTs"] = self.modifyTs!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.necessity != nil {
                map["Necessity"] = self.necessity!
            }
            if self.online != nil {
                map["Online"] = self.online!
            }
            if self.osName != nil {
                map["OsName"] = self.osName!
            }
            if self.osVersion != nil {
                map["OsVersion"] = self.osVersion!
            }
            if self.primaryId != nil {
                map["PrimaryId"] = self.primaryId!
            }
            if self.raspDefend != nil {
                map["RaspDefend"] = self.raspDefend!
            }
            if self.raspStatus != nil {
                map["RaspStatus"] = self.raspStatus!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.related != nil {
                map["Related"] = self.related!
            }
            if self.repairTs != nil {
                map["RepairTs"] = self.repairTs!
            }
            if self.resultCode != nil {
                map["ResultCode"] = self.resultCode!
            }
            if self.resultMessage != nil {
                map["ResultMessage"] = self.resultMessage!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                self.aliasName = dict["AliasName"] as! String
            }
            if dict.keys.contains("AuthVersion") && dict["AuthVersion"] != nil {
                self.authVersion = dict["AuthVersion"] as! String
            }
            if dict.keys.contains("Bind") && dict["Bind"] != nil {
                self.bind = dict["Bind"] as! Bool
            }
            if dict.keys.contains("ExtendContentJson") && dict["ExtendContentJson"] != nil {
                var model = DescribeVulListResponseBody.VulRecords.ExtendContentJson()
                model.fromMap(dict["ExtendContentJson"] as! [String: Any])
                self.extendContentJson = model
            }
            if dict.keys.contains("FirstTs") && dict["FirstTs"] != nil {
                self.firstTs = dict["FirstTs"] as! Int64
            }
            if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                self.groupId = dict["GroupId"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LastTs") && dict["LastTs"] != nil {
                self.lastTs = dict["LastTs"] as! Int64
            }
            if dict.keys.contains("ModifyTs") && dict["ModifyTs"] != nil {
                self.modifyTs = dict["ModifyTs"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
                self.necessity = dict["Necessity"] as! String
            }
            if dict.keys.contains("Online") && dict["Online"] != nil {
                self.online = dict["Online"] as! Bool
            }
            if dict.keys.contains("OsName") && dict["OsName"] != nil {
                self.osName = dict["OsName"] as! String
            }
            if dict.keys.contains("OsVersion") && dict["OsVersion"] != nil {
                self.osVersion = dict["OsVersion"] as! String
            }
            if dict.keys.contains("PrimaryId") && dict["PrimaryId"] != nil {
                self.primaryId = dict["PrimaryId"] as! Int64
            }
            if dict.keys.contains("RaspDefend") && dict["RaspDefend"] != nil {
                self.raspDefend = dict["RaspDefend"] as! Int32
            }
            if dict.keys.contains("RaspStatus") && dict["RaspStatus"] != nil {
                self.raspStatus = dict["RaspStatus"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Related") && dict["Related"] != nil {
                self.related = dict["Related"] as! String
            }
            if dict.keys.contains("RepairTs") && dict["RepairTs"] != nil {
                self.repairTs = dict["RepairTs"] as! Int64
            }
            if dict.keys.contains("ResultCode") && dict["ResultCode"] != nil {
                self.resultCode = dict["ResultCode"] as! String
            }
            if dict.keys.contains("ResultMessage") && dict["ResultMessage"] != nil {
                self.resultMessage = dict["ResultMessage"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var nextToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vulRecords: [DescribeVulListResponseBody.VulRecords]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vulRecords != nil {
            var tmp : [Any] = []
            for k in self.vulRecords! {
                tmp.append(k.toMap())
            }
            map["VulRecords"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VulRecords") && dict["VulRecords"] != nil {
            var tmp : [DescribeVulListResponseBody.VulRecords] = []
            for v in dict["VulRecords"] as! [Any] {
                var model = DescribeVulListResponseBody.VulRecords()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vulRecords = tmp
        }
    }
}

public class DescribeVulListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVulListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVulListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVulListPageRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var cveId: String?

    public var pageSize: Int32?

    public var vulNameLike: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.cveId != nil {
            map["CveId"] = self.cveId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.vulNameLike != nil {
            map["VulNameLike"] = self.vulNameLike!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("CveId") && dict["CveId"] != nil {
            self.cveId = dict["CveId"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("VulNameLike") && dict["VulNameLike"] != nil {
            self.vulNameLike = dict["VulNameLike"] as! String
        }
    }
}

public class DescribeVulListPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cveId: String?

        public var extAegis: String?

        public var id: Int64?

        public var isAegis: Int32?

        public var isSas: Int32?

        public var otherId: String?

        public var releaseTime: Int64?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cveId != nil {
                map["CveId"] = self.cveId!
            }
            if self.extAegis != nil {
                map["ExtAegis"] = self.extAegis!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.isAegis != nil {
                map["IsAegis"] = self.isAegis!
            }
            if self.isSas != nil {
                map["IsSas"] = self.isSas!
            }
            if self.otherId != nil {
                map["OtherId"] = self.otherId!
            }
            if self.releaseTime != nil {
                map["ReleaseTime"] = self.releaseTime!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CveId") && dict["CveId"] != nil {
                self.cveId = dict["CveId"] as! String
            }
            if dict.keys.contains("ExtAegis") && dict["ExtAegis"] != nil {
                self.extAegis = dict["ExtAegis"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("IsAegis") && dict["IsAegis"] != nil {
                self.isAegis = dict["IsAegis"] as! Int32
            }
            if dict.keys.contains("IsSas") && dict["IsSas"] != nil {
                self.isSas = dict["IsSas"] as! Int32
            }
            if dict.keys.contains("OtherId") && dict["OtherId"] != nil {
                self.otherId = dict["OtherId"] as! String
            }
            if dict.keys.contains("ReleaseTime") && dict["ReleaseTime"] != nil {
                self.releaseTime = dict["ReleaseTime"] as! Int64
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var data: [DescribeVulListPageResponseBody.Data]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [DescribeVulListPageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeVulListPageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeVulListPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVulListPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVulListPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVulNumStatisticsRequest : Tea.TeaModel {
    public var from: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
    }
}

public class DescribeVulNumStatisticsResponseBody : Tea.TeaModel {
    public var appCnt: Int32?

    public var appNum: Int32?

    public var cmsDealedTotalNum: Int32?

    public var cmsNum: Int32?

    public var cveNum: Int32?

    public var emgNum: Int32?

    public var requestId: String?

    public var scaNum: Int32?

    public var sysNum: Int32?

    public var vulAsapSum: Int32?

    public var vulDealedTotalNum: Int32?

    public var vulLaterSum: Int32?

    public var vulNntfSum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCnt != nil {
            map["AppCnt"] = self.appCnt!
        }
        if self.appNum != nil {
            map["AppNum"] = self.appNum!
        }
        if self.cmsDealedTotalNum != nil {
            map["CmsDealedTotalNum"] = self.cmsDealedTotalNum!
        }
        if self.cmsNum != nil {
            map["CmsNum"] = self.cmsNum!
        }
        if self.cveNum != nil {
            map["CveNum"] = self.cveNum!
        }
        if self.emgNum != nil {
            map["EmgNum"] = self.emgNum!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scaNum != nil {
            map["ScaNum"] = self.scaNum!
        }
        if self.sysNum != nil {
            map["SysNum"] = self.sysNum!
        }
        if self.vulAsapSum != nil {
            map["VulAsapSum"] = self.vulAsapSum!
        }
        if self.vulDealedTotalNum != nil {
            map["VulDealedTotalNum"] = self.vulDealedTotalNum!
        }
        if self.vulLaterSum != nil {
            map["VulLaterSum"] = self.vulLaterSum!
        }
        if self.vulNntfSum != nil {
            map["VulNntfSum"] = self.vulNntfSum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppCnt") && dict["AppCnt"] != nil {
            self.appCnt = dict["AppCnt"] as! Int32
        }
        if dict.keys.contains("AppNum") && dict["AppNum"] != nil {
            self.appNum = dict["AppNum"] as! Int32
        }
        if dict.keys.contains("CmsDealedTotalNum") && dict["CmsDealedTotalNum"] != nil {
            self.cmsDealedTotalNum = dict["CmsDealedTotalNum"] as! Int32
        }
        if dict.keys.contains("CmsNum") && dict["CmsNum"] != nil {
            self.cmsNum = dict["CmsNum"] as! Int32
        }
        if dict.keys.contains("CveNum") && dict["CveNum"] != nil {
            self.cveNum = dict["CveNum"] as! Int32
        }
        if dict.keys.contains("EmgNum") && dict["EmgNum"] != nil {
            self.emgNum = dict["EmgNum"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScaNum") && dict["ScaNum"] != nil {
            self.scaNum = dict["ScaNum"] as! Int32
        }
        if dict.keys.contains("SysNum") && dict["SysNum"] != nil {
            self.sysNum = dict["SysNum"] as! Int32
        }
        if dict.keys.contains("VulAsapSum") && dict["VulAsapSum"] != nil {
            self.vulAsapSum = dict["VulAsapSum"] as! Int32
        }
        if dict.keys.contains("VulDealedTotalNum") && dict["VulDealedTotalNum"] != nil {
            self.vulDealedTotalNum = dict["VulDealedTotalNum"] as! Int32
        }
        if dict.keys.contains("VulLaterSum") && dict["VulLaterSum"] != nil {
            self.vulLaterSum = dict["VulLaterSum"] as! Int32
        }
        if dict.keys.contains("VulNntfSum") && dict["VulNntfSum"] != nil {
            self.vulNntfSum = dict["VulNntfSum"] as! Int32
        }
    }
}

public class DescribeVulNumStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVulNumStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVulNumStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVulTargetConfigRequest : Tea.TeaModel {
    public var type: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeVulTargetConfigResponseBody : Tea.TeaModel {
    public class TargetConfigs : Tea.TeaModel {
        public var config: String?

        public var overAllConfig: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.overAllConfig != nil {
                map["OverAllConfig"] = self.overAllConfig!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("OverAllConfig") && dict["OverAllConfig"] != nil {
                self.overAllConfig = dict["OverAllConfig"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var targetConfigs: [DescribeVulTargetConfigResponseBody.TargetConfigs]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.targetConfigs != nil {
            var tmp : [Any] = []
            for k in self.targetConfigs! {
                tmp.append(k.toMap())
            }
            map["TargetConfigs"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TargetConfigs") && dict["TargetConfigs"] != nil {
            var tmp : [DescribeVulTargetConfigResponseBody.TargetConfigs] = []
            for v in dict["TargetConfigs"] as! [Any] {
                var model = DescribeVulTargetConfigResponseBody.TargetConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.targetConfigs = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeVulTargetConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVulTargetConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVulTargetConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVulTargetStatisticsRequest : Tea.TeaModel {
    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeVulTargetStatisticsResponseBody : Tea.TeaModel {
    public class TargetStats : Tea.TeaModel {
        public class Targets : Tea.TeaModel {
            public var flag: String?

            public var target: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.flag != nil {
                    map["Flag"] = self.flag!
                }
                if self.target != nil {
                    map["Target"] = self.target!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Flag") && dict["Flag"] != nil {
                    self.flag = dict["Flag"] as! String
                }
                if dict.keys.contains("Target") && dict["Target"] != nil {
                    self.target = dict["Target"] as! String
                }
                if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                    self.targetType = dict["TargetType"] as! String
                }
            }
        }
        public var targets: [DescribeVulTargetStatisticsResponseBody.TargetStats.Targets]?

        public var totalCount: Int32?

        public var uuidCount: Int32?

        public var vulType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.targets != nil {
                var tmp : [Any] = []
                for k in self.targets! {
                    tmp.append(k.toMap())
                }
                map["Targets"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            if self.uuidCount != nil {
                map["UuidCount"] = self.uuidCount!
            }
            if self.vulType != nil {
                map["VulType"] = self.vulType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Targets") && dict["Targets"] != nil {
                var tmp : [DescribeVulTargetStatisticsResponseBody.TargetStats.Targets] = []
                for v in dict["Targets"] as! [Any] {
                    var model = DescribeVulTargetStatisticsResponseBody.TargetStats.Targets()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.targets = tmp
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
            if dict.keys.contains("UuidCount") && dict["UuidCount"] != nil {
                self.uuidCount = dict["UuidCount"] as! Int32
            }
            if dict.keys.contains("VulType") && dict["VulType"] != nil {
                self.vulType = dict["VulType"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var targetStats: [DescribeVulTargetStatisticsResponseBody.TargetStats]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.targetStats != nil {
            var tmp : [Any] = []
            for k in self.targetStats! {
                tmp.append(k.toMap())
            }
            map["TargetStats"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TargetStats") && dict["TargetStats"] != nil {
            var tmp : [DescribeVulTargetStatisticsResponseBody.TargetStats] = []
            for v in dict["TargetStats"] as! [Any] {
                var model = DescribeVulTargetStatisticsResponseBody.TargetStats()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.targetStats = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeVulTargetStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVulTargetStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVulTargetStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVulWhitelistRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeVulWhitelistResponseBody : Tea.TeaModel {
    public class VulWhitelists : Tea.TeaModel {
        public var aliasName: String?

        public var id: String?

        public var name: String?

        public var reason: String?

        public var targetInfo: String?

        public var type: String?

        public var whitelist: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.targetInfo != nil {
                map["TargetInfo"] = self.targetInfo!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.whitelist != nil {
                map["Whitelist"] = self.whitelist!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                self.aliasName = dict["AliasName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("TargetInfo") && dict["TargetInfo"] != nil {
                self.targetInfo = dict["TargetInfo"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Whitelist") && dict["Whitelist"] != nil {
                self.whitelist = dict["Whitelist"] as! String
            }
        }
    }
    public var count: Int32?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vulWhitelists: [DescribeVulWhitelistResponseBody.VulWhitelists]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vulWhitelists != nil {
            var tmp : [Any] = []
            for k in self.vulWhitelists! {
                tmp.append(k.toMap())
            }
            map["VulWhitelists"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VulWhitelists") && dict["VulWhitelists"] != nil {
            var tmp : [DescribeVulWhitelistResponseBody.VulWhitelists] = []
            for v in dict["VulWhitelists"] as! [Any] {
                var model = DescribeVulWhitelistResponseBody.VulWhitelists()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vulWhitelists = tmp
        }
    }
}

public class DescribeVulWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVulWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeVulWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWarningExportInfoRequest : Tea.TeaModel {
    public var exportId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exportId != nil {
            map["ExportId"] = self.exportId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExportId") && dict["ExportId"] != nil {
            self.exportId = dict["ExportId"] as! Int64
        }
    }
}

public class DescribeWarningExportInfoResponseBody : Tea.TeaModel {
    public var currentCount: Int32?

    public var exportStatus: String?

    public var fileName: String?

    public var id: Int64?

    public var link: String?

    public var message: String?

    public var progress: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentCount != nil {
            map["CurrentCount"] = self.currentCount!
        }
        if self.exportStatus != nil {
            map["ExportStatus"] = self.exportStatus!
        }
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.link != nil {
            map["Link"] = self.link!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.progress != nil {
            map["Progress"] = self.progress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentCount") && dict["CurrentCount"] != nil {
            self.currentCount = dict["CurrentCount"] as! Int32
        }
        if dict.keys.contains("ExportStatus") && dict["ExportStatus"] != nil {
            self.exportStatus = dict["ExportStatus"] as! String
        }
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Link") && dict["Link"] != nil {
            self.link = dict["Link"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Progress") && dict["Progress"] != nil {
            self.progress = dict["Progress"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeWarningExportInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWarningExportInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWarningExportInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWarningMachinesRequest : Tea.TeaModel {
    public var clusterId: String?

    public var containerFieldName: String?

    public var containerFieldValue: String?

    public var currentPage: Int32?

    public var groupId: Int64?

    public var haveRisk: Int32?

    public var lang: String?

    public var machineName: String?

    public var pageSize: Int32?

    public var riskId: Int64?

    public var sourceIp: String?

    public var strategyId: Int64?

    public var targetType: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.containerFieldName != nil {
            map["ContainerFieldName"] = self.containerFieldName!
        }
        if self.containerFieldValue != nil {
            map["ContainerFieldValue"] = self.containerFieldValue!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.haveRisk != nil {
            map["HaveRisk"] = self.haveRisk!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.machineName != nil {
            map["MachineName"] = self.machineName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskId != nil {
            map["RiskId"] = self.riskId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ContainerFieldName") && dict["ContainerFieldName"] != nil {
            self.containerFieldName = dict["ContainerFieldName"] as! String
        }
        if dict.keys.contains("ContainerFieldValue") && dict["ContainerFieldValue"] != nil {
            self.containerFieldValue = dict["ContainerFieldValue"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("HaveRisk") && dict["HaveRisk"] != nil {
            self.haveRisk = dict["HaveRisk"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MachineName") && dict["MachineName"] != nil {
            self.machineName = dict["MachineName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
            self.riskId = dict["RiskId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
            self.strategyId = dict["StrategyId"] as! Int64
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class DescribeWarningMachinesResponseBody : Tea.TeaModel {
    public class WarningMachines : Tea.TeaModel {
        public var authVersion: Int32?

        public var bind: Bool?

        public var containerId: String?

        public var containerName: String?

        public var highWarningCount: Int32?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var lowWarningCount: Int32?

        public var mediumWarningCount: Int32?

        public var passCount: Int32?

        public var portOpen: Bool?

        public var regionId: String?

        public var status: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authVersion != nil {
                map["AuthVersion"] = self.authVersion!
            }
            if self.bind != nil {
                map["Bind"] = self.bind!
            }
            if self.containerId != nil {
                map["ContainerId"] = self.containerId!
            }
            if self.containerName != nil {
                map["ContainerName"] = self.containerName!
            }
            if self.highWarningCount != nil {
                map["HighWarningCount"] = self.highWarningCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.lowWarningCount != nil {
                map["LowWarningCount"] = self.lowWarningCount!
            }
            if self.mediumWarningCount != nil {
                map["MediumWarningCount"] = self.mediumWarningCount!
            }
            if self.passCount != nil {
                map["PassCount"] = self.passCount!
            }
            if self.portOpen != nil {
                map["PortOpen"] = self.portOpen!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthVersion") && dict["AuthVersion"] != nil {
                self.authVersion = dict["AuthVersion"] as! Int32
            }
            if dict.keys.contains("Bind") && dict["Bind"] != nil {
                self.bind = dict["Bind"] as! Bool
            }
            if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                self.containerId = dict["ContainerId"] as! String
            }
            if dict.keys.contains("ContainerName") && dict["ContainerName"] != nil {
                self.containerName = dict["ContainerName"] as! String
            }
            if dict.keys.contains("HighWarningCount") && dict["HighWarningCount"] != nil {
                self.highWarningCount = dict["HighWarningCount"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LowWarningCount") && dict["LowWarningCount"] != nil {
                self.lowWarningCount = dict["LowWarningCount"] as! Int32
            }
            if dict.keys.contains("MediumWarningCount") && dict["MediumWarningCount"] != nil {
                self.mediumWarningCount = dict["MediumWarningCount"] as! Int32
            }
            if dict.keys.contains("PassCount") && dict["PassCount"] != nil {
                self.passCount = dict["PassCount"] as! Int32
            }
            if dict.keys.contains("PortOpen") && dict["PortOpen"] != nil {
                self.portOpen = dict["PortOpen"] as! Bool
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var count: Int32?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var warningMachines: [DescribeWarningMachinesResponseBody.WarningMachines]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.warningMachines != nil {
            var tmp : [Any] = []
            for k in self.warningMachines! {
                tmp.append(k.toMap())
            }
            map["WarningMachines"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("WarningMachines") && dict["WarningMachines"] != nil {
            var tmp : [DescribeWarningMachinesResponseBody.WarningMachines] = []
            for v in dict["WarningMachines"] as! [Any] {
                var model = DescribeWarningMachinesResponseBody.WarningMachines()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.warningMachines = tmp
        }
    }
}

public class DescribeWarningMachinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWarningMachinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWarningMachinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebLockBindListRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var lang: String?

    public var pageSize: Int32?

    public var remark: String?

    public var sourceIp: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeWebLockBindListResponseBody : Tea.TeaModel {
    public class BindList : Tea.TeaModel {
        public var auditCount: String?

        public var blockCount: String?

        public var dirCount: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var os: String?

        public var percent: Int32?

        public var serviceCode: String?

        public var serviceDetail: String?

        public var serviceStatus: String?

        public var status: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.auditCount != nil {
                map["AuditCount"] = self.auditCount!
            }
            if self.blockCount != nil {
                map["BlockCount"] = self.blockCount!
            }
            if self.dirCount != nil {
                map["DirCount"] = self.dirCount!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.serviceCode != nil {
                map["ServiceCode"] = self.serviceCode!
            }
            if self.serviceDetail != nil {
                map["ServiceDetail"] = self.serviceDetail!
            }
            if self.serviceStatus != nil {
                map["ServiceStatus"] = self.serviceStatus!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuditCount") && dict["AuditCount"] != nil {
                self.auditCount = dict["AuditCount"] as! String
            }
            if dict.keys.contains("BlockCount") && dict["BlockCount"] != nil {
                self.blockCount = dict["BlockCount"] as! String
            }
            if dict.keys.contains("DirCount") && dict["DirCount"] != nil {
                self.dirCount = dict["DirCount"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("Percent") && dict["Percent"] != nil {
                self.percent = dict["Percent"] as! Int32
            }
            if dict.keys.contains("ServiceCode") && dict["ServiceCode"] != nil {
                self.serviceCode = dict["ServiceCode"] as! String
            }
            if dict.keys.contains("ServiceDetail") && dict["ServiceDetail"] != nil {
                self.serviceDetail = dict["ServiceDetail"] as! String
            }
            if dict.keys.contains("ServiceStatus") && dict["ServiceStatus"] != nil {
                self.serviceStatus = dict["ServiceStatus"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var bindList: [DescribeWebLockBindListResponseBody.BindList]?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bindList != nil {
            var tmp : [Any] = []
            for k in self.bindList! {
                tmp.append(k.toMap())
            }
            map["BindList"] = tmp
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BindList") && dict["BindList"] != nil {
            var tmp : [DescribeWebLockBindListResponseBody.BindList] = []
            for v in dict["BindList"] as! [Any] {
                var model = DescribeWebLockBindListResponseBody.BindList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bindList = tmp
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeWebLockBindListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebLockBindListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebLockBindListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebLockConfigListRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DescribeWebLockConfigListResponseBody : Tea.TeaModel {
    public class ConfigList : Tea.TeaModel {
        public var defenceMode: String?

        public var dir: String?

        public var exclusiveDir: String?

        public var exclusiveFile: String?

        public var exclusiveFileType: String?

        public var id: String?

        public var inclusiveFile: String?

        public var inclusiveFileType: String?

        public var localBackupDir: String?

        public var mode: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defenceMode != nil {
                map["DefenceMode"] = self.defenceMode!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.exclusiveDir != nil {
                map["ExclusiveDir"] = self.exclusiveDir!
            }
            if self.exclusiveFile != nil {
                map["ExclusiveFile"] = self.exclusiveFile!
            }
            if self.exclusiveFileType != nil {
                map["ExclusiveFileType"] = self.exclusiveFileType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.inclusiveFile != nil {
                map["InclusiveFile"] = self.inclusiveFile!
            }
            if self.inclusiveFileType != nil {
                map["InclusiveFileType"] = self.inclusiveFileType!
            }
            if self.localBackupDir != nil {
                map["LocalBackupDir"] = self.localBackupDir!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefenceMode") && dict["DefenceMode"] != nil {
                self.defenceMode = dict["DefenceMode"] as! String
            }
            if dict.keys.contains("Dir") && dict["Dir"] != nil {
                self.dir = dict["Dir"] as! String
            }
            if dict.keys.contains("ExclusiveDir") && dict["ExclusiveDir"] != nil {
                self.exclusiveDir = dict["ExclusiveDir"] as! String
            }
            if dict.keys.contains("ExclusiveFile") && dict["ExclusiveFile"] != nil {
                self.exclusiveFile = dict["ExclusiveFile"] as! String
            }
            if dict.keys.contains("ExclusiveFileType") && dict["ExclusiveFileType"] != nil {
                self.exclusiveFileType = dict["ExclusiveFileType"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("InclusiveFile") && dict["InclusiveFile"] != nil {
                self.inclusiveFile = dict["InclusiveFile"] as! String
            }
            if dict.keys.contains("InclusiveFileType") && dict["InclusiveFileType"] != nil {
                self.inclusiveFileType = dict["InclusiveFileType"] as! String
            }
            if dict.keys.contains("LocalBackupDir") && dict["LocalBackupDir"] != nil {
                self.localBackupDir = dict["LocalBackupDir"] as! String
            }
            if dict.keys.contains("Mode") && dict["Mode"] != nil {
                self.mode = dict["Mode"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var configList: [DescribeWebLockConfigListResponseBody.ConfigList]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configList != nil {
            var tmp : [Any] = []
            for k in self.configList! {
                tmp.append(k.toMap())
            }
            map["ConfigList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigList") && dict["ConfigList"] != nil {
            var tmp : [DescribeWebLockConfigListResponseBody.ConfigList] = []
            for v in dict["ConfigList"] as! [Any] {
                var model = DescribeWebLockConfigListResponseBody.ConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeWebLockConfigListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebLockConfigListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebLockConfigListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebLockExclusiveFileTypeResponseBody : Tea.TeaModel {
    public var exclusiveFileType: [String]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exclusiveFileType != nil {
            map["ExclusiveFileType"] = self.exclusiveFileType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExclusiveFileType") && dict["ExclusiveFileType"] != nil {
            self.exclusiveFileType = dict["ExclusiveFileType"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeWebLockExclusiveFileTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebLockExclusiveFileTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebLockExclusiveFileTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebLockFileChangeStatisticsRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeWebLockFileChangeStatisticsResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var count: Int32?

        public var file: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.file != nil {
                map["File"] = self.file!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("File") && dict["File"] != nil {
                self.file = dict["File"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var list: [DescribeWebLockFileChangeStatisticsResponseBody.List]?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [DescribeWebLockFileChangeStatisticsResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = DescribeWebLockFileChangeStatisticsResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeWebLockFileChangeStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebLockFileChangeStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebLockFileChangeStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebLockFileEventsRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var dealed: String?

    public var pageSize: Int32?

    public var processName: String?

    public var remark: String?

    public var tsBegin: Int64?

    public var tsEnd: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processName != nil {
            map["ProcessName"] = self.processName!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.tsBegin != nil {
            map["TsBegin"] = self.tsBegin!
        }
        if self.tsEnd != nil {
            map["TsEnd"] = self.tsEnd!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
            self.processName = dict["ProcessName"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("TsBegin") && dict["TsBegin"] != nil {
            self.tsBegin = dict["TsBegin"] as! Int64
        }
        if dict.keys.contains("TsEnd") && dict["TsEnd"] != nil {
            self.tsEnd = dict["TsEnd"] as! Int64
        }
    }
}

public class DescribeWebLockFileEventsResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var count: Int64?

        public var ds: Int64?

        public var eventName: String?

        public var eventStatus: String?

        public var eventType: String?

        public var gmtEvent: Int64?

        public var id: Int64?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var level: String?

        public var path: String?

        public var processName: String?

        public var processPath: String?

        public var status: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.ds != nil {
                map["Ds"] = self.ds!
            }
            if self.eventName != nil {
                map["EventName"] = self.eventName!
            }
            if self.eventStatus != nil {
                map["EventStatus"] = self.eventStatus!
            }
            if self.eventType != nil {
                map["EventType"] = self.eventType!
            }
            if self.gmtEvent != nil {
                map["GmtEvent"] = self.gmtEvent!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.processName != nil {
                map["ProcessName"] = self.processName!
            }
            if self.processPath != nil {
                map["ProcessPath"] = self.processPath!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int64
            }
            if dict.keys.contains("Ds") && dict["Ds"] != nil {
                self.ds = dict["Ds"] as! Int64
            }
            if dict.keys.contains("EventName") && dict["EventName"] != nil {
                self.eventName = dict["EventName"] as! String
            }
            if dict.keys.contains("EventStatus") && dict["EventStatus"] != nil {
                self.eventStatus = dict["EventStatus"] as! String
            }
            if dict.keys.contains("EventType") && dict["EventType"] != nil {
                self.eventType = dict["EventType"] as! String
            }
            if dict.keys.contains("GmtEvent") && dict["GmtEvent"] != nil {
                self.gmtEvent = dict["GmtEvent"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
                self.processName = dict["ProcessName"] as! String
            }
            if dict.keys.contains("ProcessPath") && dict["ProcessPath"] != nil {
                self.processPath = dict["ProcessPath"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var list: [DescribeWebLockFileEventsResponseBody.List]?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [DescribeWebLockFileEventsResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = DescribeWebLockFileEventsResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeWebLockFileEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebLockFileEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebLockFileEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebLockFileTypeSummaryResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var count: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var list: [DescribeWebLockFileTypeSummaryResponseBody.List]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [DescribeWebLockFileTypeSummaryResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = DescribeWebLockFileTypeSummaryResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeWebLockFileTypeSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebLockFileTypeSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebLockFileTypeSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebLockInclusiveFileTypeResponseBody : Tea.TeaModel {
    public var inclusiveFileType: [String]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inclusiveFileType != nil {
            map["InclusiveFileType"] = self.inclusiveFileType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InclusiveFileType") && dict["InclusiveFileType"] != nil {
            self.inclusiveFileType = dict["InclusiveFileType"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeWebLockInclusiveFileTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebLockInclusiveFileTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebLockInclusiveFileTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebLockProcessBlockStatisticsRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeWebLockProcessBlockStatisticsResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var count: Int32?

        public var process: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.process != nil {
                map["Process"] = self.process!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Process") && dict["Process"] != nil {
                self.process = dict["Process"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var list: [DescribeWebLockProcessBlockStatisticsResponseBody.List]?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [DescribeWebLockProcessBlockStatisticsResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = DescribeWebLockProcessBlockStatisticsResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeWebLockProcessBlockStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebLockProcessBlockStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebLockProcessBlockStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebLockProcessListRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var processName: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.processName != nil {
            map["ProcessName"] = self.processName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
            self.processName = dict["ProcessName"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class DescribeWebLockProcessListResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var count: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var processName: String?

        public var processPath: String?

        public var status: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.processName != nil {
                map["ProcessName"] = self.processName!
            }
            if self.processPath != nil {
                map["ProcessPath"] = self.processPath!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("ProcessName") && dict["ProcessName"] != nil {
                self.processName = dict["ProcessName"] as! String
            }
            if dict.keys.contains("ProcessPath") && dict["ProcessPath"] != nil {
                self.processPath = dict["ProcessPath"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var list: [DescribeWebLockProcessListResponseBody.List]?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [DescribeWebLockProcessListResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = DescribeWebLockProcessListResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeWebLockProcessListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebLockProcessListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebLockProcessListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebLockStatusRequest : Tea.TeaModel {
    public var from: String?

    public var lang: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class DescribeWebLockStatusResponseBody : Tea.TeaModel {
    public var authCount: Int32?

    public var bindCount: Int32?

    public var blockCount: Int32?

    public var dirCount: Int32?

    public var expireTime: Int64?

    public var requestId: String?

    public var whiteCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authCount != nil {
            map["AuthCount"] = self.authCount!
        }
        if self.bindCount != nil {
            map["BindCount"] = self.bindCount!
        }
        if self.blockCount != nil {
            map["BlockCount"] = self.blockCount!
        }
        if self.dirCount != nil {
            map["DirCount"] = self.dirCount!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.whiteCount != nil {
            map["WhiteCount"] = self.whiteCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthCount") && dict["AuthCount"] != nil {
            self.authCount = dict["AuthCount"] as! Int32
        }
        if dict.keys.contains("BindCount") && dict["BindCount"] != nil {
            self.bindCount = dict["BindCount"] as! Int32
        }
        if dict.keys.contains("BlockCount") && dict["BlockCount"] != nil {
            self.blockCount = dict["BlockCount"] as! Int32
        }
        if dict.keys.contains("DirCount") && dict["DirCount"] != nil {
            self.dirCount = dict["DirCount"] as! Int32
        }
        if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
            self.expireTime = dict["ExpireTime"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WhiteCount") && dict["WhiteCount"] != nil {
            self.whiteCount = dict["WhiteCount"] as! Int32
        }
    }
}

public class DescribeWebLockStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebLockStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebLockStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebLockTotalFileChangeCountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeWebLockTotalFileChangeCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebLockTotalFileChangeCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebLockTotalFileChangeCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWebPathRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeWebPathResponseBody : Tea.TeaModel {
    public class ConfigList : Tea.TeaModel {
        public class TargetList : Tea.TeaModel {
            public var target: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.target != nil {
                    map["Target"] = self.target!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Target") && dict["Target"] != nil {
                    self.target = dict["Target"] as! String
                }
                if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                    self.targetType = dict["TargetType"] as! String
                }
            }
        }
        public var targetList: [DescribeWebPathResponseBody.ConfigList.TargetList]?

        public var webPath: String?

        public var webPathType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.targetList != nil {
                var tmp : [Any] = []
                for k in self.targetList! {
                    tmp.append(k.toMap())
                }
                map["TargetList"] = tmp
            }
            if self.webPath != nil {
                map["WebPath"] = self.webPath!
            }
            if self.webPathType != nil {
                map["WebPathType"] = self.webPathType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TargetList") && dict["TargetList"] != nil {
                var tmp : [DescribeWebPathResponseBody.ConfigList.TargetList] = []
                for v in dict["TargetList"] as! [Any] {
                    var model = DescribeWebPathResponseBody.ConfigList.TargetList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.targetList = tmp
            }
            if dict.keys.contains("WebPath") && dict["WebPath"] != nil {
                self.webPath = dict["WebPath"] as! String
            }
            if dict.keys.contains("WebPathType") && dict["WebPathType"] != nil {
                self.webPathType = dict["WebPathType"] as! String
            }
        }
    }
    public var configList: [DescribeWebPathResponseBody.ConfigList]?

    public var count: Int32?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configList != nil {
            var tmp : [Any] = []
            for k in self.configList! {
                tmp.append(k.toMap())
            }
            map["ConfigList"] = tmp
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigList") && dict["ConfigList"] != nil {
            var tmp : [DescribeWebPathResponseBody.ConfigList] = []
            for v in dict["ConfigList"] as! [Any] {
                var model = DescribeWebPathResponseBody.ConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configList = tmp
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeWebPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWebPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeWebPathResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableBruteForceRecordRequest : Tea.TeaModel {
    public var blockIp: String?

    public var bound: String?

    public var id: Int64?

    public var port: String?

    public var resourceOwnerId: Int64?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockIp != nil {
            map["BlockIp"] = self.blockIp!
        }
        if self.bound != nil {
            map["Bound"] = self.bound!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockIp") && dict["BlockIp"] != nil {
            self.blockIp = dict["BlockIp"] as! String
        }
        if dict.keys.contains("Bound") && dict["Bound"] != nil {
            self.bound = dict["Bound"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class DisableBruteForceRecordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableBruteForceRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableBruteForceRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableBruteForceRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableCustomBlockRecordRequest : Tea.TeaModel {
    public var blockIp: String?

    public var bound: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockIp != nil {
            map["BlockIp"] = self.blockIp!
        }
        if self.bound != nil {
            map["Bound"] = self.bound!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockIp") && dict["BlockIp"] != nil {
            self.blockIp = dict["BlockIp"] as! String
        }
        if dict.keys.contains("Bound") && dict["Bound"] != nil {
            self.bound = dict["Bound"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DisableCustomBlockRecordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableCustomBlockRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableCustomBlockRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableCustomBlockRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableBruteForceRecordRequest : Tea.TeaModel {
    public var blockIp: String?

    public var bound: String?

    public var id: Int64?

    public var port: String?

    public var resourceOwnerId: Int64?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockIp != nil {
            map["BlockIp"] = self.blockIp!
        }
        if self.bound != nil {
            map["Bound"] = self.bound!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockIp") && dict["BlockIp"] != nil {
            self.blockIp = dict["BlockIp"] as! String
        }
        if dict.keys.contains("Bound") && dict["Bound"] != nil {
            self.bound = dict["Bound"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class EnableBruteForceRecordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableBruteForceRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableBruteForceRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableBruteForceRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableCustomBlockRecordRequest : Tea.TeaModel {
    public var blockIp: String?

    public var bound: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockIp != nil {
            map["BlockIp"] = self.blockIp!
        }
        if self.bound != nil {
            map["Bound"] = self.bound!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockIp") && dict["BlockIp"] != nil {
            self.blockIp = dict["BlockIp"] as! String
        }
        if dict.keys.contains("Bound") && dict["Bound"] != nil {
            self.bound = dict["Bound"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class EnableCustomBlockRecordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableCustomBlockRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableCustomBlockRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableCustomBlockRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecStrategyRequest : Tea.TeaModel {
    public var lang: String?

    public var strategyId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
            self.strategyId = dict["StrategyId"] as! Int32
        }
    }
}

public class ExecStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExecStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExecStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportRecordRequest : Tea.TeaModel {
    public var exportType: String?

    public var lang: String?

    public var params: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exportType != nil {
            map["ExportType"] = self.exportType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExportType") && dict["ExportType"] != nil {
            self.exportType = dict["ExportType"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! String
        }
    }
}

public class ExportRecordResponseBody : Tea.TeaModel {
    public var fileName: String?

    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportSuspEventsRequest : Tea.TeaModel {
    public var assetsTypeList: [String]?

    public var clusterId: String?

    public var containerFieldName: String?

    public var containerFieldValue: String?

    public var currentPage: String?

    public var dealed: String?

    public var from: String?

    public var lang: String?

    public var levels: String?

    public var name: String?

    public var pageSize: String?

    public var parentEventTypes: String?

    public var remark: String?

    public var sourceIp: String?

    public var status: String?

    public var targetType: String?

    public var timeEnd: String?

    public var timeStart: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetsTypeList != nil {
            map["AssetsTypeList"] = self.assetsTypeList!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.containerFieldName != nil {
            map["ContainerFieldName"] = self.containerFieldName!
        }
        if self.containerFieldValue != nil {
            map["ContainerFieldValue"] = self.containerFieldValue!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.levels != nil {
            map["Levels"] = self.levels!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentEventTypes != nil {
            map["ParentEventTypes"] = self.parentEventTypes!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.timeEnd != nil {
            map["TimeEnd"] = self.timeEnd!
        }
        if self.timeStart != nil {
            map["TimeStart"] = self.timeStart!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetsTypeList") && dict["AssetsTypeList"] != nil {
            self.assetsTypeList = dict["AssetsTypeList"] as! [String]
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ContainerFieldName") && dict["ContainerFieldName"] != nil {
            self.containerFieldName = dict["ContainerFieldName"] as! String
        }
        if dict.keys.contains("ContainerFieldValue") && dict["ContainerFieldValue"] != nil {
            self.containerFieldValue = dict["ContainerFieldValue"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! String
        }
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Levels") && dict["Levels"] != nil {
            self.levels = dict["Levels"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("ParentEventTypes") && dict["ParentEventTypes"] != nil {
            self.parentEventTypes = dict["ParentEventTypes"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("TimeEnd") && dict["TimeEnd"] != nil {
            self.timeEnd = dict["TimeEnd"] as! String
        }
        if dict.keys.contains("TimeStart") && dict["TimeStart"] != nil {
            self.timeStart = dict["TimeStart"] as! String
        }
    }
}

public class ExportSuspEventsResponseBody : Tea.TeaModel {
    public var fileName: String?

    public var id: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportSuspEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportSuspEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportSuspEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportVulRequest : Tea.TeaModel {
    public var aliasName: String?

    public var attachTypes: String?

    public var dealed: String?

    public var groupId: String?

    public var lang: String?

    public var necessity: String?

    public var searchTags: String?

    public var type: String?

    public var uuids: String?

    public var vpcInstanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliasName != nil {
            map["AliasName"] = self.aliasName!
        }
        if self.attachTypes != nil {
            map["AttachTypes"] = self.attachTypes!
        }
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.necessity != nil {
            map["Necessity"] = self.necessity!
        }
        if self.searchTags != nil {
            map["SearchTags"] = self.searchTags!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        if self.vpcInstanceIds != nil {
            map["VpcInstanceIds"] = self.vpcInstanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
            self.aliasName = dict["AliasName"] as! String
        }
        if dict.keys.contains("AttachTypes") && dict["AttachTypes"] != nil {
            self.attachTypes = dict["AttachTypes"] as! String
        }
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Necessity") && dict["Necessity"] != nil {
            self.necessity = dict["Necessity"] as! String
        }
        if dict.keys.contains("SearchTags") && dict["SearchTags"] != nil {
            self.searchTags = dict["SearchTags"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
        if dict.keys.contains("VpcInstanceIds") && dict["VpcInstanceIds"] != nil {
            self.vpcInstanceIds = dict["VpcInstanceIds"] as! String
        }
    }
}

public class ExportVulResponseBody : Tea.TeaModel {
    public var fileName: String?

    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportVulResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportVulResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportVulResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportWarningRequest : Tea.TeaModel {
    public var dealed: String?

    public var exportType: String?

    public var isCleartextPwd: Int32?

    public var isSummaryExport: Int32?

    public var lang: String?

    public var riskIds: String?

    public var riskLevels: String?

    public var riskName: String?

    public var sourceIp: String?

    public var statusList: String?

    public var strategyId: Int64?

    public var subTypeNames: String?

    public var typeName: String?

    public var typeNames: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.exportType != nil {
            map["ExportType"] = self.exportType!
        }
        if self.isCleartextPwd != nil {
            map["IsCleartextPwd"] = self.isCleartextPwd!
        }
        if self.isSummaryExport != nil {
            map["IsSummaryExport"] = self.isSummaryExport!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.riskIds != nil {
            map["RiskIds"] = self.riskIds!
        }
        if self.riskLevels != nil {
            map["RiskLevels"] = self.riskLevels!
        }
        if self.riskName != nil {
            map["RiskName"] = self.riskName!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.subTypeNames != nil {
            map["SubTypeNames"] = self.subTypeNames!
        }
        if self.typeName != nil {
            map["TypeName"] = self.typeName!
        }
        if self.typeNames != nil {
            map["TypeNames"] = self.typeNames!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("ExportType") && dict["ExportType"] != nil {
            self.exportType = dict["ExportType"] as! String
        }
        if dict.keys.contains("IsCleartextPwd") && dict["IsCleartextPwd"] != nil {
            self.isCleartextPwd = dict["IsCleartextPwd"] as! Int32
        }
        if dict.keys.contains("IsSummaryExport") && dict["IsSummaryExport"] != nil {
            self.isSummaryExport = dict["IsSummaryExport"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RiskIds") && dict["RiskIds"] != nil {
            self.riskIds = dict["RiskIds"] as! String
        }
        if dict.keys.contains("RiskLevels") && dict["RiskLevels"] != nil {
            self.riskLevels = dict["RiskLevels"] as! String
        }
        if dict.keys.contains("RiskName") && dict["RiskName"] != nil {
            self.riskName = dict["RiskName"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! String
        }
        if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
            self.strategyId = dict["StrategyId"] as! Int64
        }
        if dict.keys.contains("SubTypeNames") && dict["SubTypeNames"] != nil {
            self.subTypeNames = dict["SubTypeNames"] as! String
        }
        if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
            self.typeName = dict["TypeName"] as! String
        }
        if dict.keys.contains("TypeNames") && dict["TypeNames"] != nil {
            self.typeNames = dict["TypeNames"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class ExportWarningResponseBody : Tea.TeaModel {
    public var fileName: String?

    public var id: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportWarningResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportWarningResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportWarningResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FindContainerNetworkConnectRequest : Tea.TeaModel {
    public class DstNode : Tea.TeaModel {
        public var appName: String?

        public var clusterId: String?

        public var namespace: String?

        public var nodeIds: [String]?

        public var nodeType: String?

        public var podName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.nodeIds != nil {
                map["NodeIds"] = self.nodeIds!
            }
            if self.nodeType != nil {
                map["NodeType"] = self.nodeType!
            }
            if self.podName != nil {
                map["PodName"] = self.podName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NodeIds") && dict["NodeIds"] != nil {
                self.nodeIds = dict["NodeIds"] as! [String]
            }
            if dict.keys.contains("NodeType") && dict["NodeType"] != nil {
                self.nodeType = dict["NodeType"] as! String
            }
            if dict.keys.contains("PodName") && dict["PodName"] != nil {
                self.podName = dict["PodName"] as! String
            }
        }
    }
    public class SrcNode : Tea.TeaModel {
        public var appName: String?

        public var clusterId: String?

        public var namespace: String?

        public var nodeIds: [String]?

        public var nodeType: String?

        public var podName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.nodeIds != nil {
                map["NodeIds"] = self.nodeIds!
            }
            if self.nodeType != nil {
                map["NodeType"] = self.nodeType!
            }
            if self.podName != nil {
                map["PodName"] = self.podName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NodeIds") && dict["NodeIds"] != nil {
                self.nodeIds = dict["NodeIds"] as! [String]
            }
            if dict.keys.contains("NodeType") && dict["NodeType"] != nil {
                self.nodeType = dict["NodeType"] as! String
            }
            if dict.keys.contains("PodName") && dict["PodName"] != nil {
                self.podName = dict["PodName"] as! String
            }
        }
    }
    public var criteriaType: String?

    public var currentPage: Int64?

    public var dstNode: FindContainerNetworkConnectRequest.DstNode?

    public var endTime: Int64?

    public var pageSize: Int64?

    public var srcNode: FindContainerNetworkConnectRequest.SrcNode?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dstNode?.validate()
        try self.srcNode?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteriaType != nil {
            map["CriteriaType"] = self.criteriaType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dstNode != nil {
            map["DstNode"] = self.dstNode?.toMap()
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.srcNode != nil {
            map["SrcNode"] = self.srcNode?.toMap()
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CriteriaType") && dict["CriteriaType"] != nil {
            self.criteriaType = dict["CriteriaType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int64
        }
        if dict.keys.contains("DstNode") && dict["DstNode"] != nil {
            var model = FindContainerNetworkConnectRequest.DstNode()
            model.fromMap(dict["DstNode"] as! [String: Any])
            self.dstNode = model
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SrcNode") && dict["SrcNode"] != nil {
            var model = FindContainerNetworkConnectRequest.SrcNode()
            model.fromMap(dict["SrcNode"] as! [String: Any])
            self.srcNode = model
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class FindContainerNetworkConnectShrinkRequest : Tea.TeaModel {
    public var criteriaType: String?

    public var currentPage: Int64?

    public var dstNodeShrink: String?

    public var endTime: Int64?

    public var pageSize: Int64?

    public var srcNodeShrink: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteriaType != nil {
            map["CriteriaType"] = self.criteriaType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dstNodeShrink != nil {
            map["DstNode"] = self.dstNodeShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.srcNodeShrink != nil {
            map["SrcNode"] = self.srcNodeShrink!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CriteriaType") && dict["CriteriaType"] != nil {
            self.criteriaType = dict["CriteriaType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int64
        }
        if dict.keys.contains("DstNode") && dict["DstNode"] != nil {
            self.dstNodeShrink = dict["DstNode"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SrcNode") && dict["SrcNode"] != nil {
            self.srcNodeShrink = dict["SrcNode"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class FindContainerNetworkConnectResponseBody : Tea.TeaModel {
    public class Connects : Tea.TeaModel {
        public class DstContainer : Tea.TeaModel {
            public var containerId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.containerId != nil {
                    map["ContainerId"] = self.containerId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                    self.containerId = dict["ContainerId"] as! String
                }
            }
        }
        public class SrcContainer : Tea.TeaModel {
            public var containerId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.containerId != nil {
                    map["ContainerId"] = self.containerId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                    self.containerId = dict["ContainerId"] as! String
                }
            }
        }
        public var dstContainer: FindContainerNetworkConnectResponseBody.Connects.DstContainer?

        public var dstIp: String?

        public var dstPort: String?

        public var firstTime: Int64?

        public var id: Int64?

        public var lastTime: Int64?

        public var srcContainer: FindContainerNetworkConnectResponseBody.Connects.SrcContainer?

        public var srcIp: String?

        public var srcPort: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dstContainer?.validate()
            try self.srcContainer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dstContainer != nil {
                map["DstContainer"] = self.dstContainer?.toMap()
            }
            if self.dstIp != nil {
                map["DstIp"] = self.dstIp!
            }
            if self.dstPort != nil {
                map["DstPort"] = self.dstPort!
            }
            if self.firstTime != nil {
                map["FirstTime"] = self.firstTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.lastTime != nil {
                map["LastTime"] = self.lastTime!
            }
            if self.srcContainer != nil {
                map["SrcContainer"] = self.srcContainer?.toMap()
            }
            if self.srcIp != nil {
                map["SrcIp"] = self.srcIp!
            }
            if self.srcPort != nil {
                map["SrcPort"] = self.srcPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DstContainer") && dict["DstContainer"] != nil {
                var model = FindContainerNetworkConnectResponseBody.Connects.DstContainer()
                model.fromMap(dict["DstContainer"] as! [String: Any])
                self.dstContainer = model
            }
            if dict.keys.contains("DstIp") && dict["DstIp"] != nil {
                self.dstIp = dict["DstIp"] as! String
            }
            if dict.keys.contains("DstPort") && dict["DstPort"] != nil {
                self.dstPort = dict["DstPort"] as! String
            }
            if dict.keys.contains("FirstTime") && dict["FirstTime"] != nil {
                self.firstTime = dict["FirstTime"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
                self.lastTime = dict["LastTime"] as! Int64
            }
            if dict.keys.contains("SrcContainer") && dict["SrcContainer"] != nil {
                var model = FindContainerNetworkConnectResponseBody.Connects.SrcContainer()
                model.fromMap(dict["SrcContainer"] as! [String: Any])
                self.srcContainer = model
            }
            if dict.keys.contains("SrcIp") && dict["SrcIp"] != nil {
                self.srcIp = dict["SrcIp"] as! String
            }
            if dict.keys.contains("SrcPort") && dict["SrcPort"] != nil {
                self.srcPort = dict["SrcPort"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int64?

        public var currentPage: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int64
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int64
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var connects: [FindContainerNetworkConnectResponseBody.Connects]?

    public var pageInfo: FindContainerNetworkConnectResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connects != nil {
            var tmp : [Any] = []
            for k in self.connects! {
                tmp.append(k.toMap())
            }
            map["Connects"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Connects") && dict["Connects"] != nil {
            var tmp : [FindContainerNetworkConnectResponseBody.Connects] = []
            for v in dict["Connects"] as! [Any] {
                var model = FindContainerNetworkConnectResponseBody.Connects()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.connects = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = FindContainerNetworkConnectResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class FindContainerNetworkConnectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FindContainerNetworkConnectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = FindContainerNetworkConnectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FixCheckWarningsRequest : Tea.TeaModel {
    public var checkParams: String?

    public var lang: String?

    public var riskId: Int64?

    public var sourceIp: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkParams != nil {
            map["CheckParams"] = self.checkParams!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.riskId != nil {
            map["RiskId"] = self.riskId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckParams") && dict["CheckParams"] != nil {
            self.checkParams = dict["CheckParams"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
            self.riskId = dict["RiskId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class FixCheckWarningsResponseBody : Tea.TeaModel {
    public var batchId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchId != nil {
            map["BatchId"] = self.batchId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchId") && dict["BatchId"] != nil {
            self.batchId = dict["BatchId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class FixCheckWarningsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FixCheckWarningsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = FixCheckWarningsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GenerateOnceTaskRequest : Tea.TeaModel {
    public var param: String?

    public var source: String?

    public var taskName: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.param != nil {
            map["Param"] = self.param!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.param = dict["Param"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class GenerateOnceTaskResponseBody : Tea.TeaModel {
    public var canCreate: Bool?

    public var collectTime: Int64?

    public var finishCount: Int32?

    public var lastTask: String?

    public var requestId: String?

    public var taskId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.canCreate != nil {
            map["CanCreate"] = self.canCreate!
        }
        if self.collectTime != nil {
            map["CollectTime"] = self.collectTime!
        }
        if self.finishCount != nil {
            map["FinishCount"] = self.finishCount!
        }
        if self.lastTask != nil {
            map["LastTask"] = self.lastTask!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CanCreate") && dict["CanCreate"] != nil {
            self.canCreate = dict["CanCreate"] as! Bool
        }
        if dict.keys.contains("CollectTime") && dict["CollectTime"] != nil {
            self.collectTime = dict["CollectTime"] as! Int64
        }
        if dict.keys.contains("FinishCount") && dict["FinishCount"] != nil {
            self.finishCount = dict["FinishCount"] as! Int32
        }
        if dict.keys.contains("LastTask") && dict["LastTask"] != nil {
            self.lastTask = dict["LastTask"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class GenerateOnceTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GenerateOnceTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GenerateOnceTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAgentlessTaskCountResponseBody : Tea.TeaModel {
    public var baselineCheckCount: Int32?

    public var cveVulCount: Int32?

    public var lastTaskTime: Int64?

    public var maliciousFile: Int32?

    public var requestId: String?

    public var riskMachine: Int32?

    public var scaVulCount: Int32?

    public var scanMachine: Int32?

    public var sysVulCount: String?

    public var vulnerability: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineCheckCount != nil {
            map["BaselineCheckCount"] = self.baselineCheckCount!
        }
        if self.cveVulCount != nil {
            map["CveVulCount"] = self.cveVulCount!
        }
        if self.lastTaskTime != nil {
            map["LastTaskTime"] = self.lastTaskTime!
        }
        if self.maliciousFile != nil {
            map["MaliciousFile"] = self.maliciousFile!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.riskMachine != nil {
            map["RiskMachine"] = self.riskMachine!
        }
        if self.scaVulCount != nil {
            map["ScaVulCount"] = self.scaVulCount!
        }
        if self.scanMachine != nil {
            map["ScanMachine"] = self.scanMachine!
        }
        if self.sysVulCount != nil {
            map["SysVulCount"] = self.sysVulCount!
        }
        if self.vulnerability != nil {
            map["Vulnerability"] = self.vulnerability!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineCheckCount") && dict["BaselineCheckCount"] != nil {
            self.baselineCheckCount = dict["BaselineCheckCount"] as! Int32
        }
        if dict.keys.contains("CveVulCount") && dict["CveVulCount"] != nil {
            self.cveVulCount = dict["CveVulCount"] as! Int32
        }
        if dict.keys.contains("LastTaskTime") && dict["LastTaskTime"] != nil {
            self.lastTaskTime = dict["LastTaskTime"] as! Int64
        }
        if dict.keys.contains("MaliciousFile") && dict["MaliciousFile"] != nil {
            self.maliciousFile = dict["MaliciousFile"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RiskMachine") && dict["RiskMachine"] != nil {
            self.riskMachine = dict["RiskMachine"] as! Int32
        }
        if dict.keys.contains("ScaVulCount") && dict["ScaVulCount"] != nil {
            self.scaVulCount = dict["ScaVulCount"] as! Int32
        }
        if dict.keys.contains("ScanMachine") && dict["ScanMachine"] != nil {
            self.scanMachine = dict["ScanMachine"] as! Int32
        }
        if dict.keys.contains("SysVulCount") && dict["SysVulCount"] != nil {
            self.sysVulCount = dict["SysVulCount"] as! String
        }
        if dict.keys.contains("Vulnerability") && dict["Vulnerability"] != nil {
            self.vulnerability = dict["Vulnerability"] as! Int32
        }
    }
}

public class GetAgentlessTaskCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAgentlessTaskCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAgentlessTaskCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAlarmMachineCountRequest : Tea.TeaModel {
    public var from: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
    }
}

public class GetAlarmMachineCountResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var machineCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.machineCount != nil {
                map["MachineCount"] = self.machineCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MachineCount") && dict["MachineCount"] != nil {
                self.machineCount = dict["MachineCount"] as! Int32
            }
        }
    }
    public var data: GetAlarmMachineCountResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetAlarmMachineCountResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAlarmMachineCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAlarmMachineCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAlarmMachineCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAppNetworkRequest : Tea.TeaModel {
    public var clusterId: String?

    public var endTime: Int64?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetAppNetworkResponseBody : Tea.TeaModel {
    public class AppNetwork : Tea.TeaModel {
        public class Edge : Tea.TeaModel {
            public var dstNodeId: String?

            public var dstNodeType: String?

            public var id: String?

            public var port: String?

            public var srcNodeId: String?

            public var srcNodeType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dstNodeId != nil {
                    map["DstNodeId"] = self.dstNodeId!
                }
                if self.dstNodeType != nil {
                    map["DstNodeType"] = self.dstNodeType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.srcNodeId != nil {
                    map["SrcNodeId"] = self.srcNodeId!
                }
                if self.srcNodeType != nil {
                    map["SrcNodeType"] = self.srcNodeType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DstNodeId") && dict["DstNodeId"] != nil {
                    self.dstNodeId = dict["DstNodeId"] as! String
                }
                if dict.keys.contains("DstNodeType") && dict["DstNodeType"] != nil {
                    self.dstNodeType = dict["DstNodeType"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("SrcNodeId") && dict["SrcNodeId"] != nil {
                    self.srcNodeId = dict["SrcNodeId"] as! String
                }
                if dict.keys.contains("SrcNodeType") && dict["SrcNodeType"] != nil {
                    self.srcNodeType = dict["SrcNodeType"] as! String
                }
            }
        }
        public class Namespace : Tea.TeaModel {
            public var id: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public class Node : Tea.TeaModel {
            public var containerIds: [String]?

            public var id: String?

            public var name: String?

            public var namespaceId: String?

            public var riskLevel: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.containerIds != nil {
                    map["ContainerIds"] = self.containerIds!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.riskLevel != nil {
                    map["RiskLevel"] = self.riskLevel!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContainerIds") && dict["ContainerIds"] != nil {
                    self.containerIds = dict["ContainerIds"] as! [String]
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NamespaceId") && dict["NamespaceId"] != nil {
                    self.namespaceId = dict["NamespaceId"] as! String
                }
                if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                    self.riskLevel = dict["RiskLevel"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var edge: [GetAppNetworkResponseBody.AppNetwork.Edge]?

        public var namespace: [GetAppNetworkResponseBody.AppNetwork.Namespace]?

        public var node: [GetAppNetworkResponseBody.AppNetwork.Node]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edge != nil {
                var tmp : [Any] = []
                for k in self.edge! {
                    tmp.append(k.toMap())
                }
                map["Edge"] = tmp
            }
            if self.namespace != nil {
                var tmp : [Any] = []
                for k in self.namespace! {
                    tmp.append(k.toMap())
                }
                map["Namespace"] = tmp
            }
            if self.node != nil {
                var tmp : [Any] = []
                for k in self.node! {
                    tmp.append(k.toMap())
                }
                map["Node"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Edge") && dict["Edge"] != nil {
                var tmp : [GetAppNetworkResponseBody.AppNetwork.Edge] = []
                for v in dict["Edge"] as! [Any] {
                    var model = GetAppNetworkResponseBody.AppNetwork.Edge()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.edge = tmp
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                var tmp : [GetAppNetworkResponseBody.AppNetwork.Namespace] = []
                for v in dict["Namespace"] as! [Any] {
                    var model = GetAppNetworkResponseBody.AppNetwork.Namespace()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.namespace = tmp
            }
            if dict.keys.contains("Node") && dict["Node"] != nil {
                var tmp : [GetAppNetworkResponseBody.AppNetwork.Node] = []
                for v in dict["Node"] as! [Any] {
                    var model = GetAppNetworkResponseBody.AppNetwork.Node()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.node = tmp
            }
        }
    }
    public var appNetwork: GetAppNetworkResponseBody.AppNetwork?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appNetwork?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appNetwork != nil {
            map["AppNetwork"] = self.appNetwork?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppNetwork") && dict["AppNetwork"] != nil {
            var model = GetAppNetworkResponseBody.AppNetwork()
            model.fromMap(dict["AppNetwork"] as! [String: Any])
            self.appNetwork = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAppNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAppNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAssetDetailByUuidRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class GetAssetDetailByUuidResponseBody : Tea.TeaModel {
    public class AssetDetail : Tea.TeaModel {
        public class DiskInfoList : Tea.TeaModel {
            public var diskName: String?

            public var totalSize: Int64?

            public var totalSizeByte: Int64?

            public var useSize: Int64?

            public var useSizeByte: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.totalSize != nil {
                    map["TotalSize"] = self.totalSize!
                }
                if self.totalSizeByte != nil {
                    map["TotalSizeByte"] = self.totalSizeByte!
                }
                if self.useSize != nil {
                    map["UseSize"] = self.useSize!
                }
                if self.useSizeByte != nil {
                    map["UseSizeByte"] = self.useSizeByte!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("TotalSize") && dict["TotalSize"] != nil {
                    self.totalSize = dict["TotalSize"] as! Int64
                }
                if dict.keys.contains("TotalSizeByte") && dict["TotalSizeByte"] != nil {
                    self.totalSizeByte = dict["TotalSizeByte"] as! Int64
                }
                if dict.keys.contains("UseSize") && dict["UseSize"] != nil {
                    self.useSize = dict["UseSize"] as! Int64
                }
                if dict.keys.contains("UseSizeByte") && dict["UseSizeByte"] != nil {
                    self.useSizeByte = dict["UseSizeByte"] as! Int64
                }
            }
        }
        public var assetType: String?

        public var authModifyTime: Int64?

        public var authVersion: Int32?

        public var bind: Bool?

        public var clientStatus: String?

        public var clientVersion: String?

        public var cpu: Int32?

        public var cpuInfo: String?

        public var createTime: Int64?

        public var diskInfoList: [GetAssetDetailByUuidResponseBody.AssetDetail.DiskInfoList]?

        public var flag: Int32?

        public var groupTrace: String?

        public var hostName: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var ipList: [String]?

        public var kernel: String?

        public var macList: [String]?

        public var mem: Int32?

        public var memory: Int64?

        public var os: String?

        public var osDetail: String?

        public var osName: String?

        public var region: String?

        public var regionId: String?

        public var regionName: String?

        public var sysInfo: String?

        public var tag: String?

        public var uuid: String?

        public var vpcInstanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assetType != nil {
                map["AssetType"] = self.assetType!
            }
            if self.authModifyTime != nil {
                map["AuthModifyTime"] = self.authModifyTime!
            }
            if self.authVersion != nil {
                map["AuthVersion"] = self.authVersion!
            }
            if self.bind != nil {
                map["Bind"] = self.bind!
            }
            if self.clientStatus != nil {
                map["ClientStatus"] = self.clientStatus!
            }
            if self.clientVersion != nil {
                map["ClientVersion"] = self.clientVersion!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.cpuInfo != nil {
                map["CpuInfo"] = self.cpuInfo!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.diskInfoList != nil {
                var tmp : [Any] = []
                for k in self.diskInfoList! {
                    tmp.append(k.toMap())
                }
                map["DiskInfoList"] = tmp
            }
            if self.flag != nil {
                map["Flag"] = self.flag!
            }
            if self.groupTrace != nil {
                map["GroupTrace"] = self.groupTrace!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.ipList != nil {
                map["IpList"] = self.ipList!
            }
            if self.kernel != nil {
                map["Kernel"] = self.kernel!
            }
            if self.macList != nil {
                map["MacList"] = self.macList!
            }
            if self.mem != nil {
                map["Mem"] = self.mem!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.osDetail != nil {
                map["OsDetail"] = self.osDetail!
            }
            if self.osName != nil {
                map["OsName"] = self.osName!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            if self.sysInfo != nil {
                map["SysInfo"] = self.sysInfo!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vpcInstanceId != nil {
                map["VpcInstanceId"] = self.vpcInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
                self.assetType = dict["AssetType"] as! String
            }
            if dict.keys.contains("AuthModifyTime") && dict["AuthModifyTime"] != nil {
                self.authModifyTime = dict["AuthModifyTime"] as! Int64
            }
            if dict.keys.contains("AuthVersion") && dict["AuthVersion"] != nil {
                self.authVersion = dict["AuthVersion"] as! Int32
            }
            if dict.keys.contains("Bind") && dict["Bind"] != nil {
                self.bind = dict["Bind"] as! Bool
            }
            if dict.keys.contains("ClientStatus") && dict["ClientStatus"] != nil {
                self.clientStatus = dict["ClientStatus"] as! String
            }
            if dict.keys.contains("ClientVersion") && dict["ClientVersion"] != nil {
                self.clientVersion = dict["ClientVersion"] as! String
            }
            if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CpuInfo") && dict["CpuInfo"] != nil {
                self.cpuInfo = dict["CpuInfo"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("DiskInfoList") && dict["DiskInfoList"] != nil {
                var tmp : [GetAssetDetailByUuidResponseBody.AssetDetail.DiskInfoList] = []
                for v in dict["DiskInfoList"] as! [Any] {
                    var model = GetAssetDetailByUuidResponseBody.AssetDetail.DiskInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.diskInfoList = tmp
            }
            if dict.keys.contains("Flag") && dict["Flag"] != nil {
                self.flag = dict["Flag"] as! Int32
            }
            if dict.keys.contains("GroupTrace") && dict["GroupTrace"] != nil {
                self.groupTrace = dict["GroupTrace"] as! String
            }
            if dict.keys.contains("HostName") && dict["HostName"] != nil {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("IpList") && dict["IpList"] != nil {
                self.ipList = dict["IpList"] as! [String]
            }
            if dict.keys.contains("Kernel") && dict["Kernel"] != nil {
                self.kernel = dict["Kernel"] as! String
            }
            if dict.keys.contains("MacList") && dict["MacList"] != nil {
                self.macList = dict["MacList"] as! [String]
            }
            if dict.keys.contains("Mem") && dict["Mem"] != nil {
                self.mem = dict["Mem"] as! Int32
            }
            if dict.keys.contains("Memory") && dict["Memory"] != nil {
                self.memory = dict["Memory"] as! Int64
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("OsDetail") && dict["OsDetail"] != nil {
                self.osDetail = dict["OsDetail"] as! String
            }
            if dict.keys.contains("OsName") && dict["OsName"] != nil {
                self.osName = dict["OsName"] as! String
            }
            if dict.keys.contains("Region") && dict["Region"] != nil {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                self.regionName = dict["RegionName"] as! String
            }
            if dict.keys.contains("SysInfo") && dict["SysInfo"] != nil {
                self.sysInfo = dict["SysInfo"] as! String
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VpcInstanceId") && dict["VpcInstanceId"] != nil {
                self.vpcInstanceId = dict["VpcInstanceId"] as! String
            }
        }
    }
    public var assetDetail: GetAssetDetailByUuidResponseBody.AssetDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.assetDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetDetail != nil {
            map["AssetDetail"] = self.assetDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetDetail") && dict["AssetDetail"] != nil {
            var model = GetAssetDetailByUuidResponseBody.AssetDetail()
            model.fromMap(dict["AssetDetail"] as! [String: Any])
            self.assetDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAssetDetailByUuidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAssetDetailByUuidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAssetDetailByUuidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAssetSelectionConfigRequest : Tea.TeaModel {
    public var businessType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") && dict["BusinessType"] != nil {
            self.businessType = dict["BusinessType"] as! String
        }
    }
}

public class GetAssetSelectionConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var selectionKey: String?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.selectionKey != nil {
                map["SelectionKey"] = self.selectionKey!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SelectionKey") && dict["SelectionKey"] != nil {
                self.selectionKey = dict["SelectionKey"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
        }
    }
    public var data: GetAssetSelectionConfigResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetAssetSelectionConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAssetSelectionConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAssetSelectionConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAssetSelectionConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAssetsPropertyDetailRequest : Tea.TeaModel {
    public class SearchCriteriaList : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var biz: String?

    public var currentPage: Int32?

    public var itemName: String?

    public var lang: String?

    public var pageSize: Int32?

    public var remark: String?

    public var searchCriteriaList: [GetAssetsPropertyDetailRequest.SearchCriteriaList]?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.biz != nil {
            map["Biz"] = self.biz!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.itemName != nil {
            map["ItemName"] = self.itemName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.searchCriteriaList != nil {
            var tmp : [Any] = []
            for k in self.searchCriteriaList! {
                tmp.append(k.toMap())
            }
            map["SearchCriteriaList"] = tmp
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Biz") && dict["Biz"] != nil {
            self.biz = dict["Biz"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ItemName") && dict["ItemName"] != nil {
            self.itemName = dict["ItemName"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SearchCriteriaList") && dict["SearchCriteriaList"] != nil {
            var tmp : [GetAssetsPropertyDetailRequest.SearchCriteriaList] = []
            for v in dict["SearchCriteriaList"] as! [Any] {
                var model = GetAssetsPropertyDetailRequest.SearchCriteriaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.searchCriteriaList = tmp
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class GetAssetsPropertyDetailResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class Propertys : Tea.TeaModel {
        public var containerName: String?

        public var createTimestamp: Int64?

        public var domain: String?

        public var filepath: String?

        public var imageName: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var ip: String?

        public var listenProtocol: String?

        public var moduleName: String?

        public var path: String?

        public var pathMode: String?

        public var pid: String?

        public var port: String?

        public var processStarted: Int64?

        public var regionId: String?

        public var serverType: String?

        public var size: Int32?

        public var usedByCount: Int32?

        public var user: String?

        public var uuid: String?

        public var webPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.containerName != nil {
                map["ContainerName"] = self.containerName!
            }
            if self.createTimestamp != nil {
                map["CreateTimestamp"] = self.createTimestamp!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.filepath != nil {
                map["Filepath"] = self.filepath!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.listenProtocol != nil {
                map["ListenProtocol"] = self.listenProtocol!
            }
            if self.moduleName != nil {
                map["ModuleName"] = self.moduleName!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.pathMode != nil {
                map["PathMode"] = self.pathMode!
            }
            if self.pid != nil {
                map["Pid"] = self.pid!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.processStarted != nil {
                map["ProcessStarted"] = self.processStarted!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.serverType != nil {
                map["ServerType"] = self.serverType!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.usedByCount != nil {
                map["UsedByCount"] = self.usedByCount!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.webPath != nil {
                map["WebPath"] = self.webPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContainerName") && dict["ContainerName"] != nil {
                self.containerName = dict["ContainerName"] as! String
            }
            if dict.keys.contains("CreateTimestamp") && dict["CreateTimestamp"] != nil {
                self.createTimestamp = dict["CreateTimestamp"] as! Int64
            }
            if dict.keys.contains("Domain") && dict["Domain"] != nil {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Filepath") && dict["Filepath"] != nil {
                self.filepath = dict["Filepath"] as! String
            }
            if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Ip") && dict["Ip"] != nil {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("ListenProtocol") && dict["ListenProtocol"] != nil {
                self.listenProtocol = dict["ListenProtocol"] as! String
            }
            if dict.keys.contains("ModuleName") && dict["ModuleName"] != nil {
                self.moduleName = dict["ModuleName"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("PathMode") && dict["PathMode"] != nil {
                self.pathMode = dict["PathMode"] as! String
            }
            if dict.keys.contains("Pid") && dict["Pid"] != nil {
                self.pid = dict["Pid"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("ProcessStarted") && dict["ProcessStarted"] != nil {
                self.processStarted = dict["ProcessStarted"] as! Int64
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ServerType") && dict["ServerType"] != nil {
                self.serverType = dict["ServerType"] as! String
            }
            if dict.keys.contains("Size") && dict["Size"] != nil {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("UsedByCount") && dict["UsedByCount"] != nil {
                self.usedByCount = dict["UsedByCount"] as! Int32
            }
            if dict.keys.contains("User") && dict["User"] != nil {
                self.user = dict["User"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("WebPath") && dict["WebPath"] != nil {
                self.webPath = dict["WebPath"] as! String
            }
        }
    }
    public var pageInfo: GetAssetsPropertyDetailResponseBody.PageInfo?

    public var propertys: [GetAssetsPropertyDetailResponseBody.Propertys]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertys != nil {
            var tmp : [Any] = []
            for k in self.propertys! {
                tmp.append(k.toMap())
            }
            map["Propertys"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = GetAssetsPropertyDetailResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("Propertys") && dict["Propertys"] != nil {
            var tmp : [GetAssetsPropertyDetailResponseBody.Propertys] = []
            for v in dict["Propertys"] as! [Any] {
                var model = GetAssetsPropertyDetailResponseBody.Propertys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertys = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAssetsPropertyDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAssetsPropertyDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAssetsPropertyDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAssetsPropertyItemRequest : Tea.TeaModel {
    public var biz: String?

    public var currentPage: Int32?

    public var forceFlush: Bool?

    public var lang: String?

    public var pageSize: Int32?

    public var searchInfo: String?

    public var searchItem: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.biz != nil {
            map["Biz"] = self.biz!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.forceFlush != nil {
            map["ForceFlush"] = self.forceFlush!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchInfo != nil {
            map["SearchInfo"] = self.searchInfo!
        }
        if self.searchItem != nil {
            map["SearchItem"] = self.searchItem!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Biz") && dict["Biz"] != nil {
            self.biz = dict["Biz"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ForceFlush") && dict["ForceFlush"] != nil {
            self.forceFlush = dict["ForceFlush"] as! Bool
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchInfo") && dict["SearchInfo"] != nil {
            self.searchInfo = dict["SearchInfo"] as! String
        }
        if dict.keys.contains("SearchItem") && dict["SearchItem"] != nil {
            self.searchItem = dict["SearchItem"] as! String
        }
    }
}

public class GetAssetsPropertyItemResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class PropertyItems : Tea.TeaModel {
        public var count: Int32?

        public var domain: String?

        public var moduleName: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.moduleName != nil {
                map["ModuleName"] = self.moduleName!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Domain") && dict["Domain"] != nil {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("ModuleName") && dict["ModuleName"] != nil {
                self.moduleName = dict["ModuleName"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var pageInfo: GetAssetsPropertyItemResponseBody.PageInfo?

    public var propertyItems: [GetAssetsPropertyItemResponseBody.PropertyItems]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.propertyItems != nil {
            var tmp : [Any] = []
            for k in self.propertyItems! {
                tmp.append(k.toMap())
            }
            map["PropertyItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = GetAssetsPropertyItemResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("PropertyItems") && dict["PropertyItems"] != nil {
            var tmp : [GetAssetsPropertyItemResponseBody.PropertyItems] = []
            for v in dict["PropertyItems"] as! [Any] {
                var model = GetAssetsPropertyItemResponseBody.PropertyItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.propertyItems = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAssetsPropertyItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAssetsPropertyItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAssetsPropertyItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAuthVersionStatisticResponseBody : Tea.TeaModel {
    public class Statistics : Tea.TeaModel {
        public var authVersion: Int32?

        public var count: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authVersion != nil {
                map["AuthVersion"] = self.authVersion!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthVersion") && dict["AuthVersion"] != nil {
                self.authVersion = dict["AuthVersion"] as! Int32
            }
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var statistics: [GetAuthVersionStatisticResponseBody.Statistics]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statistics != nil {
            var tmp : [Any] = []
            for k in self.statistics! {
                tmp.append(k.toMap())
            }
            map["Statistics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
            var tmp : [GetAuthVersionStatisticResponseBody.Statistics] = []
            for v in dict["Statistics"] as! [Any] {
                var model = GetAuthVersionStatisticResponseBody.Statistics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statistics = tmp
        }
    }
}

public class GetAuthVersionStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAuthVersionStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAuthVersionStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBackupStorageCountResponseBody : Tea.TeaModel {
    public class BackupStorageCount : Tea.TeaModel {
        public var buyStorageByte: Int64?

        public var ecsUsageStorageByte: Int64?

        public var overflow: Int32?

        public var uniUsageStorageByte: Int64?

        public var usageStorageByte: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.buyStorageByte != nil {
                map["BuyStorageByte"] = self.buyStorageByte!
            }
            if self.ecsUsageStorageByte != nil {
                map["EcsUsageStorageByte"] = self.ecsUsageStorageByte!
            }
            if self.overflow != nil {
                map["Overflow"] = self.overflow!
            }
            if self.uniUsageStorageByte != nil {
                map["UniUsageStorageByte"] = self.uniUsageStorageByte!
            }
            if self.usageStorageByte != nil {
                map["UsageStorageByte"] = self.usageStorageByte!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BuyStorageByte") && dict["BuyStorageByte"] != nil {
                self.buyStorageByte = dict["BuyStorageByte"] as! Int64
            }
            if dict.keys.contains("EcsUsageStorageByte") && dict["EcsUsageStorageByte"] != nil {
                self.ecsUsageStorageByte = dict["EcsUsageStorageByte"] as! Int64
            }
            if dict.keys.contains("Overflow") && dict["Overflow"] != nil {
                self.overflow = dict["Overflow"] as! Int32
            }
            if dict.keys.contains("UniUsageStorageByte") && dict["UniUsageStorageByte"] != nil {
                self.uniUsageStorageByte = dict["UniUsageStorageByte"] as! Int64
            }
            if dict.keys.contains("UsageStorageByte") && dict["UsageStorageByte"] != nil {
                self.usageStorageByte = dict["UsageStorageByte"] as! Int64
            }
        }
    }
    public var backupStorageCount: GetBackupStorageCountResponseBody.BackupStorageCount?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backupStorageCount?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupStorageCount != nil {
            map["BackupStorageCount"] = self.backupStorageCount?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackupStorageCount") && dict["BackupStorageCount"] != nil {
            var model = GetBackupStorageCountResponseBody.BackupStorageCount()
            model.fromMap(dict["BackupStorageCount"] as! [String: Any])
            self.backupStorageCount = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetBackupStorageCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBackupStorageCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetBackupStorageCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCheckConfigResponseBody : Tea.TeaModel {
    public class SelectedChecks : Tea.TeaModel {
        public var checkId: Int64?

        public var sectionId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.sectionId != nil {
                map["SectionId"] = self.sectionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                self.checkId = dict["CheckId"] as! Int64
            }
            if dict.keys.contains("SectionId") && dict["SectionId"] != nil {
                self.sectionId = dict["SectionId"] as! Int64
            }
        }
    }
    public class Standards : Tea.TeaModel {
        public var id: Int64?

        public var showName: String?

        public var status: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                self.showName = dict["ShowName"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var cycleDays: [Int32]?

    public var enableAddCheck: Bool?

    public var enableAutoCheck: Bool?

    public var endTime: Int32?

    public var requestId: String?

    public var selectedChecks: [GetCheckConfigResponseBody.SelectedChecks]?

    public var standards: [GetCheckConfigResponseBody.Standards]?

    public var startTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cycleDays != nil {
            map["CycleDays"] = self.cycleDays!
        }
        if self.enableAddCheck != nil {
            map["EnableAddCheck"] = self.enableAddCheck!
        }
        if self.enableAutoCheck != nil {
            map["EnableAutoCheck"] = self.enableAutoCheck!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.selectedChecks != nil {
            var tmp : [Any] = []
            for k in self.selectedChecks! {
                tmp.append(k.toMap())
            }
            map["SelectedChecks"] = tmp
        }
        if self.standards != nil {
            var tmp : [Any] = []
            for k in self.standards! {
                tmp.append(k.toMap())
            }
            map["Standards"] = tmp
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CycleDays") && dict["CycleDays"] != nil {
            self.cycleDays = dict["CycleDays"] as! [Int32]
        }
        if dict.keys.contains("EnableAddCheck") && dict["EnableAddCheck"] != nil {
            self.enableAddCheck = dict["EnableAddCheck"] as! Bool
        }
        if dict.keys.contains("EnableAutoCheck") && dict["EnableAutoCheck"] != nil {
            self.enableAutoCheck = dict["EnableAutoCheck"] as! Bool
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SelectedChecks") && dict["SelectedChecks"] != nil {
            var tmp : [GetCheckConfigResponseBody.SelectedChecks] = []
            for v in dict["SelectedChecks"] as! [Any] {
                var model = GetCheckConfigResponseBody.SelectedChecks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.selectedChecks = tmp
        }
        if dict.keys.contains("Standards") && dict["Standards"] != nil {
            var tmp : [GetCheckConfigResponseBody.Standards] = []
            for v in dict["Standards"] as! [Any] {
                var model = GetCheckConfigResponseBody.Standards()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.standards = tmp
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int32
        }
    }
}

public class GetCheckConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCheckConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCheckConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCheckDetailRequest : Tea.TeaModel {
    public var checkId: Int64?

    public var lang: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
            self.checkId = dict["CheckId"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetCheckDetailResponseBody : Tea.TeaModel {
    public class AssistInfo : Tea.TeaModel {
        public var link: String?

        public var type: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.link != nil {
                map["Link"] = self.link!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Link") && dict["Link"] != nil {
                self.link = dict["Link"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class CustomConfigs : Tea.TeaModel {
        public var defaultValue: String?

        public var name: String?

        public var showName: String?

        public var typeDefine: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultValue != nil {
                map["DefaultValue"] = self.defaultValue!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            if self.typeDefine != nil {
                map["TypeDefine"] = self.typeDefine!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                self.defaultValue = dict["DefaultValue"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                self.showName = dict["ShowName"] as! String
            }
            if dict.keys.contains("TypeDefine") && dict["TypeDefine"] != nil {
                self.typeDefine = dict["TypeDefine"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Description_ : Tea.TeaModel {
        public var link: String?

        public var type: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.link != nil {
                map["Link"] = self.link!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Link") && dict["Link"] != nil {
                self.link = dict["Link"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Solution : Tea.TeaModel {
        public var link: String?

        public var type: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.link != nil {
                map["Link"] = self.link!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Link") && dict["Link"] != nil {
                self.link = dict["Link"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var assistInfo: GetCheckDetailResponseBody.AssistInfo?

    public var customConfigs: [GetCheckDetailResponseBody.CustomConfigs]?

    public var description_: GetCheckDetailResponseBody.Description_?

    public var requestId: String?

    public var solution: GetCheckDetailResponseBody.Solution?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.assistInfo?.validate()
        try self.description_?.validate()
        try self.solution?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assistInfo != nil {
            map["AssistInfo"] = self.assistInfo?.toMap()
        }
        if self.customConfigs != nil {
            var tmp : [Any] = []
            for k in self.customConfigs! {
                tmp.append(k.toMap())
            }
            map["CustomConfigs"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.solution != nil {
            map["Solution"] = self.solution?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssistInfo") && dict["AssistInfo"] != nil {
            var model = GetCheckDetailResponseBody.AssistInfo()
            model.fromMap(dict["AssistInfo"] as! [String: Any])
            self.assistInfo = model
        }
        if dict.keys.contains("CustomConfigs") && dict["CustomConfigs"] != nil {
            var tmp : [GetCheckDetailResponseBody.CustomConfigs] = []
            for v in dict["CustomConfigs"] as! [Any] {
                var model = GetCheckDetailResponseBody.CustomConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customConfigs = tmp
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            var model = GetCheckDetailResponseBody.Description_()
            model.fromMap(dict["Description"] as! [String: Any])
            self.description_ = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Solution") && dict["Solution"] != nil {
            var model = GetCheckDetailResponseBody.Solution()
            model.fromMap(dict["Solution"] as! [String: Any])
            self.solution = model
        }
    }
}

public class GetCheckDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCheckDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCheckDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCheckProcessRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetCheckProcessResponseBody : Tea.TeaModel {
    public var finishCount: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.finishCount != nil {
            map["FinishCount"] = self.finishCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FinishCount") && dict["FinishCount"] != nil {
            self.finishCount = dict["FinishCount"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class GetCheckProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCheckProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCheckProcessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCheckRiskStatisticsRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var lang: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GetCheckRiskStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubStatistics : Tea.TeaModel {
            public var alias: String?

            public var highWarningCount: Int32?

            public var lowWarningCount: Int32?

            public var mediumWarningCount: Int32?

            public var passCount: Int32?

            public var totalCount: Int32?

            public var typeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.highWarningCount != nil {
                    map["HighWarningCount"] = self.highWarningCount!
                }
                if self.lowWarningCount != nil {
                    map["LowWarningCount"] = self.lowWarningCount!
                }
                if self.mediumWarningCount != nil {
                    map["MediumWarningCount"] = self.mediumWarningCount!
                }
                if self.passCount != nil {
                    map["PassCount"] = self.passCount!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                if self.typeName != nil {
                    map["TypeName"] = self.typeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("HighWarningCount") && dict["HighWarningCount"] != nil {
                    self.highWarningCount = dict["HighWarningCount"] as! Int32
                }
                if dict.keys.contains("LowWarningCount") && dict["LowWarningCount"] != nil {
                    self.lowWarningCount = dict["LowWarningCount"] as! Int32
                }
                if dict.keys.contains("MediumWarningCount") && dict["MediumWarningCount"] != nil {
                    self.mediumWarningCount = dict["MediumWarningCount"] as! Int32
                }
                if dict.keys.contains("PassCount") && dict["PassCount"] != nil {
                    self.passCount = dict["PassCount"] as! Int32
                }
                if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
                if dict.keys.contains("TypeName") && dict["TypeName"] != nil {
                    self.typeName = dict["TypeName"] as! String
                }
            }
        }
        public var highWarningCount: Int32?

        public var lowWarningCount: Int32?

        public var mediumWarningCount: Int32?

        public var passCount: Int32?

        public var sceneName: String?

        public var subStatistics: [GetCheckRiskStatisticsResponseBody.Data.SubStatistics]?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.highWarningCount != nil {
                map["HighWarningCount"] = self.highWarningCount!
            }
            if self.lowWarningCount != nil {
                map["LowWarningCount"] = self.lowWarningCount!
            }
            if self.mediumWarningCount != nil {
                map["MediumWarningCount"] = self.mediumWarningCount!
            }
            if self.passCount != nil {
                map["PassCount"] = self.passCount!
            }
            if self.sceneName != nil {
                map["SceneName"] = self.sceneName!
            }
            if self.subStatistics != nil {
                var tmp : [Any] = []
                for k in self.subStatistics! {
                    tmp.append(k.toMap())
                }
                map["SubStatistics"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HighWarningCount") && dict["HighWarningCount"] != nil {
                self.highWarningCount = dict["HighWarningCount"] as! Int32
            }
            if dict.keys.contains("LowWarningCount") && dict["LowWarningCount"] != nil {
                self.lowWarningCount = dict["LowWarningCount"] as! Int32
            }
            if dict.keys.contains("MediumWarningCount") && dict["MediumWarningCount"] != nil {
                self.mediumWarningCount = dict["MediumWarningCount"] as! Int32
            }
            if dict.keys.contains("PassCount") && dict["PassCount"] != nil {
                self.passCount = dict["PassCount"] as! Int32
            }
            if dict.keys.contains("SceneName") && dict["SceneName"] != nil {
                self.sceneName = dict["SceneName"] as! String
            }
            if dict.keys.contains("SubStatistics") && dict["SubStatistics"] != nil {
                var tmp : [GetCheckRiskStatisticsResponseBody.Data.SubStatistics] = []
                for v in dict["SubStatistics"] as! [Any] {
                    var model = GetCheckRiskStatisticsResponseBody.Data.SubStatistics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.subStatistics = tmp
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var count: Int32?

    public var data: [GetCheckRiskStatisticsResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetCheckRiskStatisticsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetCheckRiskStatisticsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCheckRiskStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCheckRiskStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCheckRiskStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCheckSummaryRequest : Tea.TeaModel {
    public var lang: String?

    public var resourceDirectoryAccountId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! String
        }
    }
}

public class GetCheckSummaryResponseBody : Tea.TeaModel {
    public class Summarys : Tea.TeaModel {
        public class Standards : Tea.TeaModel {
            public var failCount: Int32?

            public var id: Int64?

            public var passCount: Int32?

            public var riskLevelHighCount: Int32?

            public var riskLevelLowCount: Int32?

            public var riskLevelMediumCount: Int32?

            public var showName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failCount != nil {
                    map["FailCount"] = self.failCount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.passCount != nil {
                    map["PassCount"] = self.passCount!
                }
                if self.riskLevelHighCount != nil {
                    map["RiskLevelHighCount"] = self.riskLevelHighCount!
                }
                if self.riskLevelLowCount != nil {
                    map["RiskLevelLowCount"] = self.riskLevelLowCount!
                }
                if self.riskLevelMediumCount != nil {
                    map["RiskLevelMediumCount"] = self.riskLevelMediumCount!
                }
                if self.showName != nil {
                    map["ShowName"] = self.showName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailCount") && dict["FailCount"] != nil {
                    self.failCount = dict["FailCount"] as! Int32
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("PassCount") && dict["PassCount"] != nil {
                    self.passCount = dict["PassCount"] as! Int32
                }
                if dict.keys.contains("RiskLevelHighCount") && dict["RiskLevelHighCount"] != nil {
                    self.riskLevelHighCount = dict["RiskLevelHighCount"] as! Int32
                }
                if dict.keys.contains("RiskLevelLowCount") && dict["RiskLevelLowCount"] != nil {
                    self.riskLevelLowCount = dict["RiskLevelLowCount"] as! Int32
                }
                if dict.keys.contains("RiskLevelMediumCount") && dict["RiskLevelMediumCount"] != nil {
                    self.riskLevelMediumCount = dict["RiskLevelMediumCount"] as! Int32
                }
                if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                    self.showName = dict["ShowName"] as! String
                }
            }
        }
        public var failCount: Int32?

        public var passCount: Int64?

        public var standards: [GetCheckSummaryResponseBody.Summarys.Standards]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failCount != nil {
                map["FailCount"] = self.failCount!
            }
            if self.passCount != nil {
                map["PassCount"] = self.passCount!
            }
            if self.standards != nil {
                var tmp : [Any] = []
                for k in self.standards! {
                    tmp.append(k.toMap())
                }
                map["Standards"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailCount") && dict["FailCount"] != nil {
                self.failCount = dict["FailCount"] as! Int32
            }
            if dict.keys.contains("PassCount") && dict["PassCount"] != nil {
                self.passCount = dict["PassCount"] as! Int64
            }
            if dict.keys.contains("Standards") && dict["Standards"] != nil {
                var tmp : [GetCheckSummaryResponseBody.Summarys.Standards] = []
                for v in dict["Standards"] as! [Any] {
                    var model = GetCheckSummaryResponseBody.Summarys.Standards()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.standards = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var summarys: [GetCheckSummaryResponseBody.Summarys]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.summarys != nil {
            var tmp : [Any] = []
            for k in self.summarys! {
                tmp.append(k.toMap())
            }
            map["Summarys"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Summarys") && dict["Summarys"] != nil {
            var tmp : [GetCheckSummaryResponseBody.Summarys] = []
            for v in dict["Summarys"] as! [Any] {
                var model = GetCheckSummaryResponseBody.Summarys()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.summarys = tmp
        }
    }
}

public class GetCheckSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCheckSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCheckSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClientInstallationStatisticRequest : Tea.TeaModel {
    public var timeEnd: Int64?

    public var timeStart: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.timeEnd != nil {
            map["TimeEnd"] = self.timeEnd!
        }
        if self.timeStart != nil {
            map["TimeStart"] = self.timeStart!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TimeEnd") && dict["TimeEnd"] != nil {
            self.timeEnd = dict["TimeEnd"] as! Int64
        }
        if dict.keys.contains("TimeStart") && dict["TimeStart"] != nil {
            self.timeStart = dict["TimeStart"] as! Int64
        }
    }
}

public class GetClientInstallationStatisticResponseBody : Tea.TeaModel {
    public class ClientInstallRatio : Tea.TeaModel {
        public class CurrentItems : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var assetTotalCount: Int32?

                public var calculateTime: Int64?

                public var installRatio: Double?

                public var installedAssetCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.assetTotalCount != nil {
                        map["AssetTotalCount"] = self.assetTotalCount!
                    }
                    if self.calculateTime != nil {
                        map["CalculateTime"] = self.calculateTime!
                    }
                    if self.installRatio != nil {
                        map["InstallRatio"] = self.installRatio!
                    }
                    if self.installedAssetCount != nil {
                        map["InstalledAssetCount"] = self.installedAssetCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AssetTotalCount") && dict["AssetTotalCount"] != nil {
                        self.assetTotalCount = dict["AssetTotalCount"] as! Int32
                    }
                    if dict.keys.contains("CalculateTime") && dict["CalculateTime"] != nil {
                        self.calculateTime = dict["CalculateTime"] as! Int64
                    }
                    if dict.keys.contains("InstallRatio") && dict["InstallRatio"] != nil {
                        self.installRatio = dict["InstallRatio"] as! Double
                    }
                    if dict.keys.contains("InstalledAssetCount") && dict["InstalledAssetCount"] != nil {
                        self.installedAssetCount = dict["InstalledAssetCount"] as! Int32
                    }
                }
            }
            public var items: [GetClientInstallationStatisticResponseBody.ClientInstallRatio.CurrentItems.Items]?

            public var vendor: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["Items"] = tmp
                }
                if self.vendor != nil {
                    map["Vendor"] = self.vendor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Items") && dict["Items"] != nil {
                    var tmp : [GetClientInstallationStatisticResponseBody.ClientInstallRatio.CurrentItems.Items] = []
                    for v in dict["Items"] as! [Any] {
                        var model = GetClientInstallationStatisticResponseBody.ClientInstallRatio.CurrentItems.Items()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.items = tmp
                }
                if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                    self.vendor = dict["Vendor"] as! Int64
                }
            }
        }
        public class HistoryItems : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var assetTotalCount: Int32?

                public var calculateTime: Int64?

                public var installRatio: Double?

                public var installedAssetCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.assetTotalCount != nil {
                        map["AssetTotalCount"] = self.assetTotalCount!
                    }
                    if self.calculateTime != nil {
                        map["CalculateTime"] = self.calculateTime!
                    }
                    if self.installRatio != nil {
                        map["InstallRatio"] = self.installRatio!
                    }
                    if self.installedAssetCount != nil {
                        map["InstalledAssetCount"] = self.installedAssetCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AssetTotalCount") && dict["AssetTotalCount"] != nil {
                        self.assetTotalCount = dict["AssetTotalCount"] as! Int32
                    }
                    if dict.keys.contains("CalculateTime") && dict["CalculateTime"] != nil {
                        self.calculateTime = dict["CalculateTime"] as! Int64
                    }
                    if dict.keys.contains("InstallRatio") && dict["InstallRatio"] != nil {
                        self.installRatio = dict["InstallRatio"] as! Double
                    }
                    if dict.keys.contains("InstalledAssetCount") && dict["InstalledAssetCount"] != nil {
                        self.installedAssetCount = dict["InstalledAssetCount"] as! Int32
                    }
                }
            }
            public var items: [GetClientInstallationStatisticResponseBody.ClientInstallRatio.HistoryItems.Items]?

            public var vendor: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["Items"] = tmp
                }
                if self.vendor != nil {
                    map["Vendor"] = self.vendor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Items") && dict["Items"] != nil {
                    var tmp : [GetClientInstallationStatisticResponseBody.ClientInstallRatio.HistoryItems.Items] = []
                    for v in dict["Items"] as! [Any] {
                        var model = GetClientInstallationStatisticResponseBody.ClientInstallRatio.HistoryItems.Items()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.items = tmp
                }
                if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                    self.vendor = dict["Vendor"] as! Int64
                }
            }
        }
        public var currentItems: [GetClientInstallationStatisticResponseBody.ClientInstallRatio.CurrentItems]?

        public var dates: [Int64]?

        public var historyItems: [GetClientInstallationStatisticResponseBody.ClientInstallRatio.HistoryItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentItems != nil {
                var tmp : [Any] = []
                for k in self.currentItems! {
                    tmp.append(k.toMap())
                }
                map["CurrentItems"] = tmp
            }
            if self.dates != nil {
                map["Dates"] = self.dates!
            }
            if self.historyItems != nil {
                var tmp : [Any] = []
                for k in self.historyItems! {
                    tmp.append(k.toMap())
                }
                map["HistoryItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentItems") && dict["CurrentItems"] != nil {
                var tmp : [GetClientInstallationStatisticResponseBody.ClientInstallRatio.CurrentItems] = []
                for v in dict["CurrentItems"] as! [Any] {
                    var model = GetClientInstallationStatisticResponseBody.ClientInstallRatio.CurrentItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.currentItems = tmp
            }
            if dict.keys.contains("Dates") && dict["Dates"] != nil {
                self.dates = dict["Dates"] as! [Int64]
            }
            if dict.keys.contains("HistoryItems") && dict["HistoryItems"] != nil {
                var tmp : [GetClientInstallationStatisticResponseBody.ClientInstallRatio.HistoryItems] = []
                for v in dict["HistoryItems"] as! [Any] {
                    var model = GetClientInstallationStatisticResponseBody.ClientInstallRatio.HistoryItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.historyItems = tmp
            }
        }
    }
    public var clientInstallRatio: GetClientInstallationStatisticResponseBody.ClientInstallRatio?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clientInstallRatio?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientInstallRatio != nil {
            map["ClientInstallRatio"] = self.clientInstallRatio?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientInstallRatio") && dict["ClientInstallRatio"] != nil {
            var model = GetClientInstallationStatisticResponseBody.ClientInstallRatio()
            model.fromMap(dict["ClientInstallRatio"] as! [String: Any])
            self.clientInstallRatio = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetClientInstallationStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClientInstallationStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetClientInstallationStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClientRatioStatisticRequest : Tea.TeaModel {
    public var resourceDirectoryAccountId: Int64?

    public var statisticTypes: [String]?

    public var timeEnd: Int64?

    public var timeStart: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceDirectoryAccountId != nil {
            map["ResourceDirectoryAccountId"] = self.resourceDirectoryAccountId!
        }
        if self.statisticTypes != nil {
            map["StatisticTypes"] = self.statisticTypes!
        }
        if self.timeEnd != nil {
            map["TimeEnd"] = self.timeEnd!
        }
        if self.timeStart != nil {
            map["TimeStart"] = self.timeStart!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceDirectoryAccountId") && dict["ResourceDirectoryAccountId"] != nil {
            self.resourceDirectoryAccountId = dict["ResourceDirectoryAccountId"] as! Int64
        }
        if dict.keys.contains("StatisticTypes") && dict["StatisticTypes"] != nil {
            self.statisticTypes = dict["StatisticTypes"] as! [String]
        }
        if dict.keys.contains("TimeEnd") && dict["TimeEnd"] != nil {
            self.timeEnd = dict["TimeEnd"] as! Int64
        }
        if dict.keys.contains("TimeStart") && dict["TimeStart"] != nil {
            self.timeStart = dict["TimeStart"] as! Int64
        }
    }
}

public class GetClientRatioStatisticResponseBody : Tea.TeaModel {
    public class ClientInstallRatio : Tea.TeaModel {
        public class CurrentItems : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var assetTotalCount: Int32?

                public var calculateTime: Int64?

                public var installRatio: Double?

                public var installedAssetCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.assetTotalCount != nil {
                        map["AssetTotalCount"] = self.assetTotalCount!
                    }
                    if self.calculateTime != nil {
                        map["CalculateTime"] = self.calculateTime!
                    }
                    if self.installRatio != nil {
                        map["InstallRatio"] = self.installRatio!
                    }
                    if self.installedAssetCount != nil {
                        map["InstalledAssetCount"] = self.installedAssetCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AssetTotalCount") && dict["AssetTotalCount"] != nil {
                        self.assetTotalCount = dict["AssetTotalCount"] as! Int32
                    }
                    if dict.keys.contains("CalculateTime") && dict["CalculateTime"] != nil {
                        self.calculateTime = dict["CalculateTime"] as! Int64
                    }
                    if dict.keys.contains("InstallRatio") && dict["InstallRatio"] != nil {
                        self.installRatio = dict["InstallRatio"] as! Double
                    }
                    if dict.keys.contains("InstalledAssetCount") && dict["InstalledAssetCount"] != nil {
                        self.installedAssetCount = dict["InstalledAssetCount"] as! Int32
                    }
                }
            }
            public var items: [GetClientRatioStatisticResponseBody.ClientInstallRatio.CurrentItems.Items]?

            public var vendor: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["Items"] = tmp
                }
                if self.vendor != nil {
                    map["Vendor"] = self.vendor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Items") && dict["Items"] != nil {
                    var tmp : [GetClientRatioStatisticResponseBody.ClientInstallRatio.CurrentItems.Items] = []
                    for v in dict["Items"] as! [Any] {
                        var model = GetClientRatioStatisticResponseBody.ClientInstallRatio.CurrentItems.Items()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.items = tmp
                }
                if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                    self.vendor = dict["Vendor"] as! Int64
                }
            }
        }
        public class HistoryItems : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var assetTotalCount: Int32?

                public var calculateTime: Int64?

                public var installRatio: Double?

                public var installedAssetCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.assetTotalCount != nil {
                        map["AssetTotalCount"] = self.assetTotalCount!
                    }
                    if self.calculateTime != nil {
                        map["CalculateTime"] = self.calculateTime!
                    }
                    if self.installRatio != nil {
                        map["InstallRatio"] = self.installRatio!
                    }
                    if self.installedAssetCount != nil {
                        map["InstalledAssetCount"] = self.installedAssetCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AssetTotalCount") && dict["AssetTotalCount"] != nil {
                        self.assetTotalCount = dict["AssetTotalCount"] as! Int32
                    }
                    if dict.keys.contains("CalculateTime") && dict["CalculateTime"] != nil {
                        self.calculateTime = dict["CalculateTime"] as! Int64
                    }
                    if dict.keys.contains("InstallRatio") && dict["InstallRatio"] != nil {
                        self.installRatio = dict["InstallRatio"] as! Double
                    }
                    if dict.keys.contains("InstalledAssetCount") && dict["InstalledAssetCount"] != nil {
                        self.installedAssetCount = dict["InstalledAssetCount"] as! Int32
                    }
                }
            }
            public var items: [GetClientRatioStatisticResponseBody.ClientInstallRatio.HistoryItems.Items]?

            public var vendor: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["Items"] = tmp
                }
                if self.vendor != nil {
                    map["Vendor"] = self.vendor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Items") && dict["Items"] != nil {
                    var tmp : [GetClientRatioStatisticResponseBody.ClientInstallRatio.HistoryItems.Items] = []
                    for v in dict["Items"] as! [Any] {
                        var model = GetClientRatioStatisticResponseBody.ClientInstallRatio.HistoryItems.Items()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.items = tmp
                }
                if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                    self.vendor = dict["Vendor"] as! Int64
                }
            }
        }
        public var currentItems: [GetClientRatioStatisticResponseBody.ClientInstallRatio.CurrentItems]?

        public var historyItems: [GetClientRatioStatisticResponseBody.ClientInstallRatio.HistoryItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentItems != nil {
                var tmp : [Any] = []
                for k in self.currentItems! {
                    tmp.append(k.toMap())
                }
                map["CurrentItems"] = tmp
            }
            if self.historyItems != nil {
                var tmp : [Any] = []
                for k in self.historyItems! {
                    tmp.append(k.toMap())
                }
                map["HistoryItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentItems") && dict["CurrentItems"] != nil {
                var tmp : [GetClientRatioStatisticResponseBody.ClientInstallRatio.CurrentItems] = []
                for v in dict["CurrentItems"] as! [Any] {
                    var model = GetClientRatioStatisticResponseBody.ClientInstallRatio.CurrentItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.currentItems = tmp
            }
            if dict.keys.contains("HistoryItems") && dict["HistoryItems"] != nil {
                var tmp : [GetClientRatioStatisticResponseBody.ClientInstallRatio.HistoryItems] = []
                for v in dict["HistoryItems"] as! [Any] {
                    var model = GetClientRatioStatisticResponseBody.ClientInstallRatio.HistoryItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.historyItems = tmp
            }
        }
    }
    public class ClientOnlineRatio : Tea.TeaModel {
        public class CurrentItems : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var assetInstallCount: Int32?

                public var calculateTime: Int64?

                public var onlineAssetCount: Int32?

                public var onlineRatio: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.assetInstallCount != nil {
                        map["AssetInstallCount"] = self.assetInstallCount!
                    }
                    if self.calculateTime != nil {
                        map["CalculateTime"] = self.calculateTime!
                    }
                    if self.onlineAssetCount != nil {
                        map["OnlineAssetCount"] = self.onlineAssetCount!
                    }
                    if self.onlineRatio != nil {
                        map["OnlineRatio"] = self.onlineRatio!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AssetInstallCount") && dict["AssetInstallCount"] != nil {
                        self.assetInstallCount = dict["AssetInstallCount"] as! Int32
                    }
                    if dict.keys.contains("CalculateTime") && dict["CalculateTime"] != nil {
                        self.calculateTime = dict["CalculateTime"] as! Int64
                    }
                    if dict.keys.contains("OnlineAssetCount") && dict["OnlineAssetCount"] != nil {
                        self.onlineAssetCount = dict["OnlineAssetCount"] as! Int32
                    }
                    if dict.keys.contains("OnlineRatio") && dict["OnlineRatio"] != nil {
                        self.onlineRatio = dict["OnlineRatio"] as! Double
                    }
                }
            }
            public var items: [GetClientRatioStatisticResponseBody.ClientOnlineRatio.CurrentItems.Items]?

            public var vendor: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["Items"] = tmp
                }
                if self.vendor != nil {
                    map["Vendor"] = self.vendor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Items") && dict["Items"] != nil {
                    var tmp : [GetClientRatioStatisticResponseBody.ClientOnlineRatio.CurrentItems.Items] = []
                    for v in dict["Items"] as! [Any] {
                        var model = GetClientRatioStatisticResponseBody.ClientOnlineRatio.CurrentItems.Items()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.items = tmp
                }
                if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                    self.vendor = dict["Vendor"] as! Int64
                }
            }
        }
        public class HistoryItems : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var assetInstallCount: Int32?

                public var calculateTime: Int64?

                public var onlineAssetCount: Int32?

                public var onlineRatio: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.assetInstallCount != nil {
                        map["AssetInstallCount"] = self.assetInstallCount!
                    }
                    if self.calculateTime != nil {
                        map["CalculateTime"] = self.calculateTime!
                    }
                    if self.onlineAssetCount != nil {
                        map["OnlineAssetCount"] = self.onlineAssetCount!
                    }
                    if self.onlineRatio != nil {
                        map["OnlineRatio"] = self.onlineRatio!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AssetInstallCount") && dict["AssetInstallCount"] != nil {
                        self.assetInstallCount = dict["AssetInstallCount"] as! Int32
                    }
                    if dict.keys.contains("CalculateTime") && dict["CalculateTime"] != nil {
                        self.calculateTime = dict["CalculateTime"] as! Int64
                    }
                    if dict.keys.contains("OnlineAssetCount") && dict["OnlineAssetCount"] != nil {
                        self.onlineAssetCount = dict["OnlineAssetCount"] as! Int32
                    }
                    if dict.keys.contains("OnlineRatio") && dict["OnlineRatio"] != nil {
                        self.onlineRatio = dict["OnlineRatio"] as! Double
                    }
                }
            }
            public var items: [GetClientRatioStatisticResponseBody.ClientOnlineRatio.HistoryItems.Items]?

            public var vendor: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["Items"] = tmp
                }
                if self.vendor != nil {
                    map["Vendor"] = self.vendor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Items") && dict["Items"] != nil {
                    var tmp : [GetClientRatioStatisticResponseBody.ClientOnlineRatio.HistoryItems.Items] = []
                    for v in dict["Items"] as! [Any] {
                        var model = GetClientRatioStatisticResponseBody.ClientOnlineRatio.HistoryItems.Items()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.items = tmp
                }
                if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                    self.vendor = dict["Vendor"] as! Int64
                }
            }
        }
        public var currentItems: [GetClientRatioStatisticResponseBody.ClientOnlineRatio.CurrentItems]?

        public var historyItems: [GetClientRatioStatisticResponseBody.ClientOnlineRatio.HistoryItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentItems != nil {
                var tmp : [Any] = []
                for k in self.currentItems! {
                    tmp.append(k.toMap())
                }
                map["CurrentItems"] = tmp
            }
            if self.historyItems != nil {
                var tmp : [Any] = []
                for k in self.historyItems! {
                    tmp.append(k.toMap())
                }
                map["HistoryItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentItems") && dict["CurrentItems"] != nil {
                var tmp : [GetClientRatioStatisticResponseBody.ClientOnlineRatio.CurrentItems] = []
                for v in dict["CurrentItems"] as! [Any] {
                    var model = GetClientRatioStatisticResponseBody.ClientOnlineRatio.CurrentItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.currentItems = tmp
            }
            if dict.keys.contains("HistoryItems") && dict["HistoryItems"] != nil {
                var tmp : [GetClientRatioStatisticResponseBody.ClientOnlineRatio.HistoryItems] = []
                for v in dict["HistoryItems"] as! [Any] {
                    var model = GetClientRatioStatisticResponseBody.ClientOnlineRatio.HistoryItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.historyItems = tmp
            }
        }
    }
    public var clientInstallRatio: GetClientRatioStatisticResponseBody.ClientInstallRatio?

    public var clientOnlineRatio: GetClientRatioStatisticResponseBody.ClientOnlineRatio?

    public var dates: [Int64]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clientInstallRatio?.validate()
        try self.clientOnlineRatio?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientInstallRatio != nil {
            map["ClientInstallRatio"] = self.clientInstallRatio?.toMap()
        }
        if self.clientOnlineRatio != nil {
            map["ClientOnlineRatio"] = self.clientOnlineRatio?.toMap()
        }
        if self.dates != nil {
            map["Dates"] = self.dates!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientInstallRatio") && dict["ClientInstallRatio"] != nil {
            var model = GetClientRatioStatisticResponseBody.ClientInstallRatio()
            model.fromMap(dict["ClientInstallRatio"] as! [String: Any])
            self.clientInstallRatio = model
        }
        if dict.keys.contains("ClientOnlineRatio") && dict["ClientOnlineRatio"] != nil {
            var model = GetClientRatioStatisticResponseBody.ClientOnlineRatio()
            model.fromMap(dict["ClientOnlineRatio"] as! [String: Any])
            self.clientOnlineRatio = model
        }
        if dict.keys.contains("Dates") && dict["Dates"] != nil {
            self.dates = dict["Dates"] as! [Int64]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetClientRatioStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClientRatioStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetClientRatioStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClientUserDefineRuleRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetClientUserDefineRuleResponseBody : Tea.TeaModel {
    public class UserDefineRuleDetail : Tea.TeaModel {
        public var actionType: String?

        public var cmdline: String?

        public var filePath: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var IP: String?

        public var id: Int64?

        public var md5List: String?

        public var name: String?

        public var newFilePath: String?

        public var parentCmdline: String?

        public var parentProcPath: String?

        public var platform: String?

        public var port: Int32?

        public var portStr: String?

        public var procPath: String?

        public var registryContent: String?

        public var registryKey: String?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionType != nil {
                map["ActionType"] = self.actionType!
            }
            if self.cmdline != nil {
                map["Cmdline"] = self.cmdline!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.md5List != nil {
                map["Md5List"] = self.md5List!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.newFilePath != nil {
                map["NewFilePath"] = self.newFilePath!
            }
            if self.parentCmdline != nil {
                map["ParentCmdline"] = self.parentCmdline!
            }
            if self.parentProcPath != nil {
                map["ParentProcPath"] = self.parentProcPath!
            }
            if self.platform != nil {
                map["Platform"] = self.platform!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.portStr != nil {
                map["PortStr"] = self.portStr!
            }
            if self.procPath != nil {
                map["ProcPath"] = self.procPath!
            }
            if self.registryContent != nil {
                map["RegistryContent"] = self.registryContent!
            }
            if self.registryKey != nil {
                map["RegistryKey"] = self.registryKey!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionType") && dict["ActionType"] != nil {
                self.actionType = dict["ActionType"] as! String
            }
            if dict.keys.contains("Cmdline") && dict["Cmdline"] != nil {
                self.cmdline = dict["Cmdline"] as! String
            }
            if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("IP") && dict["IP"] != nil {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Md5List") && dict["Md5List"] != nil {
                self.md5List = dict["Md5List"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NewFilePath") && dict["NewFilePath"] != nil {
                self.newFilePath = dict["NewFilePath"] as! String
            }
            if dict.keys.contains("ParentCmdline") && dict["ParentCmdline"] != nil {
                self.parentCmdline = dict["ParentCmdline"] as! String
            }
            if dict.keys.contains("ParentProcPath") && dict["ParentProcPath"] != nil {
                self.parentProcPath = dict["ParentProcPath"] as! String
            }
            if dict.keys.contains("Platform") && dict["Platform"] != nil {
                self.platform = dict["Platform"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("PortStr") && dict["PortStr"] != nil {
                self.portStr = dict["PortStr"] as! String
            }
            if dict.keys.contains("ProcPath") && dict["ProcPath"] != nil {
                self.procPath = dict["ProcPath"] as! String
            }
            if dict.keys.contains("RegistryContent") && dict["RegistryContent"] != nil {
                self.registryContent = dict["RegistryContent"] as! String
            }
            if dict.keys.contains("RegistryKey") && dict["RegistryKey"] != nil {
                self.registryKey = dict["RegistryKey"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var userDefineRuleDetail: GetClientUserDefineRuleResponseBody.UserDefineRuleDetail?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userDefineRuleDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userDefineRuleDetail != nil {
            map["UserDefineRuleDetail"] = self.userDefineRuleDetail?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserDefineRuleDetail") && dict["UserDefineRuleDetail"] != nil {
            var model = GetClientUserDefineRuleResponseBody.UserDefineRuleDetail()
            model.fromMap(dict["UserDefineRuleDetail"] as! [String: Any])
            self.userDefineRuleDetail = model
        }
    }
}

public class GetClientUserDefineRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClientUserDefineRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetClientUserDefineRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCloudAssetCriteriaRequest : Tea.TeaModel {
    public class CloudAssetTypes : Tea.TeaModel {
        public var assetSubType: Int32?

        public var assetType: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assetSubType != nil {
                map["AssetSubType"] = self.assetSubType!
            }
            if self.assetType != nil {
                map["AssetType"] = self.assetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssetSubType") && dict["AssetSubType"] != nil {
                self.assetSubType = dict["AssetSubType"] as! Int32
            }
            if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
                self.assetType = dict["AssetType"] as! Int32
            }
        }
    }
    public var cloudAssetTypes: [GetCloudAssetCriteriaRequest.CloudAssetTypes]?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cloudAssetTypes != nil {
            var tmp : [Any] = []
            for k in self.cloudAssetTypes! {
                tmp.append(k.toMap())
            }
            map["CloudAssetTypes"] = tmp
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CloudAssetTypes") && dict["CloudAssetTypes"] != nil {
            var tmp : [GetCloudAssetCriteriaRequest.CloudAssetTypes] = []
            for v in dict["CloudAssetTypes"] as! [Any] {
                var model = GetCloudAssetCriteriaRequest.CloudAssetTypes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cloudAssetTypes = tmp
        }
        if dict.keys.contains("Value") && dict["Value"] != nil {
            self.value = dict["Value"] as! String
        }
    }
}

public class GetCloudAssetCriteriaResponseBody : Tea.TeaModel {
    public class CriteriaList : Tea.TeaModel {
        public var multiValues: String?

        public var name: String?

        public var type: String?

        public var values: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.multiValues != nil {
                map["MultiValues"] = self.multiValues!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MultiValues") && dict["MultiValues"] != nil {
                self.multiValues = dict["MultiValues"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Values") && dict["Values"] != nil {
                self.values = dict["Values"] as! String
            }
        }
    }
    public var criteriaList: [GetCloudAssetCriteriaResponseBody.CriteriaList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteriaList != nil {
            var tmp : [Any] = []
            for k in self.criteriaList! {
                tmp.append(k.toMap())
            }
            map["CriteriaList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CriteriaList") && dict["CriteriaList"] != nil {
            var tmp : [GetCloudAssetCriteriaResponseBody.CriteriaList] = []
            for v in dict["CriteriaList"] as! [Any] {
                var model = GetCloudAssetCriteriaResponseBody.CriteriaList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.criteriaList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCloudAssetCriteriaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCloudAssetCriteriaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCloudAssetCriteriaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCloudAssetDetailRequest : Tea.TeaModel {
    public class CloudAssetInstances : Tea.TeaModel {
        public var instanceId: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var assetSubType: Int32?

    public var assetType: Int32?

    public var cloudAssetInstances: [GetCloudAssetDetailRequest.CloudAssetInstances]?

    public var vendor: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetSubType != nil {
            map["AssetSubType"] = self.assetSubType!
        }
        if self.assetType != nil {
            map["AssetType"] = self.assetType!
        }
        if self.cloudAssetInstances != nil {
            var tmp : [Any] = []
            for k in self.cloudAssetInstances! {
                tmp.append(k.toMap())
            }
            map["CloudAssetInstances"] = tmp
        }
        if self.vendor != nil {
            map["Vendor"] = self.vendor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetSubType") && dict["AssetSubType"] != nil {
            self.assetSubType = dict["AssetSubType"] as! Int32
        }
        if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
            self.assetType = dict["AssetType"] as! Int32
        }
        if dict.keys.contains("CloudAssetInstances") && dict["CloudAssetInstances"] != nil {
            var tmp : [GetCloudAssetDetailRequest.CloudAssetInstances] = []
            for v in dict["CloudAssetInstances"] as! [Any] {
                var model = GetCloudAssetDetailRequest.CloudAssetInstances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cloudAssetInstances = tmp
        }
        if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
            self.vendor = dict["Vendor"] as! Int32
        }
    }
}

public class GetCloudAssetDetailResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var alarmStatus: String?

        public var assetSubType: Int32?

        public var assetSubTypeName: String?

        public var assetType: Int32?

        public var assetTypeName: String?

        public var createdTime: Int64?

        public var detailLink: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var regionId: String?

        public var riskStatus: String?

        public var securityInfo: String?

        public var vendor: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmStatus != nil {
                map["AlarmStatus"] = self.alarmStatus!
            }
            if self.assetSubType != nil {
                map["AssetSubType"] = self.assetSubType!
            }
            if self.assetSubTypeName != nil {
                map["AssetSubTypeName"] = self.assetSubTypeName!
            }
            if self.assetType != nil {
                map["AssetType"] = self.assetType!
            }
            if self.assetTypeName != nil {
                map["AssetTypeName"] = self.assetTypeName!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.detailLink != nil {
                map["DetailLink"] = self.detailLink!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.riskStatus != nil {
                map["RiskStatus"] = self.riskStatus!
            }
            if self.securityInfo != nil {
                map["SecurityInfo"] = self.securityInfo!
            }
            if self.vendor != nil {
                map["Vendor"] = self.vendor!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmStatus") && dict["AlarmStatus"] != nil {
                self.alarmStatus = dict["AlarmStatus"] as! String
            }
            if dict.keys.contains("AssetSubType") && dict["AssetSubType"] != nil {
                self.assetSubType = dict["AssetSubType"] as! Int32
            }
            if dict.keys.contains("AssetSubTypeName") && dict["AssetSubTypeName"] != nil {
                self.assetSubTypeName = dict["AssetSubTypeName"] as! String
            }
            if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
                self.assetType = dict["AssetType"] as! Int32
            }
            if dict.keys.contains("AssetTypeName") && dict["AssetTypeName"] != nil {
                self.assetTypeName = dict["AssetTypeName"] as! String
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("DetailLink") && dict["DetailLink"] != nil {
                self.detailLink = dict["DetailLink"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
                self.riskStatus = dict["RiskStatus"] as! String
            }
            if dict.keys.contains("SecurityInfo") && dict["SecurityInfo"] != nil {
                self.securityInfo = dict["SecurityInfo"] as! String
            }
            if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                self.vendor = dict["Vendor"] as! Int32
            }
        }
    }
    public var count: Int32?

    public var instances: [GetCloudAssetDetailResponseBody.Instances]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Instances") && dict["Instances"] != nil {
            var tmp : [GetCloudAssetDetailResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = GetCloudAssetDetailResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCloudAssetDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCloudAssetDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCloudAssetDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCloudAssetSummaryResponseBody : Tea.TeaModel {
    public class GroupedFields : Tea.TeaModel {
        public class CloudAssetSummaryMetas : Tea.TeaModel {
            public var assetSubType: Int32?

            public var assetType: Int32?

            public var instanceCount: Int32?

            public var instanceRiskCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assetSubType != nil {
                    map["AssetSubType"] = self.assetSubType!
                }
                if self.assetType != nil {
                    map["AssetType"] = self.assetType!
                }
                if self.instanceCount != nil {
                    map["InstanceCount"] = self.instanceCount!
                }
                if self.instanceRiskCount != nil {
                    map["InstanceRiskCount"] = self.instanceRiskCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssetSubType") && dict["AssetSubType"] != nil {
                    self.assetSubType = dict["AssetSubType"] as! Int32
                }
                if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
                    self.assetType = dict["AssetType"] as! Int32
                }
                if dict.keys.contains("InstanceCount") && dict["InstanceCount"] != nil {
                    self.instanceCount = dict["InstanceCount"] as! Int32
                }
                if dict.keys.contains("InstanceRiskCount") && dict["InstanceRiskCount"] != nil {
                    self.instanceRiskCount = dict["InstanceRiskCount"] as! Int32
                }
            }
        }
        public var cloudAssetSummaryMetas: [GetCloudAssetSummaryResponseBody.GroupedFields.CloudAssetSummaryMetas]?

        public var instanceCountTotal: Int32?

        public var instanceRiskCountTotal: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cloudAssetSummaryMetas != nil {
                var tmp : [Any] = []
                for k in self.cloudAssetSummaryMetas! {
                    tmp.append(k.toMap())
                }
                map["CloudAssetSummaryMetas"] = tmp
            }
            if self.instanceCountTotal != nil {
                map["InstanceCountTotal"] = self.instanceCountTotal!
            }
            if self.instanceRiskCountTotal != nil {
                map["InstanceRiskCountTotal"] = self.instanceRiskCountTotal!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CloudAssetSummaryMetas") && dict["CloudAssetSummaryMetas"] != nil {
                var tmp : [GetCloudAssetSummaryResponseBody.GroupedFields.CloudAssetSummaryMetas] = []
                for v in dict["CloudAssetSummaryMetas"] as! [Any] {
                    var model = GetCloudAssetSummaryResponseBody.GroupedFields.CloudAssetSummaryMetas()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cloudAssetSummaryMetas = tmp
            }
            if dict.keys.contains("InstanceCountTotal") && dict["InstanceCountTotal"] != nil {
                self.instanceCountTotal = dict["InstanceCountTotal"] as! Int32
            }
            if dict.keys.contains("InstanceRiskCountTotal") && dict["InstanceRiskCountTotal"] != nil {
                self.instanceRiskCountTotal = dict["InstanceRiskCountTotal"] as! Int32
            }
        }
    }
    public var groupedFields: GetCloudAssetSummaryResponseBody.GroupedFields?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.groupedFields?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupedFields != nil {
            map["GroupedFields"] = self.groupedFields?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupedFields") && dict["GroupedFields"] != nil {
            var model = GetCloudAssetSummaryResponseBody.GroupedFields()
            model.fromMap(dict["GroupedFields"] as! [String: Any])
            self.groupedFields = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCloudAssetSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCloudAssetSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCloudAssetSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClusterCheckItemWarningStatisticsRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class GetClusterCheckItemWarningStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var highWarningCount: Int32?

        public var lowWarningCount: Int32?

        public var mediumWarningCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.highWarningCount != nil {
                map["HighWarningCount"] = self.highWarningCount!
            }
            if self.lowWarningCount != nil {
                map["LowWarningCount"] = self.lowWarningCount!
            }
            if self.mediumWarningCount != nil {
                map["MediumWarningCount"] = self.mediumWarningCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HighWarningCount") && dict["HighWarningCount"] != nil {
                self.highWarningCount = dict["HighWarningCount"] as! Int32
            }
            if dict.keys.contains("LowWarningCount") && dict["LowWarningCount"] != nil {
                self.lowWarningCount = dict["LowWarningCount"] as! Int32
            }
            if dict.keys.contains("MediumWarningCount") && dict["MediumWarningCount"] != nil {
                self.mediumWarningCount = dict["MediumWarningCount"] as! Int32
            }
        }
    }
    public var data: GetClusterCheckItemWarningStatisticsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetClusterCheckItemWarningStatisticsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetClusterCheckItemWarningStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClusterCheckItemWarningStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetClusterCheckItemWarningStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClusterRuleSummaryRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class GetClusterRuleSummaryResponseBody : Tea.TeaModel {
    public class ClusterRuleSummary : Tea.TeaModel {
        public var closeRuleCount: Int32?

        public var interceptionCount7Day: Int64?

        public var interceptionSwitch: Int32?

        public var interceptionType: Int32?

        public var openRuleCount: Int32?

        public var ruleCount: Int32?

        public var suggestRuleCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.closeRuleCount != nil {
                map["CloseRuleCount"] = self.closeRuleCount!
            }
            if self.interceptionCount7Day != nil {
                map["InterceptionCount7Day"] = self.interceptionCount7Day!
            }
            if self.interceptionSwitch != nil {
                map["InterceptionSwitch"] = self.interceptionSwitch!
            }
            if self.interceptionType != nil {
                map["InterceptionType"] = self.interceptionType!
            }
            if self.openRuleCount != nil {
                map["OpenRuleCount"] = self.openRuleCount!
            }
            if self.ruleCount != nil {
                map["RuleCount"] = self.ruleCount!
            }
            if self.suggestRuleCount != nil {
                map["SuggestRuleCount"] = self.suggestRuleCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CloseRuleCount") && dict["CloseRuleCount"] != nil {
                self.closeRuleCount = dict["CloseRuleCount"] as! Int32
            }
            if dict.keys.contains("InterceptionCount7Day") && dict["InterceptionCount7Day"] != nil {
                self.interceptionCount7Day = dict["InterceptionCount7Day"] as! Int64
            }
            if dict.keys.contains("InterceptionSwitch") && dict["InterceptionSwitch"] != nil {
                self.interceptionSwitch = dict["InterceptionSwitch"] as! Int32
            }
            if dict.keys.contains("InterceptionType") && dict["InterceptionType"] != nil {
                self.interceptionType = dict["InterceptionType"] as! Int32
            }
            if dict.keys.contains("OpenRuleCount") && dict["OpenRuleCount"] != nil {
                self.openRuleCount = dict["OpenRuleCount"] as! Int32
            }
            if dict.keys.contains("RuleCount") && dict["RuleCount"] != nil {
                self.ruleCount = dict["RuleCount"] as! Int32
            }
            if dict.keys.contains("SuggestRuleCount") && dict["SuggestRuleCount"] != nil {
                self.suggestRuleCount = dict["SuggestRuleCount"] as! Int32
            }
        }
    }
    public var clusterRuleSummary: GetClusterRuleSummaryResponseBody.ClusterRuleSummary?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterRuleSummary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterRuleSummary != nil {
            map["ClusterRuleSummary"] = self.clusterRuleSummary?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterRuleSummary") && dict["ClusterRuleSummary"] != nil {
            var model = GetClusterRuleSummaryResponseBody.ClusterRuleSummary()
            model.fromMap(dict["ClusterRuleSummary"] as! [String: Any])
            self.clusterRuleSummary = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetClusterRuleSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClusterRuleSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetClusterRuleSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClusterSuspEventStatisticsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var from: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
    }
}

public class GetClusterSuspEventStatisticsResponseBody : Tea.TeaModel {
    public class SuspStatistics : Tea.TeaModel {
        public var remind: Int32?

        public var serious: Int32?

        public var suspicious: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.remind != nil {
                map["Remind"] = self.remind!
            }
            if self.serious != nil {
                map["Serious"] = self.serious!
            }
            if self.suspicious != nil {
                map["Suspicious"] = self.suspicious!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Remind") && dict["Remind"] != nil {
                self.remind = dict["Remind"] as! Int32
            }
            if dict.keys.contains("Serious") && dict["Serious"] != nil {
                self.serious = dict["Serious"] as! Int32
            }
            if dict.keys.contains("Suspicious") && dict["Suspicious"] != nil {
                self.suspicious = dict["Suspicious"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var suspStatistics: GetClusterSuspEventStatisticsResponseBody.SuspStatistics?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.suspStatistics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.suspStatistics != nil {
            map["SuspStatistics"] = self.suspStatistics?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuspStatistics") && dict["SuspStatistics"] != nil {
            var model = GetClusterSuspEventStatisticsResponseBody.SuspStatistics()
            model.fromMap(dict["SuspStatistics"] as! [String: Any])
            self.suspStatistics = model
        }
    }
}

public class GetClusterSuspEventStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClusterSuspEventStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetClusterSuspEventStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCommonSwitchConfigRequest : Tea.TeaModel {
    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetCommonSwitchConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var targetDefault: String?

        public var targetSyncStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.targetDefault != nil {
                map["TargetDefault"] = self.targetDefault!
            }
            if self.targetSyncStatus != nil {
                map["TargetSyncStatus"] = self.targetSyncStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TargetDefault") && dict["TargetDefault"] != nil {
                self.targetDefault = dict["TargetDefault"] as! String
            }
            if dict.keys.contains("TargetSyncStatus") && dict["TargetSyncStatus"] != nil {
                self.targetSyncStatus = dict["TargetSyncStatus"] as! String
            }
        }
    }
    public var data: GetCommonSwitchConfigResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetCommonSwitchConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCommonSwitchConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCommonSwitchConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCommonSwitchConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileDetectApiInvokeInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var authCount: Int64?

        public var expire: Int64?

        public var flowRate: Int32?

        public var remainAuthCount: Int64?

        public var saleVersion: Int32?

        public var timeUnit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authCount != nil {
                map["AuthCount"] = self.authCount!
            }
            if self.expire != nil {
                map["Expire"] = self.expire!
            }
            if self.flowRate != nil {
                map["FlowRate"] = self.flowRate!
            }
            if self.remainAuthCount != nil {
                map["RemainAuthCount"] = self.remainAuthCount!
            }
            if self.saleVersion != nil {
                map["SaleVersion"] = self.saleVersion!
            }
            if self.timeUnit != nil {
                map["TimeUnit"] = self.timeUnit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthCount") && dict["AuthCount"] != nil {
                self.authCount = dict["AuthCount"] as! Int64
            }
            if dict.keys.contains("Expire") && dict["Expire"] != nil {
                self.expire = dict["Expire"] as! Int64
            }
            if dict.keys.contains("FlowRate") && dict["FlowRate"] != nil {
                self.flowRate = dict["FlowRate"] as! Int32
            }
            if dict.keys.contains("RemainAuthCount") && dict["RemainAuthCount"] != nil {
                self.remainAuthCount = dict["RemainAuthCount"] as! Int64
            }
            if dict.keys.contains("SaleVersion") && dict["SaleVersion"] != nil {
                self.saleVersion = dict["SaleVersion"] as! Int32
            }
            if dict.keys.contains("TimeUnit") && dict["TimeUnit"] != nil {
                self.timeUnit = dict["TimeUnit"] as! String
            }
        }
    }
    public var data: GetFileDetectApiInvokeInfoResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetFileDetectApiInvokeInfoResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetFileDetectApiInvokeInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileDetectApiInvokeInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetFileDetectApiInvokeInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileDetectResultRequest : Tea.TeaModel {
    public var hashKeyList: [String]?

    public var sourceIp: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hashKeyList != nil {
            map["HashKeyList"] = self.hashKeyList!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HashKeyList") && dict["HashKeyList"] != nil {
            self.hashKeyList = dict["HashKeyList"] as! [String]
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class GetFileDetectResultResponseBody : Tea.TeaModel {
    public class ResultList : Tea.TeaModel {
        public var code: String?

        public var ext: String?

        public var hashKey: String?

        public var message: String?

        public var result: Int32?

        public var score: Int32?

        public var virusType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.ext != nil {
                map["Ext"] = self.ext!
            }
            if self.hashKey != nil {
                map["HashKey"] = self.hashKey!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.score != nil {
                map["Score"] = self.score!
            }
            if self.virusType != nil {
                map["VirusType"] = self.virusType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") && dict["Code"] != nil {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Ext") && dict["Ext"] != nil {
                self.ext = dict["Ext"] as! String
            }
            if dict.keys.contains("HashKey") && dict["HashKey"] != nil {
                self.hashKey = dict["HashKey"] as! String
            }
            if dict.keys.contains("Message") && dict["Message"] != nil {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! Int32
            }
            if dict.keys.contains("Score") && dict["Score"] != nil {
                self.score = dict["Score"] as! Int32
            }
            if dict.keys.contains("VirusType") && dict["VirusType"] != nil {
                self.virusType = dict["VirusType"] as! String
            }
        }
    }
    public var requestId: String?

    public var resultList: [GetFileDetectResultResponseBody.ResultList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resultList != nil {
            var tmp : [Any] = []
            for k in self.resultList! {
                tmp.append(k.toMap())
            }
            map["ResultList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResultList") && dict["ResultList"] != nil {
            var tmp : [GetFileDetectResultResponseBody.ResultList] = []
            for v in dict["ResultList"] as! [Any] {
                var model = GetFileDetectResultResponseBody.ResultList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resultList = tmp
        }
    }
}

public class GetFileDetectResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileDetectResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetFileDetectResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileProtectDashboardResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enableRuleCount: Int32?

        public var pluginCount: Int32?

        public var pluginOfflineCount: Int32?

        public var pluginOnlineCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableRuleCount != nil {
                map["EnableRuleCount"] = self.enableRuleCount!
            }
            if self.pluginCount != nil {
                map["PluginCount"] = self.pluginCount!
            }
            if self.pluginOfflineCount != nil {
                map["PluginOfflineCount"] = self.pluginOfflineCount!
            }
            if self.pluginOnlineCount != nil {
                map["PluginOnlineCount"] = self.pluginOnlineCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableRuleCount") && dict["EnableRuleCount"] != nil {
                self.enableRuleCount = dict["EnableRuleCount"] as! Int32
            }
            if dict.keys.contains("PluginCount") && dict["PluginCount"] != nil {
                self.pluginCount = dict["PluginCount"] as! Int32
            }
            if dict.keys.contains("PluginOfflineCount") && dict["PluginOfflineCount"] != nil {
                self.pluginOfflineCount = dict["PluginOfflineCount"] as! Int32
            }
            if dict.keys.contains("PluginOnlineCount") && dict["PluginOnlineCount"] != nil {
                self.pluginOnlineCount = dict["PluginOnlineCount"] as! Int32
            }
        }
    }
    public var data: GetFileProtectDashboardResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetFileProtectDashboardResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetFileProtectDashboardResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileProtectDashboardResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetFileProtectDashboardResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileProtectEventRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetFileProtectEventResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var alertLevel: Int32?

        public var cmdLine: String?

        public var filePath: String?

        public var filePermission: String?

        public var firstTime: Int64?

        public var handleTime: Int64?

        public var id: Int64?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var latestTime: Int64?

        public var operation: String?

        public var procPath: String?

        public var processId: String?

        public var remark: String?

        public var ruleName: String?

        public var status: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertLevel != nil {
                map["AlertLevel"] = self.alertLevel!
            }
            if self.cmdLine != nil {
                map["CmdLine"] = self.cmdLine!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.filePermission != nil {
                map["FilePermission"] = self.filePermission!
            }
            if self.firstTime != nil {
                map["FirstTime"] = self.firstTime!
            }
            if self.handleTime != nil {
                map["HandleTime"] = self.handleTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.latestTime != nil {
                map["LatestTime"] = self.latestTime!
            }
            if self.operation != nil {
                map["Operation"] = self.operation!
            }
            if self.procPath != nil {
                map["ProcPath"] = self.procPath!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertLevel") && dict["AlertLevel"] != nil {
                self.alertLevel = dict["AlertLevel"] as! Int32
            }
            if dict.keys.contains("CmdLine") && dict["CmdLine"] != nil {
                self.cmdLine = dict["CmdLine"] as! String
            }
            if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("FilePermission") && dict["FilePermission"] != nil {
                self.filePermission = dict["FilePermission"] as! String
            }
            if dict.keys.contains("FirstTime") && dict["FirstTime"] != nil {
                self.firstTime = dict["FirstTime"] as! Int64
            }
            if dict.keys.contains("HandleTime") && dict["HandleTime"] != nil {
                self.handleTime = dict["HandleTime"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LatestTime") && dict["LatestTime"] != nil {
                self.latestTime = dict["LatestTime"] as! Int64
            }
            if dict.keys.contains("Operation") && dict["Operation"] != nil {
                self.operation = dict["Operation"] as! String
            }
            if dict.keys.contains("ProcPath") && dict["ProcPath"] != nil {
                self.procPath = dict["ProcPath"] as! String
            }
            if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
                self.processId = dict["ProcessId"] as! String
            }
            if dict.keys.contains("Remark") && dict["Remark"] != nil {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var data: GetFileProtectEventResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetFileProtectEventResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetFileProtectEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileProtectEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetFileProtectEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileProtectEventCountRequest : Tea.TeaModel {
    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class GetFileProtectEventCountResponseBody : Tea.TeaModel {
    public var data: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetFileProtectEventCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileProtectEventCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetFileProtectEventCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFileProtectRuleRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class GetFileProtectRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var action: String?

        public var alertLevel: Int32?

        public var fileOps: [String]?

        public var filePaths: [String]?

        public var id: Int64?

        public var procPaths: [String]?

        public var ruleName: String?

        public var status: Int32?

        public var switchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.alertLevel != nil {
                map["AlertLevel"] = self.alertLevel!
            }
            if self.fileOps != nil {
                map["FileOps"] = self.fileOps!
            }
            if self.filePaths != nil {
                map["FilePaths"] = self.filePaths!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.procPaths != nil {
                map["ProcPaths"] = self.procPaths!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.switchId != nil {
                map["SwitchId"] = self.switchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("AlertLevel") && dict["AlertLevel"] != nil {
                self.alertLevel = dict["AlertLevel"] as! Int32
            }
            if dict.keys.contains("FileOps") && dict["FileOps"] != nil {
                self.fileOps = dict["FileOps"] as! [String]
            }
            if dict.keys.contains("FilePaths") && dict["FilePaths"] != nil {
                self.filePaths = dict["FilePaths"] as! [String]
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ProcPaths") && dict["ProcPaths"] != nil {
                self.procPaths = dict["ProcPaths"] as! [String]
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("SwitchId") && dict["SwitchId"] != nil {
                self.switchId = dict["SwitchId"] as! String
            }
        }
    }
    public var data: GetFileProtectRuleResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetFileProtectRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetFileProtectRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFileProtectRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetFileProtectRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHoneypotAttackStatisticsRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var endTimeStamp: Int64?

    public var lang: String?

    public var pageSize: Int32?

    public var riskLevelList: [String]?

    public var srcIp: String?

    public var startTimeStamp: Int64?

    public var statisticsType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTimeStamp != nil {
            map["EndTimeStamp"] = self.endTimeStamp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskLevelList != nil {
            map["RiskLevelList"] = self.riskLevelList!
        }
        if self.srcIp != nil {
            map["SrcIp"] = self.srcIp!
        }
        if self.startTimeStamp != nil {
            map["StartTimeStamp"] = self.startTimeStamp!
        }
        if self.statisticsType != nil {
            map["StatisticsType"] = self.statisticsType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTimeStamp") && dict["EndTimeStamp"] != nil {
            self.endTimeStamp = dict["EndTimeStamp"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskLevelList") && dict["RiskLevelList"] != nil {
            self.riskLevelList = dict["RiskLevelList"] as! [String]
        }
        if dict.keys.contains("SrcIp") && dict["SrcIp"] != nil {
            self.srcIp = dict["SrcIp"] as! String
        }
        if dict.keys.contains("StartTimeStamp") && dict["StartTimeStamp"] != nil {
            self.startTimeStamp = dict["StartTimeStamp"] as! Int64
        }
        if dict.keys.contains("StatisticsType") && dict["StatisticsType"] != nil {
            self.statisticsType = dict["StatisticsType"] as! String
        }
    }
}

public class GetHoneypotAttackStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class HoneypotAttackStatistics : Tea.TeaModel {
            public var statisticsCount: Int32?

            public var statisticsValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.statisticsCount != nil {
                    map["StatisticsCount"] = self.statisticsCount!
                }
                if self.statisticsValue != nil {
                    map["StatisticsValue"] = self.statisticsValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("StatisticsCount") && dict["StatisticsCount"] != nil {
                    self.statisticsCount = dict["StatisticsCount"] as! Int32
                }
                if dict.keys.contains("StatisticsValue") && dict["StatisticsValue"] != nil {
                    self.statisticsValue = dict["StatisticsValue"] as! String
                }
            }
        }
        public var count: Int32?

        public var honeypotAttackStatistics: [GetHoneypotAttackStatisticsResponseBody.Data.HoneypotAttackStatistics]?

        public var statisticsType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.honeypotAttackStatistics != nil {
                var tmp : [Any] = []
                for k in self.honeypotAttackStatistics! {
                    tmp.append(k.toMap())
                }
                map["HoneypotAttackStatistics"] = tmp
            }
            if self.statisticsType != nil {
                map["StatisticsType"] = self.statisticsType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("HoneypotAttackStatistics") && dict["HoneypotAttackStatistics"] != nil {
                var tmp : [GetHoneypotAttackStatisticsResponseBody.Data.HoneypotAttackStatistics] = []
                for v in dict["HoneypotAttackStatistics"] as! [Any] {
                    var model = GetHoneypotAttackStatisticsResponseBody.Data.HoneypotAttackStatistics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.honeypotAttackStatistics = tmp
            }
            if dict.keys.contains("StatisticsType") && dict["StatisticsType"] != nil {
                self.statisticsType = dict["StatisticsType"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetHoneypotAttackStatisticsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetHoneypotAttackStatisticsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetHoneypotAttackStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHoneypotAttackStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetHoneypotAttackStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHoneypotEventTrendRequest : Tea.TeaModel {
    public var endTimeStamp: Int64?

    public var lang: String?

    public var riskLevelList: [String]?

    public var srcIp: String?

    public var startTimeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTimeStamp != nil {
            map["EndTimeStamp"] = self.endTimeStamp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.riskLevelList != nil {
            map["RiskLevelList"] = self.riskLevelList!
        }
        if self.srcIp != nil {
            map["SrcIp"] = self.srcIp!
        }
        if self.startTimeStamp != nil {
            map["StartTimeStamp"] = self.startTimeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTimeStamp") && dict["EndTimeStamp"] != nil {
            self.endTimeStamp = dict["EndTimeStamp"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RiskLevelList") && dict["RiskLevelList"] != nil {
            self.riskLevelList = dict["RiskLevelList"] as! [String]
        }
        if dict.keys.contains("SrcIp") && dict["SrcIp"] != nil {
            self.srcIp = dict["SrcIp"] as! String
        }
        if dict.keys.contains("StartTimeStamp") && dict["StartTimeStamp"] != nil {
            self.startTimeStamp = dict["StartTimeStamp"] as! Int64
        }
    }
}

public class GetHoneypotEventTrendResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int32?

        public var keyName: String?

        public var timeStamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.keyName != nil {
                map["KeyName"] = self.keyName!
            }
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("KeyName") && dict["KeyName"] != nil {
                self.keyName = dict["KeyName"] as! String
            }
            if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
                self.timeStamp = dict["TimeStamp"] as! Int64
            }
        }
    }
    public var code: String?

    public var count: Int32?

    public var data: [GetHoneypotEventTrendResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetHoneypotEventTrendResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetHoneypotEventTrendResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetHoneypotEventTrendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHoneypotEventTrendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetHoneypotEventTrendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHoneypotNodeRequest : Tea.TeaModel {
    public var lang: String?

    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class GetHoneypotNodeResponseBody : Tea.TeaModel {
    public class HoneypotNode : Tea.TeaModel {
        public var allowHoneypotAccessInternet: Bool?

        public var createTime: String?

        public var ecsInstanceId: String?

        public var honeypotTotalCount: Int32?

        public var honeypotUsedCount: Int32?

        public var nodeId: String?

        public var nodeIp: String?

        public var nodeName: String?

        public var probeTotalCount: Int32?

        public var probeUsedCount: Int32?

        public var securityGroupProbeIpList: [String]?

        public var totalStatus: Int32?

        public var upgradeAvailable: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowHoneypotAccessInternet != nil {
                map["AllowHoneypotAccessInternet"] = self.allowHoneypotAccessInternet!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.ecsInstanceId != nil {
                map["EcsInstanceId"] = self.ecsInstanceId!
            }
            if self.honeypotTotalCount != nil {
                map["HoneypotTotalCount"] = self.honeypotTotalCount!
            }
            if self.honeypotUsedCount != nil {
                map["HoneypotUsedCount"] = self.honeypotUsedCount!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeIp != nil {
                map["NodeIp"] = self.nodeIp!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.probeTotalCount != nil {
                map["ProbeTotalCount"] = self.probeTotalCount!
            }
            if self.probeUsedCount != nil {
                map["ProbeUsedCount"] = self.probeUsedCount!
            }
            if self.securityGroupProbeIpList != nil {
                map["SecurityGroupProbeIpList"] = self.securityGroupProbeIpList!
            }
            if self.totalStatus != nil {
                map["TotalStatus"] = self.totalStatus!
            }
            if self.upgradeAvailable != nil {
                map["UpgradeAvailable"] = self.upgradeAvailable!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowHoneypotAccessInternet") && dict["AllowHoneypotAccessInternet"] != nil {
                self.allowHoneypotAccessInternet = dict["AllowHoneypotAccessInternet"] as! Bool
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("EcsInstanceId") && dict["EcsInstanceId"] != nil {
                self.ecsInstanceId = dict["EcsInstanceId"] as! String
            }
            if dict.keys.contains("HoneypotTotalCount") && dict["HoneypotTotalCount"] != nil {
                self.honeypotTotalCount = dict["HoneypotTotalCount"] as! Int32
            }
            if dict.keys.contains("HoneypotUsedCount") && dict["HoneypotUsedCount"] != nil {
                self.honeypotUsedCount = dict["HoneypotUsedCount"] as! Int32
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("NodeIp") && dict["NodeIp"] != nil {
                self.nodeIp = dict["NodeIp"] as! String
            }
            if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("ProbeTotalCount") && dict["ProbeTotalCount"] != nil {
                self.probeTotalCount = dict["ProbeTotalCount"] as! Int32
            }
            if dict.keys.contains("ProbeUsedCount") && dict["ProbeUsedCount"] != nil {
                self.probeUsedCount = dict["ProbeUsedCount"] as! Int32
            }
            if dict.keys.contains("SecurityGroupProbeIpList") && dict["SecurityGroupProbeIpList"] != nil {
                self.securityGroupProbeIpList = dict["SecurityGroupProbeIpList"] as! [String]
            }
            if dict.keys.contains("TotalStatus") && dict["TotalStatus"] != nil {
                self.totalStatus = dict["TotalStatus"] as! Int32
            }
            if dict.keys.contains("UpgradeAvailable") && dict["UpgradeAvailable"] != nil {
                self.upgradeAvailable = dict["UpgradeAvailable"] as! Bool
            }
        }
    }
    public var code: String?

    public var honeypotNode: GetHoneypotNodeResponseBody.HoneypotNode?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.honeypotNode?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.honeypotNode != nil {
            map["HoneypotNode"] = self.honeypotNode?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HoneypotNode") && dict["HoneypotNode"] != nil {
            var model = GetHoneypotNodeResponseBody.HoneypotNode()
            model.fromMap(dict["HoneypotNode"] as! [String: Any])
            self.honeypotNode = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetHoneypotNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHoneypotNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetHoneypotNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHoneypotPresetRequest : Tea.TeaModel {
    public var honeypotPresetId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeypotPresetId != nil {
            map["HoneypotPresetId"] = self.honeypotPresetId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneypotPresetId") && dict["HoneypotPresetId"] != nil {
            self.honeypotPresetId = dict["HoneypotPresetId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class GetHoneypotPresetResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class FileInfoList : Tea.TeaModel {
            public var fileId: String?

            public var fileName: String?

            public var ossUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.fileName != nil {
                    map["FileName"] = self.fileName!
                }
                if self.ossUrl != nil {
                    map["OssUrl"] = self.ossUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileId") && dict["FileId"] != nil {
                    self.fileId = dict["FileId"] as! String
                }
                if dict.keys.contains("FileName") && dict["FileName"] != nil {
                    self.fileName = dict["FileName"] as! String
                }
                if dict.keys.contains("OssUrl") && dict["OssUrl"] != nil {
                    self.ossUrl = dict["OssUrl"] as! String
                }
            }
        }
        public var controlNodeName: String?

        public var fileInfoList: [GetHoneypotPresetResponseBody.Data.FileInfoList]?

        public var honeypotImageDisplayName: String?

        public var honeypotImageName: String?

        public var honeypotPresetId: String?

        public var meta: String?

        public var nodeId: String?

        public var presetName: String?

        public var presetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.controlNodeName != nil {
                map["ControlNodeName"] = self.controlNodeName!
            }
            if self.fileInfoList != nil {
                var tmp : [Any] = []
                for k in self.fileInfoList! {
                    tmp.append(k.toMap())
                }
                map["FileInfoList"] = tmp
            }
            if self.honeypotImageDisplayName != nil {
                map["HoneypotImageDisplayName"] = self.honeypotImageDisplayName!
            }
            if self.honeypotImageName != nil {
                map["HoneypotImageName"] = self.honeypotImageName!
            }
            if self.honeypotPresetId != nil {
                map["HoneypotPresetId"] = self.honeypotPresetId!
            }
            if self.meta != nil {
                map["Meta"] = self.meta!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.presetName != nil {
                map["PresetName"] = self.presetName!
            }
            if self.presetType != nil {
                map["PresetType"] = self.presetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ControlNodeName") && dict["ControlNodeName"] != nil {
                self.controlNodeName = dict["ControlNodeName"] as! String
            }
            if dict.keys.contains("FileInfoList") && dict["FileInfoList"] != nil {
                var tmp : [GetHoneypotPresetResponseBody.Data.FileInfoList] = []
                for v in dict["FileInfoList"] as! [Any] {
                    var model = GetHoneypotPresetResponseBody.Data.FileInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fileInfoList = tmp
            }
            if dict.keys.contains("HoneypotImageDisplayName") && dict["HoneypotImageDisplayName"] != nil {
                self.honeypotImageDisplayName = dict["HoneypotImageDisplayName"] as! String
            }
            if dict.keys.contains("HoneypotImageName") && dict["HoneypotImageName"] != nil {
                self.honeypotImageName = dict["HoneypotImageName"] as! String
            }
            if dict.keys.contains("HoneypotPresetId") && dict["HoneypotPresetId"] != nil {
                self.honeypotPresetId = dict["HoneypotPresetId"] as! String
            }
            if dict.keys.contains("Meta") && dict["Meta"] != nil {
                self.meta = dict["Meta"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PresetName") && dict["PresetName"] != nil {
                self.presetName = dict["PresetName"] as! String
            }
            if dict.keys.contains("PresetType") && dict["PresetType"] != nil {
                self.presetType = dict["PresetType"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetHoneypotPresetResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetHoneypotPresetResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetHoneypotPresetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHoneypotPresetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetHoneypotPresetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHoneypotProbeRequest : Tea.TeaModel {
    public var lang: String?

    public var probeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.probeId != nil {
            map["ProbeId"] = self.probeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ProbeId") && dict["ProbeId"] != nil {
            self.probeId = dict["ProbeId"] as! String
        }
    }
}

public class GetHoneypotProbeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ControlNode : Tea.TeaModel {
            public var ecsInstanceId: String?

            public var nodeId: String?

            public var nodeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ecsInstanceId != nil {
                    map["EcsInstanceId"] = self.ecsInstanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EcsInstanceId") && dict["EcsInstanceId"] != nil {
                    self.ecsInstanceId = dict["EcsInstanceId"] as! String
                }
                if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                    self.nodeName = dict["NodeName"] as! String
                }
            }
        }
        public class HoneyPotProbeScanPort : Tea.TeaModel {
            public var id: Int64?

            public var ports: String?

            public var probeId: String?

            public var serviceIpList: [String]?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.ports != nil {
                    map["Ports"] = self.ports!
                }
                if self.probeId != nil {
                    map["ProbeId"] = self.probeId!
                }
                if self.serviceIpList != nil {
                    map["ServiceIpList"] = self.serviceIpList!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Ports") && dict["Ports"] != nil {
                    self.ports = dict["Ports"] as! String
                }
                if dict.keys.contains("ProbeId") && dict["ProbeId"] != nil {
                    self.probeId = dict["ProbeId"] as! String
                }
                if dict.keys.contains("ServiceIpList") && dict["ServiceIpList"] != nil {
                    self.serviceIpList = dict["ServiceIpList"] as! [String]
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public class HoneypotProbeBindList : Tea.TeaModel {
            public class BindPortList : Tea.TeaModel {
                public var bindPort: Bool?

                public var endPort: Int32?

                public var err: String?

                public var fixed: Bool?

                public var id: Int64?

                public var msg: String?

                public var proto: String?

                public var startPort: Int32?

                public var status: Int32?

                public var targetPort: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bindPort != nil {
                        map["BindPort"] = self.bindPort!
                    }
                    if self.endPort != nil {
                        map["EndPort"] = self.endPort!
                    }
                    if self.err != nil {
                        map["Err"] = self.err!
                    }
                    if self.fixed != nil {
                        map["Fixed"] = self.fixed!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.msg != nil {
                        map["Msg"] = self.msg!
                    }
                    if self.proto != nil {
                        map["Proto"] = self.proto!
                    }
                    if self.startPort != nil {
                        map["StartPort"] = self.startPort!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.targetPort != nil {
                        map["TargetPort"] = self.targetPort!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BindPort") && dict["BindPort"] != nil {
                        self.bindPort = dict["BindPort"] as! Bool
                    }
                    if dict.keys.contains("EndPort") && dict["EndPort"] != nil {
                        self.endPort = dict["EndPort"] as! Int32
                    }
                    if dict.keys.contains("Err") && dict["Err"] != nil {
                        self.err = dict["Err"] as! String
                    }
                    if dict.keys.contains("Fixed") && dict["Fixed"] != nil {
                        self.fixed = dict["Fixed"] as! Bool
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Msg") && dict["Msg"] != nil {
                        self.msg = dict["Msg"] as! String
                    }
                    if dict.keys.contains("Proto") && dict["Proto"] != nil {
                        self.proto = dict["Proto"] as! String
                    }
                    if dict.keys.contains("StartPort") && dict["StartPort"] != nil {
                        self.startPort = dict["StartPort"] as! Int32
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! Int32
                    }
                    if dict.keys.contains("TargetPort") && dict["TargetPort"] != nil {
                        self.targetPort = dict["TargetPort"] as! Int32
                    }
                }
            }
            public var bindId: String?

            public var bindPortList: [GetHoneypotProbeResponseBody.Data.HoneypotProbeBindList.BindPortList]?

            public var honeypotId: String?

            public var serviceIpList: [String]?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindId != nil {
                    map["BindId"] = self.bindId!
                }
                if self.bindPortList != nil {
                    var tmp : [Any] = []
                    for k in self.bindPortList! {
                        tmp.append(k.toMap())
                    }
                    map["BindPortList"] = tmp
                }
                if self.honeypotId != nil {
                    map["HoneypotId"] = self.honeypotId!
                }
                if self.serviceIpList != nil {
                    map["ServiceIpList"] = self.serviceIpList!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindId") && dict["BindId"] != nil {
                    self.bindId = dict["BindId"] as! String
                }
                if dict.keys.contains("BindPortList") && dict["BindPortList"] != nil {
                    var tmp : [GetHoneypotProbeResponseBody.Data.HoneypotProbeBindList.BindPortList] = []
                    for v in dict["BindPortList"] as! [Any] {
                        var model = GetHoneypotProbeResponseBody.Data.HoneypotProbeBindList.BindPortList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.bindPortList = tmp
                }
                if dict.keys.contains("HoneypotId") && dict["HoneypotId"] != nil {
                    self.honeypotId = dict["HoneypotId"] as! String
                }
                if dict.keys.contains("ServiceIpList") && dict["ServiceIpList"] != nil {
                    self.serviceIpList = dict["ServiceIpList"] as! [String]
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var arp: Bool?

        public var canListenIpList: [String]?

        public var cidrList: [String]?

        public var controlNode: GetHoneypotProbeResponseBody.Data.ControlNode?

        public var cpuLoad: Double?

        public var deployTime: Int64?

        public var displayName: String?

        public var honeyPotProbeScanPort: GetHoneypotProbeResponseBody.Data.HoneyPotProbeScanPort?

        public var honeypotProbeBindList: [GetHoneypotProbeResponseBody.Data.HoneypotProbeBindList]?

        public var hostIp: String?

        public var listenIpList: [String]?

        public var memoryLoad: Double?

        public var osType: String?

        public var ping: Bool?

        public var probeId: String?

        public var probeType: String?

        public var probeVersion: String?

        public var proxyIp: String?

        public var status: Int32?

        public var uuid: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.controlNode?.validate()
            try self.honeyPotProbeScanPort?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arp != nil {
                map["Arp"] = self.arp!
            }
            if self.canListenIpList != nil {
                map["CanListenIpList"] = self.canListenIpList!
            }
            if self.cidrList != nil {
                map["CidrList"] = self.cidrList!
            }
            if self.controlNode != nil {
                map["ControlNode"] = self.controlNode?.toMap()
            }
            if self.cpuLoad != nil {
                map["CpuLoad"] = self.cpuLoad!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.honeyPotProbeScanPort != nil {
                map["HoneyPotProbeScanPort"] = self.honeyPotProbeScanPort?.toMap()
            }
            if self.honeypotProbeBindList != nil {
                var tmp : [Any] = []
                for k in self.honeypotProbeBindList! {
                    tmp.append(k.toMap())
                }
                map["HoneypotProbeBindList"] = tmp
            }
            if self.hostIp != nil {
                map["HostIp"] = self.hostIp!
            }
            if self.listenIpList != nil {
                map["ListenIpList"] = self.listenIpList!
            }
            if self.memoryLoad != nil {
                map["MemoryLoad"] = self.memoryLoad!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.ping != nil {
                map["Ping"] = self.ping!
            }
            if self.probeId != nil {
                map["ProbeId"] = self.probeId!
            }
            if self.probeType != nil {
                map["ProbeType"] = self.probeType!
            }
            if self.probeVersion != nil {
                map["ProbeVersion"] = self.probeVersion!
            }
            if self.proxyIp != nil {
                map["ProxyIp"] = self.proxyIp!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arp") && dict["Arp"] != nil {
                self.arp = dict["Arp"] as! Bool
            }
            if dict.keys.contains("CanListenIpList") && dict["CanListenIpList"] != nil {
                self.canListenIpList = dict["CanListenIpList"] as! [String]
            }
            if dict.keys.contains("CidrList") && dict["CidrList"] != nil {
                self.cidrList = dict["CidrList"] as! [String]
            }
            if dict.keys.contains("ControlNode") && dict["ControlNode"] != nil {
                var model = GetHoneypotProbeResponseBody.Data.ControlNode()
                model.fromMap(dict["ControlNode"] as! [String: Any])
                self.controlNode = model
            }
            if dict.keys.contains("CpuLoad") && dict["CpuLoad"] != nil {
                self.cpuLoad = dict["CpuLoad"] as! Double
            }
            if dict.keys.contains("DeployTime") && dict["DeployTime"] != nil {
                self.deployTime = dict["DeployTime"] as! Int64
            }
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("HoneyPotProbeScanPort") && dict["HoneyPotProbeScanPort"] != nil {
                var model = GetHoneypotProbeResponseBody.Data.HoneyPotProbeScanPort()
                model.fromMap(dict["HoneyPotProbeScanPort"] as! [String: Any])
                self.honeyPotProbeScanPort = model
            }
            if dict.keys.contains("HoneypotProbeBindList") && dict["HoneypotProbeBindList"] != nil {
                var tmp : [GetHoneypotProbeResponseBody.Data.HoneypotProbeBindList] = []
                for v in dict["HoneypotProbeBindList"] as! [Any] {
                    var model = GetHoneypotProbeResponseBody.Data.HoneypotProbeBindList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.honeypotProbeBindList = tmp
            }
            if dict.keys.contains("HostIp") && dict["HostIp"] != nil {
                self.hostIp = dict["HostIp"] as! String
            }
            if dict.keys.contains("ListenIpList") && dict["ListenIpList"] != nil {
                self.listenIpList = dict["ListenIpList"] as! [String]
            }
            if dict.keys.contains("MemoryLoad") && dict["MemoryLoad"] != nil {
                self.memoryLoad = dict["MemoryLoad"] as! Double
            }
            if dict.keys.contains("OsType") && dict["OsType"] != nil {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("Ping") && dict["Ping"] != nil {
                self.ping = dict["Ping"] as! Bool
            }
            if dict.keys.contains("ProbeId") && dict["ProbeId"] != nil {
                self.probeId = dict["ProbeId"] as! String
            }
            if dict.keys.contains("ProbeType") && dict["ProbeType"] != nil {
                self.probeType = dict["ProbeType"] as! String
            }
            if dict.keys.contains("ProbeVersion") && dict["ProbeVersion"] != nil {
                self.probeVersion = dict["ProbeVersion"] as! String
            }
            if dict.keys.contains("ProxyIp") && dict["ProxyIp"] != nil {
                self.proxyIp = dict["ProxyIp"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetHoneypotProbeResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetHoneypotProbeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetHoneypotProbeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHoneypotProbeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetHoneypotProbeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHoneypotStatisticsRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class GetHoneypotStatisticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var totalHoneypotCount: Int32?

        public var totalNodeStatus: Int32?

        public var totalProbeCount: Int32?

        public var usedHoneypotCount: Int32?

        public var usedHostProbeCount: Int32?

        public var usedProbeCount: Int32?

        public var usedVpcProbeCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.totalHoneypotCount != nil {
                map["TotalHoneypotCount"] = self.totalHoneypotCount!
            }
            if self.totalNodeStatus != nil {
                map["TotalNodeStatus"] = self.totalNodeStatus!
            }
            if self.totalProbeCount != nil {
                map["TotalProbeCount"] = self.totalProbeCount!
            }
            if self.usedHoneypotCount != nil {
                map["UsedHoneypotCount"] = self.usedHoneypotCount!
            }
            if self.usedHostProbeCount != nil {
                map["UsedHostProbeCount"] = self.usedHostProbeCount!
            }
            if self.usedProbeCount != nil {
                map["UsedProbeCount"] = self.usedProbeCount!
            }
            if self.usedVpcProbeCount != nil {
                map["UsedVpcProbeCount"] = self.usedVpcProbeCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TotalHoneypotCount") && dict["TotalHoneypotCount"] != nil {
                self.totalHoneypotCount = dict["TotalHoneypotCount"] as! Int32
            }
            if dict.keys.contains("TotalNodeStatus") && dict["TotalNodeStatus"] != nil {
                self.totalNodeStatus = dict["TotalNodeStatus"] as! Int32
            }
            if dict.keys.contains("TotalProbeCount") && dict["TotalProbeCount"] != nil {
                self.totalProbeCount = dict["TotalProbeCount"] as! Int32
            }
            if dict.keys.contains("UsedHoneypotCount") && dict["UsedHoneypotCount"] != nil {
                self.usedHoneypotCount = dict["UsedHoneypotCount"] as! Int32
            }
            if dict.keys.contains("UsedHostProbeCount") && dict["UsedHostProbeCount"] != nil {
                self.usedHostProbeCount = dict["UsedHostProbeCount"] as! Int32
            }
            if dict.keys.contains("UsedProbeCount") && dict["UsedProbeCount"] != nil {
                self.usedProbeCount = dict["UsedProbeCount"] as! Int32
            }
            if dict.keys.contains("UsedVpcProbeCount") && dict["UsedVpcProbeCount"] != nil {
                self.usedVpcProbeCount = dict["UsedVpcProbeCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: GetHoneypotStatisticsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetHoneypotStatisticsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetHoneypotStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHoneypotStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetHoneypotStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetImageScanNumInPeriodRequest : Tea.TeaModel {
    public var pastDay: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pastDay != nil {
            map["PastDay"] = self.pastDay!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PastDay") && dict["PastDay"] != nil {
            self.pastDay = dict["PastDay"] as! String
        }
    }
}

public class GetImageScanNumInPeriodResponseBody : Tea.TeaModel {
    public class ImageScanData : Tea.TeaModel {
        public var imageScanCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageScanCount != nil {
                map["ImageScanCount"] = self.imageScanCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageScanCount") && dict["ImageScanCount"] != nil {
                self.imageScanCount = dict["ImageScanCount"] as! Int32
            }
        }
    }
    public var imageScanData: GetImageScanNumInPeriodResponseBody.ImageScanData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageScanData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageScanData != nil {
            map["ImageScanData"] = self.imageScanData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageScanData") && dict["ImageScanData"] != nil {
            var model = GetImageScanNumInPeriodResponseBody.ImageScanData()
            model.fromMap(dict["ImageScanData"] as! [String: Any])
            self.imageScanData = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetImageScanNumInPeriodResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetImageScanNumInPeriodResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetImageScanNumInPeriodResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInterceptionRuleDetailRequest : Tea.TeaModel {
    public var clusterId: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class GetInterceptionRuleDetailResponseBody : Tea.TeaModel {
    public class InterceptionRuleDetail : Tea.TeaModel {
        public class DstTarget : Tea.TeaModel {
            public var appName: String?

            public var imageList: [String]?

            public var namespace: String?

            public var ports: [String]?

            public var ruleType: String?

            public var tagList: [String]?

            public var targetId: Int32?

            public var targetName: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.imageList != nil {
                    map["ImageList"] = self.imageList!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.ports != nil {
                    map["Ports"] = self.ports!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                if self.tagList != nil {
                    map["TagList"] = self.tagList!
                }
                if self.targetId != nil {
                    map["TargetId"] = self.targetId!
                }
                if self.targetName != nil {
                    map["TargetName"] = self.targetName!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("ImageList") && dict["ImageList"] != nil {
                    self.imageList = dict["ImageList"] as! [String]
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Ports") && dict["Ports"] != nil {
                    self.ports = dict["Ports"] as! [String]
                }
                if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                    self.ruleType = dict["RuleType"] as! String
                }
                if dict.keys.contains("TagList") && dict["TagList"] != nil {
                    self.tagList = dict["TagList"] as! [String]
                }
                if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                    self.targetId = dict["TargetId"] as! Int32
                }
                if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                    self.targetName = dict["TargetName"] as! String
                }
                if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                    self.targetType = dict["TargetType"] as! String
                }
            }
        }
        public class SrcTarget : Tea.TeaModel {
            public var appName: String?

            public var imageList: [String]?

            public var namespace: String?

            public var ruleType: String?

            public var tagList: [String]?

            public var targetId: Int32?

            public var targetName: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.imageList != nil {
                    map["ImageList"] = self.imageList!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                if self.tagList != nil {
                    map["TagList"] = self.tagList!
                }
                if self.targetId != nil {
                    map["TargetId"] = self.targetId!
                }
                if self.targetName != nil {
                    map["TargetName"] = self.targetName!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("ImageList") && dict["ImageList"] != nil {
                    self.imageList = dict["ImageList"] as! [String]
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                    self.ruleType = dict["RuleType"] as! String
                }
                if dict.keys.contains("TagList") && dict["TagList"] != nil {
                    self.tagList = dict["TagList"] as! [String]
                }
                if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                    self.targetId = dict["TargetId"] as! Int32
                }
                if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                    self.targetName = dict["TargetName"] as! String
                }
                if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                    self.targetType = dict["TargetType"] as! String
                }
            }
        }
        public var dstTarget: GetInterceptionRuleDetailResponseBody.InterceptionRuleDetail.DstTarget?

        public var interceptType: Int64?

        public var orderIndex: Int64?

        public var ruleId: Int64?

        public var ruleName: String?

        public var ruleSwitch: Int32?

        public var ruleType: String?

        public var srcTarget: GetInterceptionRuleDetailResponseBody.InterceptionRuleDetail.SrcTarget?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dstTarget?.validate()
            try self.srcTarget?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dstTarget != nil {
                map["DstTarget"] = self.dstTarget?.toMap()
            }
            if self.interceptType != nil {
                map["InterceptType"] = self.interceptType!
            }
            if self.orderIndex != nil {
                map["OrderIndex"] = self.orderIndex!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleSwitch != nil {
                map["RuleSwitch"] = self.ruleSwitch!
            }
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            if self.srcTarget != nil {
                map["SrcTarget"] = self.srcTarget?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DstTarget") && dict["DstTarget"] != nil {
                var model = GetInterceptionRuleDetailResponseBody.InterceptionRuleDetail.DstTarget()
                model.fromMap(dict["DstTarget"] as! [String: Any])
                self.dstTarget = model
            }
            if dict.keys.contains("InterceptType") && dict["InterceptType"] != nil {
                self.interceptType = dict["InterceptType"] as! Int64
            }
            if dict.keys.contains("OrderIndex") && dict["OrderIndex"] != nil {
                self.orderIndex = dict["OrderIndex"] as! Int64
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! Int64
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("RuleSwitch") && dict["RuleSwitch"] != nil {
                self.ruleSwitch = dict["RuleSwitch"] as! Int32
            }
            if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                self.ruleType = dict["RuleType"] as! String
            }
            if dict.keys.contains("SrcTarget") && dict["SrcTarget"] != nil {
                var model = GetInterceptionRuleDetailResponseBody.InterceptionRuleDetail.SrcTarget()
                model.fromMap(dict["SrcTarget"] as! [String: Any])
                self.srcTarget = model
            }
        }
    }
    public var interceptionRuleDetail: GetInterceptionRuleDetailResponseBody.InterceptionRuleDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.interceptionRuleDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.interceptionRuleDetail != nil {
            map["InterceptionRuleDetail"] = self.interceptionRuleDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InterceptionRuleDetail") && dict["InterceptionRuleDetail"] != nil {
            var model = GetInterceptionRuleDetailResponseBody.InterceptionRuleDetail()
            model.fromMap(dict["InterceptionRuleDetail"] as! [String: Any])
            self.interceptionRuleDetail = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetInterceptionRuleDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInterceptionRuleDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetInterceptionRuleDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInterceptionSummaryRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class GetInterceptionSummaryResponseBody : Tea.TeaModel {
    public class InterceptionSummary : Tea.TeaModel {
        public var closeClusterCount: Int32?

        public var closeRuleCount: Int32?

        public var clusterCount: Int32?

        public var interceptionCountInDays: Int32?

        public var openClusterCount: Int32?

        public var openRuleCount: Int32?

        public var riskCount180Day: Int64?

        public var riskCount30Day: Int64?

        public var riskCountToday: Int64?

        public var ruleCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.closeClusterCount != nil {
                map["CloseClusterCount"] = self.closeClusterCount!
            }
            if self.closeRuleCount != nil {
                map["CloseRuleCount"] = self.closeRuleCount!
            }
            if self.clusterCount != nil {
                map["ClusterCount"] = self.clusterCount!
            }
            if self.interceptionCountInDays != nil {
                map["InterceptionCountInDays"] = self.interceptionCountInDays!
            }
            if self.openClusterCount != nil {
                map["OpenClusterCount"] = self.openClusterCount!
            }
            if self.openRuleCount != nil {
                map["OpenRuleCount"] = self.openRuleCount!
            }
            if self.riskCount180Day != nil {
                map["RiskCount180Day"] = self.riskCount180Day!
            }
            if self.riskCount30Day != nil {
                map["RiskCount30Day"] = self.riskCount30Day!
            }
            if self.riskCountToday != nil {
                map["RiskCountToday"] = self.riskCountToday!
            }
            if self.ruleCount != nil {
                map["RuleCount"] = self.ruleCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CloseClusterCount") && dict["CloseClusterCount"] != nil {
                self.closeClusterCount = dict["CloseClusterCount"] as! Int32
            }
            if dict.keys.contains("CloseRuleCount") && dict["CloseRuleCount"] != nil {
                self.closeRuleCount = dict["CloseRuleCount"] as! Int32
            }
            if dict.keys.contains("ClusterCount") && dict["ClusterCount"] != nil {
                self.clusterCount = dict["ClusterCount"] as! Int32
            }
            if dict.keys.contains("InterceptionCountInDays") && dict["InterceptionCountInDays"] != nil {
                self.interceptionCountInDays = dict["InterceptionCountInDays"] as! Int32
            }
            if dict.keys.contains("OpenClusterCount") && dict["OpenClusterCount"] != nil {
                self.openClusterCount = dict["OpenClusterCount"] as! Int32
            }
            if dict.keys.contains("OpenRuleCount") && dict["OpenRuleCount"] != nil {
                self.openRuleCount = dict["OpenRuleCount"] as! Int32
            }
            if dict.keys.contains("RiskCount180Day") && dict["RiskCount180Day"] != nil {
                self.riskCount180Day = dict["RiskCount180Day"] as! Int64
            }
            if dict.keys.contains("RiskCount30Day") && dict["RiskCount30Day"] != nil {
                self.riskCount30Day = dict["RiskCount30Day"] as! Int64
            }
            if dict.keys.contains("RiskCountToday") && dict["RiskCountToday"] != nil {
                self.riskCountToday = dict["RiskCountToday"] as! Int64
            }
            if dict.keys.contains("RuleCount") && dict["RuleCount"] != nil {
                self.ruleCount = dict["RuleCount"] as! Int32
            }
        }
    }
    public var interceptionSummary: GetInterceptionSummaryResponseBody.InterceptionSummary?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.interceptionSummary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.interceptionSummary != nil {
            map["InterceptionSummary"] = self.interceptionSummary?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InterceptionSummary") && dict["InterceptionSummary"] != nil {
            var model = GetInterceptionSummaryResponseBody.InterceptionSummary()
            model.fromMap(dict["InterceptionSummary"] as! [String: Any])
            self.interceptionSummary = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetInterceptionSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInterceptionSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetInterceptionSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInterceptionTargetDetailRequest : Tea.TeaModel {
    public var targetId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.targetId != nil {
            map["TargetId"] = self.targetId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
            self.targetId = dict["TargetId"] as! Int64
        }
    }
}

public class GetInterceptionTargetDetailResponseBody : Tea.TeaModel {
    public class RuleTarget : Tea.TeaModel {
        public var appName: String?

        public var clusterId: String?

        public var clusterName: String?

        public var imageList: [String]?

        public var namespace: String?

        public var tagList: [String]?

        public var targetId: Int64?

        public var targetName: String?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.imageList != nil {
                map["ImageList"] = self.imageList!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.tagList != nil {
                map["TagList"] = self.tagList!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ImageList") && dict["ImageList"] != nil {
                self.imageList = dict["ImageList"] as! [String]
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("TagList") && dict["TagList"] != nil {
                self.tagList = dict["TagList"] as! [String]
            }
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! Int64
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
        }
    }
    public var requestId: String?

    public var ruleTarget: GetInterceptionTargetDetailResponseBody.RuleTarget?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ruleTarget?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleTarget != nil {
            map["RuleTarget"] = self.ruleTarget?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleTarget") && dict["RuleTarget"] != nil {
            var model = GetInterceptionTargetDetailResponseBody.RuleTarget()
            model.fromMap(dict["RuleTarget"] as! [String: Any])
            self.ruleTarget = model
        }
    }
}

public class GetInterceptionTargetDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInterceptionTargetDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetInterceptionTargetDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLastOnceTaskInfoRequest : Tea.TeaModel {
    public var source: String?

    public var taskName: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class GetLastOnceTaskInfoResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public var progress: Int32?

        public var result: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Progress") && dict["Progress"] != nil {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var collectTime: Int64?

    public var finishCount: Int32?

    public var requestId: String?

    public var taskId: Int64?

    public var taskInfo: GetLastOnceTaskInfoResponseBody.TaskInfo?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectTime != nil {
            map["CollectTime"] = self.collectTime!
        }
        if self.finishCount != nil {
            map["FinishCount"] = self.finishCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CollectTime") && dict["CollectTime"] != nil {
            self.collectTime = dict["CollectTime"] as! Int64
        }
        if dict.keys.contains("FinishCount") && dict["FinishCount"] != nil {
            self.finishCount = dict["FinishCount"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TaskInfo") && dict["TaskInfo"] != nil {
            var model = GetLastOnceTaskInfoResponseBody.TaskInfo()
            model.fromMap(dict["TaskInfo"] as! [String: Any])
            self.taskInfo = model
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class GetLastOnceTaskInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLastOnceTaskInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLastOnceTaskInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetModuleConfigRequest : Tea.TeaModel {
    public var currentPage: String?

    public var pageSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
    }
}

public class GetModuleConfigResponseBody : Tea.TeaModel {
    public class ModuleConfigList : Tea.TeaModel {
        public class Items : Tea.TeaModel {
            public var groupId: Int32?

            public var instanceId: String?

            public var instanceName: String?

            public var ip: String?

            public var region: String?

            public var uuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.uuid != nil {
                    map["Uuid"] = self.uuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! Int32
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                    self.uuid = dict["Uuid"] as! String
                }
            }
        }
        public var configName: String?

        public var items: [GetModuleConfigResponseBody.ModuleConfigList.Items]?

        public var moduleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configName != nil {
                map["ConfigName"] = self.configName!
            }
            if self.items != nil {
                var tmp : [Any] = []
                for k in self.items! {
                    tmp.append(k.toMap())
                }
                map["Items"] = tmp
            }
            if self.moduleName != nil {
                map["ModuleName"] = self.moduleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigName") && dict["ConfigName"] != nil {
                self.configName = dict["ConfigName"] as! String
            }
            if dict.keys.contains("Items") && dict["Items"] != nil {
                var tmp : [GetModuleConfigResponseBody.ModuleConfigList.Items] = []
                for v in dict["Items"] as! [Any] {
                    var model = GetModuleConfigResponseBody.ModuleConfigList.Items()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.items = tmp
            }
            if dict.keys.contains("ModuleName") && dict["ModuleName"] != nil {
                self.moduleName = dict["ModuleName"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var httpStatusCode: Int32?

    public var moduleConfigList: [GetModuleConfigResponseBody.ModuleConfigList]?

    public var pageInfo: GetModuleConfigResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.moduleConfigList != nil {
            var tmp : [Any] = []
            for k in self.moduleConfigList! {
                tmp.append(k.toMap())
            }
            map["ModuleConfigList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("ModuleConfigList") && dict["ModuleConfigList"] != nil {
            var tmp : [GetModuleConfigResponseBody.ModuleConfigList] = []
            for v in dict["ModuleConfigList"] as! [Any] {
                var model = GetModuleConfigResponseBody.ModuleConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.moduleConfigList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = GetModuleConfigResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetModuleConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetModuleConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetModuleConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOnceTaskResultInfoRequest : Tea.TeaModel {
    public var taskId: String?

    public var taskName: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class GetOnceTaskResultInfoResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var collectTime: Int64?

    public var finishCount: Int32?

    public var requestId: String?

    public var taskId: Int64?

    public var taskInfo: GetOnceTaskResultInfoResponseBody.TaskInfo?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectTime != nil {
            map["CollectTime"] = self.collectTime!
        }
        if self.finishCount != nil {
            map["FinishCount"] = self.finishCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CollectTime") && dict["CollectTime"] != nil {
            self.collectTime = dict["CollectTime"] as! Int64
        }
        if dict.keys.contains("FinishCount") && dict["FinishCount"] != nil {
            self.finishCount = dict["FinishCount"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
        if dict.keys.contains("TaskInfo") && dict["TaskInfo"] != nil {
            var model = GetOnceTaskResultInfoResponseBody.TaskInfo()
            model.fromMap(dict["TaskInfo"] as! [String: Any])
            self.taskInfo = model
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class GetOnceTaskResultInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOnceTaskResultInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOnceTaskResultInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpaClusterBaseLineListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var alias: String?

        public var classKey: String?

        public var itemKey: String?

        public var nameKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.classKey != nil {
                map["ClassKey"] = self.classKey!
            }
            if self.itemKey != nil {
                map["ItemKey"] = self.itemKey!
            }
            if self.nameKey != nil {
                map["NameKey"] = self.nameKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") && dict["Alias"] != nil {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("ClassKey") && dict["ClassKey"] != nil {
                self.classKey = dict["ClassKey"] as! String
            }
            if dict.keys.contains("ItemKey") && dict["ItemKey"] != nil {
                self.itemKey = dict["ItemKey"] as! String
            }
            if dict.keys.contains("NameKey") && dict["NameKey"] != nil {
                self.nameKey = dict["NameKey"] as! String
            }
        }
    }
    public var code: String?

    public var data: [GetOpaClusterBaseLineListResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetOpaClusterBaseLineListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetOpaClusterBaseLineListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOpaClusterBaseLineListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpaClusterBaseLineListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOpaClusterBaseLineListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpaClusterImageListRequest : Tea.TeaModel {
    public var clusterId: String?

    public var currentPage: Int32?

    public var imageName: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GetOpaClusterImageListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var imageName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                self.imageName = dict["ImageName"] as! String
            }
        }
    }
    public var code: String?

    public var count: Int32?

    public var data: [GetOpaClusterImageListResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetOpaClusterImageListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetOpaClusterImageListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOpaClusterImageListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpaClusterImageListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOpaClusterImageListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpaClusterLabelListRequest : Tea.TeaModel {
    public var clusterId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var tagName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tagName != nil {
            map["TagName"] = self.tagName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TagName") && dict["TagName"] != nil {
            self.tagName = dict["TagName"] as! String
        }
    }
}

public class GetOpaClusterLabelListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var tagName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagName != nil {
                map["TagName"] = self.tagName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagName") && dict["TagName"] != nil {
                self.tagName = dict["TagName"] as! String
            }
        }
    }
    public var code: String?

    public var count: Int32?

    public var data: [GetOpaClusterLabelListResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetOpaClusterLabelListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetOpaClusterLabelListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOpaClusterLabelListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpaClusterLabelListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOpaClusterLabelListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpaClusterNamespaceListRequest : Tea.TeaModel {
    public var clusterId: String?

    public var currentPage: Int32?

    public var nameSpaceName: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.nameSpaceName != nil {
            map["NameSpaceName"] = self.nameSpaceName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("NameSpaceName") && dict["NameSpaceName"] != nil {
            self.nameSpaceName = dict["NameSpaceName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GetOpaClusterNamespaceListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var nameSpaceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nameSpaceName != nil {
                map["NameSpaceName"] = self.nameSpaceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NameSpaceName") && dict["NameSpaceName"] != nil {
                self.nameSpaceName = dict["NameSpaceName"] as! String
            }
        }
    }
    public var code: String?

    public var count: Int32?

    public var data: [GetOpaClusterNamespaceListResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetOpaClusterNamespaceListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetOpaClusterNamespaceListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOpaClusterNamespaceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpaClusterNamespaceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOpaClusterNamespaceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpaPluginStatusRequest : Tea.TeaModel {
    public var clusterIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") && dict["ClusterIds"] != nil {
            self.clusterIds = dict["ClusterIds"] as! [String]
        }
    }
}

public class GetOpaPluginStatusResponseBody : Tea.TeaModel {
    public class InstallStatus : Tea.TeaModel {
        public var clusterId: String?

        public var installStatus: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.installStatus != nil {
                map["InstallStatus"] = self.installStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("InstallStatus") && dict["InstallStatus"] != nil {
                self.installStatus = dict["InstallStatus"] as! Bool
            }
        }
    }
    public var installStatus: [GetOpaPluginStatusResponseBody.InstallStatus]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.installStatus != nil {
            var tmp : [Any] = []
            for k in self.installStatus! {
                tmp.append(k.toMap())
            }
            map["InstallStatus"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstallStatus") && dict["InstallStatus"] != nil {
            var tmp : [GetOpaPluginStatusResponseBody.InstallStatus] = []
            for v in dict["InstallStatus"] as! [Any] {
                var model = GetOpaPluginStatusResponseBody.InstallStatus()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.installStatus = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetOpaPluginStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpaPluginStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOpaPluginStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpaStrategyTemplateSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int32?

        public var description_: String?

        public var templateId: Int64?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("TemplateId") && dict["TemplateId"] != nil {
                self.templateId = dict["TemplateId"] as! Int64
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var code: String?

    public var data: [GetOpaStrategyTemplateSummaryResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [GetOpaStrategyTemplateSummaryResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetOpaStrategyTemplateSummaryResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetOpaStrategyTemplateSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpaStrategyTemplateSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetOpaStrategyTemplateSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPropertyScheduleConfigRequest : Tea.TeaModel {
    public var type: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class GetPropertyScheduleConfigResponseBody : Tea.TeaModel {
    public class PropertyScheduleConfig : Tea.TeaModel {
        public var nextScheduleTime: Int64?

        public var scheduleTime: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextScheduleTime != nil {
                map["NextScheduleTime"] = self.nextScheduleTime!
            }
            if self.scheduleTime != nil {
                map["ScheduleTime"] = self.scheduleTime!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextScheduleTime") && dict["NextScheduleTime"] != nil {
                self.nextScheduleTime = dict["NextScheduleTime"] as! Int64
            }
            if dict.keys.contains("ScheduleTime") && dict["ScheduleTime"] != nil {
                self.scheduleTime = dict["ScheduleTime"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var propertyScheduleConfig: GetPropertyScheduleConfigResponseBody.PropertyScheduleConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.propertyScheduleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.propertyScheduleConfig != nil {
            map["PropertyScheduleConfig"] = self.propertyScheduleConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PropertyScheduleConfig") && dict["PropertyScheduleConfig"] != nil {
            var model = GetPropertyScheduleConfigResponseBody.PropertyScheduleConfig()
            model.fromMap(dict["PropertyScheduleConfig"] as! [String: Any])
            self.propertyScheduleConfig = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetPropertyScheduleConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPropertyScheduleConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetPropertyScheduleConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRulesCountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var totalSystemClientRuleCount: Int64?

    public var totalUserDefineRuleCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalSystemClientRuleCount != nil {
            map["TotalSystemClientRuleCount"] = self.totalSystemClientRuleCount!
        }
        if self.totalUserDefineRuleCount != nil {
            map["TotalUserDefineRuleCount"] = self.totalUserDefineRuleCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalSystemClientRuleCount") && dict["TotalSystemClientRuleCount"] != nil {
            self.totalSystemClientRuleCount = dict["TotalSystemClientRuleCount"] as! Int64
        }
        if dict.keys.contains("TotalUserDefineRuleCount") && dict["TotalUserDefineRuleCount"] != nil {
            self.totalUserDefineRuleCount = dict["TotalUserDefineRuleCount"] as! Int64
        }
    }
}

public class GetRulesCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRulesCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRulesCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSecurityScoreRuleRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class GetSecurityScoreRuleResponseBody : Tea.TeaModel {
    public class SecurityScoreRuleList : Tea.TeaModel {
        public class SecurityScoreItemList : Tea.TeaModel {
            public var score: Int32?

            public var scoreThreshold: Int32?

            public var subRuleType: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.scoreThreshold != nil {
                    map["ScoreThreshold"] = self.scoreThreshold!
                }
                if self.subRuleType != nil {
                    map["SubRuleType"] = self.subRuleType!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Score") && dict["Score"] != nil {
                    self.score = dict["Score"] as! Int32
                }
                if dict.keys.contains("ScoreThreshold") && dict["ScoreThreshold"] != nil {
                    self.scoreThreshold = dict["ScoreThreshold"] as! Int32
                }
                if dict.keys.contains("SubRuleType") && dict["SubRuleType"] != nil {
                    self.subRuleType = dict["SubRuleType"] as! String
                }
                if dict.keys.contains("Title") && dict["Title"] != nil {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var ruleType: String?

        public var score: Int32?

        public var securityScoreItemList: [GetSecurityScoreRuleResponseBody.SecurityScoreRuleList.SecurityScoreItemList]?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            if self.score != nil {
                map["Score"] = self.score!
            }
            if self.securityScoreItemList != nil {
                var tmp : [Any] = []
                for k in self.securityScoreItemList! {
                    tmp.append(k.toMap())
                }
                map["SecurityScoreItemList"] = tmp
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                self.ruleType = dict["RuleType"] as! String
            }
            if dict.keys.contains("Score") && dict["Score"] != nil {
                self.score = dict["Score"] as! Int32
            }
            if dict.keys.contains("SecurityScoreItemList") && dict["SecurityScoreItemList"] != nil {
                var tmp : [GetSecurityScoreRuleResponseBody.SecurityScoreRuleList.SecurityScoreItemList] = []
                for v in dict["SecurityScoreItemList"] as! [Any] {
                    var model = GetSecurityScoreRuleResponseBody.SecurityScoreRuleList.SecurityScoreItemList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityScoreItemList = tmp
            }
            if dict.keys.contains("Title") && dict["Title"] != nil {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var enableStatus: Bool?

    public var requestId: String?

    public var securityScoreRuleList: [GetSecurityScoreRuleResponseBody.SecurityScoreRuleList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableStatus != nil {
            map["EnableStatus"] = self.enableStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityScoreRuleList != nil {
            var tmp : [Any] = []
            for k in self.securityScoreRuleList! {
                tmp.append(k.toMap())
            }
            map["SecurityScoreRuleList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableStatus") && dict["EnableStatus"] != nil {
            self.enableStatus = dict["EnableStatus"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityScoreRuleList") && dict["SecurityScoreRuleList"] != nil {
            var tmp : [GetSecurityScoreRuleResponseBody.SecurityScoreRuleList] = []
            for v in dict["SecurityScoreRuleList"] as! [Any] {
                var model = GetSecurityScoreRuleResponseBody.SecurityScoreRuleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityScoreRuleList = tmp
        }
    }
}

public class GetSecurityScoreRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSecurityScoreRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSecurityScoreRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetServiceTrailRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetServiceTrailResponseBody : Tea.TeaModel {
    public class ServiceTrail : Tea.TeaModel {
        public var config: String?

        public var createTime: Int64?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") && dict["Config"] != nil {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var serviceTrail: GetServiceTrailResponseBody.ServiceTrail?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serviceTrail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceTrail != nil {
            map["ServiceTrail"] = self.serviceTrail?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServiceTrail") && dict["ServiceTrail"] != nil {
            var model = GetServiceTrailResponseBody.ServiceTrail()
            model.fromMap(dict["ServiceTrail"] as! [String: Any])
            self.serviceTrail = model
        }
    }
}

public class GetServiceTrailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetServiceTrailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetServiceTrailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStrategyTemplateDetailRequest : Tea.TeaModel {
    public var strategyId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
            self.strategyId = dict["StrategyId"] as! Int64
        }
    }
}

public class GetStrategyTemplateDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AlarmDetail : Tea.TeaModel {
            public class Baseline : Tea.TeaModel {
                public class Item : Tea.TeaModel {
                    public var id: String?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Id") && dict["Id"] != nil {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var item: [GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.Baseline.Item]?

                public var riskLevel: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.item != nil {
                        var tmp : [Any] = []
                        for k in self.item! {
                            tmp.append(k.toMap())
                        }
                        map["Item"] = tmp
                    }
                    if self.riskLevel != nil {
                        map["RiskLevel"] = self.riskLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Item") && dict["Item"] != nil {
                        var tmp : [GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.Baseline.Item] = []
                        for v in dict["Item"] as! [Any] {
                            var model = GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.Baseline.Item()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.item = tmp
                    }
                    if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                        self.riskLevel = dict["RiskLevel"] as! [String]
                    }
                }
            }
            public class MaliciousFile : Tea.TeaModel {
                public class Item : Tea.TeaModel {
                    public var id: String?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Id") && dict["Id"] != nil {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var item: [GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.MaliciousFile.Item]?

                public var riskLevel: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.item != nil {
                        var tmp : [Any] = []
                        for k in self.item! {
                            tmp.append(k.toMap())
                        }
                        map["Item"] = tmp
                    }
                    if self.riskLevel != nil {
                        map["RiskLevel"] = self.riskLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Item") && dict["Item"] != nil {
                        var tmp : [GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.MaliciousFile.Item] = []
                        for v in dict["Item"] as! [Any] {
                            var model = GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.MaliciousFile.Item()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.item = tmp
                    }
                    if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                        self.riskLevel = dict["RiskLevel"] as! [String]
                    }
                }
            }
            public class Vul : Tea.TeaModel {
                public class Item : Tea.TeaModel {
                    public var id: String?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Id") && dict["Id"] != nil {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var item: [GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.Vul.Item]?

                public var riskLevel: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.item != nil {
                        var tmp : [Any] = []
                        for k in self.item! {
                            tmp.append(k.toMap())
                        }
                        map["Item"] = tmp
                    }
                    if self.riskLevel != nil {
                        map["RiskLevel"] = self.riskLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Item") && dict["Item"] != nil {
                        var tmp : [GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.Vul.Item] = []
                        for v in dict["Item"] as! [Any] {
                            var model = GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.Vul.Item()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.item = tmp
                    }
                    if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                        self.riskLevel = dict["RiskLevel"] as! [String]
                    }
                }
            }
            public var baseline: GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.Baseline?

            public var maliciousFile: GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.MaliciousFile?

            public var vul: GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.Vul?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.baseline?.validate()
                try self.maliciousFile?.validate()
                try self.vul?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baseline != nil {
                    map["Baseline"] = self.baseline?.toMap()
                }
                if self.maliciousFile != nil {
                    map["MaliciousFile"] = self.maliciousFile?.toMap()
                }
                if self.vul != nil {
                    map["Vul"] = self.vul?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Baseline") && dict["Baseline"] != nil {
                    var model = GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.Baseline()
                    model.fromMap(dict["Baseline"] as! [String: Any])
                    self.baseline = model
                }
                if dict.keys.contains("MaliciousFile") && dict["MaliciousFile"] != nil {
                    var model = GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.MaliciousFile()
                    model.fromMap(dict["MaliciousFile"] as! [String: Any])
                    self.maliciousFile = model
                }
                if dict.keys.contains("Vul") && dict["Vul"] != nil {
                    var model = GetStrategyTemplateDetailResponseBody.Data.AlarmDetail.Vul()
                    model.fromMap(dict["Vul"] as! [String: Any])
                    self.vul = model
                }
            }
        }
        public var alarmDetail: GetStrategyTemplateDetailResponseBody.Data.AlarmDetail?

        public var clusterId: String?

        public var clusterName: String?

        public var description_: String?

        public var imageName: [String]?

        public var label: [String]?

        public var maliciousImage: Bool?

        public var namespace: [String]?

        public var ruleAction: Int32?

        public var strategyId: Int64?

        public var strategyName: String?

        public var strategyTemplateId: Int64?

        public var unScanedImage: Bool?

        public var whiteList: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.alarmDetail?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmDetail != nil {
                map["AlarmDetail"] = self.alarmDetail?.toMap()
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.label != nil {
                map["Label"] = self.label!
            }
            if self.maliciousImage != nil {
                map["MaliciousImage"] = self.maliciousImage!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.ruleAction != nil {
                map["RuleAction"] = self.ruleAction!
            }
            if self.strategyId != nil {
                map["StrategyId"] = self.strategyId!
            }
            if self.strategyName != nil {
                map["StrategyName"] = self.strategyName!
            }
            if self.strategyTemplateId != nil {
                map["StrategyTemplateId"] = self.strategyTemplateId!
            }
            if self.unScanedImage != nil {
                map["UnScanedImage"] = self.unScanedImage!
            }
            if self.whiteList != nil {
                map["WhiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmDetail") && dict["AlarmDetail"] != nil {
                var model = GetStrategyTemplateDetailResponseBody.Data.AlarmDetail()
                model.fromMap(dict["AlarmDetail"] as! [String: Any])
                self.alarmDetail = model
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
                self.imageName = dict["ImageName"] as! [String]
            }
            if dict.keys.contains("Label") && dict["Label"] != nil {
                self.label = dict["Label"] as! [String]
            }
            if dict.keys.contains("MaliciousImage") && dict["MaliciousImage"] != nil {
                self.maliciousImage = dict["MaliciousImage"] as! Bool
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! [String]
            }
            if dict.keys.contains("RuleAction") && dict["RuleAction"] != nil {
                self.ruleAction = dict["RuleAction"] as! Int32
            }
            if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
                self.strategyId = dict["StrategyId"] as! Int64
            }
            if dict.keys.contains("StrategyName") && dict["StrategyName"] != nil {
                self.strategyName = dict["StrategyName"] as! String
            }
            if dict.keys.contains("StrategyTemplateId") && dict["StrategyTemplateId"] != nil {
                self.strategyTemplateId = dict["StrategyTemplateId"] as! Int64
            }
            if dict.keys.contains("UnScanedImage") && dict["UnScanedImage"] != nil {
                self.unScanedImage = dict["UnScanedImage"] as! Bool
            }
            if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                self.whiteList = dict["WhiteList"] as! [String]
            }
        }
    }
    public var code: String?

    public var data: GetStrategyTemplateDetailResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetStrategyTemplateDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetStrategyTemplateDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStrategyTemplateDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetStrategyTemplateDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSuspiciousStatisticsRequest : Tea.TeaModel {
    public var groupIdList: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupIdList != nil {
            map["GroupIdList"] = self.groupIdList!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupIdList") && dict["GroupIdList"] != nil {
            self.groupIdList = dict["GroupIdList"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class GetSuspiciousStatisticsResponseBody : Tea.TeaModel {
    public var remindCount: Int32?

    public var requestId: String?

    public var seriousCount: Int32?

    public var suspiciousCount: Int32?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remindCount != nil {
            map["RemindCount"] = self.remindCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.seriousCount != nil {
            map["SeriousCount"] = self.seriousCount!
        }
        if self.suspiciousCount != nil {
            map["SuspiciousCount"] = self.suspiciousCount!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RemindCount") && dict["RemindCount"] != nil {
            self.remindCount = dict["RemindCount"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SeriousCount") && dict["SeriousCount"] != nil {
            self.seriousCount = dict["SeriousCount"] as! Int32
        }
        if dict.keys.contains("SuspiciousCount") && dict["SuspiciousCount"] != nil {
            self.suspiciousCount = dict["SuspiciousCount"] as! Int32
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class GetSuspiciousStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSuspiciousStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSuspiciousStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSwitchRegionDetailRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class GetSwitchRegionDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RegionStatus : Tea.TeaModel {
            public var ecsCount: Int32?

            public var gmtPlanSwitchTime: Int64?

            public var regionId: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ecsCount != nil {
                    map["EcsCount"] = self.ecsCount!
                }
                if self.gmtPlanSwitchTime != nil {
                    map["GmtPlanSwitchTime"] = self.gmtPlanSwitchTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EcsCount") && dict["EcsCount"] != nil {
                    self.ecsCount = dict["EcsCount"] as! Int32
                }
                if dict.keys.contains("GmtPlanSwitchTime") && dict["GmtPlanSwitchTime"] != nil {
                    self.gmtPlanSwitchTime = dict["GmtPlanSwitchTime"] as! Int64
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var gmtIsAgreeModified: Int64?

        public var gmtNoticed: Int64?

        public var isAgree: String?

        public var isNoticed: String?

        public var regionStatus: [GetSwitchRegionDetailResponseBody.Data.RegionStatus]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtIsAgreeModified != nil {
                map["GmtIsAgreeModified"] = self.gmtIsAgreeModified!
            }
            if self.gmtNoticed != nil {
                map["GmtNoticed"] = self.gmtNoticed!
            }
            if self.isAgree != nil {
                map["IsAgree"] = self.isAgree!
            }
            if self.isNoticed != nil {
                map["IsNoticed"] = self.isNoticed!
            }
            if self.regionStatus != nil {
                var tmp : [Any] = []
                for k in self.regionStatus! {
                    tmp.append(k.toMap())
                }
                map["RegionStatus"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GmtIsAgreeModified") && dict["GmtIsAgreeModified"] != nil {
                self.gmtIsAgreeModified = dict["GmtIsAgreeModified"] as! Int64
            }
            if dict.keys.contains("GmtNoticed") && dict["GmtNoticed"] != nil {
                self.gmtNoticed = dict["GmtNoticed"] as! Int64
            }
            if dict.keys.contains("IsAgree") && dict["IsAgree"] != nil {
                self.isAgree = dict["IsAgree"] as! String
            }
            if dict.keys.contains("IsNoticed") && dict["IsNoticed"] != nil {
                self.isNoticed = dict["IsNoticed"] as! String
            }
            if dict.keys.contains("RegionStatus") && dict["RegionStatus"] != nil {
                var tmp : [GetSwitchRegionDetailResponseBody.Data.RegionStatus] = []
                for v in dict["RegionStatus"] as! [Any] {
                    var model = GetSwitchRegionDetailResponseBody.Data.RegionStatus()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.regionStatus = tmp
            }
        }
    }
    public var data: GetSwitchRegionDetailResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetSwitchRegionDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSwitchRegionDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSwitchRegionDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSwitchRegionDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserLangResponseBody : Tea.TeaModel {
    public class SasUserLang : Tea.TeaModel {
        public var lang: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lang != nil {
                map["Lang"] = self.lang!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Lang") && dict["Lang"] != nil {
                self.lang = dict["Lang"] as! String
            }
        }
    }
    public var requestId: String?

    public var sasUserLang: GetUserLangResponseBody.SasUserLang?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sasUserLang?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sasUserLang != nil {
            map["SasUserLang"] = self.sasUserLang?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SasUserLang") && dict["SasUserLang"] != nil {
            var model = GetUserLangResponseBody.SasUserLang()
            model.fromMap(dict["SasUserLang"] as! [String: Any])
            self.sasUserLang = model
        }
    }
}

public class GetUserLangResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserLangResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserLangResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVulStatisticsRequest : Tea.TeaModel {
    public var groupIdList: String?

    public var sourceIp: String?

    public var typeList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupIdList != nil {
            map["GroupIdList"] = self.groupIdList!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.typeList != nil {
            map["TypeList"] = self.typeList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupIdList") && dict["GroupIdList"] != nil {
            self.groupIdList = dict["GroupIdList"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("TypeList") && dict["TypeList"] != nil {
            self.typeList = dict["TypeList"] as! String
        }
    }
}

public class GetVulStatisticsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vulAsapSum: Int32?

    public var vulLaterSum: Int32?

    public var vulNntfSum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vulAsapSum != nil {
            map["VulAsapSum"] = self.vulAsapSum!
        }
        if self.vulLaterSum != nil {
            map["VulLaterSum"] = self.vulLaterSum!
        }
        if self.vulNntfSum != nil {
            map["VulNntfSum"] = self.vulNntfSum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VulAsapSum") && dict["VulAsapSum"] != nil {
            self.vulAsapSum = dict["VulAsapSum"] as! Int32
        }
        if dict.keys.contains("VulLaterSum") && dict["VulLaterSum"] != nil {
            self.vulLaterSum = dict["VulLaterSum"] as! Int32
        }
        if dict.keys.contains("VulNntfSum") && dict["VulNntfSum"] != nil {
            self.vulNntfSum = dict["VulNntfSum"] as! Int32
        }
    }
}

public class GetVulStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVulStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetVulStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVulWhitelistRequest : Tea.TeaModel {
    public var vulWhitelistId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.vulWhitelistId != nil {
            map["VulWhitelistId"] = self.vulWhitelistId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("VulWhitelistId") && dict["VulWhitelistId"] != nil {
            self.vulWhitelistId = dict["VulWhitelistId"] as! Int64
        }
    }
}

public class GetVulWhitelistResponseBody : Tea.TeaModel {
    public class VulWhitelist : Tea.TeaModel {
        public var aliasName: String?

        public var id: Int64?

        public var name: String?

        public var reason: String?

        public var target: String?

        public var type: String?

        public var whitelist: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.whitelist != nil {
                map["Whitelist"] = self.whitelist!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                self.aliasName = dict["AliasName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Target") && dict["Target"] != nil {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Whitelist") && dict["Whitelist"] != nil {
                self.whitelist = dict["Whitelist"] as! String
            }
        }
    }
    public var requestId: String?

    public var vulWhitelist: GetVulWhitelistResponseBody.VulWhitelist?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vulWhitelist?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vulWhitelist != nil {
            map["VulWhitelist"] = self.vulWhitelist?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VulWhitelist") && dict["VulWhitelist"] != nil {
            var model = GetVulWhitelistResponseBody.VulWhitelist()
            model.fromMap(dict["VulWhitelist"] as! [String: Any])
            self.vulWhitelist = model
        }
    }
}

public class GetVulWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVulWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetVulWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class HandleSecurityEventsRequest : Tea.TeaModel {
    public var markBatch: String?

    public var markMissParam: String?

    public var operationCode: String?

    public var operationParams: String?

    public var remark: String?

    public var securityEventIds: [String]?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.markBatch != nil {
            map["MarkBatch"] = self.markBatch!
        }
        if self.markMissParam != nil {
            map["MarkMissParam"] = self.markMissParam!
        }
        if self.operationCode != nil {
            map["OperationCode"] = self.operationCode!
        }
        if self.operationParams != nil {
            map["OperationParams"] = self.operationParams!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.securityEventIds != nil {
            map["SecurityEventIds"] = self.securityEventIds!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MarkBatch") && dict["MarkBatch"] != nil {
            self.markBatch = dict["MarkBatch"] as! String
        }
        if dict.keys.contains("MarkMissParam") && dict["MarkMissParam"] != nil {
            self.markMissParam = dict["MarkMissParam"] as! String
        }
        if dict.keys.contains("OperationCode") && dict["OperationCode"] != nil {
            self.operationCode = dict["OperationCode"] as! String
        }
        if dict.keys.contains("OperationParams") && dict["OperationParams"] != nil {
            self.operationParams = dict["OperationParams"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SecurityEventIds") && dict["SecurityEventIds"] != nil {
            self.securityEventIds = dict["SecurityEventIds"] as! [String]
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class HandleSecurityEventsResponseBody : Tea.TeaModel {
    public class HandleSecurityEventsResponse : Tea.TeaModel {
        public var taskId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! Int64
            }
        }
    }
    public var handleSecurityEventsResponse: HandleSecurityEventsResponseBody.HandleSecurityEventsResponse?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.handleSecurityEventsResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.handleSecurityEventsResponse != nil {
            map["HandleSecurityEventsResponse"] = self.handleSecurityEventsResponse?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HandleSecurityEventsResponse") && dict["HandleSecurityEventsResponse"] != nil {
            var model = HandleSecurityEventsResponseBody.HandleSecurityEventsResponse()
            model.fromMap(dict["HandleSecurityEventsResponse"] as! [String: Any])
            self.handleSecurityEventsResponse = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class HandleSecurityEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: HandleSecurityEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = HandleSecurityEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class HandleSimilarSecurityEventsRequest : Tea.TeaModel {
    public var markMissParam: String?

    public var operationCode: String?

    public var operationParams: String?

    public var remark: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.markMissParam != nil {
            map["MarkMissParam"] = self.markMissParam!
        }
        if self.operationCode != nil {
            map["OperationCode"] = self.operationCode!
        }
        if self.operationParams != nil {
            map["OperationParams"] = self.operationParams!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MarkMissParam") && dict["MarkMissParam"] != nil {
            self.markMissParam = dict["MarkMissParam"] as! String
        }
        if dict.keys.contains("OperationCode") && dict["OperationCode"] != nil {
            self.operationCode = dict["OperationCode"] as! String
        }
        if dict.keys.contains("OperationParams") && dict["OperationParams"] != nil {
            self.operationParams = dict["OperationParams"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class HandleSimilarSecurityEventsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class HandleSimilarSecurityEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: HandleSimilarSecurityEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = HandleSimilarSecurityEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class IgnoreCheckItemsRequest : Tea.TeaModel {
    public class CheckAndRiskTypeList : Tea.TeaModel {
        public var checkId: Int64?

        public var riskType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.riskType != nil {
                map["RiskType"] = self.riskType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                self.checkId = dict["CheckId"] as! Int64
            }
            if dict.keys.contains("RiskType") && dict["RiskType"] != nil {
                self.riskType = dict["RiskType"] as! String
            }
        }
    }
    public var checkAndRiskTypeList: [IgnoreCheckItemsRequest.CheckAndRiskTypeList]?

    public var lang: String?

    public var reason: String?

    public var source: String?

    public var type: Int32?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkAndRiskTypeList != nil {
            var tmp : [Any] = []
            for k in self.checkAndRiskTypeList! {
                tmp.append(k.toMap())
            }
            map["CheckAndRiskTypeList"] = tmp
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckAndRiskTypeList") && dict["CheckAndRiskTypeList"] != nil {
            var tmp : [IgnoreCheckItemsRequest.CheckAndRiskTypeList] = []
            for v in dict["CheckAndRiskTypeList"] as! [Any] {
                var model = IgnoreCheckItemsRequest.CheckAndRiskTypeList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.checkAndRiskTypeList = tmp
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class IgnoreCheckItemsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class IgnoreCheckItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: IgnoreCheckItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = IgnoreCheckItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class IgnoreHcCheckWarningsRequest : Tea.TeaModel {
    public var checkIds: String?

    public var checkWarningIds: String?

    public var reason: String?

    public var riskId: String?

    public var source: String?

    public var sourceIp: String?

    public var type: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkIds != nil {
            map["CheckIds"] = self.checkIds!
        }
        if self.checkWarningIds != nil {
            map["CheckWarningIds"] = self.checkWarningIds!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.riskId != nil {
            map["RiskId"] = self.riskId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckIds") && dict["CheckIds"] != nil {
            self.checkIds = dict["CheckIds"] as! String
        }
        if dict.keys.contains("CheckWarningIds") && dict["CheckWarningIds"] != nil {
            self.checkWarningIds = dict["CheckWarningIds"] as! String
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
            self.riskId = dict["RiskId"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int64
        }
    }
}

public class IgnoreHcCheckWarningsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class IgnoreHcCheckWarningsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: IgnoreHcCheckWarningsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = IgnoreHcCheckWarningsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallBackupClientRequest : Tea.TeaModel {
    public var policyVersion: String?

    public var uuid: String?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyVersion != nil {
            map["PolicyVersion"] = self.policyVersion!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
            self.policyVersion = dict["PolicyVersion"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class InstallBackupClientResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InstallBackupClientResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallBackupClientResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InstallBackupClientResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallCloudMonitorRequest : Tea.TeaModel {
    public var agentAccessKey: String?

    public var agentSecretKey: String?

    public var argusVersion: String?

    public var instanceIdList: [String]?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentAccessKey != nil {
            map["AgentAccessKey"] = self.agentAccessKey!
        }
        if self.agentSecretKey != nil {
            map["AgentSecretKey"] = self.agentSecretKey!
        }
        if self.argusVersion != nil {
            map["ArgusVersion"] = self.argusVersion!
        }
        if self.instanceIdList != nil {
            map["InstanceIdList"] = self.instanceIdList!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentAccessKey") && dict["AgentAccessKey"] != nil {
            self.agentAccessKey = dict["AgentAccessKey"] as! String
        }
        if dict.keys.contains("AgentSecretKey") && dict["AgentSecretKey"] != nil {
            self.agentSecretKey = dict["AgentSecretKey"] as! String
        }
        if dict.keys.contains("ArgusVersion") && dict["ArgusVersion"] != nil {
            self.argusVersion = dict["ArgusVersion"] as! String
        }
        if dict.keys.contains("InstanceIdList") && dict["InstanceIdList"] != nil {
            self.instanceIdList = dict["InstanceIdList"] as! [String]
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class InstallCloudMonitorResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InstallCloudMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallCloudMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InstallCloudMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallPmAgentRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public var type: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class InstallPmAgentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InstallPmAgentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallPmAgentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InstallPmAgentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallRaspAttachRequest : Tea.TeaModel {
    public var applicationId: String?

    public var ecsUUIDList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.ecsUUIDList != nil {
            map["EcsUUIDList"] = self.ecsUUIDList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationId") && dict["ApplicationId"] != nil {
            self.applicationId = dict["ApplicationId"] as! String
        }
        if dict.keys.contains("EcsUUIDList") && dict["EcsUUIDList"] != nil {
            self.ecsUUIDList = dict["EcsUUIDList"] as! [String]
        }
    }
}

public class InstallRaspAttachResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InstallRaspAttachResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallRaspAttachResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InstallRaspAttachResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallUniBackupAgentRequest : Tea.TeaModel {
    public var policyId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! Int64
        }
    }
}

public class InstallUniBackupAgentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InstallUniBackupAgentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallUniBackupAgentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InstallUniBackupAgentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinWebLockProcessWhiteListRequest : Tea.TeaModel {
    public var processPaths: [String]?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.processPaths != nil {
            map["ProcessPaths"] = self.processPaths!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProcessPaths") && dict["ProcessPaths"] != nil {
            self.processPaths = dict["ProcessPaths"] as! [String]
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class JoinWebLockProcessWhiteListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinWebLockProcessWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinWebLockProcessWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = JoinWebLockProcessWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAgentlessMaliciousFilesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var dealed: String?

    public var eventId: Int64?

    public var fuzzyMaliciousName: String?

    public var lang: String?

    public var levels: String?

    public var maliciousMd5: String?

    public var maliciousType: String?

    public var pageSize: String?

    public var remark: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.fuzzyMaliciousName != nil {
            map["FuzzyMaliciousName"] = self.fuzzyMaliciousName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.levels != nil {
            map["Levels"] = self.levels!
        }
        if self.maliciousMd5 != nil {
            map["MaliciousMd5"] = self.maliciousMd5!
        }
        if self.maliciousType != nil {
            map["MaliciousType"] = self.maliciousType!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! Int64
        }
        if dict.keys.contains("FuzzyMaliciousName") && dict["FuzzyMaliciousName"] != nil {
            self.fuzzyMaliciousName = dict["FuzzyMaliciousName"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Levels") && dict["Levels"] != nil {
            self.levels = dict["Levels"] as! String
        }
        if dict.keys.contains("MaliciousMd5") && dict["MaliciousMd5"] != nil {
            self.maliciousMd5 = dict["MaliciousMd5"] as! String
        }
        if dict.keys.contains("MaliciousType") && dict["MaliciousType"] != nil {
            self.maliciousType = dict["MaliciousType"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ListAgentlessMaliciousFilesResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public class Details : Tea.TeaModel {
            public var name: String?

            public var nameKey: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameKey != nil {
                    map["NameKey"] = self.nameKey!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameKey") && dict["NameKey"] != nil {
                    self.nameKey = dict["NameKey"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Notes : Tea.TeaModel {
            public var note: String?

            public var noteId: String?

            public var noteTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.note != nil {
                    map["Note"] = self.note!
                }
                if self.noteId != nil {
                    map["NoteId"] = self.noteId!
                }
                if self.noteTime != nil {
                    map["NoteTime"] = self.noteTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Note") && dict["Note"] != nil {
                    self.note = dict["Note"] as! String
                }
                if dict.keys.contains("NoteId") && dict["NoteId"] != nil {
                    self.noteId = dict["NoteId"] as! String
                }
                if dict.keys.contains("NoteTime") && dict["NoteTime"] != nil {
                    self.noteTime = dict["NoteTime"] as! String
                }
            }
        }
        public var details: [ListAgentlessMaliciousFilesResponseBody.List.Details]?

        public var downloadUrl: String?

        public var filePath: Int64?

        public var firstScanTimestamp: Int64?

        public var highLight: String?

        public var id: Int64?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var latestScanTimestamp: Int64?

        public var level: String?

        public var maliciousMd5: String?

        public var maliciousName: String?

        public var maliciousType: String?

        public var notes: [ListAgentlessMaliciousFilesResponseBody.List.Notes]?

        public var operateResult: String?

        public var operateTimestamp: String?

        public var partition: String?

        public var targetId: String?

        public var targetName: String?

        public var targetType: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.details != nil {
                var tmp : [Any] = []
                for k in self.details! {
                    tmp.append(k.toMap())
                }
                map["Details"] = tmp
            }
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.firstScanTimestamp != nil {
                map["FirstScanTimestamp"] = self.firstScanTimestamp!
            }
            if self.highLight != nil {
                map["HighLight"] = self.highLight!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.latestScanTimestamp != nil {
                map["LatestScanTimestamp"] = self.latestScanTimestamp!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.maliciousMd5 != nil {
                map["MaliciousMd5"] = self.maliciousMd5!
            }
            if self.maliciousName != nil {
                map["MaliciousName"] = self.maliciousName!
            }
            if self.maliciousType != nil {
                map["MaliciousType"] = self.maliciousType!
            }
            if self.notes != nil {
                var tmp : [Any] = []
                for k in self.notes! {
                    tmp.append(k.toMap())
                }
                map["Notes"] = tmp
            }
            if self.operateResult != nil {
                map["OperateResult"] = self.operateResult!
            }
            if self.operateTimestamp != nil {
                map["OperateTimestamp"] = self.operateTimestamp!
            }
            if self.partition != nil {
                map["Partition"] = self.partition!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Details") && dict["Details"] != nil {
                var tmp : [ListAgentlessMaliciousFilesResponseBody.List.Details] = []
                for v in dict["Details"] as! [Any] {
                    var model = ListAgentlessMaliciousFilesResponseBody.List.Details()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.details = tmp
            }
            if dict.keys.contains("DownloadUrl") && dict["DownloadUrl"] != nil {
                self.downloadUrl = dict["DownloadUrl"] as! String
            }
            if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
                self.filePath = dict["FilePath"] as! Int64
            }
            if dict.keys.contains("FirstScanTimestamp") && dict["FirstScanTimestamp"] != nil {
                self.firstScanTimestamp = dict["FirstScanTimestamp"] as! Int64
            }
            if dict.keys.contains("HighLight") && dict["HighLight"] != nil {
                self.highLight = dict["HighLight"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LatestScanTimestamp") && dict["LatestScanTimestamp"] != nil {
                self.latestScanTimestamp = dict["LatestScanTimestamp"] as! Int64
            }
            if dict.keys.contains("Level") && dict["Level"] != nil {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("MaliciousMd5") && dict["MaliciousMd5"] != nil {
                self.maliciousMd5 = dict["MaliciousMd5"] as! String
            }
            if dict.keys.contains("MaliciousName") && dict["MaliciousName"] != nil {
                self.maliciousName = dict["MaliciousName"] as! String
            }
            if dict.keys.contains("MaliciousType") && dict["MaliciousType"] != nil {
                self.maliciousType = dict["MaliciousType"] as! String
            }
            if dict.keys.contains("Notes") && dict["Notes"] != nil {
                var tmp : [ListAgentlessMaliciousFilesResponseBody.List.Notes] = []
                for v in dict["Notes"] as! [Any] {
                    var model = ListAgentlessMaliciousFilesResponseBody.List.Notes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.notes = tmp
            }
            if dict.keys.contains("OperateResult") && dict["OperateResult"] != nil {
                self.operateResult = dict["OperateResult"] as! String
            }
            if dict.keys.contains("OperateTimestamp") && dict["OperateTimestamp"] != nil {
                self.operateTimestamp = dict["OperateTimestamp"] as! String
            }
            if dict.keys.contains("Partition") && dict["Partition"] != nil {
                self.partition = dict["Partition"] as! String
            }
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! String
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var list: [ListAgentlessMaliciousFilesResponseBody.List]?

    public var pageInfo: ListAgentlessMaliciousFilesResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListAgentlessMaliciousFilesResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListAgentlessMaliciousFilesResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListAgentlessMaliciousFilesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAgentlessMaliciousFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAgentlessMaliciousFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAgentlessMaliciousFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAgentlessRegionResponseBody : Tea.TeaModel {
    public var regionList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionList != nil {
            map["RegionList"] = self.regionList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionList") && dict["RegionList"] != nil {
            self.regionList = dict["RegionList"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAgentlessRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAgentlessRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAgentlessRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAgentlessRelateMaliciousRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var eventId: Int64?

    public var pageSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EventId") && dict["EventId"] != nil {
            self.eventId = dict["EventId"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
    }
}

public class ListAgentlessRelateMaliciousResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var filePath: String?

        public var firstScanTimestamp: Int64?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var latestScanTimestamp: Int64?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.firstScanTimestamp != nil {
                map["FirstScanTimestamp"] = self.firstScanTimestamp!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.latestScanTimestamp != nil {
                map["LatestScanTimestamp"] = self.latestScanTimestamp!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("FirstScanTimestamp") && dict["FirstScanTimestamp"] != nil {
                self.firstScanTimestamp = dict["FirstScanTimestamp"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LatestScanTimestamp") && dict["LatestScanTimestamp"] != nil {
                self.latestScanTimestamp = dict["LatestScanTimestamp"] as! Int64
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var list: [ListAgentlessRelateMaliciousResponseBody.List]?

    public var pageInfo: ListAgentlessRelateMaliciousResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListAgentlessRelateMaliciousResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListAgentlessRelateMaliciousResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListAgentlessRelateMaliciousResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAgentlessRelateMaliciousResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAgentlessRelateMaliciousResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAgentlessRelateMaliciousResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAgentlessRiskUuidRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var internetIp: String?

    public var intranetIp: String?

    public var machineName: String?

    public var pageSize: Int32?

    public var risk: Bool?

    public var targetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.intranetIp != nil {
            map["IntranetIp"] = self.intranetIp!
        }
        if self.machineName != nil {
            map["MachineName"] = self.machineName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.risk != nil {
            map["Risk"] = self.risk!
        }
        if self.targetName != nil {
            map["TargetName"] = self.targetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
            self.internetIp = dict["InternetIp"] as! String
        }
        if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
            self.intranetIp = dict["IntranetIp"] as! String
        }
        if dict.keys.contains("MachineName") && dict["MachineName"] != nil {
            self.machineName = dict["MachineName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Risk") && dict["Risk"] != nil {
            self.risk = dict["Risk"] as! Bool
        }
        if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
            self.targetName = dict["TargetName"] as! String
        }
    }
}

public class ListAgentlessRiskUuidResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var baselineCount: Int32?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var maliciousCount: Int32?

        public var scanTime: Int64?

        public var targetId: String?

        public var targetName: String?

        public var uuid: String?

        public var vulCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.baselineCount != nil {
                map["BaselineCount"] = self.baselineCount!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.maliciousCount != nil {
                map["MaliciousCount"] = self.maliciousCount!
            }
            if self.scanTime != nil {
                map["ScanTime"] = self.scanTime!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vulCount != nil {
                map["VulCount"] = self.vulCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BaselineCount") && dict["BaselineCount"] != nil {
                self.baselineCount = dict["BaselineCount"] as! Int32
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("MaliciousCount") && dict["MaliciousCount"] != nil {
                self.maliciousCount = dict["MaliciousCount"] as! Int32
            }
            if dict.keys.contains("ScanTime") && dict["ScanTime"] != nil {
                self.scanTime = dict["ScanTime"] as! Int64
            }
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! String
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VulCount") && dict["VulCount"] != nil {
                self.vulCount = dict["VulCount"] as! Int32
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var list: [ListAgentlessRiskUuidResponseBody.List]?

    public var pageInfo: ListAgentlessRiskUuidResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListAgentlessRiskUuidResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListAgentlessRiskUuidResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListAgentlessRiskUuidResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAgentlessRiskUuidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAgentlessRiskUuidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAgentlessRiskUuidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAgentlessTaskRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var endTime: Int64?

    public var internetIp: String?

    public var intranetIp: String?

    public var lang: String?

    public var machineName: String?

    public var pageSize: Int32?

    public var rootTask: Bool?

    public var rootTaskId: String?

    public var startTime: Int64?

    public var status: Int32?

    public var targetName: String?

    public var targetType: Int32?

    public var taskId: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.internetIp != nil {
            map["InternetIp"] = self.internetIp!
        }
        if self.intranetIp != nil {
            map["IntranetIp"] = self.intranetIp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.machineName != nil {
            map["MachineName"] = self.machineName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.rootTask != nil {
            map["RootTask"] = self.rootTask!
        }
        if self.rootTaskId != nil {
            map["RootTaskId"] = self.rootTaskId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.targetName != nil {
            map["TargetName"] = self.targetName!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
            self.internetIp = dict["InternetIp"] as! String
        }
        if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
            self.intranetIp = dict["IntranetIp"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("MachineName") && dict["MachineName"] != nil {
            self.machineName = dict["MachineName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RootTask") && dict["RootTask"] != nil {
            self.rootTask = dict["RootTask"] as! Bool
        }
        if dict.keys.contains("RootTaskId") && dict["RootTaskId"] != nil {
            self.rootTaskId = dict["RootTaskId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
            self.targetName = dict["TargetName"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! Int32
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ListAgentlessTaskResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var endTime: Int64?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var progress: Int32?

        public var result: String?

        public var startTime: Int64?

        public var status: Int32?

        public var targetName: String?

        public var targetType: Int32?

        public var taskId: String?

        public var taskName: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Progress") && dict["Progress"] != nil {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! Int32
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var list: [ListAgentlessTaskResponseBody.List]?

    public var pageInfo: ListAgentlessTaskResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListAgentlessTaskResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListAgentlessTaskResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListAgentlessTaskResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAgentlessTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAgentlessTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAgentlessTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAssetCleanConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cleanDays: Int32?

        public var status: Int32?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cleanDays != nil {
                map["CleanDays"] = self.cleanDays!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CleanDays") && dict["CleanDays"] != nil {
                self.cleanDays = dict["CleanDays"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var count: Int32?

    public var data: [ListAssetCleanConfigResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListAssetCleanConfigResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAssetCleanConfigResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAssetCleanConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAssetCleanConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAssetCleanConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAssetRefreshTaskConfigRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListAssetRefreshTaskConfigResponseBody : Tea.TeaModel {
    public class AssetRefreshConfig : Tea.TeaModel {
        public var schedulePeriod: Int32?

        public var status: Int32?

        public var vendor: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schedulePeriod != nil {
                map["SchedulePeriod"] = self.schedulePeriod!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.vendor != nil {
                map["Vendor"] = self.vendor!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SchedulePeriod") && dict["SchedulePeriod"] != nil {
                self.schedulePeriod = dict["SchedulePeriod"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                self.vendor = dict["Vendor"] as! Int32
            }
        }
    }
    public var assetRefreshConfig: [ListAssetRefreshTaskConfigResponseBody.AssetRefreshConfig]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetRefreshConfig != nil {
            var tmp : [Any] = []
            for k in self.assetRefreshConfig! {
                tmp.append(k.toMap())
            }
            map["AssetRefreshConfig"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetRefreshConfig") && dict["AssetRefreshConfig"] != nil {
            var tmp : [ListAssetRefreshTaskConfigResponseBody.AssetRefreshConfig] = []
            for v in dict["AssetRefreshConfig"] as! [Any] {
                var model = ListAssetRefreshTaskConfigResponseBody.AssetRefreshConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.assetRefreshConfig = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAssetRefreshTaskConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAssetRefreshTaskConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAssetRefreshTaskConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAssetSelectionSelectedTargetRequest : Tea.TeaModel {
    public var selectionKey: String?

    public var targetList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.selectionKey != nil {
            map["SelectionKey"] = self.selectionKey!
        }
        if self.targetList != nil {
            map["TargetList"] = self.targetList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SelectionKey") && dict["SelectionKey"] != nil {
            self.selectionKey = dict["SelectionKey"] as! String
        }
        if dict.keys.contains("TargetList") && dict["TargetList"] != nil {
            self.targetList = dict["TargetList"] as! [String]
        }
    }
}

public class ListAssetSelectionSelectedTargetResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var targetId: String?

        public var targetName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! String
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
        }
    }
    public var data: [ListAssetSelectionSelectedTargetResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListAssetSelectionSelectedTargetResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAssetSelectionSelectedTargetResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAssetSelectionSelectedTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAssetSelectionSelectedTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAssetSelectionSelectedTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAssetSelectionTargetRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var selectionKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.selectionKey != nil {
            map["SelectionKey"] = self.selectionKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SelectionKey") && dict["SelectionKey"] != nil {
            self.selectionKey = dict["SelectionKey"] as! String
        }
    }
}

public class ListAssetSelectionTargetResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var targetId: String?

        public var targetName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! String
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: [ListAssetSelectionTargetResponseBody.Data]?

    public var pageInfo: ListAssetSelectionTargetResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListAssetSelectionTargetResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAssetSelectionTargetResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListAssetSelectionTargetResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAssetSelectionTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAssetSelectionTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAssetSelectionTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAvailableHoneypotRequest : Tea.TeaModel {
    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class ListAvailableHoneypotResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var honeypotImageDisplayName: String?

        public var honeypotImageId: String?

        public var honeypotImageName: String?

        public var honeypotImageType: String?

        public var honeypotImageVersion: String?

        public var multiports: String?

        public var proto: String?

        public var servicePort: String?

        public var template: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.honeypotImageDisplayName != nil {
                map["HoneypotImageDisplayName"] = self.honeypotImageDisplayName!
            }
            if self.honeypotImageId != nil {
                map["HoneypotImageId"] = self.honeypotImageId!
            }
            if self.honeypotImageName != nil {
                map["HoneypotImageName"] = self.honeypotImageName!
            }
            if self.honeypotImageType != nil {
                map["HoneypotImageType"] = self.honeypotImageType!
            }
            if self.honeypotImageVersion != nil {
                map["HoneypotImageVersion"] = self.honeypotImageVersion!
            }
            if self.multiports != nil {
                map["Multiports"] = self.multiports!
            }
            if self.proto != nil {
                map["Proto"] = self.proto!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.template != nil {
                map["Template"] = self.template!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HoneypotImageDisplayName") && dict["HoneypotImageDisplayName"] != nil {
                self.honeypotImageDisplayName = dict["HoneypotImageDisplayName"] as! String
            }
            if dict.keys.contains("HoneypotImageId") && dict["HoneypotImageId"] != nil {
                self.honeypotImageId = dict["HoneypotImageId"] as! String
            }
            if dict.keys.contains("HoneypotImageName") && dict["HoneypotImageName"] != nil {
                self.honeypotImageName = dict["HoneypotImageName"] as! String
            }
            if dict.keys.contains("HoneypotImageType") && dict["HoneypotImageType"] != nil {
                self.honeypotImageType = dict["HoneypotImageType"] as! String
            }
            if dict.keys.contains("HoneypotImageVersion") && dict["HoneypotImageVersion"] != nil {
                self.honeypotImageVersion = dict["HoneypotImageVersion"] as! String
            }
            if dict.keys.contains("Multiports") && dict["Multiports"] != nil {
                self.multiports = dict["Multiports"] as! String
            }
            if dict.keys.contains("Proto") && dict["Proto"] != nil {
                self.proto = dict["Proto"] as! String
            }
            if dict.keys.contains("ServicePort") && dict["ServicePort"] != nil {
                self.servicePort = dict["ServicePort"] as! String
            }
            if dict.keys.contains("Template") && dict["Template"] != nil {
                self.template = dict["Template"] as! String
            }
        }
    }
    public var code: String?

    public var count: Int32?

    public var data: [ListAvailableHoneypotResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListAvailableHoneypotResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAvailableHoneypotResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAvailableHoneypotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAvailableHoneypotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAvailableHoneypotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCheckInstanceResultRequest : Tea.TeaModel {
    public var checkId: Int64?

    public var currentPage: Int32?

    public var instanceIdKey: String?

    public var instanceIds: [String]?

    public var instanceNameKey: String?

    public var lang: String?

    public var pageSize: Int32?

    public var regionIdKey: String?

    public var sortTypes: [String]?

    public var statuses: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.instanceIdKey != nil {
            map["InstanceIdKey"] = self.instanceIdKey!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.instanceNameKey != nil {
            map["InstanceNameKey"] = self.instanceNameKey!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionIdKey != nil {
            map["RegionIdKey"] = self.regionIdKey!
        }
        if self.sortTypes != nil {
            map["SortTypes"] = self.sortTypes!
        }
        if self.statuses != nil {
            map["Statuses"] = self.statuses!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
            self.checkId = dict["CheckId"] as! Int64
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("InstanceIdKey") && dict["InstanceIdKey"] != nil {
            self.instanceIdKey = dict["InstanceIdKey"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("InstanceNameKey") && dict["InstanceNameKey"] != nil {
            self.instanceNameKey = dict["InstanceNameKey"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionIdKey") && dict["RegionIdKey"] != nil {
            self.regionIdKey = dict["RegionIdKey"] as! String
        }
        if dict.keys.contains("SortTypes") && dict["SortTypes"] != nil {
            self.sortTypes = dict["SortTypes"] as! [String]
        }
        if dict.keys.contains("Statuses") && dict["Statuses"] != nil {
            self.statuses = dict["Statuses"] as! [String]
        }
    }
}

public class ListCheckInstanceResultResponseBody : Tea.TeaModel {
    public class BasicData : Tea.TeaModel {
        public var id: Int64?

        public var instanceId: String?

        public var instanceName: String?

        public var regionId: String?

        public var status: String?

        public var statusMessage: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusMessage != nil {
                map["StatusMessage"] = self.statusMessage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StatusMessage") && dict["StatusMessage"] != nil {
                self.statusMessage = dict["StatusMessage"] as! String
            }
        }
    }
    public class Columns : Tea.TeaModel {
        public class Grids : Tea.TeaModel {
            public var key: String?

            public var showName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.showName != nil {
                    map["ShowName"] = self.showName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                    self.showName = dict["ShowName"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var grids: [ListCheckInstanceResultResponseBody.Columns.Grids]?

        public var key: String?

        public var search: Bool?

        public var searchKey: String?

        public var showName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.grids != nil {
                var tmp : [Any] = []
                for k in self.grids! {
                    tmp.append(k.toMap())
                }
                map["Grids"] = tmp
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.search != nil {
                map["Search"] = self.search!
            }
            if self.searchKey != nil {
                map["SearchKey"] = self.searchKey!
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Grids") && dict["Grids"] != nil {
                var tmp : [ListCheckInstanceResultResponseBody.Columns.Grids] = []
                for v in dict["Grids"] as! [Any] {
                    var model = ListCheckInstanceResultResponseBody.Columns.Grids()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.grids = tmp
            }
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Search") && dict["Search"] != nil {
                self.search = dict["Search"] as! Bool
            }
            if dict.keys.contains("SearchKey") && dict["SearchKey"] != nil {
                self.searchKey = dict["SearchKey"] as! String
            }
            if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                self.showName = dict["ShowName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: String?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! String
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var basicData: [ListCheckInstanceResultResponseBody.BasicData]?

    public var checks: [[String: Any]]?

    public var columns: [ListCheckInstanceResultResponseBody.Columns]?

    public var pageInfo: ListCheckInstanceResultResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.basicData != nil {
            var tmp : [Any] = []
            for k in self.basicData! {
                tmp.append(k.toMap())
            }
            map["BasicData"] = tmp
        }
        if self.checks != nil {
            map["Checks"] = self.checks!
        }
        if self.columns != nil {
            var tmp : [Any] = []
            for k in self.columns! {
                tmp.append(k.toMap())
            }
            map["Columns"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BasicData") && dict["BasicData"] != nil {
            var tmp : [ListCheckInstanceResultResponseBody.BasicData] = []
            for v in dict["BasicData"] as! [Any] {
                var model = ListCheckInstanceResultResponseBody.BasicData()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.basicData = tmp
        }
        if dict.keys.contains("Checks") && dict["Checks"] != nil {
            self.checks = dict["Checks"] as! [[String: Any]]
        }
        if dict.keys.contains("Columns") && dict["Columns"] != nil {
            var tmp : [ListCheckInstanceResultResponseBody.Columns] = []
            for v in dict["Columns"] as! [Any] {
                var model = ListCheckInstanceResultResponseBody.Columns()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.columns = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListCheckInstanceResultResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCheckInstanceResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCheckInstanceResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCheckInstanceResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCheckItemRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var lang: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListCheckItemResponseBody : Tea.TeaModel {
    public class CheckItems : Tea.TeaModel {
        public class CustomConfigs : Tea.TeaModel {
            public var defaultValue: String?

            public var name: String?

            public var showName: String?

            public var typeDefine: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.showName != nil {
                    map["ShowName"] = self.showName!
                }
                if self.typeDefine != nil {
                    map["TypeDefine"] = self.typeDefine!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DefaultValue") && dict["DefaultValue"] != nil {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                    self.showName = dict["ShowName"] as! String
                }
                if dict.keys.contains("TypeDefine") && dict["TypeDefine"] != nil {
                    self.typeDefine = dict["TypeDefine"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Description_ : Tea.TeaModel {
            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var checkId: Int64?

        public var checkShowName: String?

        public var customConfigs: [ListCheckItemResponseBody.CheckItems.CustomConfigs]?

        public var description_: ListCheckItemResponseBody.CheckItems.Description_?

        public var instanceSubType: String?

        public var instanceType: String?

        public var riskLevel: String?

        public var sectionIds: [Int64]?

        public var vendor: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.description_?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.checkShowName != nil {
                map["CheckShowName"] = self.checkShowName!
            }
            if self.customConfigs != nil {
                var tmp : [Any] = []
                for k in self.customConfigs! {
                    tmp.append(k.toMap())
                }
                map["CustomConfigs"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_?.toMap()
            }
            if self.instanceSubType != nil {
                map["InstanceSubType"] = self.instanceSubType!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.sectionIds != nil {
                map["SectionIds"] = self.sectionIds!
            }
            if self.vendor != nil {
                map["Vendor"] = self.vendor!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                self.checkId = dict["CheckId"] as! Int64
            }
            if dict.keys.contains("CheckShowName") && dict["CheckShowName"] != nil {
                self.checkShowName = dict["CheckShowName"] as! String
            }
            if dict.keys.contains("CustomConfigs") && dict["CustomConfigs"] != nil {
                var tmp : [ListCheckItemResponseBody.CheckItems.CustomConfigs] = []
                for v in dict["CustomConfigs"] as! [Any] {
                    var model = ListCheckItemResponseBody.CheckItems.CustomConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customConfigs = tmp
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                var model = ListCheckItemResponseBody.CheckItems.Description_()
                model.fromMap(dict["Description"] as! [String: Any])
                self.description_ = model
            }
            if dict.keys.contains("InstanceSubType") && dict["InstanceSubType"] != nil {
                self.instanceSubType = dict["InstanceSubType"] as! String
            }
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("SectionIds") && dict["SectionIds"] != nil {
                self.sectionIds = dict["SectionIds"] as! [Int64]
            }
            if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                self.vendor = dict["Vendor"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var checkItems: [ListCheckItemResponseBody.CheckItems]?

    public var pageInfo: ListCheckItemResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkItems != nil {
            var tmp : [Any] = []
            for k in self.checkItems! {
                tmp.append(k.toMap())
            }
            map["CheckItems"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckItems") && dict["CheckItems"] != nil {
            var tmp : [ListCheckItemResponseBody.CheckItems] = []
            for v in dict["CheckItems"] as! [Any] {
                var model = ListCheckItemResponseBody.CheckItems()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.checkItems = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListCheckItemResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCheckItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCheckItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCheckItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCheckItemWarningMachineRequest : Tea.TeaModel {
    public var checkId: Int64?

    public var containerFieldName: String?

    public var containerFieldValue: String?

    public var currentPage: Int32?

    public var groupId: Int64?

    public var lang: String?

    public var pageSize: Int32?

    public var remark: String?

    public var riskType: String?

    public var source: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.containerFieldName != nil {
            map["ContainerFieldName"] = self.containerFieldName!
        }
        if self.containerFieldValue != nil {
            map["ContainerFieldValue"] = self.containerFieldValue!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.riskType != nil {
            map["RiskType"] = self.riskType!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
            self.checkId = dict["CheckId"] as! Int64
        }
        if dict.keys.contains("ContainerFieldName") && dict["ContainerFieldName"] != nil {
            self.containerFieldName = dict["ContainerFieldName"] as! String
        }
        if dict.keys.contains("ContainerFieldValue") && dict["ContainerFieldValue"] != nil {
            self.containerFieldValue = dict["ContainerFieldValue"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("RiskType") && dict["RiskType"] != nil {
            self.riskType = dict["RiskType"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class ListCheckItemWarningMachineResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public class FixList : Tea.TeaModel {
            public var riskId: Int64?

            public var riskName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.riskId != nil {
                    map["RiskId"] = self.riskId!
                }
                if self.riskName != nil {
                    map["RiskName"] = self.riskName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
                    self.riskId = dict["RiskId"] as! Int64
                }
                if dict.keys.contains("RiskName") && dict["RiskName"] != nil {
                    self.riskName = dict["RiskName"] as! String
                }
            }
        }
        public class WarningRiskList : Tea.TeaModel {
            public var riskId: Int64?

            public var riskName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.riskId != nil {
                    map["RiskId"] = self.riskId!
                }
                if self.riskName != nil {
                    map["RiskName"] = self.riskName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RiskId") && dict["RiskId"] != nil {
                    self.riskId = dict["RiskId"] as! Int64
                }
                if dict.keys.contains("RiskName") && dict["RiskName"] != nil {
                    self.riskName = dict["RiskName"] as! String
                }
            }
        }
        public var authVersion: Int32?

        public var bind: Bool?

        public var containerId: String?

        public var containerName: String?

        public var fixList: [ListCheckItemWarningMachineResponseBody.List.FixList]?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var lastScanTime: Int64?

        public var portOpen: Bool?

        public var prompt: String?

        public var regionId: String?

        public var status: Int32?

        public var targetId: String?

        public var targetName: String?

        public var targetType: String?

        public var uuid: String?

        public var warningRiskList: [ListCheckItemWarningMachineResponseBody.List.WarningRiskList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authVersion != nil {
                map["AuthVersion"] = self.authVersion!
            }
            if self.bind != nil {
                map["Bind"] = self.bind!
            }
            if self.containerId != nil {
                map["ContainerId"] = self.containerId!
            }
            if self.containerName != nil {
                map["ContainerName"] = self.containerName!
            }
            if self.fixList != nil {
                var tmp : [Any] = []
                for k in self.fixList! {
                    tmp.append(k.toMap())
                }
                map["FixList"] = tmp
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.lastScanTime != nil {
                map["LastScanTime"] = self.lastScanTime!
            }
            if self.portOpen != nil {
                map["PortOpen"] = self.portOpen!
            }
            if self.prompt != nil {
                map["Prompt"] = self.prompt!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.warningRiskList != nil {
                var tmp : [Any] = []
                for k in self.warningRiskList! {
                    tmp.append(k.toMap())
                }
                map["WarningRiskList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthVersion") && dict["AuthVersion"] != nil {
                self.authVersion = dict["AuthVersion"] as! Int32
            }
            if dict.keys.contains("Bind") && dict["Bind"] != nil {
                self.bind = dict["Bind"] as! Bool
            }
            if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                self.containerId = dict["ContainerId"] as! String
            }
            if dict.keys.contains("ContainerName") && dict["ContainerName"] != nil {
                self.containerName = dict["ContainerName"] as! String
            }
            if dict.keys.contains("FixList") && dict["FixList"] != nil {
                var tmp : [ListCheckItemWarningMachineResponseBody.List.FixList] = []
                for v in dict["FixList"] as! [Any] {
                    var model = ListCheckItemWarningMachineResponseBody.List.FixList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fixList = tmp
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LastScanTime") && dict["LastScanTime"] != nil {
                self.lastScanTime = dict["LastScanTime"] as! Int64
            }
            if dict.keys.contains("PortOpen") && dict["PortOpen"] != nil {
                self.portOpen = dict["PortOpen"] as! Bool
            }
            if dict.keys.contains("Prompt") && dict["Prompt"] != nil {
                self.prompt = dict["Prompt"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! String
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("WarningRiskList") && dict["WarningRiskList"] != nil {
                var tmp : [ListCheckItemWarningMachineResponseBody.List.WarningRiskList] = []
                for v in dict["WarningRiskList"] as! [Any] {
                    var model = ListCheckItemWarningMachineResponseBody.List.WarningRiskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.warningRiskList = tmp
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var list: [ListCheckItemWarningMachineResponseBody.List]?

    public var pageInfo: ListCheckItemWarningMachineResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListCheckItemWarningMachineResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListCheckItemWarningMachineResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListCheckItemWarningMachineResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCheckItemWarningMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCheckItemWarningMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCheckItemWarningMachineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCheckItemWarningSummaryRequest : Tea.TeaModel {
    public var checkItemFuzzy: String?

    public var checkLevel: String?

    public var checkType: String?

    public var checkWarningStatus: Int32?

    public var containerFieldName: String?

    public var containerFieldValue: String?

    public var currentPage: Int32?

    public var groupId: Int64?

    public var lang: String?

    public var pageSize: Int32?

    public var riskType: String?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkItemFuzzy != nil {
            map["CheckItemFuzzy"] = self.checkItemFuzzy!
        }
        if self.checkLevel != nil {
            map["CheckLevel"] = self.checkLevel!
        }
        if self.checkType != nil {
            map["CheckType"] = self.checkType!
        }
        if self.checkWarningStatus != nil {
            map["CheckWarningStatus"] = self.checkWarningStatus!
        }
        if self.containerFieldName != nil {
            map["ContainerFieldName"] = self.containerFieldName!
        }
        if self.containerFieldValue != nil {
            map["ContainerFieldValue"] = self.containerFieldValue!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskType != nil {
            map["RiskType"] = self.riskType!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckItemFuzzy") && dict["CheckItemFuzzy"] != nil {
            self.checkItemFuzzy = dict["CheckItemFuzzy"] as! String
        }
        if dict.keys.contains("CheckLevel") && dict["CheckLevel"] != nil {
            self.checkLevel = dict["CheckLevel"] as! String
        }
        if dict.keys.contains("CheckType") && dict["CheckType"] != nil {
            self.checkType = dict["CheckType"] as! String
        }
        if dict.keys.contains("CheckWarningStatus") && dict["CheckWarningStatus"] != nil {
            self.checkWarningStatus = dict["CheckWarningStatus"] as! Int32
        }
        if dict.keys.contains("ContainerFieldName") && dict["ContainerFieldName"] != nil {
            self.containerFieldName = dict["ContainerFieldName"] as! String
        }
        if dict.keys.contains("ContainerFieldValue") && dict["ContainerFieldValue"] != nil {
            self.containerFieldValue = dict["ContainerFieldValue"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskType") && dict["RiskType"] != nil {
            self.riskType = dict["RiskType"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
    }
}

public class ListCheckItemWarningSummaryResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var advice: String?

        public var alias: String?

        public var checkId: Int64?

        public var checkItem: String?

        public var checkLevel: String?

        public var checkType: String?

        public var containerCheckItem: Bool?

        public var description_: String?

        public var riskType: String?

        public var status: Int32?

        public var warningMachineCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advice != nil {
                map["Advice"] = self.advice!
            }
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.checkItem != nil {
                map["CheckItem"] = self.checkItem!
            }
            if self.checkLevel != nil {
                map["CheckLevel"] = self.checkLevel!
            }
            if self.checkType != nil {
                map["CheckType"] = self.checkType!
            }
            if self.containerCheckItem != nil {
                map["ContainerCheckItem"] = self.containerCheckItem!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.riskType != nil {
                map["RiskType"] = self.riskType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.warningMachineCount != nil {
                map["WarningMachineCount"] = self.warningMachineCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Advice") && dict["Advice"] != nil {
                self.advice = dict["Advice"] as! String
            }
            if dict.keys.contains("Alias") && dict["Alias"] != nil {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                self.checkId = dict["CheckId"] as! Int64
            }
            if dict.keys.contains("CheckItem") && dict["CheckItem"] != nil {
                self.checkItem = dict["CheckItem"] as! String
            }
            if dict.keys.contains("CheckLevel") && dict["CheckLevel"] != nil {
                self.checkLevel = dict["CheckLevel"] as! String
            }
            if dict.keys.contains("CheckType") && dict["CheckType"] != nil {
                self.checkType = dict["CheckType"] as! String
            }
            if dict.keys.contains("ContainerCheckItem") && dict["ContainerCheckItem"] != nil {
                self.containerCheckItem = dict["ContainerCheckItem"] as! Bool
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("RiskType") && dict["RiskType"] != nil {
                self.riskType = dict["RiskType"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("WarningMachineCount") && dict["WarningMachineCount"] != nil {
                self.warningMachineCount = dict["WarningMachineCount"] as! Int32
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var list: [ListCheckItemWarningSummaryResponseBody.List]?

    public var pageInfo: ListCheckItemWarningSummaryResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListCheckItemWarningSummaryResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListCheckItemWarningSummaryResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListCheckItemWarningSummaryResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCheckItemWarningSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCheckItemWarningSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCheckItemWarningSummaryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCheckResultRequest : Tea.TeaModel {
    public var checkKey: String?

    public var currentPage: Int32?

    public var customParam: Bool?

    public var instanceIds: [String]?

    public var instanceTypes: [String]?

    public var lang: String?

    public var pageSize: Int32?

    public var regionId: String?

    public var requirementIds: [Int64]?

    public var riskLevels: [String]?

    public var sortTypes: [String]?

    public var standardIds: [Int64]?

    public var statuses: [String]?

    public var types: [String]?

    public var vendors: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkKey != nil {
            map["CheckKey"] = self.checkKey!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.customParam != nil {
            map["CustomParam"] = self.customParam!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requirementIds != nil {
            map["RequirementIds"] = self.requirementIds!
        }
        if self.riskLevels != nil {
            map["RiskLevels"] = self.riskLevels!
        }
        if self.sortTypes != nil {
            map["SortTypes"] = self.sortTypes!
        }
        if self.standardIds != nil {
            map["StandardIds"] = self.standardIds!
        }
        if self.statuses != nil {
            map["Statuses"] = self.statuses!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        if self.vendors != nil {
            map["Vendors"] = self.vendors!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckKey") && dict["CheckKey"] != nil {
            self.checkKey = dict["CheckKey"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("CustomParam") && dict["CustomParam"] != nil {
            self.customParam = dict["CustomParam"] as! Bool
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequirementIds") && dict["RequirementIds"] != nil {
            self.requirementIds = dict["RequirementIds"] as! [Int64]
        }
        if dict.keys.contains("RiskLevels") && dict["RiskLevels"] != nil {
            self.riskLevels = dict["RiskLevels"] as! [String]
        }
        if dict.keys.contains("SortTypes") && dict["SortTypes"] != nil {
            self.sortTypes = dict["SortTypes"] as! [String]
        }
        if dict.keys.contains("StandardIds") && dict["StandardIds"] != nil {
            self.standardIds = dict["StandardIds"] as! [Int64]
        }
        if dict.keys.contains("Statuses") && dict["Statuses"] != nil {
            self.statuses = dict["Statuses"] as! [String]
        }
        if dict.keys.contains("Types") && dict["Types"] != nil {
            self.types = dict["Types"] as! [String]
        }
        if dict.keys.contains("Vendors") && dict["Vendors"] != nil {
            self.vendors = dict["Vendors"] as! [String]
        }
    }
}

public class ListCheckResultResponseBody : Tea.TeaModel {
    public class Checks : Tea.TeaModel {
        public class CheckPolicies : Tea.TeaModel {
            public var requirementId: Int64?

            public var requirementShowName: String?

            public var sectionId: Int64?

            public var sectionShowName: String?

            public var standardId: Int64?

            public var standardShowName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requirementId != nil {
                    map["RequirementId"] = self.requirementId!
                }
                if self.requirementShowName != nil {
                    map["RequirementShowName"] = self.requirementShowName!
                }
                if self.sectionId != nil {
                    map["SectionId"] = self.sectionId!
                }
                if self.sectionShowName != nil {
                    map["SectionShowName"] = self.sectionShowName!
                }
                if self.standardId != nil {
                    map["StandardId"] = self.standardId!
                }
                if self.standardShowName != nil {
                    map["StandardShowName"] = self.standardShowName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequirementId") && dict["RequirementId"] != nil {
                    self.requirementId = dict["RequirementId"] as! Int64
                }
                if dict.keys.contains("RequirementShowName") && dict["RequirementShowName"] != nil {
                    self.requirementShowName = dict["RequirementShowName"] as! String
                }
                if dict.keys.contains("SectionId") && dict["SectionId"] != nil {
                    self.sectionId = dict["SectionId"] as! Int64
                }
                if dict.keys.contains("SectionShowName") && dict["SectionShowName"] != nil {
                    self.sectionShowName = dict["SectionShowName"] as! String
                }
                if dict.keys.contains("StandardId") && dict["StandardId"] != nil {
                    self.standardId = dict["StandardId"] as! Int64
                }
                if dict.keys.contains("StandardShowName") && dict["StandardShowName"] != nil {
                    self.standardShowName = dict["StandardShowName"] as! String
                }
            }
        }
        public var checkId: Int64?

        public var checkPolicies: [ListCheckResultResponseBody.Checks.CheckPolicies]?

        public var checkShowName: String?

        public var instanceSubType: String?

        public var instanceType: String?

        public var lastCheckTime: Int64?

        public var riskLevel: String?

        public var status: String?

        public var statusMessage: String?

        public var taskId: String?

        public var trialPermission: Bool?

        public var vendor: String?

        public var vendorShowName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.checkId != nil {
                map["CheckId"] = self.checkId!
            }
            if self.checkPolicies != nil {
                var tmp : [Any] = []
                for k in self.checkPolicies! {
                    tmp.append(k.toMap())
                }
                map["CheckPolicies"] = tmp
            }
            if self.checkShowName != nil {
                map["CheckShowName"] = self.checkShowName!
            }
            if self.instanceSubType != nil {
                map["InstanceSubType"] = self.instanceSubType!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.lastCheckTime != nil {
                map["LastCheckTime"] = self.lastCheckTime!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusMessage != nil {
                map["StatusMessage"] = self.statusMessage!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.trialPermission != nil {
                map["TrialPermission"] = self.trialPermission!
            }
            if self.vendor != nil {
                map["Vendor"] = self.vendor!
            }
            if self.vendorShowName != nil {
                map["VendorShowName"] = self.vendorShowName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
                self.checkId = dict["CheckId"] as! Int64
            }
            if dict.keys.contains("CheckPolicies") && dict["CheckPolicies"] != nil {
                var tmp : [ListCheckResultResponseBody.Checks.CheckPolicies] = []
                for v in dict["CheckPolicies"] as! [Any] {
                    var model = ListCheckResultResponseBody.Checks.CheckPolicies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.checkPolicies = tmp
            }
            if dict.keys.contains("CheckShowName") && dict["CheckShowName"] != nil {
                self.checkShowName = dict["CheckShowName"] as! String
            }
            if dict.keys.contains("InstanceSubType") && dict["InstanceSubType"] != nil {
                self.instanceSubType = dict["InstanceSubType"] as! String
            }
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("LastCheckTime") && dict["LastCheckTime"] != nil {
                self.lastCheckTime = dict["LastCheckTime"] as! Int64
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StatusMessage") && dict["StatusMessage"] != nil {
                self.statusMessage = dict["StatusMessage"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TrialPermission") && dict["TrialPermission"] != nil {
                self.trialPermission = dict["TrialPermission"] as! Bool
            }
            if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                self.vendor = dict["Vendor"] as! String
            }
            if dict.keys.contains("VendorShowName") && dict["VendorShowName"] != nil {
                self.vendorShowName = dict["VendorShowName"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var checks: [ListCheckResultResponseBody.Checks]?

    public var pageInfo: ListCheckResultResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checks != nil {
            var tmp : [Any] = []
            for k in self.checks! {
                tmp.append(k.toMap())
            }
            map["Checks"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Checks") && dict["Checks"] != nil {
            var tmp : [ListCheckResultResponseBody.Checks] = []
            for v in dict["Checks"] as! [Any] {
                var model = ListCheckResultResponseBody.Checks()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.checks = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListCheckResultResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCheckResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCheckResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCheckResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCheckStandardRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var instanceSubTypes: [String]?

    public var instanceTypes: [String]?

    public var lang: String?

    public var vendors: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.instanceSubTypes != nil {
            map["InstanceSubTypes"] = self.instanceSubTypes!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.vendors != nil {
            map["Vendors"] = self.vendors!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("InstanceSubTypes") && dict["InstanceSubTypes"] != nil {
            self.instanceSubTypes = dict["InstanceSubTypes"] as! [String]
        }
        if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Vendors") && dict["Vendors"] != nil {
            self.vendors = dict["Vendors"] as! [String]
        }
    }
}

public class ListCheckStandardResponseBody : Tea.TeaModel {
    public class Standards : Tea.TeaModel {
        public class Requirements : Tea.TeaModel {
            public var id: Int64?

            public var riskCheckCount: Int64?

            public var showName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.riskCheckCount != nil {
                    map["RiskCheckCount"] = self.riskCheckCount!
                }
                if self.showName != nil {
                    map["ShowName"] = self.showName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("RiskCheckCount") && dict["RiskCheckCount"] != nil {
                    self.riskCheckCount = dict["RiskCheckCount"] as! Int64
                }
                if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                    self.showName = dict["ShowName"] as! String
                }
            }
        }
        public var id: Int64?

        public var requirements: [ListCheckStandardResponseBody.Standards.Requirements]?

        public var showName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.requirements != nil {
                var tmp : [Any] = []
                for k in self.requirements! {
                    tmp.append(k.toMap())
                }
                map["Requirements"] = tmp
            }
            if self.showName != nil {
                map["ShowName"] = self.showName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Requirements") && dict["Requirements"] != nil {
                var tmp : [ListCheckStandardResponseBody.Standards.Requirements] = []
                for v in dict["Requirements"] as! [Any] {
                    var model = ListCheckStandardResponseBody.Standards.Requirements()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.requirements = tmp
            }
            if dict.keys.contains("ShowName") && dict["ShowName"] != nil {
                self.showName = dict["ShowName"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var requestId: String?

    public var standards: [ListCheckStandardResponseBody.Standards]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.standards != nil {
            var tmp : [Any] = []
            for k in self.standards! {
                tmp.append(k.toMap())
            }
            map["Standards"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Standards") && dict["Standards"] != nil {
            var tmp : [ListCheckStandardResponseBody.Standards] = []
            for v in dict["Standards"] as! [Any] {
                var model = ListCheckStandardResponseBody.Standards()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.standards = tmp
        }
    }
}

public class ListCheckStandardResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCheckStandardResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCheckStandardResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClientAlertModeRequest : Tea.TeaModel {
    public var mode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
    }
}

public class ListClientAlertModeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int32?

        public var uuids: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.uuids != nil {
                map["Uuids"] = self.uuids!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
                self.uuids = dict["Uuids"] as! [String]
            }
        }
    }
    public var data: ListClientAlertModeResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListClientAlertModeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListClientAlertModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClientAlertModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClientAlertModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClientUserDefineRuleTypesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var userDefineRuleTypes: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userDefineRuleTypes != nil {
            map["UserDefineRuleTypes"] = self.userDefineRuleTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserDefineRuleTypes") && dict["UserDefineRuleTypes"] != nil {
            self.userDefineRuleTypes = dict["UserDefineRuleTypes"] as! [String]
        }
    }
}

public class ListClientUserDefineRuleTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClientUserDefineRuleTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClientUserDefineRuleTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClientUserDefineRulesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var name: String?

    public var pageSize: Int32?

    public var type: [Int32]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! [Int32]
        }
    }
}

public class ListClientUserDefineRulesResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class UserDefineRuleList : Tea.TeaModel {
        public var actionType: Int32?

        public var id: Int64?

        public var name: String?

        public var platform: String?

        public var switchId: String?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionType != nil {
                map["ActionType"] = self.actionType!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.platform != nil {
                map["Platform"] = self.platform!
            }
            if self.switchId != nil {
                map["SwitchId"] = self.switchId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionType") && dict["ActionType"] != nil {
                self.actionType = dict["ActionType"] as! Int32
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Platform") && dict["Platform"] != nil {
                self.platform = dict["Platform"] as! String
            }
            if dict.keys.contains("SwitchId") && dict["SwitchId"] != nil {
                self.switchId = dict["SwitchId"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var pageInfo: ListClientUserDefineRulesResponseBody.PageInfo?

    public var requestId: String?

    public var userDefineRuleList: [ListClientUserDefineRulesResponseBody.UserDefineRuleList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userDefineRuleList != nil {
            var tmp : [Any] = []
            for k in self.userDefineRuleList! {
                tmp.append(k.toMap())
            }
            map["UserDefineRuleList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListClientUserDefineRulesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserDefineRuleList") && dict["UserDefineRuleList"] != nil {
            var tmp : [ListClientUserDefineRulesResponseBody.UserDefineRuleList] = []
            for v in dict["UserDefineRuleList"] as! [Any] {
                var model = ListClientUserDefineRulesResponseBody.UserDefineRuleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.userDefineRuleList = tmp
        }
    }
}

public class ListClientUserDefineRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClientUserDefineRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClientUserDefineRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCloudAssetInstancesRequest : Tea.TeaModel {
    public class CloudAssetTypes : Tea.TeaModel {
        public var assetSubType: Int32?

        public var assetType: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assetSubType != nil {
                map["AssetSubType"] = self.assetSubType!
            }
            if self.assetType != nil {
                map["AssetType"] = self.assetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssetSubType") && dict["AssetSubType"] != nil {
                self.assetSubType = dict["AssetSubType"] as! Int32
            }
            if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
                self.assetType = dict["AssetType"] as! Int32
            }
        }
    }
    public var cloudAssetTypes: [ListCloudAssetInstancesRequest.CloudAssetTypes]?

    public var criteria: String?

    public var currentPage: Int32?

    public var logicalExp: String?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cloudAssetTypes != nil {
            var tmp : [Any] = []
            for k in self.cloudAssetTypes! {
                tmp.append(k.toMap())
            }
            map["CloudAssetTypes"] = tmp
        }
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.logicalExp != nil {
            map["LogicalExp"] = self.logicalExp!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CloudAssetTypes") && dict["CloudAssetTypes"] != nil {
            var tmp : [ListCloudAssetInstancesRequest.CloudAssetTypes] = []
            for v in dict["CloudAssetTypes"] as! [Any] {
                var model = ListCloudAssetInstancesRequest.CloudAssetTypes()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.cloudAssetTypes = tmp
        }
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("LogicalExp") && dict["LogicalExp"] != nil {
            self.logicalExp = dict["LogicalExp"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListCloudAssetInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var alarmStatus: String?

        public var assetSubType: String?

        public var assetSubTypeName: String?

        public var assetType: Int32?

        public var assetTypeName: String?

        public var createdTime: Int64?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var regionId: String?

        public var riskStatus: String?

        public var securityInfo: String?

        public var vendor: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmStatus != nil {
                map["AlarmStatus"] = self.alarmStatus!
            }
            if self.assetSubType != nil {
                map["AssetSubType"] = self.assetSubType!
            }
            if self.assetSubTypeName != nil {
                map["AssetSubTypeName"] = self.assetSubTypeName!
            }
            if self.assetType != nil {
                map["AssetType"] = self.assetType!
            }
            if self.assetTypeName != nil {
                map["AssetTypeName"] = self.assetTypeName!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.riskStatus != nil {
                map["RiskStatus"] = self.riskStatus!
            }
            if self.securityInfo != nil {
                map["SecurityInfo"] = self.securityInfo!
            }
            if self.vendor != nil {
                map["Vendor"] = self.vendor!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmStatus") && dict["AlarmStatus"] != nil {
                self.alarmStatus = dict["AlarmStatus"] as! String
            }
            if dict.keys.contains("AssetSubType") && dict["AssetSubType"] != nil {
                self.assetSubType = dict["AssetSubType"] as! String
            }
            if dict.keys.contains("AssetSubTypeName") && dict["AssetSubTypeName"] != nil {
                self.assetSubTypeName = dict["AssetSubTypeName"] as! String
            }
            if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
                self.assetType = dict["AssetType"] as! Int32
            }
            if dict.keys.contains("AssetTypeName") && dict["AssetTypeName"] != nil {
                self.assetTypeName = dict["AssetTypeName"] as! String
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RiskStatus") && dict["RiskStatus"] != nil {
                self.riskStatus = dict["RiskStatus"] as! String
            }
            if dict.keys.contains("SecurityInfo") && dict["SecurityInfo"] != nil {
                self.securityInfo = dict["SecurityInfo"] as! String
            }
            if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                self.vendor = dict["Vendor"] as! Int32
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var instances: [ListCloudAssetInstancesResponseBody.Instances]?

    public var pageInfo: ListCloudAssetInstancesResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") && dict["Instances"] != nil {
            var tmp : [ListCloudAssetInstancesResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = ListCloudAssetInstancesResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListCloudAssetInstancesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCloudAssetInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudAssetInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCloudAssetInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCloudVendorRegionsRequest : Tea.TeaModel {
    public var lang: String?

    public var vendor: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.vendor != nil {
            map["Vendor"] = self.vendor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
            self.vendor = dict["Vendor"] as! String
        }
    }
}

public class ListCloudVendorRegionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var area: String?

        public var disable: Int32?

        public var regionId: String?

        public var selected: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.area != nil {
                map["Area"] = self.area!
            }
            if self.disable != nil {
                map["Disable"] = self.disable!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.selected != nil {
                map["Selected"] = self.selected!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Area") && dict["Area"] != nil {
                self.area = dict["Area"] as! String
            }
            if dict.keys.contains("Disable") && dict["Disable"] != nil {
                self.disable = dict["Disable"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Selected") && dict["Selected"] != nil {
                self.selected = dict["Selected"] as! Int32
            }
        }
    }
    public var code: String?

    public var count: Int32?

    public var data: [ListCloudVendorRegionsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListCloudVendorRegionsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListCloudVendorRegionsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCloudVendorRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCloudVendorRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCloudVendorRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterCnnfStatusDetailRequest : Tea.TeaModel {
    public var clusterIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") && dict["ClusterIds"] != nil {
            self.clusterIds = dict["ClusterIds"] as! [String]
        }
    }
}

public class ListClusterCnnfStatusDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clusterId: String?

        public var installed: Bool?

        public var instanceId: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var invalidType: String?

        public var machineName: String?

        public var machineType: Int32?

        public var pluginName: String?

        public var pluginVersion: String?

        public var status: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.installed != nil {
                map["Installed"] = self.installed!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.invalidType != nil {
                map["InvalidType"] = self.invalidType!
            }
            if self.machineName != nil {
                map["MachineName"] = self.machineName!
            }
            if self.machineType != nil {
                map["MachineType"] = self.machineType!
            }
            if self.pluginName != nil {
                map["PluginName"] = self.pluginName!
            }
            if self.pluginVersion != nil {
                map["PluginVersion"] = self.pluginVersion!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Installed") && dict["Installed"] != nil {
                self.installed = dict["Installed"] as! Bool
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("InvalidType") && dict["InvalidType"] != nil {
                self.invalidType = dict["InvalidType"] as! String
            }
            if dict.keys.contains("MachineName") && dict["MachineName"] != nil {
                self.machineName = dict["MachineName"] as! String
            }
            if dict.keys.contains("MachineType") && dict["MachineType"] != nil {
                self.machineType = dict["MachineType"] as! Int32
            }
            if dict.keys.contains("PluginName") && dict["PluginName"] != nil {
                self.pluginName = dict["PluginName"] as! String
            }
            if dict.keys.contains("PluginVersion") && dict["PluginVersion"] != nil {
                self.pluginVersion = dict["PluginVersion"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var data: [ListClusterCnnfStatusDetailResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListClusterCnnfStatusDetailResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListClusterCnnfStatusDetailResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListClusterCnnfStatusDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterCnnfStatusDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterCnnfStatusDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterInterceptionConfigRequest : Tea.TeaModel {
    public var clusterCNNFStatus: Int32?

    public var clusterId: String?

    public var clusterName: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterCNNFStatus != nil {
            map["ClusterCNNFStatus"] = self.clusterCNNFStatus!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterCNNFStatus") && dict["ClusterCNNFStatus"] != nil {
            self.clusterCNNFStatus = dict["ClusterCNNFStatus"] as! Int32
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListClusterInterceptionConfigResponseBody : Tea.TeaModel {
    public class ClusterConfigList : Tea.TeaModel {
        public var clusterCNNFStatus: Int32?

        public var clusterId: String?

        public var clusterName: String?

        public var clusterType: String?

        public var interceptionSwitch: Int32?

        public var openRuleCount: Int64?

        public var supportCNNF: Bool?

        public var totalRuleCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterCNNFStatus != nil {
                map["ClusterCNNFStatus"] = self.clusterCNNFStatus!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.interceptionSwitch != nil {
                map["InterceptionSwitch"] = self.interceptionSwitch!
            }
            if self.openRuleCount != nil {
                map["OpenRuleCount"] = self.openRuleCount!
            }
            if self.supportCNNF != nil {
                map["SupportCNNF"] = self.supportCNNF!
            }
            if self.totalRuleCount != nil {
                map["TotalRuleCount"] = self.totalRuleCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterCNNFStatus") && dict["ClusterCNNFStatus"] != nil {
                self.clusterCNNFStatus = dict["ClusterCNNFStatus"] as! Int32
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("InterceptionSwitch") && dict["InterceptionSwitch"] != nil {
                self.interceptionSwitch = dict["InterceptionSwitch"] as! Int32
            }
            if dict.keys.contains("OpenRuleCount") && dict["OpenRuleCount"] != nil {
                self.openRuleCount = dict["OpenRuleCount"] as! Int64
            }
            if dict.keys.contains("SupportCNNF") && dict["SupportCNNF"] != nil {
                self.supportCNNF = dict["SupportCNNF"] as! Bool
            }
            if dict.keys.contains("TotalRuleCount") && dict["TotalRuleCount"] != nil {
                self.totalRuleCount = dict["TotalRuleCount"] as! Int64
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currrentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currrentPage != nil {
                map["CurrrentPage"] = self.currrentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrrentPage") && dict["CurrrentPage"] != nil {
                self.currrentPage = dict["CurrrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var clusterConfigList: [ListClusterInterceptionConfigResponseBody.ClusterConfigList]?

    public var pageInfo: ListClusterInterceptionConfigResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterConfigList != nil {
            var tmp : [Any] = []
            for k in self.clusterConfigList! {
                tmp.append(k.toMap())
            }
            map["ClusterConfigList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterConfigList") && dict["ClusterConfigList"] != nil {
            var tmp : [ListClusterInterceptionConfigResponseBody.ClusterConfigList] = []
            for v in dict["ClusterConfigList"] as! [Any] {
                var model = ListClusterInterceptionConfigResponseBody.ClusterConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.clusterConfigList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListClusterInterceptionConfigResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListClusterInterceptionConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterInterceptionConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterInterceptionConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCriteriaStrategyRequest : Tea.TeaModel {
    public var clusterId: String?

    public var imageName: String?

    public var label: String?

    public var namespace: String?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.label != nil {
            map["Label"] = self.label!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("Label") && dict["Label"] != nil {
            self.label = dict["Label"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("StrategyName") && dict["StrategyName"] != nil {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class ListCriteriaStrategyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var id: Int64?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListCriteriaStrategyResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListCriteriaStrategyResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListCriteriaStrategyResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCriteriaStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCriteriaStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCriteriaStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFileProtectEventRequest : Tea.TeaModel {
    public var alertLevels: [Int32]?

    public var currentPage: Int32?

    public var pageSize: String?

    public var ruleName: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertLevels != nil {
            map["AlertLevels"] = self.alertLevels!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertLevels") && dict["AlertLevels"] != nil {
            self.alertLevels = dict["AlertLevels"] as! [Int32]
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListFileProtectEventResponseBody : Tea.TeaModel {
    public class EventList : Tea.TeaModel {
        public var alertLevel: Int32?

        public var cmdLine: String?

        public var filePath: String?

        public var handleTime: Int64?

        public var id: Int64?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var latestTime: Int64?

        public var operation: String?

        public var procPath: String?

        public var procPermission: String?

        public var processId: String?

        public var remark: String?

        public var ruleName: String?

        public var status: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alertLevel != nil {
                map["AlertLevel"] = self.alertLevel!
            }
            if self.cmdLine != nil {
                map["CmdLine"] = self.cmdLine!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.handleTime != nil {
                map["HandleTime"] = self.handleTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.latestTime != nil {
                map["LatestTime"] = self.latestTime!
            }
            if self.operation != nil {
                map["Operation"] = self.operation!
            }
            if self.procPath != nil {
                map["ProcPath"] = self.procPath!
            }
            if self.procPermission != nil {
                map["ProcPermission"] = self.procPermission!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.remark != nil {
                map["Remark"] = self.remark!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlertLevel") && dict["AlertLevel"] != nil {
                self.alertLevel = dict["AlertLevel"] as! Int32
            }
            if dict.keys.contains("CmdLine") && dict["CmdLine"] != nil {
                self.cmdLine = dict["CmdLine"] as! String
            }
            if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("HandleTime") && dict["HandleTime"] != nil {
                self.handleTime = dict["HandleTime"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("LatestTime") && dict["LatestTime"] != nil {
                self.latestTime = dict["LatestTime"] as! Int64
            }
            if dict.keys.contains("Operation") && dict["Operation"] != nil {
                self.operation = dict["Operation"] as! String
            }
            if dict.keys.contains("ProcPath") && dict["ProcPath"] != nil {
                self.procPath = dict["ProcPath"] as! String
            }
            if dict.keys.contains("ProcPermission") && dict["ProcPermission"] != nil {
                self.procPermission = dict["ProcPermission"] as! String
            }
            if dict.keys.contains("ProcessId") && dict["ProcessId"] != nil {
                self.processId = dict["ProcessId"] as! String
            }
            if dict.keys.contains("Remark") && dict["Remark"] != nil {
                self.remark = dict["Remark"] as! String
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var eventList: [ListFileProtectEventResponseBody.EventList]?

    public var pageInfo: ListFileProtectEventResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventList != nil {
            var tmp : [Any] = []
            for k in self.eventList! {
                tmp.append(k.toMap())
            }
            map["EventList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventList") && dict["EventList"] != nil {
            var tmp : [ListFileProtectEventResponseBody.EventList] = []
            for v in dict["EventList"] as! [Any] {
                var model = ListFileProtectEventResponseBody.EventList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.eventList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListFileProtectEventResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFileProtectEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFileProtectEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFileProtectEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFileProtectPluginStatusRequest : Tea.TeaModel {
    public var currentPage: Int64?

    public var pageSize: Int64?

    public var switchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.switchId != nil {
            map["SwitchId"] = self.switchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("SwitchId") && dict["SwitchId"] != nil {
            self.switchId = dict["SwitchId"] as! String
        }
    }
}

public class ListFileProtectPluginStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clientVersion: String?

        public var installCode: String?

        public var installMessage: String?

        public var installed: Bool?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var online: Bool?

        public var supportFile: Bool?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientVersion != nil {
                map["ClientVersion"] = self.clientVersion!
            }
            if self.installCode != nil {
                map["InstallCode"] = self.installCode!
            }
            if self.installMessage != nil {
                map["InstallMessage"] = self.installMessage!
            }
            if self.installed != nil {
                map["Installed"] = self.installed!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.online != nil {
                map["Online"] = self.online!
            }
            if self.supportFile != nil {
                map["SupportFile"] = self.supportFile!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientVersion") && dict["ClientVersion"] != nil {
                self.clientVersion = dict["ClientVersion"] as! String
            }
            if dict.keys.contains("InstallCode") && dict["InstallCode"] != nil {
                self.installCode = dict["InstallCode"] as! String
            }
            if dict.keys.contains("InstallMessage") && dict["InstallMessage"] != nil {
                self.installMessage = dict["InstallMessage"] as! String
            }
            if dict.keys.contains("Installed") && dict["Installed"] != nil {
                self.installed = dict["Installed"] as! Bool
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("Online") && dict["Online"] != nil {
                self.online = dict["Online"] as! Bool
            }
            if dict.keys.contains("SupportFile") && dict["SupportFile"] != nil {
                self.supportFile = dict["SupportFile"] as! Bool
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: [ListFileProtectPluginStatusResponseBody.Data]?

    public var pageInfo: ListFileProtectPluginStatusResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListFileProtectPluginStatusResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListFileProtectPluginStatusResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListFileProtectPluginStatusResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFileProtectPluginStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFileProtectPluginStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFileProtectPluginStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFileProtectRuleRequest : Tea.TeaModel {
    public var alertLevel: Int32?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var ruleAction: String?

    public var ruleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertLevel != nil {
            map["AlertLevel"] = self.alertLevel!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ruleAction != nil {
            map["RuleAction"] = self.ruleAction!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertLevel") && dict["AlertLevel"] != nil {
            self.alertLevel = dict["AlertLevel"] as! Int32
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RuleAction") && dict["RuleAction"] != nil {
            self.ruleAction = dict["RuleAction"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
    }
}

public class ListFileProtectRuleResponseBody : Tea.TeaModel {
    public class FileProtectList : Tea.TeaModel {
        public var action: String?

        public var alertLevel: String?

        public var effectInstanceCount: Int64?

        public var fileOps: [String]?

        public var filePaths: [String]?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var procPaths: [String]?

        public var ruleName: String?

        public var status: Int32?

        public var switchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.alertLevel != nil {
                map["AlertLevel"] = self.alertLevel!
            }
            if self.effectInstanceCount != nil {
                map["EffectInstanceCount"] = self.effectInstanceCount!
            }
            if self.fileOps != nil {
                map["FileOps"] = self.fileOps!
            }
            if self.filePaths != nil {
                map["FilePaths"] = self.filePaths!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.procPaths != nil {
                map["ProcPaths"] = self.procPaths!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.switchId != nil {
                map["SwitchId"] = self.switchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("AlertLevel") && dict["AlertLevel"] != nil {
                self.alertLevel = dict["AlertLevel"] as! String
            }
            if dict.keys.contains("EffectInstanceCount") && dict["EffectInstanceCount"] != nil {
                self.effectInstanceCount = dict["EffectInstanceCount"] as! Int64
            }
            if dict.keys.contains("FileOps") && dict["FileOps"] != nil {
                self.fileOps = dict["FileOps"] as! [String]
            }
            if dict.keys.contains("FilePaths") && dict["FilePaths"] != nil {
                self.filePaths = dict["FilePaths"] as! [String]
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ProcPaths") && dict["ProcPaths"] != nil {
                self.procPaths = dict["ProcPaths"] as! [String]
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("SwitchId") && dict["SwitchId"] != nil {
                self.switchId = dict["SwitchId"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var fileProtectList: [ListFileProtectRuleResponseBody.FileProtectList]?

    public var pageInfo: ListFileProtectRuleResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileProtectList != nil {
            var tmp : [Any] = []
            for k in self.fileProtectList! {
                tmp.append(k.toMap())
            }
            map["FileProtectList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileProtectList") && dict["FileProtectList"] != nil {
            var tmp : [ListFileProtectRuleResponseBody.FileProtectList] = []
            for v in dict["FileProtectList"] as! [Any] {
                var model = ListFileProtectRuleResponseBody.FileProtectList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fileProtectList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListFileProtectRuleResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFileProtectRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFileProtectRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFileProtectRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHoneypotRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var honeypotIds: [String]?

    public var honeypotName: String?

    public var nodeId: String?

    public var nodeName: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.honeypotIds != nil {
            map["HoneypotIds"] = self.honeypotIds!
        }
        if self.honeypotName != nil {
            map["HoneypotName"] = self.honeypotName!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("HoneypotIds") && dict["HoneypotIds"] != nil {
            self.honeypotIds = dict["HoneypotIds"] as! [String]
        }
        if dict.keys.contains("HoneypotName") && dict["HoneypotName"] != nil {
            self.honeypotName = dict["HoneypotName"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListHoneypotResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var controlNodeName: String?

        public var honeypotId: String?

        public var honeypotImageDisplayName: String?

        public var honeypotImageId: String?

        public var honeypotImageName: String?

        public var honeypotName: String?

        public var nodeId: String?

        public var presetId: String?

        public var state: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.controlNodeName != nil {
                map["ControlNodeName"] = self.controlNodeName!
            }
            if self.honeypotId != nil {
                map["HoneypotId"] = self.honeypotId!
            }
            if self.honeypotImageDisplayName != nil {
                map["HoneypotImageDisplayName"] = self.honeypotImageDisplayName!
            }
            if self.honeypotImageId != nil {
                map["HoneypotImageId"] = self.honeypotImageId!
            }
            if self.honeypotImageName != nil {
                map["HoneypotImageName"] = self.honeypotImageName!
            }
            if self.honeypotName != nil {
                map["HoneypotName"] = self.honeypotName!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.presetId != nil {
                map["PresetId"] = self.presetId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ControlNodeName") && dict["ControlNodeName"] != nil {
                self.controlNodeName = dict["ControlNodeName"] as! String
            }
            if dict.keys.contains("HoneypotId") && dict["HoneypotId"] != nil {
                self.honeypotId = dict["HoneypotId"] as! String
            }
            if dict.keys.contains("HoneypotImageDisplayName") && dict["HoneypotImageDisplayName"] != nil {
                self.honeypotImageDisplayName = dict["HoneypotImageDisplayName"] as! String
            }
            if dict.keys.contains("HoneypotImageId") && dict["HoneypotImageId"] != nil {
                self.honeypotImageId = dict["HoneypotImageId"] as! String
            }
            if dict.keys.contains("HoneypotImageName") && dict["HoneypotImageName"] != nil {
                self.honeypotImageName = dict["HoneypotImageName"] as! String
            }
            if dict.keys.contains("HoneypotName") && dict["HoneypotName"] != nil {
                self.honeypotName = dict["HoneypotName"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PresetId") && dict["PresetId"] != nil {
                self.presetId = dict["PresetId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! [String]
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var list: [ListHoneypotResponseBody.List]?

    public var message: String?

    public var pageInfo: ListHoneypotResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListHoneypotResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListHoneypotResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListHoneypotResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListHoneypotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHoneypotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHoneypotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHoneypotAlarmEventsRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var dealed: String?

    public var dstIp: String?

    public var pageSize: Int32?

    public var riskLevelList: [String]?

    public var srcIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.dstIp != nil {
            map["DstIp"] = self.dstIp!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskLevelList != nil {
            map["RiskLevelList"] = self.riskLevelList!
        }
        if self.srcIp != nil {
            map["SrcIp"] = self.srcIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("DstIp") && dict["DstIp"] != nil {
            self.dstIp = dict["DstIp"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskLevelList") && dict["RiskLevelList"] != nil {
            self.riskLevelList = dict["RiskLevelList"] as! [String]
        }
        if dict.keys.contains("SrcIp") && dict["SrcIp"] != nil {
            self.srcIp = dict["SrcIp"] as! String
        }
    }
}

public class ListHoneypotAlarmEventsResponseBody : Tea.TeaModel {
    public class HoneypotAlarmEvents : Tea.TeaModel {
        public class MergeFieldList : Tea.TeaModel {
            public var fieldExtInfo: String?

            public var fieldKey: String?

            public var fieldType: String?

            public var fieldValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldExtInfo != nil {
                    map["FieldExtInfo"] = self.fieldExtInfo!
                }
                if self.fieldKey != nil {
                    map["FieldKey"] = self.fieldKey!
                }
                if self.fieldType != nil {
                    map["FieldType"] = self.fieldType!
                }
                if self.fieldValue != nil {
                    map["FieldValue"] = self.fieldValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FieldExtInfo") && dict["FieldExtInfo"] != nil {
                    self.fieldExtInfo = dict["FieldExtInfo"] as! String
                }
                if dict.keys.contains("FieldKey") && dict["FieldKey"] != nil {
                    self.fieldKey = dict["FieldKey"] as! String
                }
                if dict.keys.contains("FieldType") && dict["FieldType"] != nil {
                    self.fieldType = dict["FieldType"] as! String
                }
                if dict.keys.contains("FieldValue") && dict["FieldValue"] != nil {
                    self.fieldValue = dict["FieldValue"] as! String
                }
            }
        }
        public var alarmEventId: Int64?

        public var alarmEventName: String?

        public var alarmEventType: String?

        public var alarmUniqueInfo: String?

        public var eventCount: Int32?

        public var firstTime: Int64?

        public var lastTime: Int64?

        public var mergeFieldList: [ListHoneypotAlarmEventsResponseBody.HoneypotAlarmEvents.MergeFieldList]?

        public var operateStatus: Int32?

        public var riskLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmEventId != nil {
                map["AlarmEventId"] = self.alarmEventId!
            }
            if self.alarmEventName != nil {
                map["AlarmEventName"] = self.alarmEventName!
            }
            if self.alarmEventType != nil {
                map["AlarmEventType"] = self.alarmEventType!
            }
            if self.alarmUniqueInfo != nil {
                map["AlarmUniqueInfo"] = self.alarmUniqueInfo!
            }
            if self.eventCount != nil {
                map["EventCount"] = self.eventCount!
            }
            if self.firstTime != nil {
                map["FirstTime"] = self.firstTime!
            }
            if self.lastTime != nil {
                map["LastTime"] = self.lastTime!
            }
            if self.mergeFieldList != nil {
                var tmp : [Any] = []
                for k in self.mergeFieldList! {
                    tmp.append(k.toMap())
                }
                map["MergeFieldList"] = tmp
            }
            if self.operateStatus != nil {
                map["OperateStatus"] = self.operateStatus!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmEventId") && dict["AlarmEventId"] != nil {
                self.alarmEventId = dict["AlarmEventId"] as! Int64
            }
            if dict.keys.contains("AlarmEventName") && dict["AlarmEventName"] != nil {
                self.alarmEventName = dict["AlarmEventName"] as! String
            }
            if dict.keys.contains("AlarmEventType") && dict["AlarmEventType"] != nil {
                self.alarmEventType = dict["AlarmEventType"] as! String
            }
            if dict.keys.contains("AlarmUniqueInfo") && dict["AlarmUniqueInfo"] != nil {
                self.alarmUniqueInfo = dict["AlarmUniqueInfo"] as! String
            }
            if dict.keys.contains("EventCount") && dict["EventCount"] != nil {
                self.eventCount = dict["EventCount"] as! Int32
            }
            if dict.keys.contains("FirstTime") && dict["FirstTime"] != nil {
                self.firstTime = dict["FirstTime"] as! Int64
            }
            if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
                self.lastTime = dict["LastTime"] as! Int64
            }
            if dict.keys.contains("MergeFieldList") && dict["MergeFieldList"] != nil {
                var tmp : [ListHoneypotAlarmEventsResponseBody.HoneypotAlarmEvents.MergeFieldList] = []
                for v in dict["MergeFieldList"] as! [Any] {
                    var model = ListHoneypotAlarmEventsResponseBody.HoneypotAlarmEvents.MergeFieldList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mergeFieldList = tmp
            }
            if dict.keys.contains("OperateStatus") && dict["OperateStatus"] != nil {
                self.operateStatus = dict["OperateStatus"] as! Int32
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var honeypotAlarmEvents: [ListHoneypotAlarmEventsResponseBody.HoneypotAlarmEvents]?

    public var pageInfo: ListHoneypotAlarmEventsResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeypotAlarmEvents != nil {
            var tmp : [Any] = []
            for k in self.honeypotAlarmEvents! {
                tmp.append(k.toMap())
            }
            map["HoneypotAlarmEvents"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneypotAlarmEvents") && dict["HoneypotAlarmEvents"] != nil {
            var tmp : [ListHoneypotAlarmEventsResponseBody.HoneypotAlarmEvents] = []
            for v in dict["HoneypotAlarmEvents"] as! [Any] {
                var model = ListHoneypotAlarmEventsResponseBody.HoneypotAlarmEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.honeypotAlarmEvents = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListHoneypotAlarmEventsResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListHoneypotAlarmEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHoneypotAlarmEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHoneypotAlarmEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHoneypotAttackerPortraitRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var endTimeStamp: Int64?

    public var lang: String?

    public var pageSize: Int32?

    public var srcIp: String?

    public var startTimeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTimeStamp != nil {
            map["EndTimeStamp"] = self.endTimeStamp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.srcIp != nil {
            map["SrcIp"] = self.srcIp!
        }
        if self.startTimeStamp != nil {
            map["StartTimeStamp"] = self.startTimeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTimeStamp") && dict["EndTimeStamp"] != nil {
            self.endTimeStamp = dict["EndTimeStamp"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SrcIp") && dict["SrcIp"] != nil {
            self.srcIp = dict["SrcIp"] as! String
        }
        if dict.keys.contains("StartTimeStamp") && dict["StartTimeStamp"] != nil {
            self.startTimeStamp = dict["StartTimeStamp"] as! Int64
        }
    }
}

public class ListHoneypotAttackerPortraitResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public class Network : Tea.TeaModel {
            public var externalIp: [String]?

            public var internalIp: [String]?

            public var realIp: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.externalIp != nil {
                    map["ExternalIp"] = self.externalIp!
                }
                if self.internalIp != nil {
                    map["InternalIp"] = self.internalIp!
                }
                if self.realIp != nil {
                    map["RealIp"] = self.realIp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExternalIp") && dict["ExternalIp"] != nil {
                    self.externalIp = dict["ExternalIp"] as! [String]
                }
                if dict.keys.contains("InternalIp") && dict["InternalIp"] != nil {
                    self.internalIp = dict["InternalIp"] as! [String]
                }
                if dict.keys.contains("RealIp") && dict["RealIp"] != nil {
                    self.realIp = dict["RealIp"] as! [String]
                }
            }
        }
        public var attackCount: Int32?

        public var browser: [String]?

        public var host: [String]?

        public var lastTime: Int64?

        public var network: ListHoneypotAttackerPortraitResponseBody.List.Network?

        public var portraitId: String?

        public var social: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.network?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attackCount != nil {
                map["AttackCount"] = self.attackCount!
            }
            if self.browser != nil {
                map["Browser"] = self.browser!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.lastTime != nil {
                map["LastTime"] = self.lastTime!
            }
            if self.network != nil {
                map["Network"] = self.network?.toMap()
            }
            if self.portraitId != nil {
                map["PortraitId"] = self.portraitId!
            }
            if self.social != nil {
                map["Social"] = self.social!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttackCount") && dict["AttackCount"] != nil {
                self.attackCount = dict["AttackCount"] as! Int32
            }
            if dict.keys.contains("Browser") && dict["Browser"] != nil {
                self.browser = dict["Browser"] as! [String]
            }
            if dict.keys.contains("Host") && dict["Host"] != nil {
                self.host = dict["Host"] as! [String]
            }
            if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
                self.lastTime = dict["LastTime"] as! Int64
            }
            if dict.keys.contains("Network") && dict["Network"] != nil {
                var model = ListHoneypotAttackerPortraitResponseBody.List.Network()
                model.fromMap(dict["Network"] as! [String: Any])
                self.network = model
            }
            if dict.keys.contains("PortraitId") && dict["PortraitId"] != nil {
                self.portraitId = dict["PortraitId"] as! String
            }
            if dict.keys.contains("Social") && dict["Social"] != nil {
                self.social = dict["Social"] as! [String]
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var list: [ListHoneypotAttackerPortraitResponseBody.List]?

    public var message: String?

    public var pageInfo: ListHoneypotAttackerPortraitResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListHoneypotAttackerPortraitResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListHoneypotAttackerPortraitResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListHoneypotAttackerPortraitResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListHoneypotAttackerPortraitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHoneypotAttackerPortraitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHoneypotAttackerPortraitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHoneypotAttackerSourceRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var endTimeStamp: Int64?

    public var lang: String?

    public var pageSize: Int32?

    public var riskLevelList: [String]?

    public var srcIp: String?

    public var startTimeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTimeStamp != nil {
            map["EndTimeStamp"] = self.endTimeStamp!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.riskLevelList != nil {
            map["RiskLevelList"] = self.riskLevelList!
        }
        if self.srcIp != nil {
            map["SrcIp"] = self.srcIp!
        }
        if self.startTimeStamp != nil {
            map["StartTimeStamp"] = self.startTimeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTimeStamp") && dict["EndTimeStamp"] != nil {
            self.endTimeStamp = dict["EndTimeStamp"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RiskLevelList") && dict["RiskLevelList"] != nil {
            self.riskLevelList = dict["RiskLevelList"] as! [String]
        }
        if dict.keys.contains("SrcIp") && dict["SrcIp"] != nil {
            self.srcIp = dict["SrcIp"] as! String
        }
        if dict.keys.contains("StartTimeStamp") && dict["StartTimeStamp"] != nil {
            self.startTimeStamp = dict["StartTimeStamp"] as! Int64
        }
    }
}

public class ListHoneypotAttackerSourceResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var eventCount: Int32?

        public var lastTargetHoneypot: String?

        public var lastTargetIp: String?

        public var lastTime: Int64?

        public var riskLevel: String?

        public var srcIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventCount != nil {
                map["EventCount"] = self.eventCount!
            }
            if self.lastTargetHoneypot != nil {
                map["LastTargetHoneypot"] = self.lastTargetHoneypot!
            }
            if self.lastTargetIp != nil {
                map["LastTargetIp"] = self.lastTargetIp!
            }
            if self.lastTime != nil {
                map["LastTime"] = self.lastTime!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.srcIp != nil {
                map["SrcIp"] = self.srcIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventCount") && dict["EventCount"] != nil {
                self.eventCount = dict["EventCount"] as! Int32
            }
            if dict.keys.contains("LastTargetHoneypot") && dict["LastTargetHoneypot"] != nil {
                self.lastTargetHoneypot = dict["LastTargetHoneypot"] as! String
            }
            if dict.keys.contains("LastTargetIp") && dict["LastTargetIp"] != nil {
                self.lastTargetIp = dict["LastTargetIp"] as! String
            }
            if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
                self.lastTime = dict["LastTime"] as! Int64
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("SrcIp") && dict["SrcIp"] != nil {
                self.srcIp = dict["SrcIp"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var list: [ListHoneypotAttackerSourceResponseBody.List]?

    public var message: String?

    public var pageInfo: ListHoneypotAttackerSourceResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListHoneypotAttackerSourceResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListHoneypotAttackerSourceResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListHoneypotAttackerSourceResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListHoneypotAttackerSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHoneypotAttackerSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHoneypotAttackerSourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHoneypotEventsRequest : Tea.TeaModel {
    public var agentIdList: [String]?

    public var alarmEventId: Int64?

    public var currentPage: Int32?

    public var dealed: String?

    public var honeypotIdList: [String]?

    public var lang: String?

    public var pageSize: Int32?

    public var portraitId: String?

    public var requestId: String?

    public var riskLevelList: [String]?

    public var srcIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentIdList != nil {
            map["AgentIdList"] = self.agentIdList!
        }
        if self.alarmEventId != nil {
            map["AlarmEventId"] = self.alarmEventId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.dealed != nil {
            map["Dealed"] = self.dealed!
        }
        if self.honeypotIdList != nil {
            map["HoneypotIdList"] = self.honeypotIdList!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.portraitId != nil {
            map["PortraitId"] = self.portraitId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.riskLevelList != nil {
            map["RiskLevelList"] = self.riskLevelList!
        }
        if self.srcIp != nil {
            map["SrcIp"] = self.srcIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentIdList") && dict["AgentIdList"] != nil {
            self.agentIdList = dict["AgentIdList"] as! [String]
        }
        if dict.keys.contains("AlarmEventId") && dict["AlarmEventId"] != nil {
            self.alarmEventId = dict["AlarmEventId"] as! Int64
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Dealed") && dict["Dealed"] != nil {
            self.dealed = dict["Dealed"] as! String
        }
        if dict.keys.contains("HoneypotIdList") && dict["HoneypotIdList"] != nil {
            self.honeypotIdList = dict["HoneypotIdList"] as! [String]
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PortraitId") && dict["PortraitId"] != nil {
            self.portraitId = dict["PortraitId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RiskLevelList") && dict["RiskLevelList"] != nil {
            self.riskLevelList = dict["RiskLevelList"] as! [String]
        }
        if dict.keys.contains("SrcIp") && dict["SrcIp"] != nil {
            self.srcIp = dict["SrcIp"] as! String
        }
    }
}

public class ListHoneypotEventsResponseBody : Tea.TeaModel {
    public class HoneypotEvents : Tea.TeaModel {
        public class MergeFieldList : Tea.TeaModel {
            public var fieldExtInfo: String?

            public var fieldKey: String?

            public var fieldType: String?

            public var fieldValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldExtInfo != nil {
                    map["FieldExtInfo"] = self.fieldExtInfo!
                }
                if self.fieldKey != nil {
                    map["FieldKey"] = self.fieldKey!
                }
                if self.fieldType != nil {
                    map["FieldType"] = self.fieldType!
                }
                if self.fieldValue != nil {
                    map["FieldValue"] = self.fieldValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FieldExtInfo") && dict["FieldExtInfo"] != nil {
                    self.fieldExtInfo = dict["FieldExtInfo"] as! String
                }
                if dict.keys.contains("FieldKey") && dict["FieldKey"] != nil {
                    self.fieldKey = dict["FieldKey"] as! String
                }
                if dict.keys.contains("FieldType") && dict["FieldType"] != nil {
                    self.fieldType = dict["FieldType"] as! String
                }
                if dict.keys.contains("FieldValue") && dict["FieldValue"] != nil {
                    self.fieldValue = dict["FieldValue"] as! String
                }
            }
        }
        public var agentId: String?

        public var agentName: String?

        public var alarmEventId: Int64?

        public var dstIp: String?

        public var firstTime: Int64?

        public var honeypotName: String?

        public var lastTime: Int64?

        public var location: String?

        public var mergeFieldList: [ListHoneypotEventsResponseBody.HoneypotEvents.MergeFieldList]?

        public var protocol_: String?

        public var riskLevel: String?

        public var securityEventId: Int64?

        public var srcIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentId != nil {
                map["AgentId"] = self.agentId!
            }
            if self.agentName != nil {
                map["AgentName"] = self.agentName!
            }
            if self.alarmEventId != nil {
                map["AlarmEventId"] = self.alarmEventId!
            }
            if self.dstIp != nil {
                map["DstIp"] = self.dstIp!
            }
            if self.firstTime != nil {
                map["FirstTime"] = self.firstTime!
            }
            if self.honeypotName != nil {
                map["HoneypotName"] = self.honeypotName!
            }
            if self.lastTime != nil {
                map["LastTime"] = self.lastTime!
            }
            if self.location != nil {
                map["Location"] = self.location!
            }
            if self.mergeFieldList != nil {
                var tmp : [Any] = []
                for k in self.mergeFieldList! {
                    tmp.append(k.toMap())
                }
                map["MergeFieldList"] = tmp
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.securityEventId != nil {
                map["SecurityEventId"] = self.securityEventId!
            }
            if self.srcIp != nil {
                map["SrcIp"] = self.srcIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
                self.agentId = dict["AgentId"] as! String
            }
            if dict.keys.contains("AgentName") && dict["AgentName"] != nil {
                self.agentName = dict["AgentName"] as! String
            }
            if dict.keys.contains("AlarmEventId") && dict["AlarmEventId"] != nil {
                self.alarmEventId = dict["AlarmEventId"] as! Int64
            }
            if dict.keys.contains("DstIp") && dict["DstIp"] != nil {
                self.dstIp = dict["DstIp"] as! String
            }
            if dict.keys.contains("FirstTime") && dict["FirstTime"] != nil {
                self.firstTime = dict["FirstTime"] as! Int64
            }
            if dict.keys.contains("HoneypotName") && dict["HoneypotName"] != nil {
                self.honeypotName = dict["HoneypotName"] as! String
            }
            if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
                self.lastTime = dict["LastTime"] as! Int64
            }
            if dict.keys.contains("Location") && dict["Location"] != nil {
                self.location = dict["Location"] as! String
            }
            if dict.keys.contains("MergeFieldList") && dict["MergeFieldList"] != nil {
                var tmp : [ListHoneypotEventsResponseBody.HoneypotEvents.MergeFieldList] = []
                for v in dict["MergeFieldList"] as! [Any] {
                    var model = ListHoneypotEventsResponseBody.HoneypotEvents.MergeFieldList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mergeFieldList = tmp
            }
            if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! String
            }
            if dict.keys.contains("SecurityEventId") && dict["SecurityEventId"] != nil {
                self.securityEventId = dict["SecurityEventId"] as! Int64
            }
            if dict.keys.contains("SrcIp") && dict["SrcIp"] != nil {
                self.srcIp = dict["SrcIp"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var lastRowKey: String?

        public var nextToken: String?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.lastRowKey != nil {
                map["LastRowKey"] = self.lastRowKey!
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("LastRowKey") && dict["LastRowKey"] != nil {
                self.lastRowKey = dict["LastRowKey"] as! String
            }
            if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var honeypotEvents: [ListHoneypotEventsResponseBody.HoneypotEvents]?

    public var pageInfo: ListHoneypotEventsResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeypotEvents != nil {
            var tmp : [Any] = []
            for k in self.honeypotEvents! {
                tmp.append(k.toMap())
            }
            map["HoneypotEvents"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneypotEvents") && dict["HoneypotEvents"] != nil {
            var tmp : [ListHoneypotEventsResponseBody.HoneypotEvents] = []
            for v in dict["HoneypotEvents"] as! [Any] {
                var model = ListHoneypotEventsResponseBody.HoneypotEvents()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.honeypotEvents = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListHoneypotEventsResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListHoneypotEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHoneypotEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHoneypotEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHoneypotNodeRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var nodeId: String?

    public var nodeName: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListHoneypotNodeResponseBody : Tea.TeaModel {
    public class HoneypotNodeList : Tea.TeaModel {
        public var allowHoneypotAccessInternet: Bool?

        public var createTime: String?

        public var defaultNode: Bool?

        public var ecsInstanceId: String?

        public var honeypotTotalCount: Int32?

        public var honeypotUsedCount: Int32?

        public var nodeId: String?

        public var nodeIp: String?

        public var nodeName: String?

        public var probeTotalCount: Int32?

        public var probeUsedCount: Int32?

        public var securityGroupProbeIpList: [String]?

        public var totalStatus: Int32?

        public var upgradeAvailable: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowHoneypotAccessInternet != nil {
                map["AllowHoneypotAccessInternet"] = self.allowHoneypotAccessInternet!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.defaultNode != nil {
                map["DefaultNode"] = self.defaultNode!
            }
            if self.ecsInstanceId != nil {
                map["EcsInstanceId"] = self.ecsInstanceId!
            }
            if self.honeypotTotalCount != nil {
                map["HoneypotTotalCount"] = self.honeypotTotalCount!
            }
            if self.honeypotUsedCount != nil {
                map["HoneypotUsedCount"] = self.honeypotUsedCount!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeIp != nil {
                map["NodeIp"] = self.nodeIp!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.probeTotalCount != nil {
                map["ProbeTotalCount"] = self.probeTotalCount!
            }
            if self.probeUsedCount != nil {
                map["ProbeUsedCount"] = self.probeUsedCount!
            }
            if self.securityGroupProbeIpList != nil {
                map["SecurityGroupProbeIpList"] = self.securityGroupProbeIpList!
            }
            if self.totalStatus != nil {
                map["TotalStatus"] = self.totalStatus!
            }
            if self.upgradeAvailable != nil {
                map["UpgradeAvailable"] = self.upgradeAvailable!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowHoneypotAccessInternet") && dict["AllowHoneypotAccessInternet"] != nil {
                self.allowHoneypotAccessInternet = dict["AllowHoneypotAccessInternet"] as! Bool
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DefaultNode") && dict["DefaultNode"] != nil {
                self.defaultNode = dict["DefaultNode"] as! Bool
            }
            if dict.keys.contains("EcsInstanceId") && dict["EcsInstanceId"] != nil {
                self.ecsInstanceId = dict["EcsInstanceId"] as! String
            }
            if dict.keys.contains("HoneypotTotalCount") && dict["HoneypotTotalCount"] != nil {
                self.honeypotTotalCount = dict["HoneypotTotalCount"] as! Int32
            }
            if dict.keys.contains("HoneypotUsedCount") && dict["HoneypotUsedCount"] != nil {
                self.honeypotUsedCount = dict["HoneypotUsedCount"] as! Int32
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("NodeIp") && dict["NodeIp"] != nil {
                self.nodeIp = dict["NodeIp"] as! String
            }
            if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("ProbeTotalCount") && dict["ProbeTotalCount"] != nil {
                self.probeTotalCount = dict["ProbeTotalCount"] as! Int32
            }
            if dict.keys.contains("ProbeUsedCount") && dict["ProbeUsedCount"] != nil {
                self.probeUsedCount = dict["ProbeUsedCount"] as! Int32
            }
            if dict.keys.contains("SecurityGroupProbeIpList") && dict["SecurityGroupProbeIpList"] != nil {
                self.securityGroupProbeIpList = dict["SecurityGroupProbeIpList"] as! [String]
            }
            if dict.keys.contains("TotalStatus") && dict["TotalStatus"] != nil {
                self.totalStatus = dict["TotalStatus"] as! Int32
            }
            if dict.keys.contains("UpgradeAvailable") && dict["UpgradeAvailable"] != nil {
                self.upgradeAvailable = dict["UpgradeAvailable"] as! Bool
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var honeypotNodeList: [ListHoneypotNodeResponseBody.HoneypotNodeList]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pageInfo: ListHoneypotNodeResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.honeypotNodeList != nil {
            var tmp : [Any] = []
            for k in self.honeypotNodeList! {
                tmp.append(k.toMap())
            }
            map["HoneypotNodeList"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HoneypotNodeList") && dict["HoneypotNodeList"] != nil {
            var tmp : [ListHoneypotNodeResponseBody.HoneypotNodeList] = []
            for v in dict["HoneypotNodeList"] as! [Any] {
                var model = ListHoneypotNodeResponseBody.HoneypotNodeList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.honeypotNodeList = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListHoneypotNodeResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListHoneypotNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHoneypotNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHoneypotNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHoneypotPresetRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var honeypotImageName: String?

    public var lang: String?

    public var nodeId: String?

    public var nodeName: String?

    public var pageSize: Int32?

    public var presetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.honeypotImageName != nil {
            map["HoneypotImageName"] = self.honeypotImageName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.presetName != nil {
            map["PresetName"] = self.presetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("HoneypotImageName") && dict["HoneypotImageName"] != nil {
            self.honeypotImageName = dict["HoneypotImageName"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PresetName") && dict["PresetName"] != nil {
            self.presetName = dict["PresetName"] as! String
        }
    }
}

public class ListHoneypotPresetResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var controlNodeName: String?

        public var honeypotImageDisplayName: String?

        public var honeypotImageName: String?

        public var honeypotPresetId: String?

        public var nodeId: String?

        public var presetName: String?

        public var presetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.controlNodeName != nil {
                map["ControlNodeName"] = self.controlNodeName!
            }
            if self.honeypotImageDisplayName != nil {
                map["HoneypotImageDisplayName"] = self.honeypotImageDisplayName!
            }
            if self.honeypotImageName != nil {
                map["HoneypotImageName"] = self.honeypotImageName!
            }
            if self.honeypotPresetId != nil {
                map["HoneypotPresetId"] = self.honeypotPresetId!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.presetName != nil {
                map["PresetName"] = self.presetName!
            }
            if self.presetType != nil {
                map["PresetType"] = self.presetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ControlNodeName") && dict["ControlNodeName"] != nil {
                self.controlNodeName = dict["ControlNodeName"] as! String
            }
            if dict.keys.contains("HoneypotImageDisplayName") && dict["HoneypotImageDisplayName"] != nil {
                self.honeypotImageDisplayName = dict["HoneypotImageDisplayName"] as! String
            }
            if dict.keys.contains("HoneypotImageName") && dict["HoneypotImageName"] != nil {
                self.honeypotImageName = dict["HoneypotImageName"] as! String
            }
            if dict.keys.contains("HoneypotPresetId") && dict["HoneypotPresetId"] != nil {
                self.honeypotPresetId = dict["HoneypotPresetId"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PresetName") && dict["PresetName"] != nil {
                self.presetName = dict["PresetName"] as! String
            }
            if dict.keys.contains("PresetType") && dict["PresetType"] != nil {
                self.presetType = dict["PresetType"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var list: [ListHoneypotPresetResponseBody.List]?

    public var message: String?

    public var pageInfo: ListHoneypotPresetResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListHoneypotPresetResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListHoneypotPresetResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListHoneypotPresetResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListHoneypotPresetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHoneypotPresetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHoneypotPresetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHoneypotProbeRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var displayName: String?

    public var lang: String?

    public var pageSize: Int32?

    public var probeStatus: String?

    public var probeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.probeStatus != nil {
            map["ProbeStatus"] = self.probeStatus!
        }
        if self.probeType != nil {
            map["ProbeType"] = self.probeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProbeStatus") && dict["ProbeStatus"] != nil {
            self.probeStatus = dict["ProbeStatus"] as! String
        }
        if dict.keys.contains("ProbeType") && dict["ProbeType"] != nil {
            self.probeType = dict["ProbeType"] as! String
        }
    }
}

public class ListHoneypotProbeResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public class ControlNode : Tea.TeaModel {
            public var ecsInstanceId: String?

            public var nodeId: String?

            public var nodeName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ecsInstanceId != nil {
                    map["EcsInstanceId"] = self.ecsInstanceId!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EcsInstanceId") && dict["EcsInstanceId"] != nil {
                    self.ecsInstanceId = dict["EcsInstanceId"] as! String
                }
                if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                    self.nodeName = dict["NodeName"] as! String
                }
            }
        }
        public var controlNode: ListHoneypotProbeResponseBody.List.ControlNode?

        public var deployTime: Int64?

        public var displayName: String?

        public var hostIp: String?

        public var osType: String?

        public var probeId: String?

        public var probeType: String?

        public var probeVersion: String?

        public var status: String?

        public var uuid: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.controlNode?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.controlNode != nil {
                map["ControlNode"] = self.controlNode?.toMap()
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.hostIp != nil {
                map["HostIp"] = self.hostIp!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.probeId != nil {
                map["ProbeId"] = self.probeId!
            }
            if self.probeType != nil {
                map["ProbeType"] = self.probeType!
            }
            if self.probeVersion != nil {
                map["ProbeVersion"] = self.probeVersion!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ControlNode") && dict["ControlNode"] != nil {
                var model = ListHoneypotProbeResponseBody.List.ControlNode()
                model.fromMap(dict["ControlNode"] as! [String: Any])
                self.controlNode = model
            }
            if dict.keys.contains("DeployTime") && dict["DeployTime"] != nil {
                self.deployTime = dict["DeployTime"] as! Int64
            }
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("HostIp") && dict["HostIp"] != nil {
                self.hostIp = dict["HostIp"] as! String
            }
            if dict.keys.contains("OsType") && dict["OsType"] != nil {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("ProbeId") && dict["ProbeId"] != nil {
                self.probeId = dict["ProbeId"] as! String
            }
            if dict.keys.contains("ProbeType") && dict["ProbeType"] != nil {
                self.probeType = dict["ProbeType"] as! String
            }
            if dict.keys.contains("ProbeVersion") && dict["ProbeVersion"] != nil {
                self.probeVersion = dict["ProbeVersion"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var list: [ListHoneypotProbeResponseBody.List]?

    public var message: String?

    public var pageInfo: ListHoneypotProbeResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListHoneypotProbeResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListHoneypotProbeResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListHoneypotProbeResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListHoneypotProbeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHoneypotProbeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHoneypotProbeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHoneypotProbeUuidRequest : Tea.TeaModel {
    public var controlNodeId: String?

    public var lang: String?

    public var probeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.controlNodeId != nil {
            map["ControlNodeId"] = self.controlNodeId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.probeType != nil {
            map["ProbeType"] = self.probeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ControlNodeId") && dict["ControlNodeId"] != nil {
            self.controlNodeId = dict["ControlNodeId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ProbeType") && dict["ProbeType"] != nil {
            self.probeType = dict["ProbeType"] as! String
        }
    }
}

public class ListHoneypotProbeUuidResponseBody : Tea.TeaModel {
    public var code: String?

    public var count: Int32?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListHoneypotProbeUuidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHoneypotProbeUuidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHoneypotProbeUuidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListImageRegistryRegionResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var regionId: String?

        public var regionName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegionName") && dict["RegionName"] != nil {
                self.regionName = dict["RegionName"] as! String
            }
        }
    }
    public var regions: [ListImageRegistryRegionResponseBody.Regions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            var tmp : [Any] = []
            for k in self.regions! {
                tmp.append(k.toMap())
            }
            map["Regions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Regions") && dict["Regions"] != nil {
            var tmp : [ListImageRegistryRegionResponseBody.Regions] = []
            for v in dict["Regions"] as! [Any] {
                var model = ListImageRegistryRegionResponseBody.Regions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.regions = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListImageRegistryRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListImageRegistryRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListImageRegistryRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListImageRiskRequest : Tea.TeaModel {
    public var appName: String?

    public var clusterId: String?

    public var currentPage: Int32?

    public var imageName: String?

    public var namespace: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ImageName") && dict["ImageName"] != nil {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListImageRiskResponseBody : Tea.TeaModel {
    public class ImageRiskList : Tea.TeaModel {
        public class EndPointList : Tea.TeaModel {
            public var domains: [String]?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domains != nil {
                    map["Domains"] = self.domains!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Domains") && dict["Domains"] != nil {
                    self.domains = dict["Domains"] as! [String]
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var digest: String?

        public var endPointList: [ListImageRiskResponseBody.ImageRiskList.EndPointList]?

        public var endpoints: String?

        public var image: String?

        public var imageAccessType: String?

        public var imageId: String?

        public var internetURLs: String?

        public var regionId: String?

        public var registryType: String?

        public var repoId: String?

        public var repoName: String?

        public var repoNamespace: String?

        public var repoType: String?

        public var statistics: String?

        public var tag: String?

        public var tagImmutable: Int32?

        public var uuid: String?

        public var vpcURLs: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.digest != nil {
                map["Digest"] = self.digest!
            }
            if self.endPointList != nil {
                var tmp : [Any] = []
                for k in self.endPointList! {
                    tmp.append(k.toMap())
                }
                map["EndPointList"] = tmp
            }
            if self.endpoints != nil {
                map["Endpoints"] = self.endpoints!
            }
            if self.image != nil {
                map["Image"] = self.image!
            }
            if self.imageAccessType != nil {
                map["ImageAccessType"] = self.imageAccessType!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.internetURLs != nil {
                map["InternetURLs"] = self.internetURLs!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.repoId != nil {
                map["RepoId"] = self.repoId!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            if self.repoType != nil {
                map["RepoType"] = self.repoType!
            }
            if self.statistics != nil {
                map["Statistics"] = self.statistics!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            if self.tagImmutable != nil {
                map["TagImmutable"] = self.tagImmutable!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vpcURLs != nil {
                map["VpcURLs"] = self.vpcURLs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Digest") && dict["Digest"] != nil {
                self.digest = dict["Digest"] as! String
            }
            if dict.keys.contains("EndPointList") && dict["EndPointList"] != nil {
                var tmp : [ListImageRiskResponseBody.ImageRiskList.EndPointList] = []
                for v in dict["EndPointList"] as! [Any] {
                    var model = ListImageRiskResponseBody.ImageRiskList.EndPointList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endPointList = tmp
            }
            if dict.keys.contains("Endpoints") && dict["Endpoints"] != nil {
                self.endpoints = dict["Endpoints"] as! String
            }
            if dict.keys.contains("Image") && dict["Image"] != nil {
                self.image = dict["Image"] as! String
            }
            if dict.keys.contains("ImageAccessType") && dict["ImageAccessType"] != nil {
                self.imageAccessType = dict["ImageAccessType"] as! String
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("InternetURLs") && dict["InternetURLs"] != nil {
                self.internetURLs = dict["InternetURLs"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("RepoId") && dict["RepoId"] != nil {
                self.repoId = dict["RepoId"] as! String
            }
            if dict.keys.contains("RepoName") && dict["RepoName"] != nil {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoNamespace") && dict["RepoNamespace"] != nil {
                self.repoNamespace = dict["RepoNamespace"] as! String
            }
            if dict.keys.contains("RepoType") && dict["RepoType"] != nil {
                self.repoType = dict["RepoType"] as! String
            }
            if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                self.statistics = dict["Statistics"] as! String
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                self.tag = dict["Tag"] as! String
            }
            if dict.keys.contains("TagImmutable") && dict["TagImmutable"] != nil {
                self.tagImmutable = dict["TagImmutable"] as! Int32
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VpcURLs") && dict["VpcURLs"] != nil {
                self.vpcURLs = dict["VpcURLs"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var imageRiskList: [ListImageRiskResponseBody.ImageRiskList]?

    public var pageInfo: ListImageRiskResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageRiskList != nil {
            var tmp : [Any] = []
            for k in self.imageRiskList! {
                tmp.append(k.toMap())
            }
            map["ImageRiskList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageRiskList") && dict["ImageRiskList"] != nil {
            var tmp : [ListImageRiskResponseBody.ImageRiskList] = []
            for v in dict["ImageRiskList"] as! [Any] {
                var model = ListImageRiskResponseBody.ImageRiskList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageRiskList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListImageRiskResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListImageRiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListImageRiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListImageRiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceCatalogRequest : Tea.TeaModel {
    public var lang: String?

    public var regionId: String?

    public var requirementIds: [Int64]?

    public var standardIds: [Int64]?

    public var types: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requirementIds != nil {
            map["RequirementIds"] = self.requirementIds!
        }
        if self.standardIds != nil {
            map["StandardIds"] = self.standardIds!
        }
        if self.types != nil {
            map["Types"] = self.types!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequirementIds") && dict["RequirementIds"] != nil {
            self.requirementIds = dict["RequirementIds"] as! [Int64]
        }
        if dict.keys.contains("StandardIds") && dict["StandardIds"] != nil {
            self.standardIds = dict["StandardIds"] as! [Int64]
        }
        if dict.keys.contains("Types") && dict["Types"] != nil {
            self.types = dict["Types"] as! [String]
        }
    }
}

public class ListInstanceCatalogResponseBody : Tea.TeaModel {
    public class Vendors : Tea.TeaModel {
        public class InstanceTypes : Tea.TeaModel {
            public class InstanceSubTypes : Tea.TeaModel {
                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var instanceSubTypes: [ListInstanceCatalogResponseBody.Vendors.InstanceTypes.InstanceSubTypes]?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceSubTypes != nil {
                    var tmp : [Any] = []
                    for k in self.instanceSubTypes! {
                        tmp.append(k.toMap())
                    }
                    map["InstanceSubTypes"] = tmp
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceSubTypes") && dict["InstanceSubTypes"] != nil {
                    var tmp : [ListInstanceCatalogResponseBody.Vendors.InstanceTypes.InstanceSubTypes] = []
                    for v in dict["InstanceSubTypes"] as! [Any] {
                        var model = ListInstanceCatalogResponseBody.Vendors.InstanceTypes.InstanceSubTypes()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.instanceSubTypes = tmp
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var instanceTypes: [ListInstanceCatalogResponseBody.Vendors.InstanceTypes]?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceTypes != nil {
                var tmp : [Any] = []
                for k in self.instanceTypes! {
                    tmp.append(k.toMap())
                }
                map["InstanceTypes"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceTypes") && dict["InstanceTypes"] != nil {
                var tmp : [ListInstanceCatalogResponseBody.Vendors.InstanceTypes] = []
                for v in dict["InstanceTypes"] as! [Any] {
                    var model = ListInstanceCatalogResponseBody.Vendors.InstanceTypes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceTypes = tmp
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var requestId: String?

    public var vendors: [ListInstanceCatalogResponseBody.Vendors]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vendors != nil {
            var tmp : [Any] = []
            for k in self.vendors! {
                tmp.append(k.toMap())
            }
            map["Vendors"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Vendors") && dict["Vendors"] != nil {
            var tmp : [ListInstanceCatalogResponseBody.Vendors] = []
            for v in dict["Vendors"] as! [Any] {
                var model = ListInstanceCatalogResponseBody.Vendors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vendors = tmp
        }
    }
}

public class ListInstanceCatalogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceCatalogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListInstanceCatalogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInterceptionHistoryRequest : Tea.TeaModel {
    public var clusterId: String?

    public var currentPage: Int32?

    public var endTime: Int64?

    public var historyName: String?

    public var interceptionTypes: [Int32]?

    public var lang: String?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.historyName != nil {
            map["HistoryName"] = self.historyName!
        }
        if self.interceptionTypes != nil {
            map["InterceptionTypes"] = self.interceptionTypes!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("HistoryName") && dict["HistoryName"] != nil {
            self.historyName = dict["HistoryName"] as! String
        }
        if dict.keys.contains("InterceptionTypes") && dict["InterceptionTypes"] != nil {
            self.interceptionTypes = dict["InterceptionTypes"] as! [Int32]
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListInterceptionHistoryResponseBody : Tea.TeaModel {
    public class InterceptionHistoryList : Tea.TeaModel {
        public var clusterId: String?

        public var clusterName: String?

        public var dstAppName: String?

        public var dstNamespace: String?

        public var dstPort: Int64?

        public var dstRuleTargetName: String?

        public var firstTime: Int64?

        public var id: Int64?

        public var interceptionName: Int64?

        public var interceptionType: Int32?

        public var lastTime: Int64?

        public var realDstAppName: String?

        public var realDstImageName: String?

        public var realDstNamespace: String?

        public var realDstPodName: String?

        public var realInterceptionType: Int32?

        public var realSrcAppName: String?

        public var realSrcImageName: String?

        public var realSrcNamespace: String?

        public var realSrcPodName: String?

        public var riskLevel: Int64?

        public var ruleId: Int64?

        public var ruleName: String?

        public var srcAppName: String?

        public var srcNamespace: String?

        public var srcRuleTargetName: String?

        public var status: Int64?

        public var tryCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.dstAppName != nil {
                map["DstAppName"] = self.dstAppName!
            }
            if self.dstNamespace != nil {
                map["DstNamespace"] = self.dstNamespace!
            }
            if self.dstPort != nil {
                map["DstPort"] = self.dstPort!
            }
            if self.dstRuleTargetName != nil {
                map["DstRuleTargetName"] = self.dstRuleTargetName!
            }
            if self.firstTime != nil {
                map["FirstTime"] = self.firstTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.interceptionName != nil {
                map["InterceptionName"] = self.interceptionName!
            }
            if self.interceptionType != nil {
                map["InterceptionType"] = self.interceptionType!
            }
            if self.lastTime != nil {
                map["LastTime"] = self.lastTime!
            }
            if self.realDstAppName != nil {
                map["RealDstAppName"] = self.realDstAppName!
            }
            if self.realDstImageName != nil {
                map["RealDstImageName"] = self.realDstImageName!
            }
            if self.realDstNamespace != nil {
                map["RealDstNamespace"] = self.realDstNamespace!
            }
            if self.realDstPodName != nil {
                map["RealDstPodName"] = self.realDstPodName!
            }
            if self.realInterceptionType != nil {
                map["RealInterceptionType"] = self.realInterceptionType!
            }
            if self.realSrcAppName != nil {
                map["RealSrcAppName"] = self.realSrcAppName!
            }
            if self.realSrcImageName != nil {
                map["RealSrcImageName"] = self.realSrcImageName!
            }
            if self.realSrcNamespace != nil {
                map["RealSrcNamespace"] = self.realSrcNamespace!
            }
            if self.realSrcPodName != nil {
                map["RealSrcPodName"] = self.realSrcPodName!
            }
            if self.riskLevel != nil {
                map["RiskLevel"] = self.riskLevel!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.srcAppName != nil {
                map["SrcAppName"] = self.srcAppName!
            }
            if self.srcNamespace != nil {
                map["SrcNamespace"] = self.srcNamespace!
            }
            if self.srcRuleTargetName != nil {
                map["SrcRuleTargetName"] = self.srcRuleTargetName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tryCount != nil {
                map["TryCount"] = self.tryCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("DstAppName") && dict["DstAppName"] != nil {
                self.dstAppName = dict["DstAppName"] as! String
            }
            if dict.keys.contains("DstNamespace") && dict["DstNamespace"] != nil {
                self.dstNamespace = dict["DstNamespace"] as! String
            }
            if dict.keys.contains("DstPort") && dict["DstPort"] != nil {
                self.dstPort = dict["DstPort"] as! Int64
            }
            if dict.keys.contains("DstRuleTargetName") && dict["DstRuleTargetName"] != nil {
                self.dstRuleTargetName = dict["DstRuleTargetName"] as! String
            }
            if dict.keys.contains("FirstTime") && dict["FirstTime"] != nil {
                self.firstTime = dict["FirstTime"] as! Int64
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("InterceptionName") && dict["InterceptionName"] != nil {
                self.interceptionName = dict["InterceptionName"] as! Int64
            }
            if dict.keys.contains("InterceptionType") && dict["InterceptionType"] != nil {
                self.interceptionType = dict["InterceptionType"] as! Int32
            }
            if dict.keys.contains("LastTime") && dict["LastTime"] != nil {
                self.lastTime = dict["LastTime"] as! Int64
            }
            if dict.keys.contains("RealDstAppName") && dict["RealDstAppName"] != nil {
                self.realDstAppName = dict["RealDstAppName"] as! String
            }
            if dict.keys.contains("RealDstImageName") && dict["RealDstImageName"] != nil {
                self.realDstImageName = dict["RealDstImageName"] as! String
            }
            if dict.keys.contains("RealDstNamespace") && dict["RealDstNamespace"] != nil {
                self.realDstNamespace = dict["RealDstNamespace"] as! String
            }
            if dict.keys.contains("RealDstPodName") && dict["RealDstPodName"] != nil {
                self.realDstPodName = dict["RealDstPodName"] as! String
            }
            if dict.keys.contains("RealInterceptionType") && dict["RealInterceptionType"] != nil {
                self.realInterceptionType = dict["RealInterceptionType"] as! Int32
            }
            if dict.keys.contains("RealSrcAppName") && dict["RealSrcAppName"] != nil {
                self.realSrcAppName = dict["RealSrcAppName"] as! String
            }
            if dict.keys.contains("RealSrcImageName") && dict["RealSrcImageName"] != nil {
                self.realSrcImageName = dict["RealSrcImageName"] as! String
            }
            if dict.keys.contains("RealSrcNamespace") && dict["RealSrcNamespace"] != nil {
                self.realSrcNamespace = dict["RealSrcNamespace"] as! String
            }
            if dict.keys.contains("RealSrcPodName") && dict["RealSrcPodName"] != nil {
                self.realSrcPodName = dict["RealSrcPodName"] as! String
            }
            if dict.keys.contains("RiskLevel") && dict["RiskLevel"] != nil {
                self.riskLevel = dict["RiskLevel"] as! Int64
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! Int64
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("SrcAppName") && dict["SrcAppName"] != nil {
                self.srcAppName = dict["SrcAppName"] as! String
            }
            if dict.keys.contains("SrcNamespace") && dict["SrcNamespace"] != nil {
                self.srcNamespace = dict["SrcNamespace"] as! String
            }
            if dict.keys.contains("SrcRuleTargetName") && dict["SrcRuleTargetName"] != nil {
                self.srcRuleTargetName = dict["SrcRuleTargetName"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int64
            }
            if dict.keys.contains("TryCount") && dict["TryCount"] != nil {
                self.tryCount = dict["TryCount"] as! Int32
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var interceptionHistoryList: [ListInterceptionHistoryResponseBody.InterceptionHistoryList]?

    public var pageInfo: ListInterceptionHistoryResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.interceptionHistoryList != nil {
            var tmp : [Any] = []
            for k in self.interceptionHistoryList! {
                tmp.append(k.toMap())
            }
            map["InterceptionHistoryList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InterceptionHistoryList") && dict["InterceptionHistoryList"] != nil {
            var tmp : [ListInterceptionHistoryResponseBody.InterceptionHistoryList] = []
            for v in dict["InterceptionHistoryList"] as! [Any] {
                var model = ListInterceptionHistoryResponseBody.InterceptionHistoryList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.interceptionHistoryList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListInterceptionHistoryResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListInterceptionHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInterceptionHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListInterceptionHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInterceptionRulePageRequest : Tea.TeaModel {
    public var clusterId: String?

    public var criteria: String?

    public var criteriaType: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.criteriaType != nil {
            map["CriteriaType"] = self.criteriaType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("CriteriaType") && dict["CriteriaType"] != nil {
            self.criteriaType = dict["CriteriaType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListInterceptionRulePageResponseBody : Tea.TeaModel {
    public class InterceptionRuleList : Tea.TeaModel {
        public class DstTarget : Tea.TeaModel {
            public var appName: String?

            public var imageList: [String]?

            public var namespace: String?

            public var ports: [String]?

            public var ruleType: String?

            public var tagList: [String]?

            public var targetId: Int32?

            public var targetName: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.imageList != nil {
                    map["ImageList"] = self.imageList!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.ports != nil {
                    map["Ports"] = self.ports!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                if self.tagList != nil {
                    map["TagList"] = self.tagList!
                }
                if self.targetId != nil {
                    map["TargetId"] = self.targetId!
                }
                if self.targetName != nil {
                    map["TargetName"] = self.targetName!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("ImageList") && dict["ImageList"] != nil {
                    self.imageList = dict["ImageList"] as! [String]
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("Ports") && dict["Ports"] != nil {
                    self.ports = dict["Ports"] as! [String]
                }
                if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                    self.ruleType = dict["RuleType"] as! String
                }
                if dict.keys.contains("TagList") && dict["TagList"] != nil {
                    self.tagList = dict["TagList"] as! [String]
                }
                if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                    self.targetId = dict["TargetId"] as! Int32
                }
                if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                    self.targetName = dict["TargetName"] as! String
                }
                if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                    self.targetType = dict["TargetType"] as! String
                }
            }
        }
        public class SrcTarget : Tea.TeaModel {
            public var appName: String?

            public var imageList: [String]?

            public var namespace: String?

            public var ruleType: String?

            public var tagList: [String]?

            public var targetId: Int32?

            public var targetName: String?

            public var targetType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.imageList != nil {
                    map["ImageList"] = self.imageList!
                }
                if self.namespace != nil {
                    map["Namespace"] = self.namespace!
                }
                if self.ruleType != nil {
                    map["RuleType"] = self.ruleType!
                }
                if self.tagList != nil {
                    map["TagList"] = self.tagList!
                }
                if self.targetId != nil {
                    map["TargetId"] = self.targetId!
                }
                if self.targetName != nil {
                    map["TargetName"] = self.targetName!
                }
                if self.targetType != nil {
                    map["TargetType"] = self.targetType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") && dict["AppName"] != nil {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("ImageList") && dict["ImageList"] != nil {
                    self.imageList = dict["ImageList"] as! [String]
                }
                if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                    self.namespace = dict["Namespace"] as! String
                }
                if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                    self.ruleType = dict["RuleType"] as! String
                }
                if dict.keys.contains("TagList") && dict["TagList"] != nil {
                    self.tagList = dict["TagList"] as! [String]
                }
                if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                    self.targetId = dict["TargetId"] as! Int32
                }
                if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                    self.targetName = dict["TargetName"] as! String
                }
                if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                    self.targetType = dict["TargetType"] as! String
                }
            }
        }
        public var dstTarget: ListInterceptionRulePageResponseBody.InterceptionRuleList.DstTarget?

        public var interceptType: Int64?

        public var orderIndex: Int64?

        public var ruleId: Int64?

        public var ruleName: String?

        public var ruleSwitch: Int32?

        public var ruleType: String?

        public var srcTarget: ListInterceptionRulePageResponseBody.InterceptionRuleList.SrcTarget?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dstTarget?.validate()
            try self.srcTarget?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dstTarget != nil {
                map["DstTarget"] = self.dstTarget?.toMap()
            }
            if self.interceptType != nil {
                map["InterceptType"] = self.interceptType!
            }
            if self.orderIndex != nil {
                map["OrderIndex"] = self.orderIndex!
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleSwitch != nil {
                map["RuleSwitch"] = self.ruleSwitch!
            }
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            if self.srcTarget != nil {
                map["SrcTarget"] = self.srcTarget?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DstTarget") && dict["DstTarget"] != nil {
                var model = ListInterceptionRulePageResponseBody.InterceptionRuleList.DstTarget()
                model.fromMap(dict["DstTarget"] as! [String: Any])
                self.dstTarget = model
            }
            if dict.keys.contains("InterceptType") && dict["InterceptType"] != nil {
                self.interceptType = dict["InterceptType"] as! Int64
            }
            if dict.keys.contains("OrderIndex") && dict["OrderIndex"] != nil {
                self.orderIndex = dict["OrderIndex"] as! Int64
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! Int64
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("RuleSwitch") && dict["RuleSwitch"] != nil {
                self.ruleSwitch = dict["RuleSwitch"] as! Int32
            }
            if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                self.ruleType = dict["RuleType"] as! String
            }
            if dict.keys.contains("SrcTarget") && dict["SrcTarget"] != nil {
                var model = ListInterceptionRulePageResponseBody.InterceptionRuleList.SrcTarget()
                model.fromMap(dict["SrcTarget"] as! [String: Any])
                self.srcTarget = model
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var interceptionRuleList: [ListInterceptionRulePageResponseBody.InterceptionRuleList]?

    public var pageInfo: ListInterceptionRulePageResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.interceptionRuleList != nil {
            var tmp : [Any] = []
            for k in self.interceptionRuleList! {
                tmp.append(k.toMap())
            }
            map["InterceptionRuleList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InterceptionRuleList") && dict["InterceptionRuleList"] != nil {
            var tmp : [ListInterceptionRulePageResponseBody.InterceptionRuleList] = []
            for v in dict["InterceptionRuleList"] as! [Any] {
                var model = ListInterceptionRulePageResponseBody.InterceptionRuleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.interceptionRuleList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListInterceptionRulePageResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListInterceptionRulePageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInterceptionRulePageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListInterceptionRulePageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInterceptionTargetPageRequest : Tea.TeaModel {
    public var appName: String?

    public var currentPage: Int32?

    public var imageList: [String]?

    public var namespace: String?

    public var pageSize: Int32?

    public var tagList: [String]?

    public var targetName: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.imageList != nil {
            map["ImageList"] = self.imageList!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.tagList != nil {
            map["TagList"] = self.tagList!
        }
        if self.targetName != nil {
            map["TargetName"] = self.targetName!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("ImageList") && dict["ImageList"] != nil {
            self.imageList = dict["ImageList"] as! [String]
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TagList") && dict["TagList"] != nil {
            self.tagList = dict["TagList"] as! [String]
        }
        if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
            self.targetName = dict["TargetName"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class ListInterceptionTargetPageResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class RuleTargetList : Tea.TeaModel {
        public var appName: String?

        public var clusterId: String?

        public var clusterName: String?

        public var imageList: [String]?

        public var namespace: String?

        public var ruleType: String?

        public var tagList: [String]?

        public var targetId: Int64?

        public var targetName: String?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.imageList != nil {
                map["ImageList"] = self.imageList!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            if self.tagList != nil {
                map["TagList"] = self.tagList!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") && dict["AppName"] != nil {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("ImageList") && dict["ImageList"] != nil {
                self.imageList = dict["ImageList"] as! [String]
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                self.ruleType = dict["RuleType"] as! String
            }
            if dict.keys.contains("TagList") && dict["TagList"] != nil {
                self.tagList = dict["TagList"] as! [String]
            }
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! Int64
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
        }
    }
    public var pageInfo: ListInterceptionTargetPageResponseBody.PageInfo?

    public var requestId: String?

    public var ruleTargetList: [ListInterceptionTargetPageResponseBody.RuleTargetList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleTargetList != nil {
            var tmp : [Any] = []
            for k in self.ruleTargetList! {
                tmp.append(k.toMap())
            }
            map["RuleTargetList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListInterceptionTargetPageResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleTargetList") && dict["RuleTargetList"] != nil {
            var tmp : [ListInterceptionTargetPageResponseBody.RuleTargetList] = []
            for v in dict["RuleTargetList"] as! [Any] {
                var model = ListInterceptionTargetPageResponseBody.RuleTargetList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ruleTargetList = tmp
        }
    }
}

public class ListInterceptionTargetPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInterceptionTargetPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListInterceptionTargetPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPluginForUuidRequest : Tea.TeaModel {
    public var types: [String]?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.types != nil {
            map["Types"] = self.types!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Types") && dict["Types"] != nil {
            self.types = dict["Types"] as! [String]
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ListPluginForUuidShrinkRequest : Tea.TeaModel {
    public var typesShrink: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.typesShrink != nil {
            map["Types"] = self.typesShrink!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Types") && dict["Types"] != nil {
            self.typesShrink = dict["Types"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ListPluginForUuidResponseBody : Tea.TeaModel {
    public class AegisUuidTargetPluginConfigList : Tea.TeaModel {
        public class AegisSuspiciousConfigList : Tea.TeaModel {
            public var config: Bool?

            public var msg: String?

            public var overallConfig: Bool?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.config != nil {
                    map["Config"] = self.config!
                }
                if self.msg != nil {
                    map["Msg"] = self.msg!
                }
                if self.overallConfig != nil {
                    map["OverallConfig"] = self.overallConfig!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Config") && dict["Config"] != nil {
                    self.config = dict["Config"] as! Bool
                }
                if dict.keys.contains("Msg") && dict["Msg"] != nil {
                    self.msg = dict["Msg"] as! String
                }
                if dict.keys.contains("OverallConfig") && dict["OverallConfig"] != nil {
                    self.overallConfig = dict["OverallConfig"] as! Bool
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var aegisSuspiciousConfigList: [ListPluginForUuidResponseBody.AegisUuidTargetPluginConfigList.AegisSuspiciousConfigList]?

        public var pluginInstallCode: String?

        public var pluginName: String?

        public var pluginOnlineInstalled: Bool?

        public var pluginOnlineStatus: Bool?

        public var pluginVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aegisSuspiciousConfigList != nil {
                var tmp : [Any] = []
                for k in self.aegisSuspiciousConfigList! {
                    tmp.append(k.toMap())
                }
                map["AegisSuspiciousConfigList"] = tmp
            }
            if self.pluginInstallCode != nil {
                map["PluginInstallCode"] = self.pluginInstallCode!
            }
            if self.pluginName != nil {
                map["PluginName"] = self.pluginName!
            }
            if self.pluginOnlineInstalled != nil {
                map["PluginOnlineInstalled"] = self.pluginOnlineInstalled!
            }
            if self.pluginOnlineStatus != nil {
                map["PluginOnlineStatus"] = self.pluginOnlineStatus!
            }
            if self.pluginVersion != nil {
                map["PluginVersion"] = self.pluginVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AegisSuspiciousConfigList") && dict["AegisSuspiciousConfigList"] != nil {
                var tmp : [ListPluginForUuidResponseBody.AegisUuidTargetPluginConfigList.AegisSuspiciousConfigList] = []
                for v in dict["AegisSuspiciousConfigList"] as! [Any] {
                    var model = ListPluginForUuidResponseBody.AegisUuidTargetPluginConfigList.AegisSuspiciousConfigList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.aegisSuspiciousConfigList = tmp
            }
            if dict.keys.contains("PluginInstallCode") && dict["PluginInstallCode"] != nil {
                self.pluginInstallCode = dict["PluginInstallCode"] as! String
            }
            if dict.keys.contains("PluginName") && dict["PluginName"] != nil {
                self.pluginName = dict["PluginName"] as! String
            }
            if dict.keys.contains("PluginOnlineInstalled") && dict["PluginOnlineInstalled"] != nil {
                self.pluginOnlineInstalled = dict["PluginOnlineInstalled"] as! Bool
            }
            if dict.keys.contains("PluginOnlineStatus") && dict["PluginOnlineStatus"] != nil {
                self.pluginOnlineStatus = dict["PluginOnlineStatus"] as! Bool
            }
            if dict.keys.contains("PluginVersion") && dict["PluginVersion"] != nil {
                self.pluginVersion = dict["PluginVersion"] as! String
            }
        }
    }
    public var aegisUuidTargetPluginConfigList: [ListPluginForUuidResponseBody.AegisUuidTargetPluginConfigList]?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aegisUuidTargetPluginConfigList != nil {
            var tmp : [Any] = []
            for k in self.aegisUuidTargetPluginConfigList! {
                tmp.append(k.toMap())
            }
            map["AegisUuidTargetPluginConfigList"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AegisUuidTargetPluginConfigList") && dict["AegisUuidTargetPluginConfigList"] != nil {
            var tmp : [ListPluginForUuidResponseBody.AegisUuidTargetPluginConfigList] = []
            for v in dict["AegisUuidTargetPluginConfigList"] as! [Any] {
                var model = ListPluginForUuidResponseBody.AegisUuidTargetPluginConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aegisUuidTargetPluginConfigList = tmp
        }
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPluginForUuidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPluginForUuidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPluginForUuidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPodRiskRequest : Tea.TeaModel {
    public var appName: String?

    public var clusterId: String?

    public var currentPage: Int64?

    public var namespace: String?

    public var pageSize: Int64?

    public var podName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.podName != nil {
            map["PodName"] = self.podName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int64
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PodName") && dict["PodName"] != nil {
            self.podName = dict["PodName"] as! String
        }
    }
}

public class ListPodRiskResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class PodRiskList : Tea.TeaModel {
        public var alarmCount: Int32?

        public var clusterId: String?

        public var clusterName: String?

        public var createTime: Int64?

        public var hcCount: Int32?

        public var instanceId: String?

        public var namespace: String?

        public var nodeName: String?

        public var pod: String?

        public var podIp: String?

        public var vulCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alarmCount != nil {
                map["AlarmCount"] = self.alarmCount!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.clusterName != nil {
                map["ClusterName"] = self.clusterName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.hcCount != nil {
                map["HcCount"] = self.hcCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.pod != nil {
                map["Pod"] = self.pod!
            }
            if self.podIp != nil {
                map["PodIp"] = self.podIp!
            }
            if self.vulCount != nil {
                map["VulCount"] = self.vulCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlarmCount") && dict["AlarmCount"] != nil {
                self.alarmCount = dict["AlarmCount"] as! Int32
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                self.clusterName = dict["ClusterName"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("HcCount") && dict["HcCount"] != nil {
                self.hcCount = dict["HcCount"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("Pod") && dict["Pod"] != nil {
                self.pod = dict["Pod"] as! String
            }
            if dict.keys.contains("PodIp") && dict["PodIp"] != nil {
                self.podIp = dict["PodIp"] as! String
            }
            if dict.keys.contains("VulCount") && dict["VulCount"] != nil {
                self.vulCount = dict["VulCount"] as! Int32
            }
        }
    }
    public var pageInfo: ListPodRiskResponseBody.PageInfo?

    public var podRiskList: [ListPodRiskResponseBody.PodRiskList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.podRiskList != nil {
            var tmp : [Any] = []
            for k in self.podRiskList! {
                tmp.append(k.toMap())
            }
            map["PodRiskList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListPodRiskResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("PodRiskList") && dict["PodRiskList"] != nil {
            var tmp : [ListPodRiskResponseBody.PodRiskList] = []
            for v in dict["PodRiskList"] as! [Any] {
                var model = ListPodRiskResponseBody.PodRiskList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.podRiskList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPodRiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPodRiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPodRiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrivateRegistryListRequest : Tea.TeaModel {
    public var registryType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.registryType != nil {
            map["RegistryType"] = self.registryType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
            self.registryType = dict["RegistryType"] as! String
        }
    }
}

public class ListPrivateRegistryListResponseBody : Tea.TeaModel {
    public class ImageRegistryInfos : Tea.TeaModel {
        public var aliUid: Int64?

        public var domainName: String?

        public var id: Int64?

        public var jenkinsEnv: String?

        public var netType: Int64?

        public var password: String?

        public var persistenceDay: Int64?

        public var protocolType: Int64?

        public var regionId: String?

        public var registryHostIp: String?

        public var registryName: String?

        public var registryType: String?

        public var registryVersion: String?

        public var token: String?

        public var transPerHour: Int32?

        public var userName: String?

        public var vpcId: String?

        public var whiteList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.jenkinsEnv != nil {
                map["JenkinsEnv"] = self.jenkinsEnv!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.persistenceDay != nil {
                map["PersistenceDay"] = self.persistenceDay!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.registryHostIp != nil {
                map["RegistryHostIp"] = self.registryHostIp!
            }
            if self.registryName != nil {
                map["RegistryName"] = self.registryName!
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.registryVersion != nil {
                map["RegistryVersion"] = self.registryVersion!
            }
            if self.token != nil {
                map["Token"] = self.token!
            }
            if self.transPerHour != nil {
                map["TransPerHour"] = self.transPerHour!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.whiteList != nil {
                map["WhiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliUid") && dict["AliUid"] != nil {
                self.aliUid = dict["AliUid"] as! Int64
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("JenkinsEnv") && dict["JenkinsEnv"] != nil {
                self.jenkinsEnv = dict["JenkinsEnv"] as! String
            }
            if dict.keys.contains("NetType") && dict["NetType"] != nil {
                self.netType = dict["NetType"] as! Int64
            }
            if dict.keys.contains("Password") && dict["Password"] != nil {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("PersistenceDay") && dict["PersistenceDay"] != nil {
                self.persistenceDay = dict["PersistenceDay"] as! Int64
            }
            if dict.keys.contains("ProtocolType") && dict["ProtocolType"] != nil {
                self.protocolType = dict["ProtocolType"] as! Int64
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegistryHostIp") && dict["RegistryHostIp"] != nil {
                self.registryHostIp = dict["RegistryHostIp"] as! String
            }
            if dict.keys.contains("RegistryName") && dict["RegistryName"] != nil {
                self.registryName = dict["RegistryName"] as! String
            }
            if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("RegistryVersion") && dict["RegistryVersion"] != nil {
                self.registryVersion = dict["RegistryVersion"] as! String
            }
            if dict.keys.contains("Token") && dict["Token"] != nil {
                self.token = dict["Token"] as! String
            }
            if dict.keys.contains("TransPerHour") && dict["TransPerHour"] != nil {
                self.transPerHour = dict["TransPerHour"] as! Int32
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                self.whiteList = dict["WhiteList"] as! String
            }
        }
    }
    public var imageRegistryInfos: [ListPrivateRegistryListResponseBody.ImageRegistryInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageRegistryInfos != nil {
            var tmp : [Any] = []
            for k in self.imageRegistryInfos! {
                tmp.append(k.toMap())
            }
            map["ImageRegistryInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageRegistryInfos") && dict["ImageRegistryInfos"] != nil {
            var tmp : [ListPrivateRegistryListResponseBody.ImageRegistryInfos] = []
            for v in dict["ImageRegistryInfos"] as! [Any] {
                var model = ListPrivateRegistryListResponseBody.ImageRegistryInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.imageRegistryInfos = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrivateRegistryListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrivateRegistryListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPrivateRegistryListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrivateRegistryTypeRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class ListPrivateRegistryTypeResponseBody : Tea.TeaModel {
    public class RegistryTypeInfos : Tea.TeaModel {
        public var count: Int64?

        public var registryType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int64
            }
            if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                self.registryType = dict["RegistryType"] as! String
            }
        }
    }
    public var registryTypeInfos: [ListPrivateRegistryTypeResponseBody.RegistryTypeInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.registryTypeInfos != nil {
            var tmp : [Any] = []
            for k in self.registryTypeInfos! {
                tmp.append(k.toMap())
            }
            map["RegistryTypeInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegistryTypeInfos") && dict["RegistryTypeInfos"] != nil {
            var tmp : [ListPrivateRegistryTypeResponseBody.RegistryTypeInfos] = []
            for v in dict["RegistryTypeInfos"] as! [Any] {
                var model = ListPrivateRegistryTypeResponseBody.RegistryTypeInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.registryTypeInfos = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrivateRegistryTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrivateRegistryTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPrivateRegistryTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListQueryRaspAppInfoRequest : Tea.TeaModel {
    public var lang: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class ListQueryRaspAppInfoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var raspAppName: String?

        public var raspOnlineStatus: Int32?

        public var raspStatus: String?

        public var result: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.raspAppName != nil {
                map["RaspAppName"] = self.raspAppName!
            }
            if self.raspOnlineStatus != nil {
                map["RaspOnlineStatus"] = self.raspOnlineStatus!
            }
            if self.raspStatus != nil {
                map["RaspStatus"] = self.raspStatus!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RaspAppName") && dict["RaspAppName"] != nil {
                self.raspAppName = dict["RaspAppName"] as! String
            }
            if dict.keys.contains("RaspOnlineStatus") && dict["RaspOnlineStatus"] != nil {
                self.raspOnlineStatus = dict["RaspOnlineStatus"] as! Int32
            }
            if dict.keys.contains("RaspStatus") && dict["RaspStatus"] != nil {
                self.raspStatus = dict["RaspStatus"] as! String
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListQueryRaspAppInfoResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListQueryRaspAppInfoResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListQueryRaspAppInfoResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListQueryRaspAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListQueryRaspAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListQueryRaspAppInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRuleTargetAllRequest : Tea.TeaModel {
    public var clusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
    }
}

public class ListRuleTargetAllResponseBody : Tea.TeaModel {
    public class RuleTargetList : Tea.TeaModel {
        public var targetId: Int64?

        public var targetName: String?

        public var targetType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetName != nil {
                map["TargetName"] = self.targetName!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! Int64
            }
            if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
                self.targetName = dict["TargetName"] as! String
            }
            if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
                self.targetType = dict["TargetType"] as! String
            }
        }
    }
    public var requestId: String?

    public var ruleTargetList: [ListRuleTargetAllResponseBody.RuleTargetList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleTargetList != nil {
            var tmp : [Any] = []
            for k in self.ruleTargetList! {
                tmp.append(k.toMap())
            }
            map["RuleTargetList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleTargetList") && dict["RuleTargetList"] != nil {
            var tmp : [ListRuleTargetAllResponseBody.RuleTargetList] = []
            for v in dict["RuleTargetList"] as! [Any] {
                var model = ListRuleTargetAllResponseBody.RuleTargetList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ruleTargetList = tmp
        }
    }
}

public class ListRuleTargetAllResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRuleTargetAllResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRuleTargetAllResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSystemAggregationRulesRequest : Tea.TeaModel {
    public var aggregationIds: [Int32]?

    public var currentPage: Int32?

    public var lang: String?

    public var pageSize: Int32?

    public var ruleName: String?

    public var ruleTypes: [Int32]?

    public var systemType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregationIds != nil {
            map["AggregationIds"] = self.aggregationIds!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleTypes != nil {
            map["RuleTypes"] = self.ruleTypes!
        }
        if self.systemType != nil {
            map["SystemType"] = self.systemType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AggregationIds") && dict["AggregationIds"] != nil {
            self.aggregationIds = dict["AggregationIds"] as! [Int32]
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleTypes") && dict["RuleTypes"] != nil {
            self.ruleTypes = dict["RuleTypes"] as! [Int32]
        }
        if dict.keys.contains("SystemType") && dict["SystemType"] != nil {
            self.systemType = dict["SystemType"] as! Int32
        }
    }
}

public class ListSystemAggregationRulesResponseBody : Tea.TeaModel {
    public class AggregationList : Tea.TeaModel {
        public var id: Int32?

        public var name: String?

        public var ruleCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ruleCount != nil {
                map["RuleCount"] = self.ruleCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RuleCount") && dict["RuleCount"] != nil {
                self.ruleCount = dict["RuleCount"] as! Int32
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var aggregationList: [ListSystemAggregationRulesResponseBody.AggregationList]?

    public var pageInfo: ListSystemAggregationRulesResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregationList != nil {
            var tmp : [Any] = []
            for k in self.aggregationList! {
                tmp.append(k.toMap())
            }
            map["AggregationList"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AggregationList") && dict["AggregationList"] != nil {
            var tmp : [ListSystemAggregationRulesResponseBody.AggregationList] = []
            for v in dict["AggregationList"] as! [Any] {
                var model = ListSystemAggregationRulesResponseBody.AggregationList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aggregationList = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListSystemAggregationRulesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSystemAggregationRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSystemAggregationRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSystemAggregationRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSystemClientRuleTypesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var ruleTypes: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleTypes != nil {
            map["RuleTypes"] = self.ruleTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleTypes") && dict["RuleTypes"] != nil {
            self.ruleTypes = dict["RuleTypes"] as! [String]
        }
    }
}

public class ListSystemClientRuleTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSystemClientRuleTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSystemClientRuleTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSystemClientRulesRequest : Tea.TeaModel {
    public var aggregationIds: [Int32]?

    public var currentPage: Int32?

    public var isContainer: Int32?

    public var lang: String?

    public var pageSize: Int32?

    public var ruleName: String?

    public var ruleTypes: [Int32]?

    public var systemType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregationIds != nil {
            map["AggregationIds"] = self.aggregationIds!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.isContainer != nil {
            map["IsContainer"] = self.isContainer!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleTypes != nil {
            map["RuleTypes"] = self.ruleTypes!
        }
        if self.systemType != nil {
            map["SystemType"] = self.systemType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AggregationIds") && dict["AggregationIds"] != nil {
            self.aggregationIds = dict["AggregationIds"] as! [Int32]
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("IsContainer") && dict["IsContainer"] != nil {
            self.isContainer = dict["IsContainer"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleTypes") && dict["RuleTypes"] != nil {
            self.ruleTypes = dict["RuleTypes"] as! [Int32]
        }
        if dict.keys.contains("SystemType") && dict["SystemType"] != nil {
            self.systemType = dict["SystemType"] as! Int32
        }
    }
}

public class ListSystemClientRulesResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class RuleList : Tea.TeaModel {
        public class Policies : Tea.TeaModel {
            public var policyKey: String?

            public var policyName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.policyKey != nil {
                    map["PolicyKey"] = self.policyKey!
                }
                if self.policyName != nil {
                    map["PolicyName"] = self.policyName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PolicyKey") && dict["PolicyKey"] != nil {
                    self.policyKey = dict["PolicyKey"] as! String
                }
                if dict.keys.contains("PolicyName") && dict["PolicyName"] != nil {
                    self.policyName = dict["PolicyName"] as! String
                }
            }
        }
        public var aggregationName: String?

        public var description_: String?

        public var platform: String?

        public var policies: [ListSystemClientRulesResponseBody.RuleList.Policies]?

        public var ruleId: Int64?

        public var ruleName: String?

        public var ruleType: Int32?

        public var status: Int32?

        public var switchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aggregationName != nil {
                map["AggregationName"] = self.aggregationName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.platform != nil {
                map["Platform"] = self.platform!
            }
            if self.policies != nil {
                var tmp : [Any] = []
                for k in self.policies! {
                    tmp.append(k.toMap())
                }
                map["Policies"] = tmp
            }
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            if self.ruleType != nil {
                map["RuleType"] = self.ruleType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.switchId != nil {
                map["SwitchId"] = self.switchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AggregationName") && dict["AggregationName"] != nil {
                self.aggregationName = dict["AggregationName"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Platform") && dict["Platform"] != nil {
                self.platform = dict["Platform"] as! String
            }
            if dict.keys.contains("Policies") && dict["Policies"] != nil {
                var tmp : [ListSystemClientRulesResponseBody.RuleList.Policies] = []
                for v in dict["Policies"] as! [Any] {
                    var model = ListSystemClientRulesResponseBody.RuleList.Policies()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.policies = tmp
            }
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! Int64
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
            if dict.keys.contains("RuleType") && dict["RuleType"] != nil {
                self.ruleType = dict["RuleType"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("SwitchId") && dict["SwitchId"] != nil {
                self.switchId = dict["SwitchId"] as! String
            }
        }
    }
    public var pageInfo: ListSystemClientRulesResponseBody.PageInfo?

    public var requestId: String?

    public var ruleList: [ListSystemClientRulesResponseBody.RuleList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleList != nil {
            var tmp : [Any] = []
            for k in self.ruleList! {
                tmp.append(k.toMap())
            }
            map["RuleList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListSystemClientRulesResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleList") && dict["RuleList"] != nil {
            var tmp : [ListSystemClientRulesResponseBody.RuleList] = []
            for v in dict["RuleList"] as! [Any] {
                var model = ListSystemClientRulesResponseBody.RuleList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ruleList = tmp
        }
    }
}

public class ListSystemClientRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSystemClientRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSystemClientRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSystemRuleAggregationTypesRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class ListSystemRuleAggregationTypesResponseBody : Tea.TeaModel {
    public class AggregationTypeList : Tea.TeaModel {
        public var id: Int32?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var aggregationTypeList: [ListSystemRuleAggregationTypesResponseBody.AggregationTypeList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregationTypeList != nil {
            var tmp : [Any] = []
            for k in self.aggregationTypeList! {
                tmp.append(k.toMap())
            }
            map["AggregationTypeList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AggregationTypeList") && dict["AggregationTypeList"] != nil {
            var tmp : [ListSystemRuleAggregationTypesResponseBody.AggregationTypeList] = []
            for v in dict["AggregationTypeList"] as! [Any] {
                var model = ListSystemRuleAggregationTypesResponseBody.AggregationTypeList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aggregationTypeList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSystemRuleAggregationTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSystemRuleAggregationTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSystemRuleAggregationTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUninstallAegisMachinesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var os: String?

    public var pageSize: Int32?

    public var regionIdStr: String?

    public var regionNo: String?

    public var remark: String?

    public var sourceIp: String?

    public var vendor: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionIdStr != nil {
            map["RegionIdStr"] = self.regionIdStr!
        }
        if self.regionNo != nil {
            map["RegionNo"] = self.regionNo!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.vendor != nil {
            map["Vendor"] = self.vendor!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Os") && dict["Os"] != nil {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionIdStr") && dict["RegionIdStr"] != nil {
            self.regionIdStr = dict["RegionIdStr"] as! String
        }
        if dict.keys.contains("RegionNo") && dict["RegionNo"] != nil {
            self.regionNo = dict["RegionNo"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
            self.vendor = dict["Vendor"] as! Int32
        }
    }
}

public class ListUninstallAegisMachinesResponseBody : Tea.TeaModel {
    public class MachineList : Tea.TeaModel {
        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var machineRegion: String?

        public var os: String?

        public var regionId: String?

        public var uuid: String?

        public var vendor: Int32?

        public var vendorName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.machineRegion != nil {
                map["MachineRegion"] = self.machineRegion!
            }
            if self.os != nil {
                map["Os"] = self.os!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vendor != nil {
                map["Vendor"] = self.vendor!
            }
            if self.vendorName != nil {
                map["VendorName"] = self.vendorName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("MachineRegion") && dict["MachineRegion"] != nil {
                self.machineRegion = dict["MachineRegion"] as! String
            }
            if dict.keys.contains("Os") && dict["Os"] != nil {
                self.os = dict["Os"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("Vendor") && dict["Vendor"] != nil {
                self.vendor = dict["Vendor"] as! Int32
            }
            if dict.keys.contains("VendorName") && dict["VendorName"] != nil {
                self.vendorName = dict["VendorName"] as! String
            }
        }
    }
    public var currentPage: Int32?

    public var machineList: [ListUninstallAegisMachinesResponseBody.MachineList]?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.machineList != nil {
            var tmp : [Any] = []
            for k in self.machineList! {
                tmp.append(k.toMap())
            }
            map["MachineList"] = tmp
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("MachineList") && dict["MachineList"] != nil {
            var tmp : [ListUninstallAegisMachinesResponseBody.MachineList] = []
            for v in dict["MachineList"] as! [Any] {
                var model = ListUninstallAegisMachinesResponseBody.MachineList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.machineList = tmp
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListUninstallAegisMachinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUninstallAegisMachinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUninstallAegisMachinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUuidsByWebPathRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var type: String?

    public var webPath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.webPath != nil {
            map["WebPath"] = self.webPath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("WebPath") && dict["WebPath"] != nil {
            self.webPath = dict["WebPath"] as! String
        }
    }
}

public class ListUuidsByWebPathResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var internetIp: String?

        public var intranetIp: String?

        public var machineName: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.machineName != nil {
                map["MachineName"] = self.machineName!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InternetIp") && dict["InternetIp"] != nil {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") && dict["IntranetIp"] != nil {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("MachineName") && dict["MachineName"] != nil {
                self.machineName = dict["MachineName"] as! String
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var list: [ListUuidsByWebPathResponseBody.List]?

    public var pageInfo: ListUuidsByWebPathResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [ListUuidsByWebPathResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = ListUuidsByWebPathResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListUuidsByWebPathResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUuidsByWebPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUuidsByWebPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUuidsByWebPathResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVulAutoRepairConfigRequest : Tea.TeaModel {
    public var aliasName: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliasName != nil {
            map["AliasName"] = self.aliasName!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
            self.aliasName = dict["AliasName"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListVulAutoRepairConfigResponseBody : Tea.TeaModel {
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public class VulAutoRepairConfigList : Tea.TeaModel {
        public var aliasName: String?

        public var id: Int64?

        public var name: String?

        public var reason: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliasName != nil {
                map["AliasName"] = self.aliasName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliasName") && dict["AliasName"] != nil {
                self.aliasName = dict["AliasName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pageInfo: ListVulAutoRepairConfigResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public var vulAutoRepairConfigList: [ListVulAutoRepairConfigResponseBody.VulAutoRepairConfigList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.vulAutoRepairConfigList != nil {
            var tmp : [Any] = []
            for k in self.vulAutoRepairConfigList! {
                tmp.append(k.toMap())
            }
            map["VulAutoRepairConfigList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = ListVulAutoRepairConfigResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("VulAutoRepairConfigList") && dict["VulAutoRepairConfigList"] != nil {
            var tmp : [ListVulAutoRepairConfigResponseBody.VulAutoRepairConfigList] = []
            for v in dict["VulAutoRepairConfigList"] as! [Any] {
                var model = ListVulAutoRepairConfigResponseBody.VulAutoRepairConfigList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vulAutoRepairConfigList = tmp
        }
    }
}

public class ListVulAutoRepairConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVulAutoRepairConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListVulAutoRepairConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAccessKeyLeakDealRequest : Tea.TeaModel {
    public var id: Int64?

    public var idList: [Int64]?

    public var remark: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.idList != nil {
            map["IdList"] = self.idList!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("IdList") && dict["IdList"] != nil {
            self.idList = dict["IdList"] as! [Int64]
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ModifyAccessKeyLeakDealResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAccessKeyLeakDealResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAccessKeyLeakDealResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyAccessKeyLeakDealResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAntiBruteForceRuleRequest : Tea.TeaModel {
    public var defaultRule: Bool?

    public var failCount: Int32?

    public var forbiddenTime: Int32?

    public var id: Int64?

    public var name: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public var span: Int32?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultRule != nil {
            map["DefaultRule"] = self.defaultRule!
        }
        if self.failCount != nil {
            map["FailCount"] = self.failCount!
        }
        if self.forbiddenTime != nil {
            map["ForbiddenTime"] = self.forbiddenTime!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.span != nil {
            map["Span"] = self.span!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultRule") && dict["DefaultRule"] != nil {
            self.defaultRule = dict["DefaultRule"] as! Bool
        }
        if dict.keys.contains("FailCount") && dict["FailCount"] != nil {
            self.failCount = dict["FailCount"] as! Int32
        }
        if dict.keys.contains("ForbiddenTime") && dict["ForbiddenTime"] != nil {
            self.forbiddenTime = dict["ForbiddenTime"] as! Int32
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Span") && dict["Span"] != nil {
            self.span = dict["Span"] as! Int32
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class ModifyAntiBruteForceRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAntiBruteForceRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAntiBruteForceRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyAntiBruteForceRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAppVulScanCycleRequest : Tea.TeaModel {
    public var cycle: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cycle != nil {
            map["Cycle"] = self.cycle!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cycle") && dict["Cycle"] != nil {
            self.cycle = dict["Cycle"] as! String
        }
    }
}

public class ModifyAppVulScanCycleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAppVulScanCycleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAppVulScanCycleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyAppVulScanCycleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAssetCleanConfigRequest : Tea.TeaModel {
    public class AssetCleanConfigs : Tea.TeaModel {
        public var cleanDays: Int32?

        public var status: Int32?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cleanDays != nil {
                map["CleanDays"] = self.cleanDays!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CleanDays") && dict["CleanDays"] != nil {
                self.cleanDays = dict["CleanDays"] as! Int32
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var assetCleanConfigs: [ModifyAssetCleanConfigRequest.AssetCleanConfigs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetCleanConfigs != nil {
            var tmp : [Any] = []
            for k in self.assetCleanConfigs! {
                tmp.append(k.toMap())
            }
            map["AssetCleanConfigs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetCleanConfigs") && dict["AssetCleanConfigs"] != nil {
            var tmp : [ModifyAssetCleanConfigRequest.AssetCleanConfigs] = []
            for v in dict["AssetCleanConfigs"] as! [Any] {
                var model = ModifyAssetCleanConfigRequest.AssetCleanConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.assetCleanConfigs = tmp
        }
    }
}

public class ModifyAssetCleanConfigResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAssetCleanConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAssetCleanConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyAssetCleanConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAssetGroupRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var sourceIp: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class ModifyAssetGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAssetGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAssetGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyAssetGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAssetImportantRequest : Tea.TeaModel {
    public var importantCode: Int32?

    public var uuidList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.importantCode != nil {
            map["ImportantCode"] = self.importantCode!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImportantCode") && dict["ImportantCode"] != nil {
            self.importantCode = dict["ImportantCode"] as! Int32
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! String
        }
    }
}

public class ModifyAssetImportantResponseBody : Tea.TeaModel {
    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrCode") && dict["ErrCode"] != nil {
            self.errCode = dict["ErrCode"] as! String
        }
        if dict.keys.contains("ErrMessage") && dict["ErrMessage"] != nil {
            self.errMessage = dict["ErrMessage"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyAssetImportantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAssetImportantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyAssetImportantResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAutoDelConfigRequest : Tea.TeaModel {
    public var days: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.days != nil {
            map["Days"] = self.days!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Days") && dict["Days"] != nil {
            self.days = dict["Days"] as! Int32
        }
    }
}

public class ModifyAutoDelConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAutoDelConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAutoDelConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyAutoDelConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBackupPolicyRequest : Tea.TeaModel {
    public var id: Int64?

    public var name: String?

    public var policy: [String: Any]?

    public var policyRegionId: String?

    public var policyVersion: String?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.policyRegionId != nil {
            map["PolicyRegionId"] = self.policyRegionId!
        }
        if self.policyVersion != nil {
            map["PolicyVersion"] = self.policyVersion!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policy = dict["Policy"] as! [String: Any]
        }
        if dict.keys.contains("PolicyRegionId") && dict["PolicyRegionId"] != nil {
            self.policyRegionId = dict["PolicyRegionId"] as! String
        }
        if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
            self.policyVersion = dict["PolicyVersion"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class ModifyBackupPolicyShrinkRequest : Tea.TeaModel {
    public var id: Int64?

    public var name: String?

    public var policyShrink: String?

    public var policyRegionId: String?

    public var policyVersion: String?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.policyShrink != nil {
            map["Policy"] = self.policyShrink!
        }
        if self.policyRegionId != nil {
            map["PolicyRegionId"] = self.policyRegionId!
        }
        if self.policyVersion != nil {
            map["PolicyVersion"] = self.policyVersion!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Policy") && dict["Policy"] != nil {
            self.policyShrink = dict["Policy"] as! String
        }
        if dict.keys.contains("PolicyRegionId") && dict["PolicyRegionId"] != nil {
            self.policyRegionId = dict["PolicyRegionId"] as! String
        }
        if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
            self.policyVersion = dict["PolicyVersion"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class ModifyBackupPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyBackupPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBackupPolicyStatusRequest : Tea.TeaModel {
    public var id: Int64?

    public var policyVersion: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.policyVersion != nil {
            map["PolicyVersion"] = self.policyVersion!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
            self.policyVersion = dict["PolicyVersion"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ModifyBackupPolicyStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBackupPolicyStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBackupPolicyStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyBackupPolicyStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyClearLogstoreStorageRequest : Tea.TeaModel {
    public var from: String?

    public var lang: String?

    public var userLogStore: String?

    public var userProject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.userLogStore != nil {
            map["UserLogStore"] = self.userLogStore!
        }
        if self.userProject != nil {
            map["UserProject"] = self.userProject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("UserLogStore") && dict["UserLogStore"] != nil {
            self.userLogStore = dict["UserLogStore"] as! String
        }
        if dict.keys.contains("UserProject") && dict["UserProject"] != nil {
            self.userProject = dict["UserProject"] as! String
        }
    }
}

public class ModifyClearLogstoreStorageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyClearLogstoreStorageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyClearLogstoreStorageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyClearLogstoreStorageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyClientConfSetupRequest : Tea.TeaModel {
    public var strategyConfig: String?

    public var strategyTag: String?

    public var strategyTagValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.strategyConfig != nil {
            map["StrategyConfig"] = self.strategyConfig!
        }
        if self.strategyTag != nil {
            map["StrategyTag"] = self.strategyTag!
        }
        if self.strategyTagValue != nil {
            map["StrategyTagValue"] = self.strategyTagValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("StrategyConfig") && dict["StrategyConfig"] != nil {
            self.strategyConfig = dict["StrategyConfig"] as! String
        }
        if dict.keys.contains("StrategyTag") && dict["StrategyTag"] != nil {
            self.strategyTag = dict["StrategyTag"] as! String
        }
        if dict.keys.contains("StrategyTagValue") && dict["StrategyTagValue"] != nil {
            self.strategyTagValue = dict["StrategyTagValue"] as! String
        }
    }
}

public class ModifyClientConfSetupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyClientConfSetupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyClientConfSetupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyClientConfSetupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyClientConfStrategyRequest : Tea.TeaModel {
    public var tag: String?

    public var tagExt: String?

    public var tagValue: String?

    public var uuid: String?

    public var uuids: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.tagExt != nil {
            map["TagExt"] = self.tagExt!
        }
        if self.tagValue != nil {
            map["TagValue"] = self.tagValue!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            self.tag = dict["Tag"] as! String
        }
        if dict.keys.contains("TagExt") && dict["TagExt"] != nil {
            self.tagExt = dict["TagExt"] as! String
        }
        if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
            self.tagValue = dict["TagValue"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! [String]
        }
    }
}

public class ModifyClientConfStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyClientConfStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyClientConfStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyClientConfStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyClientUserDefineRuleRequest : Tea.TeaModel {
    public var actionType: Int32?

    public var cmdline: String?

    public var filePath: String?

    public var IP: String?

    public var id: Int64?

    public var md5List: String?

    public var name: String?

    public var newFilePath: String?

    public var parentCmdline: String?

    public var parentProcPath: String?

    public var platform: String?

    public var port: Int32?

    public var portStr: String?

    public var procPath: String?

    public var registryContent: String?

    public var registryKey: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.cmdline != nil {
            map["Cmdline"] = self.cmdline!
        }
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.IP != nil {
            map["IP"] = self.IP!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.md5List != nil {
            map["Md5List"] = self.md5List!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.newFilePath != nil {
            map["NewFilePath"] = self.newFilePath!
        }
        if self.parentCmdline != nil {
            map["ParentCmdline"] = self.parentCmdline!
        }
        if self.parentProcPath != nil {
            map["ParentProcPath"] = self.parentProcPath!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.portStr != nil {
            map["PortStr"] = self.portStr!
        }
        if self.procPath != nil {
            map["ProcPath"] = self.procPath!
        }
        if self.registryContent != nil {
            map["RegistryContent"] = self.registryContent!
        }
        if self.registryKey != nil {
            map["RegistryKey"] = self.registryKey!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionType") && dict["ActionType"] != nil {
            self.actionType = dict["ActionType"] as! Int32
        }
        if dict.keys.contains("Cmdline") && dict["Cmdline"] != nil {
            self.cmdline = dict["Cmdline"] as! String
        }
        if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("IP") && dict["IP"] != nil {
            self.IP = dict["IP"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Md5List") && dict["Md5List"] != nil {
            self.md5List = dict["Md5List"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NewFilePath") && dict["NewFilePath"] != nil {
            self.newFilePath = dict["NewFilePath"] as! String
        }
        if dict.keys.contains("ParentCmdline") && dict["ParentCmdline"] != nil {
            self.parentCmdline = dict["ParentCmdline"] as! String
        }
        if dict.keys.contains("ParentProcPath") && dict["ParentProcPath"] != nil {
            self.parentProcPath = dict["ParentProcPath"] as! String
        }
        if dict.keys.contains("Platform") && dict["Platform"] != nil {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("Port") && dict["Port"] != nil {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("PortStr") && dict["PortStr"] != nil {
            self.portStr = dict["PortStr"] as! String
        }
        if dict.keys.contains("ProcPath") && dict["ProcPath"] != nil {
            self.procPath = dict["ProcPath"] as! String
        }
        if dict.keys.contains("RegistryContent") && dict["RegistryContent"] != nil {
            self.registryContent = dict["RegistryContent"] as! String
        }
        if dict.keys.contains("RegistryKey") && dict["RegistryKey"] != nil {
            self.registryKey = dict["RegistryKey"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class ModifyClientUserDefineRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyClientUserDefineRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyClientUserDefineRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyClientUserDefineRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyClusterCnnfStatusUserConfirmRequest : Tea.TeaModel {
    public var clusterIds: [String]?

    public var userConfirm: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        if self.userConfirm != nil {
            map["UserConfirm"] = self.userConfirm!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") && dict["ClusterIds"] != nil {
            self.clusterIds = dict["ClusterIds"] as! [String]
        }
        if dict.keys.contains("UserConfirm") && dict["UserConfirm"] != nil {
            self.userConfirm = dict["UserConfirm"] as! Bool
        }
    }
}

public class ModifyClusterCnnfStatusUserConfirmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyClusterCnnfStatusUserConfirmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyClusterCnnfStatusUserConfirmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyClusterCnnfStatusUserConfirmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyConcernNecessityRequest : Tea.TeaModel {
    public var concernNecessity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.concernNecessity != nil {
            map["ConcernNecessity"] = self.concernNecessity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConcernNecessity") && dict["ConcernNecessity"] != nil {
            self.concernNecessity = dict["ConcernNecessity"] as! String
        }
    }
}

public class ModifyConcernNecessityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyConcernNecessityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyConcernNecessityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyConcernNecessityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyContainerScanConfigRequest : Tea.TeaModel {
    public var appNames: String?

    public var clusterId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appNames != nil {
            map["AppNames"] = self.appNames!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppNames") && dict["AppNames"] != nil {
            self.appNames = dict["AppNames"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class ModifyContainerScanConfigResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyContainerScanConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyContainerScanConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyContainerScanConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCreateVulWhitelistRequest : Tea.TeaModel {
    public var reason: String?

    public var targetInfo: String?

    public var whitelist: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.targetInfo != nil {
            map["TargetInfo"] = self.targetInfo!
        }
        if self.whitelist != nil {
            map["Whitelist"] = self.whitelist!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("TargetInfo") && dict["TargetInfo"] != nil {
            self.targetInfo = dict["TargetInfo"] as! String
        }
        if dict.keys.contains("Whitelist") && dict["Whitelist"] != nil {
            self.whitelist = dict["Whitelist"] as! String
        }
    }
}

public class ModifyCreateVulWhitelistResponseBody : Tea.TeaModel {
    public class VulWhitelistList : Tea.TeaModel {
        public var id: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var vulWhitelistList: [ModifyCreateVulWhitelistResponseBody.VulWhitelistList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vulWhitelistList != nil {
            var tmp : [Any] = []
            for k in self.vulWhitelistList! {
                tmp.append(k.toMap())
            }
            map["VulWhitelistList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VulWhitelistList") && dict["VulWhitelistList"] != nil {
            var tmp : [ModifyCreateVulWhitelistResponseBody.VulWhitelistList] = []
            for v in dict["VulWhitelistList"] as! [Any] {
                var model = ModifyCreateVulWhitelistResponseBody.VulWhitelistList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vulWhitelistList = tmp
        }
    }
}

public class ModifyCreateVulWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCreateVulWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyCreateVulWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCustomBlockRecordRequest : Tea.TeaModel {
    public var blockIp: String?

    public var bound: String?

    public var expireTime: Int64?

    public var resourceOwnerId: Int64?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.blockIp != nil {
            map["BlockIp"] = self.blockIp!
        }
        if self.bound != nil {
            map["Bound"] = self.bound!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BlockIp") && dict["BlockIp"] != nil {
            self.blockIp = dict["BlockIp"] as! String
        }
        if dict.keys.contains("Bound") && dict["Bound"] != nil {
            self.bound = dict["Bound"] as! String
        }
        if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
            self.expireTime = dict["ExpireTime"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class ModifyCustomBlockRecordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCustomBlockRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCustomBlockRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyCustomBlockRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCycleTaskRequest : Tea.TeaModel {
    public var configId: String?

    public var enable: Int32?

    public var firstDateStr: Int64?

    public var intervalPeriod: Int32?

    public var param: String?

    public var periodUnit: String?

    public var targetEndTime: Int32?

    public var targetStartTime: Int32?

    public var taskName: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.firstDateStr != nil {
            map["FirstDateStr"] = self.firstDateStr!
        }
        if self.intervalPeriod != nil {
            map["IntervalPeriod"] = self.intervalPeriod!
        }
        if self.param != nil {
            map["Param"] = self.param!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.targetEndTime != nil {
            map["TargetEndTime"] = self.targetEndTime!
        }
        if self.targetStartTime != nil {
            map["TargetStartTime"] = self.targetStartTime!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigId") && dict["ConfigId"] != nil {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! Int32
        }
        if dict.keys.contains("FirstDateStr") && dict["FirstDateStr"] != nil {
            self.firstDateStr = dict["FirstDateStr"] as! Int64
        }
        if dict.keys.contains("IntervalPeriod") && dict["IntervalPeriod"] != nil {
            self.intervalPeriod = dict["IntervalPeriod"] as! Int32
        }
        if dict.keys.contains("Param") && dict["Param"] != nil {
            self.param = dict["Param"] as! String
        }
        if dict.keys.contains("PeriodUnit") && dict["PeriodUnit"] != nil {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("TargetEndTime") && dict["TargetEndTime"] != nil {
            self.targetEndTime = dict["TargetEndTime"] as! Int32
        }
        if dict.keys.contains("TargetStartTime") && dict["TargetStartTime"] != nil {
            self.targetStartTime = dict["TargetStartTime"] as! Int32
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
        if dict.keys.contains("TaskType") && dict["TaskType"] != nil {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class ModifyCycleTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCycleTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCycleTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyCycleTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEmgVulSubmitRequest : Tea.TeaModel {
    public var lang: String?

    public var name: String?

    public var userAgreement: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.userAgreement != nil {
            map["UserAgreement"] = self.userAgreement!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("UserAgreement") && dict["UserAgreement"] != nil {
            self.userAgreement = dict["UserAgreement"] as! String
        }
    }
}

public class ModifyEmgVulSubmitResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEmgVulSubmitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEmgVulSubmitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyEmgVulSubmitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyGroupPropertyRequest : Tea.TeaModel {
    public var data: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
    }
}

public class ModifyGroupPropertyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyGroupPropertyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyGroupPropertyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyGroupPropertyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyImageFixCycleConfigRequest : Tea.TeaModel {
    public var imageFixCycle: Int32?

    public var imageFixSwitch: String?

    public var imageFixTarget: String?

    public var imageTimeRange: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageFixCycle != nil {
            map["ImageFixCycle"] = self.imageFixCycle!
        }
        if self.imageFixSwitch != nil {
            map["ImageFixSwitch"] = self.imageFixSwitch!
        }
        if self.imageFixTarget != nil {
            map["ImageFixTarget"] = self.imageFixTarget!
        }
        if self.imageTimeRange != nil {
            map["ImageTimeRange"] = self.imageTimeRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageFixCycle") && dict["ImageFixCycle"] != nil {
            self.imageFixCycle = dict["ImageFixCycle"] as! Int32
        }
        if dict.keys.contains("ImageFixSwitch") && dict["ImageFixSwitch"] != nil {
            self.imageFixSwitch = dict["ImageFixSwitch"] as! String
        }
        if dict.keys.contains("ImageFixTarget") && dict["ImageFixTarget"] != nil {
            self.imageFixTarget = dict["ImageFixTarget"] as! String
        }
        if dict.keys.contains("ImageTimeRange") && dict["ImageTimeRange"] != nil {
            self.imageTimeRange = dict["ImageTimeRange"] as! Int32
        }
    }
}

public class ModifyImageFixCycleConfigResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyImageFixCycleConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageFixCycleConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyImageFixCycleConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAntiBruteForceRuleRequest : Tea.TeaModel {
    public var newRuleId: Int64?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.newRuleId != nil {
            map["NewRuleId"] = self.newRuleId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NewRuleId") && dict["NewRuleId"] != nil {
            self.newRuleId = dict["NewRuleId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ModifyInstanceAntiBruteForceRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAntiBruteForceRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAntiBruteForceRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyInstanceAntiBruteForceRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInterceptionRuleRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dstTarget: [String: Any]?

    public var interceptType: Int32?

    public var orderIndex: Int64?

    public var ruleId: Int64?

    public var ruleName: String?

    public var ruleSwitch: Int32?

    public var srcTarget: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dstTarget != nil {
            map["DstTarget"] = self.dstTarget!
        }
        if self.interceptType != nil {
            map["InterceptType"] = self.interceptType!
        }
        if self.orderIndex != nil {
            map["OrderIndex"] = self.orderIndex!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleSwitch != nil {
            map["RuleSwitch"] = self.ruleSwitch!
        }
        if self.srcTarget != nil {
            map["SrcTarget"] = self.srcTarget!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DstTarget") && dict["DstTarget"] != nil {
            self.dstTarget = dict["DstTarget"] as! [String: Any]
        }
        if dict.keys.contains("InterceptType") && dict["InterceptType"] != nil {
            self.interceptType = dict["InterceptType"] as! Int32
        }
        if dict.keys.contains("OrderIndex") && dict["OrderIndex"] != nil {
            self.orderIndex = dict["OrderIndex"] as! Int64
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int64
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleSwitch") && dict["RuleSwitch"] != nil {
            self.ruleSwitch = dict["RuleSwitch"] as! Int32
        }
        if dict.keys.contains("SrcTarget") && dict["SrcTarget"] != nil {
            self.srcTarget = dict["SrcTarget"] as! [String: Any]
        }
    }
}

public class ModifyInterceptionRuleShrinkRequest : Tea.TeaModel {
    public var clusterId: String?

    public var dstTargetShrink: String?

    public var interceptType: Int32?

    public var orderIndex: Int64?

    public var ruleId: Int64?

    public var ruleName: String?

    public var ruleSwitch: Int32?

    public var srcTargetShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.dstTargetShrink != nil {
            map["DstTarget"] = self.dstTargetShrink!
        }
        if self.interceptType != nil {
            map["InterceptType"] = self.interceptType!
        }
        if self.orderIndex != nil {
            map["OrderIndex"] = self.orderIndex!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.ruleSwitch != nil {
            map["RuleSwitch"] = self.ruleSwitch!
        }
        if self.srcTargetShrink != nil {
            map["SrcTarget"] = self.srcTargetShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DstTarget") && dict["DstTarget"] != nil {
            self.dstTargetShrink = dict["DstTarget"] as! String
        }
        if dict.keys.contains("InterceptType") && dict["InterceptType"] != nil {
            self.interceptType = dict["InterceptType"] as! Int32
        }
        if dict.keys.contains("OrderIndex") && dict["OrderIndex"] != nil {
            self.orderIndex = dict["OrderIndex"] as! Int64
        }
        if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
            self.ruleId = dict["RuleId"] as! Int64
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("RuleSwitch") && dict["RuleSwitch"] != nil {
            self.ruleSwitch = dict["RuleSwitch"] as! Int32
        }
        if dict.keys.contains("SrcTarget") && dict["SrcTarget"] != nil {
            self.srcTargetShrink = dict["SrcTarget"] as! String
        }
    }
}

public class ModifyInterceptionRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInterceptionRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInterceptionRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyInterceptionRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInterceptionRuleSwitchRequest : Tea.TeaModel {
    public var clusterId: String?

    public var ruleIds: String?

    public var ruleSwitch: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.ruleIds != nil {
            map["RuleIds"] = self.ruleIds!
        }
        if self.ruleSwitch != nil {
            map["RuleSwitch"] = self.ruleSwitch!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RuleIds") && dict["RuleIds"] != nil {
            self.ruleIds = dict["RuleIds"] as! String
        }
        if dict.keys.contains("RuleSwitch") && dict["RuleSwitch"] != nil {
            self.ruleSwitch = dict["RuleSwitch"] as! Int32
        }
    }
}

public class ModifyInterceptionRuleSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInterceptionRuleSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInterceptionRuleSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyInterceptionRuleSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInterceptionTargetRequest : Tea.TeaModel {
    public var appName: String?

    public var imageList: [String]?

    public var namespace: String?

    public var tagList: [String]?

    public var targetId: Int64?

    public var targetName: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.imageList != nil {
            map["ImageList"] = self.imageList!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.tagList != nil {
            map["TagList"] = self.tagList!
        }
        if self.targetId != nil {
            map["TargetId"] = self.targetId!
        }
        if self.targetName != nil {
            map["TargetName"] = self.targetName!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("ImageList") && dict["ImageList"] != nil {
            self.imageList = dict["ImageList"] as! [String]
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("TagList") && dict["TagList"] != nil {
            self.tagList = dict["TagList"] as! [String]
        }
        if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
            self.targetId = dict["TargetId"] as! Int64
        }
        if dict.keys.contains("TargetName") && dict["TargetName"] != nil {
            self.targetName = dict["TargetName"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class ModifyInterceptionTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ModifyInterceptionTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInterceptionTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyInterceptionTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLogMetaStatusRequest : Tea.TeaModel {
    public var from: String?

    public var logStore: String?

    public var project: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.logStore != nil {
            map["LogStore"] = self.logStore!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("LogStore") && dict["LogStore"] != nil {
            self.logStore = dict["LogStore"] as! String
        }
        if dict.keys.contains("Project") && dict["Project"] != nil {
            self.project = dict["Project"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ModifyLogMetaStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyLogMetaStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLogMetaStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyLogMetaStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLoginBaseConfigRequest : Tea.TeaModel {
    public var config: String?

    public var target: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ModifyLoginBaseConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyLoginBaseConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLoginBaseConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyLoginBaseConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLoginSwitchConfigRequest : Tea.TeaModel {
    public var item: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.item != nil {
            map["Item"] = self.item!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Item") && dict["Item"] != nil {
            self.item = dict["Item"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class ModifyLoginSwitchConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyLoginSwitchConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLoginSwitchConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyLoginSwitchConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNoticeConfigRequest : Tea.TeaModel {
    public var project: String?

    public var route: Int32?

    public var sourceIp: String?

    public var timeLimit: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.route != nil {
            map["Route"] = self.route!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.timeLimit != nil {
            map["TimeLimit"] = self.timeLimit!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Project") && dict["Project"] != nil {
            self.project = dict["Project"] as! String
        }
        if dict.keys.contains("Route") && dict["Route"] != nil {
            self.route = dict["Route"] as! Int32
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("TimeLimit") && dict["TimeLimit"] != nil {
            self.timeLimit = dict["TimeLimit"] as! Int32
        }
    }
}

public class ModifyNoticeConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNoticeConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNoticeConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyNoticeConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyOpenLogShipperRequest : Tea.TeaModel {
    public var from: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
    }
}

public class ModifyOpenLogShipperResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyOpenLogShipperResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyOpenLogShipperResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyOpenLogShipperResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyOperateVulRequest : Tea.TeaModel {
    public var from: String?

    public var info: String?

    public var operateType: String?

    public var reason: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.info != nil {
            map["Info"] = self.info!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Info") && dict["Info"] != nil {
            self.info = dict["Info"] as! String
        }
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! String
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ModifyOperateVulResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyOperateVulResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyOperateVulResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyOperateVulResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPropertyScheduleConfigRequest : Tea.TeaModel {
    public var scheduleTime: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scheduleTime != nil {
            map["ScheduleTime"] = self.scheduleTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScheduleTime") && dict["ScheduleTime"] != nil {
            self.scheduleTime = dict["ScheduleTime"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ModifyPropertyScheduleConfigResponseBody : Tea.TeaModel {
    public var modifyResult: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modifyResult != nil {
            map["ModifyResult"] = self.modifyResult!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ModifyResult") && dict["ModifyResult"] != nil {
            self.modifyResult = dict["ModifyResult"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPropertyScheduleConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPropertyScheduleConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyPropertyScheduleConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPushAllTaskRequest : Tea.TeaModel {
    public var sourceIp: String?

    public var tasks: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.tasks != nil {
            map["Tasks"] = self.tasks!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Tasks") && dict["Tasks"] != nil {
            self.tasks = dict["Tasks"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class ModifyPushAllTaskResponseBody : Tea.TeaModel {
    public class PushTaskRsp : Tea.TeaModel {
        public class PushTaskResultList : Tea.TeaModel {
            public var groupId: Int64?

            public var instanceId: String?

            public var instanceName: String?

            public var ip: String?

            public var message: String?

            public var online: Bool?

            public var osVersion: String?

            public var region: String?

            public var success: Bool?

            public var uuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.online != nil {
                    map["Online"] = self.online!
                }
                if self.osVersion != nil {
                    map["OsVersion"] = self.osVersion!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                if self.uuid != nil {
                    map["Uuid"] = self.uuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
                    self.groupId = dict["GroupId"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") && dict["InstanceName"] != nil {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("Ip") && dict["Ip"] != nil {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Message") && dict["Message"] != nil {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Online") && dict["Online"] != nil {
                    self.online = dict["Online"] as! Bool
                }
                if dict.keys.contains("OsVersion") && dict["OsVersion"] != nil {
                    self.osVersion = dict["OsVersion"] as! String
                }
                if dict.keys.contains("Region") && dict["Region"] != nil {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Success") && dict["Success"] != nil {
                    self.success = dict["Success"] as! Bool
                }
                if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                    self.uuid = dict["Uuid"] as! String
                }
            }
        }
        public var pushTaskResultList: [ModifyPushAllTaskResponseBody.PushTaskRsp.PushTaskResultList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pushTaskResultList != nil {
                var tmp : [Any] = []
                for k in self.pushTaskResultList! {
                    tmp.append(k.toMap())
                }
                map["PushTaskResultList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PushTaskResultList") && dict["PushTaskResultList"] != nil {
                var tmp : [ModifyPushAllTaskResponseBody.PushTaskRsp.PushTaskResultList] = []
                for v in dict["PushTaskResultList"] as! [Any] {
                    var model = ModifyPushAllTaskResponseBody.PushTaskRsp.PushTaskResultList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pushTaskResultList = tmp
            }
        }
    }
    public var pushTaskRsp: ModifyPushAllTaskResponseBody.PushTaskRsp?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushTaskRsp?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pushTaskRsp != nil {
            map["PushTaskRsp"] = self.pushTaskRsp?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PushTaskRsp") && dict["PushTaskRsp"] != nil {
            var model = ModifyPushAllTaskResponseBody.PushTaskRsp()
            model.fromMap(dict["PushTaskRsp"] as! [String: Any])
            self.pushTaskRsp = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPushAllTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPushAllTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyPushAllTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRefreshProcessInfoRequest : Tea.TeaModel {
    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ModifyRefreshProcessInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyRefreshProcessInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRefreshProcessInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyRefreshProcessInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRiskCheckStatusRequest : Tea.TeaModel {
    public var itemId: Int64?

    public var lang: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public var status: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ItemId") && dict["ItemId"] != nil {
            self.itemId = dict["ItemId"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class ModifyRiskCheckStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyRiskCheckStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRiskCheckStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyRiskCheckStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRiskSingleResultStatusRequest : Tea.TeaModel {
    public var ids: [String]?

    public var lang: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public var status: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ids != nil {
            map["Ids"] = self.ids!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ids") && dict["Ids"] != nil {
            self.ids = dict["Ids"] as! [String]
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class ModifyRiskSingleResultStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyRiskSingleResultStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRiskSingleResultStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyRiskSingleResultStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySecurityCheckScheduleConfigRequest : Tea.TeaModel {
    public var daysOfWeek: String?

    public var endTime: Int32?

    public var lang: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public var startTime: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.daysOfWeek != nil {
            map["DaysOfWeek"] = self.daysOfWeek!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DaysOfWeek") && dict["DaysOfWeek"] != nil {
            self.daysOfWeek = dict["DaysOfWeek"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int32
        }
    }
}

public class ModifySecurityCheckScheduleConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySecurityCheckScheduleConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityCheckScheduleConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifySecurityCheckScheduleConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySecurityEventMarkMissIndividuallyRequest : Tea.TeaModel {
    public var deleteMarkMissParam: String?

    public var from: String?

    public var insertMarkMissParam: String?

    public var lang: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteMarkMissParam != nil {
            map["DeleteMarkMissParam"] = self.deleteMarkMissParam!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.insertMarkMissParam != nil {
            map["InsertMarkMissParam"] = self.insertMarkMissParam!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteMarkMissParam") && dict["DeleteMarkMissParam"] != nil {
            self.deleteMarkMissParam = dict["DeleteMarkMissParam"] as! String
        }
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("InsertMarkMissParam") && dict["InsertMarkMissParam"] != nil {
            self.insertMarkMissParam = dict["InsertMarkMissParam"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class ModifySecurityEventMarkMissIndividuallyResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var timeCost: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeCost != nil {
            map["TimeCost"] = self.timeCost!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeCost") && dict["TimeCost"] != nil {
            self.timeCost = dict["TimeCost"] as! Int64
        }
    }
}

public class ModifySecurityEventMarkMissIndividuallyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityEventMarkMissIndividuallyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifySecurityEventMarkMissIndividuallyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyStartVulScanRequest : Tea.TeaModel {
    public var types: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.types != nil {
            map["Types"] = self.types!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Types") && dict["Types"] != nil {
            self.types = dict["Types"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class ModifyStartVulScanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyStartVulScanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyStartVulScanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyStartVulScanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyStrategyRequest : Tea.TeaModel {
    public var customType: String?

    public var cycleDays: String?

    public var cycleStartTime: String?

    public var endTime: String?

    public var id: String?

    public var name: String?

    public var riskCustomParams: String?

    public var riskSubTypeName: String?

    public var sourceIp: String?

    public var startTime: String?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customType != nil {
            map["CustomType"] = self.customType!
        }
        if self.cycleDays != nil {
            map["CycleDays"] = self.cycleDays!
        }
        if self.cycleStartTime != nil {
            map["CycleStartTime"] = self.cycleStartTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.riskCustomParams != nil {
            map["RiskCustomParams"] = self.riskCustomParams!
        }
        if self.riskSubTypeName != nil {
            map["RiskSubTypeName"] = self.riskSubTypeName!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomType") && dict["CustomType"] != nil {
            self.customType = dict["CustomType"] as! String
        }
        if dict.keys.contains("CycleDays") && dict["CycleDays"] != nil {
            self.cycleDays = dict["CycleDays"] as! String
        }
        if dict.keys.contains("CycleStartTime") && dict["CycleStartTime"] != nil {
            self.cycleStartTime = dict["CycleStartTime"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RiskCustomParams") && dict["RiskCustomParams"] != nil {
            self.riskCustomParams = dict["RiskCustomParams"] as! String
        }
        if dict.keys.contains("RiskSubTypeName") && dict["RiskSubTypeName"] != nil {
            self.riskSubTypeName = dict["RiskSubTypeName"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
    }
}

public class ModifyStrategyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var strategyId: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.strategyId != nil {
                map["StrategyId"] = self.strategyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
                self.strategyId = dict["StrategyId"] as! Int32
            }
        }
    }
    public var httpStatusCode: Int32?

    public var requestId: String?

    public var result: ModifyStrategyResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            var model = ModifyStrategyResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyStrategyTargetRequest : Tea.TeaModel {
    public var config: String?

    public var sourceIp: String?

    public var target: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ModifyStrategyTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyStrategyTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyStrategyTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyStrategyTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTagWithUuidRequest : Tea.TeaModel {
    public var machineTypes: String?

    public var tagId: String?

    public var tagList: String?

    public var uuidList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.machineTypes != nil {
            map["MachineTypes"] = self.machineTypes!
        }
        if self.tagId != nil {
            map["TagId"] = self.tagId!
        }
        if self.tagList != nil {
            map["TagList"] = self.tagList!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MachineTypes") && dict["MachineTypes"] != nil {
            self.machineTypes = dict["MachineTypes"] as! String
        }
        if dict.keys.contains("TagId") && dict["TagId"] != nil {
            self.tagId = dict["TagId"] as! String
        }
        if dict.keys.contains("TagList") && dict["TagList"] != nil {
            self.tagList = dict["TagList"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! String
        }
    }
}

public class ModifyTagWithUuidResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyTagWithUuidResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTagWithUuidResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyTagWithUuidResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyUniBackupPolicyRequest : Tea.TeaModel {
    public var accountName: String?

    public var accountPassword: String?

    public var fullPlan: [String: Any]?

    public var incPlan: [String: Any]?

    public var policyId: Int64?

    public var policyName: String?

    public var policyStatus: String?

    public var retention: Int32?

    public var speedLimiter: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPassword != nil {
            map["AccountPassword"] = self.accountPassword!
        }
        if self.fullPlan != nil {
            map["FullPlan"] = self.fullPlan!
        }
        if self.incPlan != nil {
            map["IncPlan"] = self.incPlan!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.policyName != nil {
            map["PolicyName"] = self.policyName!
        }
        if self.policyStatus != nil {
            map["PolicyStatus"] = self.policyStatus!
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        if self.speedLimiter != nil {
            map["SpeedLimiter"] = self.speedLimiter!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountName") && dict["AccountName"] != nil {
            self.accountName = dict["AccountName"] as! String
        }
        if dict.keys.contains("AccountPassword") && dict["AccountPassword"] != nil {
            self.accountPassword = dict["AccountPassword"] as! String
        }
        if dict.keys.contains("FullPlan") && dict["FullPlan"] != nil {
            self.fullPlan = dict["FullPlan"] as! [String: Any]
        }
        if dict.keys.contains("IncPlan") && dict["IncPlan"] != nil {
            self.incPlan = dict["IncPlan"] as! [String: Any]
        }
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! Int64
        }
        if dict.keys.contains("PolicyName") && dict["PolicyName"] != nil {
            self.policyName = dict["PolicyName"] as! String
        }
        if dict.keys.contains("PolicyStatus") && dict["PolicyStatus"] != nil {
            self.policyStatus = dict["PolicyStatus"] as! String
        }
        if dict.keys.contains("Retention") && dict["Retention"] != nil {
            self.retention = dict["Retention"] as! Int32
        }
        if dict.keys.contains("SpeedLimiter") && dict["SpeedLimiter"] != nil {
            self.speedLimiter = dict["SpeedLimiter"] as! Int64
        }
    }
}

public class ModifyUniBackupPolicyShrinkRequest : Tea.TeaModel {
    public var accountName: String?

    public var accountPassword: String?

    public var fullPlanShrink: String?

    public var incPlanShrink: String?

    public var policyId: Int64?

    public var policyName: String?

    public var policyStatus: String?

    public var retention: Int32?

    public var speedLimiter: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPassword != nil {
            map["AccountPassword"] = self.accountPassword!
        }
        if self.fullPlanShrink != nil {
            map["FullPlan"] = self.fullPlanShrink!
        }
        if self.incPlanShrink != nil {
            map["IncPlan"] = self.incPlanShrink!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.policyName != nil {
            map["PolicyName"] = self.policyName!
        }
        if self.policyStatus != nil {
            map["PolicyStatus"] = self.policyStatus!
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        if self.speedLimiter != nil {
            map["SpeedLimiter"] = self.speedLimiter!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountName") && dict["AccountName"] != nil {
            self.accountName = dict["AccountName"] as! String
        }
        if dict.keys.contains("AccountPassword") && dict["AccountPassword"] != nil {
            self.accountPassword = dict["AccountPassword"] as! String
        }
        if dict.keys.contains("FullPlan") && dict["FullPlan"] != nil {
            self.fullPlanShrink = dict["FullPlan"] as! String
        }
        if dict.keys.contains("IncPlan") && dict["IncPlan"] != nil {
            self.incPlanShrink = dict["IncPlan"] as! String
        }
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! Int64
        }
        if dict.keys.contains("PolicyName") && dict["PolicyName"] != nil {
            self.policyName = dict["PolicyName"] as! String
        }
        if dict.keys.contains("PolicyStatus") && dict["PolicyStatus"] != nil {
            self.policyStatus = dict["PolicyStatus"] as! String
        }
        if dict.keys.contains("Retention") && dict["Retention"] != nil {
            self.retention = dict["Retention"] as! Int32
        }
        if dict.keys.contains("SpeedLimiter") && dict["SpeedLimiter"] != nil {
            self.speedLimiter = dict["SpeedLimiter"] as! Int64
        }
    }
}

public class ModifyUniBackupPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyUniBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyUniBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyUniBackupPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpcHoneyPotRequest : Tea.TeaModel {
    public var honeyPotAction: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeyPotAction != nil {
            map["HoneyPotAction"] = self.honeyPotAction!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneyPotAction") && dict["HoneyPotAction"] != nil {
            self.honeyPotAction = dict["HoneyPotAction"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class ModifyVpcHoneyPotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVpcHoneyPotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpcHoneyPotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyVpcHoneyPotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVulConfigRequest : Tea.TeaModel {
    public var config: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ModifyVulConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVulConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVulConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyVulConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVulTargetRequest : Tea.TeaModel {
    public var config: String?

    public var target: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
    }
}

public class ModifyVulTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVulTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVulTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyVulTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVulTargetConfigRequest : Tea.TeaModel {
    public var config: String?

    public var sourceIp: String?

    public var type: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ModifyVulTargetConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVulTargetConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVulTargetConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyVulTargetConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVulWhitelistTargetRequest : Tea.TeaModel {
    public var id: Int64?

    public var reason: String?

    public var sourceIp: String?

    public var targetInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.targetInfo != nil {
            map["TargetInfo"] = self.targetInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("TargetInfo") && dict["TargetInfo"] != nil {
            self.targetInfo = dict["TargetInfo"] as! String
        }
    }
}

public class ModifyVulWhitelistTargetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVulWhitelistTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVulWhitelistTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyVulWhitelistTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyWebLockCreateConfigRequest : Tea.TeaModel {
    public var defenceMode: String?

    public var dir: String?

    public var exclusiveDir: String?

    public var exclusiveFile: String?

    public var exclusiveFileType: String?

    public var inclusiveFile: String?

    public var inclusiveFileType: String?

    public var lang: String?

    public var localBackupDir: String?

    public var mode: String?

    public var sourceIp: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defenceMode != nil {
            map["DefenceMode"] = self.defenceMode!
        }
        if self.dir != nil {
            map["Dir"] = self.dir!
        }
        if self.exclusiveDir != nil {
            map["ExclusiveDir"] = self.exclusiveDir!
        }
        if self.exclusiveFile != nil {
            map["ExclusiveFile"] = self.exclusiveFile!
        }
        if self.exclusiveFileType != nil {
            map["ExclusiveFileType"] = self.exclusiveFileType!
        }
        if self.inclusiveFile != nil {
            map["InclusiveFile"] = self.inclusiveFile!
        }
        if self.inclusiveFileType != nil {
            map["InclusiveFileType"] = self.inclusiveFileType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.localBackupDir != nil {
            map["LocalBackupDir"] = self.localBackupDir!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefenceMode") && dict["DefenceMode"] != nil {
            self.defenceMode = dict["DefenceMode"] as! String
        }
        if dict.keys.contains("Dir") && dict["Dir"] != nil {
            self.dir = dict["Dir"] as! String
        }
        if dict.keys.contains("ExclusiveDir") && dict["ExclusiveDir"] != nil {
            self.exclusiveDir = dict["ExclusiveDir"] as! String
        }
        if dict.keys.contains("ExclusiveFile") && dict["ExclusiveFile"] != nil {
            self.exclusiveFile = dict["ExclusiveFile"] as! String
        }
        if dict.keys.contains("ExclusiveFileType") && dict["ExclusiveFileType"] != nil {
            self.exclusiveFileType = dict["ExclusiveFileType"] as! String
        }
        if dict.keys.contains("InclusiveFile") && dict["InclusiveFile"] != nil {
            self.inclusiveFile = dict["InclusiveFile"] as! String
        }
        if dict.keys.contains("InclusiveFileType") && dict["InclusiveFileType"] != nil {
            self.inclusiveFileType = dict["InclusiveFileType"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LocalBackupDir") && dict["LocalBackupDir"] != nil {
            self.localBackupDir = dict["LocalBackupDir"] as! String
        }
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ModifyWebLockCreateConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyWebLockCreateConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWebLockCreateConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyWebLockCreateConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyWebLockDeleteConfigRequest : Tea.TeaModel {
    public var id: Int32?

    public var lang: String?

    public var sourceIp: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int32
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ModifyWebLockDeleteConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyWebLockDeleteConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWebLockDeleteConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyWebLockDeleteConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyWebLockProcessStatusRequest : Tea.TeaModel {
    public var dealAll: Int32?

    public var operateInfo: String?

    public var processPath: [String]?

    public var status: Int32?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dealAll != nil {
            map["DealAll"] = self.dealAll!
        }
        if self.operateInfo != nil {
            map["OperateInfo"] = self.operateInfo!
        }
        if self.processPath != nil {
            map["ProcessPath"] = self.processPath!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DealAll") && dict["DealAll"] != nil {
            self.dealAll = dict["DealAll"] as! Int32
        }
        if dict.keys.contains("OperateInfo") && dict["OperateInfo"] != nil {
            self.operateInfo = dict["OperateInfo"] as! String
        }
        if dict.keys.contains("ProcessPath") && dict["ProcessPath"] != nil {
            self.processPath = dict["ProcessPath"] as! [String]
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ModifyWebLockProcessStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyWebLockProcessStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWebLockProcessStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyWebLockProcessStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyWebLockStartRequest : Tea.TeaModel {
    public var defenceMode: String?

    public var dir: String?

    public var exclusiveDir: String?

    public var exclusiveFile: String?

    public var exclusiveFileType: String?

    public var inclusiveFileType: String?

    public var localBackupDir: String?

    public var mode: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defenceMode != nil {
            map["DefenceMode"] = self.defenceMode!
        }
        if self.dir != nil {
            map["Dir"] = self.dir!
        }
        if self.exclusiveDir != nil {
            map["ExclusiveDir"] = self.exclusiveDir!
        }
        if self.exclusiveFile != nil {
            map["ExclusiveFile"] = self.exclusiveFile!
        }
        if self.exclusiveFileType != nil {
            map["ExclusiveFileType"] = self.exclusiveFileType!
        }
        if self.inclusiveFileType != nil {
            map["InclusiveFileType"] = self.inclusiveFileType!
        }
        if self.localBackupDir != nil {
            map["LocalBackupDir"] = self.localBackupDir!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefenceMode") && dict["DefenceMode"] != nil {
            self.defenceMode = dict["DefenceMode"] as! String
        }
        if dict.keys.contains("Dir") && dict["Dir"] != nil {
            self.dir = dict["Dir"] as! String
        }
        if dict.keys.contains("ExclusiveDir") && dict["ExclusiveDir"] != nil {
            self.exclusiveDir = dict["ExclusiveDir"] as! String
        }
        if dict.keys.contains("ExclusiveFile") && dict["ExclusiveFile"] != nil {
            self.exclusiveFile = dict["ExclusiveFile"] as! String
        }
        if dict.keys.contains("ExclusiveFileType") && dict["ExclusiveFileType"] != nil {
            self.exclusiveFileType = dict["ExclusiveFileType"] as! String
        }
        if dict.keys.contains("InclusiveFileType") && dict["InclusiveFileType"] != nil {
            self.inclusiveFileType = dict["InclusiveFileType"] as! String
        }
        if dict.keys.contains("LocalBackupDir") && dict["LocalBackupDir"] != nil {
            self.localBackupDir = dict["LocalBackupDir"] as! String
        }
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ModifyWebLockStartResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyWebLockStartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWebLockStartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyWebLockStartResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyWebLockStatusRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public var status: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ModifyWebLockStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyWebLockStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWebLockStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyWebLockStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyWebLockUnbindRequest : Tea.TeaModel {
    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ModifyWebLockUnbindResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyWebLockUnbindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWebLockUnbindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyWebLockUnbindResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyWebLockUpdateConfigRequest : Tea.TeaModel {
    public var defenceMode: String?

    public var dir: String?

    public var exclusiveDir: String?

    public var exclusiveFile: String?

    public var exclusiveFileType: String?

    public var id: Int32?

    public var inclusiveFile: String?

    public var inclusiveFileType: String?

    public var lang: String?

    public var localBackupDir: String?

    public var mode: String?

    public var sourceIp: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defenceMode != nil {
            map["DefenceMode"] = self.defenceMode!
        }
        if self.dir != nil {
            map["Dir"] = self.dir!
        }
        if self.exclusiveDir != nil {
            map["ExclusiveDir"] = self.exclusiveDir!
        }
        if self.exclusiveFile != nil {
            map["ExclusiveFile"] = self.exclusiveFile!
        }
        if self.exclusiveFileType != nil {
            map["ExclusiveFileType"] = self.exclusiveFileType!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.inclusiveFile != nil {
            map["InclusiveFile"] = self.inclusiveFile!
        }
        if self.inclusiveFileType != nil {
            map["InclusiveFileType"] = self.inclusiveFileType!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.localBackupDir != nil {
            map["LocalBackupDir"] = self.localBackupDir!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefenceMode") && dict["DefenceMode"] != nil {
            self.defenceMode = dict["DefenceMode"] as! String
        }
        if dict.keys.contains("Dir") && dict["Dir"] != nil {
            self.dir = dict["Dir"] as! String
        }
        if dict.keys.contains("ExclusiveDir") && dict["ExclusiveDir"] != nil {
            self.exclusiveDir = dict["ExclusiveDir"] as! String
        }
        if dict.keys.contains("ExclusiveFile") && dict["ExclusiveFile"] != nil {
            self.exclusiveFile = dict["ExclusiveFile"] as! String
        }
        if dict.keys.contains("ExclusiveFileType") && dict["ExclusiveFileType"] != nil {
            self.exclusiveFileType = dict["ExclusiveFileType"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int32
        }
        if dict.keys.contains("InclusiveFile") && dict["InclusiveFile"] != nil {
            self.inclusiveFile = dict["InclusiveFile"] as! String
        }
        if dict.keys.contains("InclusiveFileType") && dict["InclusiveFileType"] != nil {
            self.inclusiveFileType = dict["InclusiveFileType"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("LocalBackupDir") && dict["LocalBackupDir"] != nil {
            self.localBackupDir = dict["LocalBackupDir"] as! String
        }
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class ModifyWebLockUpdateConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyWebLockUpdateConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWebLockUpdateConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyWebLockUpdateConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyWebPathRequest : Tea.TeaModel {
    public var config: String?

    public var target: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ModifyWebPathResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyWebPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWebPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyWebPathResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenSensitiveFileScanRequest : Tea.TeaModel {
    public var switchOn: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.switchOn != nil {
            map["SwitchOn"] = self.switchOn!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SwitchOn") && dict["SwitchOn"] != nil {
            self.switchOn = dict["SwitchOn"] as! String
        }
    }
}

public class OpenSensitiveFileScanResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var switchOn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.switchOn != nil {
                map["SwitchOn"] = self.switchOn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SwitchOn") && dict["SwitchOn"] != nil {
                self.switchOn = dict["SwitchOn"] as! String
            }
        }
    }
    public var code: String?

    public var data: OpenSensitiveFileScanResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = OpenSensitiveFileScanResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class OpenSensitiveFileScanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenSensitiveFileScanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenSensitiveFileScanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateAgentClientInstallRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var lang: String?

    public var os: String?

    public var region: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Os") && dict["Os"] != nil {
            self.os = dict["Os"] as! String
        }
        if dict.keys.contains("Region") && dict["Region"] != nil {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class OperateAgentClientInstallResponseBody : Tea.TeaModel {
    public class AegisCelintInstallResposeList : Tea.TeaModel {
        public var instanceId: String?

        public var recordId: Int64?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("RecordId") && dict["RecordId"] != nil {
                self.recordId = dict["RecordId"] as! Int64
            }
            if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var aegisCelintInstallResposeList: [OperateAgentClientInstallResponseBody.AegisCelintInstallResposeList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aegisCelintInstallResposeList != nil {
            var tmp : [Any] = []
            for k in self.aegisCelintInstallResposeList! {
                tmp.append(k.toMap())
            }
            map["AegisCelintInstallResposeList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AegisCelintInstallResposeList") && dict["AegisCelintInstallResposeList"] != nil {
            var tmp : [OperateAgentClientInstallResponseBody.AegisCelintInstallResposeList] = []
            for v in dict["AegisCelintInstallResposeList"] as! [Any] {
                var model = OperateAgentClientInstallResponseBody.AegisCelintInstallResposeList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aegisCelintInstallResposeList = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OperateAgentClientInstallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateAgentClientInstallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperateAgentClientInstallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateCommonOverallConfigRequest : Tea.TeaModel {
    public var config: String?

    public var sourceIp: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class OperateCommonOverallConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OperateCommonOverallConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateCommonOverallConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperateCommonOverallConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateCommonTargetConfigRequest : Tea.TeaModel {
    public var fieldName: String?

    public var fieldValue: String?

    public var sourceIp: String?

    public var targetOperations: String?

    public var targetType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fieldName != nil {
            map["FieldName"] = self.fieldName!
        }
        if self.fieldValue != nil {
            map["FieldValue"] = self.fieldValue!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.targetOperations != nil {
            map["TargetOperations"] = self.targetOperations!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FieldName") && dict["FieldName"] != nil {
            self.fieldName = dict["FieldName"] as! String
        }
        if dict.keys.contains("FieldValue") && dict["FieldValue"] != nil {
            self.fieldValue = dict["FieldValue"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("TargetOperations") && dict["TargetOperations"] != nil {
            self.targetOperations = dict["TargetOperations"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class OperateCommonTargetConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OperateCommonTargetConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateCommonTargetConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperateCommonTargetConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateImageBaselineWhitelistRequest : Tea.TeaModel {
    public var baselineItemKeyList: String?

    public var imageUuid: String?

    public var lang: String?

    public var operation: String?

    public var scanRange: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineItemKeyList != nil {
            map["BaselineItemKeyList"] = self.baselineItemKeyList!
        }
        if self.imageUuid != nil {
            map["ImageUuid"] = self.imageUuid!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.operation != nil {
            map["Operation"] = self.operation!
        }
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineItemKeyList") && dict["BaselineItemKeyList"] != nil {
            self.baselineItemKeyList = dict["BaselineItemKeyList"] as! String
        }
        if dict.keys.contains("ImageUuid") && dict["ImageUuid"] != nil {
            self.imageUuid = dict["ImageUuid"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Operation") && dict["Operation"] != nil {
            self.operation = dict["Operation"] as! String
        }
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! [String]
        }
    }
}

public class OperateImageBaselineWhitelistResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OperateImageBaselineWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateImageBaselineWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperateImageBaselineWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateImageVulRequest : Tea.TeaModel {
    public var info: String?

    public var operateType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.info != nil {
            map["Info"] = self.info!
        }
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Info") && dict["Info"] != nil {
            self.info = dict["Info"] as! String
        }
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class OperateImageVulResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OperateImageVulResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateImageVulResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperateImageVulResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateSuspiciousOverallConfigRequest : Tea.TeaModel {
    public var config: String?

    public var lang: String?

    public var noTargetAsOn: Bool?

    public var sourceIp: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.noTargetAsOn != nil {
            map["NoTargetAsOn"] = self.noTargetAsOn!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("NoTargetAsOn") && dict["NoTargetAsOn"] != nil {
            self.noTargetAsOn = dict["NoTargetAsOn"] as! Bool
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class OperateSuspiciousOverallConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OperateSuspiciousOverallConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateSuspiciousOverallConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperateSuspiciousOverallConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateSuspiciousTargetConfigRequest : Tea.TeaModel {
    public var lang: String?

    public var sourceIp: String?

    public var targetOperations: String?

    public var targetType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.targetOperations != nil {
            map["TargetOperations"] = self.targetOperations!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("TargetOperations") && dict["TargetOperations"] != nil {
            self.targetOperations = dict["TargetOperations"] as! String
        }
        if dict.keys.contains("TargetType") && dict["TargetType"] != nil {
            self.targetType = dict["TargetType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class OperateSuspiciousTargetConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OperateSuspiciousTargetConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateSuspiciousTargetConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperateSuspiciousTargetConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateVirusEventsRequest : Tea.TeaModel {
    public var operationAll: Int32?

    public var operationCode: String?

    public var operationRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationAll != nil {
            map["OperationAll"] = self.operationAll!
        }
        if self.operationCode != nil {
            map["OperationCode"] = self.operationCode!
        }
        if self.operationRange != nil {
            map["OperationRange"] = self.operationRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationAll") && dict["OperationAll"] != nil {
            self.operationAll = dict["OperationAll"] as! Int32
        }
        if dict.keys.contains("OperationCode") && dict["OperationCode"] != nil {
            self.operationCode = dict["OperationCode"] as! String
        }
        if dict.keys.contains("OperationRange") && dict["OperationRange"] != nil {
            self.operationRange = dict["OperationRange"] as! String
        }
    }
}

public class OperateVirusEventsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! Int64
        }
    }
}

public class OperateVirusEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateVirusEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperateVirusEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateVulsRequest : Tea.TeaModel {
    public var operateType: String?

    public var type: String?

    public var uuids: [String]?

    public var vulNames: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operateType != nil {
            map["OperateType"] = self.operateType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        if self.vulNames != nil {
            map["VulNames"] = self.vulNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperateType") && dict["OperateType"] != nil {
            self.operateType = dict["OperateType"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! [String]
        }
        if dict.keys.contains("VulNames") && dict["VulNames"] != nil {
            self.vulNames = dict["VulNames"] as! [String]
        }
    }
}

public class OperateVulsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OperateVulsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateVulsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperateVulsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateWebLockFileEventsRequest : Tea.TeaModel {
    public var dealAll: Int32?

    public var eventIds: [Int64]?

    public var operationCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dealAll != nil {
            map["DealAll"] = self.dealAll!
        }
        if self.eventIds != nil {
            map["EventIds"] = self.eventIds!
        }
        if self.operationCode != nil {
            map["OperationCode"] = self.operationCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DealAll") && dict["DealAll"] != nil {
            self.dealAll = dict["DealAll"] as! Int32
        }
        if dict.keys.contains("EventIds") && dict["EventIds"] != nil {
            self.eventIds = dict["EventIds"] as! [Int64]
        }
        if dict.keys.contains("OperationCode") && dict["OperationCode"] != nil {
            self.operationCode = dict["OperationCode"] as! String
        }
    }
}

public class OperateWebLockFileEventsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OperateWebLockFileEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateWebLockFileEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperateWebLockFileEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperationCancelIgnoreSuspEventRequest : Tea.TeaModel {
    public var remark: String?

    public var securityEventIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.securityEventIds != nil {
            map["SecurityEventIds"] = self.securityEventIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SecurityEventIds") && dict["SecurityEventIds"] != nil {
            self.securityEventIds = dict["SecurityEventIds"] as! [Int64]
        }
    }
}

public class OperationCancelIgnoreSuspEventResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var timeCost: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeCost != nil {
            map["TimeCost"] = self.timeCost!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeCost") && dict["TimeCost"] != nil {
            self.timeCost = dict["TimeCost"] as! Int64
        }
    }
}

public class OperationCancelIgnoreSuspEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperationCancelIgnoreSuspEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperationCancelIgnoreSuspEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperationSuspEventsRequest : Tea.TeaModel {
    public var from: String?

    public var operation: String?

    public var sourceIp: String?

    public var subOperation: String?

    public var suspiciousEventIds: String?

    public var warnType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.operation != nil {
            map["Operation"] = self.operation!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.subOperation != nil {
            map["SubOperation"] = self.subOperation!
        }
        if self.suspiciousEventIds != nil {
            map["SuspiciousEventIds"] = self.suspiciousEventIds!
        }
        if self.warnType != nil {
            map["WarnType"] = self.warnType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Operation") && dict["Operation"] != nil {
            self.operation = dict["Operation"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("SubOperation") && dict["SubOperation"] != nil {
            self.subOperation = dict["SubOperation"] as! String
        }
        if dict.keys.contains("SuspiciousEventIds") && dict["SuspiciousEventIds"] != nil {
            self.suspiciousEventIds = dict["SuspiciousEventIds"] as! String
        }
        if dict.keys.contains("WarnType") && dict["WarnType"] != nil {
            self.warnType = dict["WarnType"] as! String
        }
    }
}

public class OperationSuspEventsResponseBody : Tea.TeaModel {
    public var accessCode: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessCode != nil {
            map["AccessCode"] = self.accessCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessCode") && dict["AccessCode"] != nil {
            self.accessCode = dict["AccessCode"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class OperationSuspEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperationSuspEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OperationSuspEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PageImageRegistryRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public var registryNameLike: String?

    public var registryTypeInList: [String]?

    public var registryTypeNotInList: [String]?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.registryNameLike != nil {
            map["RegistryNameLike"] = self.registryNameLike!
        }
        if self.registryTypeInList != nil {
            map["RegistryTypeInList"] = self.registryTypeInList!
        }
        if self.registryTypeNotInList != nil {
            map["RegistryTypeNotInList"] = self.registryTypeNotInList!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegistryNameLike") && dict["RegistryNameLike"] != nil {
            self.registryNameLike = dict["RegistryNameLike"] as! String
        }
        if dict.keys.contains("RegistryTypeInList") && dict["RegistryTypeInList"] != nil {
            self.registryTypeInList = dict["RegistryTypeInList"] as! [String]
        }
        if dict.keys.contains("RegistryTypeNotInList") && dict["RegistryTypeNotInList"] != nil {
            self.registryTypeNotInList = dict["RegistryTypeNotInList"] as! [String]
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class PageImageRegistryResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var blackList: String?

        public var domainName: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var id: Int64?

        public var imageCount: Int32?

        public var jenkinsEnv: String?

        public var netType: Int32?

        public var password: String?

        public var persistenceDay: Int32?

        public var protocolType: Int32?

        public var regionId: String?

        public var registryHostIp: String?

        public var registryName: String?

        public var registryType: String?

        public var token: String?

        public var transPerHour: Int32?

        public var userName: String?

        public var vpcId: String?

        public var whiteList: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blackList != nil {
                map["BlackList"] = self.blackList!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.imageCount != nil {
                map["ImageCount"] = self.imageCount!
            }
            if self.jenkinsEnv != nil {
                map["JenkinsEnv"] = self.jenkinsEnv!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.persistenceDay != nil {
                map["PersistenceDay"] = self.persistenceDay!
            }
            if self.protocolType != nil {
                map["ProtocolType"] = self.protocolType!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.registryHostIp != nil {
                map["RegistryHostIp"] = self.registryHostIp!
            }
            if self.registryName != nil {
                map["RegistryName"] = self.registryName!
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.token != nil {
                map["Token"] = self.token!
            }
            if self.transPerHour != nil {
                map["TransPerHour"] = self.transPerHour!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.whiteList != nil {
                map["WhiteList"] = self.whiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlackList") && dict["BlackList"] != nil {
                self.blackList = dict["BlackList"] as! String
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ImageCount") && dict["ImageCount"] != nil {
                self.imageCount = dict["ImageCount"] as! Int32
            }
            if dict.keys.contains("JenkinsEnv") && dict["JenkinsEnv"] != nil {
                self.jenkinsEnv = dict["JenkinsEnv"] as! String
            }
            if dict.keys.contains("NetType") && dict["NetType"] != nil {
                self.netType = dict["NetType"] as! Int32
            }
            if dict.keys.contains("Password") && dict["Password"] != nil {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("PersistenceDay") && dict["PersistenceDay"] != nil {
                self.persistenceDay = dict["PersistenceDay"] as! Int32
            }
            if dict.keys.contains("ProtocolType") && dict["ProtocolType"] != nil {
                self.protocolType = dict["ProtocolType"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegistryHostIp") && dict["RegistryHostIp"] != nil {
                self.registryHostIp = dict["RegistryHostIp"] as! String
            }
            if dict.keys.contains("RegistryName") && dict["RegistryName"] != nil {
                self.registryName = dict["RegistryName"] as! String
            }
            if dict.keys.contains("RegistryType") && dict["RegistryType"] != nil {
                self.registryType = dict["RegistryType"] as! String
            }
            if dict.keys.contains("Token") && dict["Token"] != nil {
                self.token = dict["Token"] as! String
            }
            if dict.keys.contains("TransPerHour") && dict["TransPerHour"] != nil {
                self.transPerHour = dict["TransPerHour"] as! Int32
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("WhiteList") && dict["WhiteList"] != nil {
                self.whiteList = dict["WhiteList"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var list: [PageImageRegistryResponseBody.List]?

    public var pageInfo: PageImageRegistryResponseBody.PageInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [PageImageRegistryResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = PageImageRegistryResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = PageImageRegistryResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PageImageRegistryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PageImageRegistryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PageImageRegistryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PauseClientRequest : Tea.TeaModel {
    public var uuids: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
        if dict.keys.contains("Value") && dict["Value"] != nil {
            self.value = dict["Value"] as! String
        }
    }
}

public class PauseClientResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PauseClientResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PauseClientResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PauseClientResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublicCreateImageScanTaskRequest : Tea.TeaModel {
    public var digests: String?

    public var instanceIds: String?

    public var regionIds: String?

    public var registryTypes: String?

    public var repoIds: String?

    public var repoNames: String?

    public var repoNamespaces: String?

    public var sourceIp: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.digests != nil {
            map["Digests"] = self.digests!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.regionIds != nil {
            map["RegionIds"] = self.regionIds!
        }
        if self.registryTypes != nil {
            map["RegistryTypes"] = self.registryTypes!
        }
        if self.repoIds != nil {
            map["RepoIds"] = self.repoIds!
        }
        if self.repoNames != nil {
            map["RepoNames"] = self.repoNames!
        }
        if self.repoNamespaces != nil {
            map["RepoNamespaces"] = self.repoNamespaces!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Digests") && dict["Digests"] != nil {
            self.digests = dict["Digests"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("RegionIds") && dict["RegionIds"] != nil {
            self.regionIds = dict["RegionIds"] as! String
        }
        if dict.keys.contains("RegistryTypes") && dict["RegistryTypes"] != nil {
            self.registryTypes = dict["RegistryTypes"] as! String
        }
        if dict.keys.contains("RepoIds") && dict["RepoIds"] != nil {
            self.repoIds = dict["RepoIds"] as! String
        }
        if dict.keys.contains("RepoNames") && dict["RepoNames"] != nil {
            self.repoNames = dict["RepoNames"] as! String
        }
        if dict.keys.contains("RepoNamespaces") && dict["RepoNamespaces"] != nil {
            self.repoNamespaces = dict["RepoNamespaces"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class PublicCreateImageScanTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var canCreate: Bool?

        public var collectTime: Int64?

        public var execTime: Int64?

        public var finishCount: Int32?

        public var progress: Int32?

        public var result: String?

        public var status: String?

        public var taskId: String?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canCreate != nil {
                map["CanCreate"] = self.canCreate!
            }
            if self.collectTime != nil {
                map["CollectTime"] = self.collectTime!
            }
            if self.execTime != nil {
                map["ExecTime"] = self.execTime!
            }
            if self.finishCount != nil {
                map["FinishCount"] = self.finishCount!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanCreate") && dict["CanCreate"] != nil {
                self.canCreate = dict["CanCreate"] as! Bool
            }
            if dict.keys.contains("CollectTime") && dict["CollectTime"] != nil {
                self.collectTime = dict["CollectTime"] as! Int64
            }
            if dict.keys.contains("ExecTime") && dict["ExecTime"] != nil {
                self.execTime = dict["ExecTime"] as! Int64
            }
            if dict.keys.contains("FinishCount") && dict["FinishCount"] != nil {
                self.finishCount = dict["FinishCount"] as! Int32
            }
            if dict.keys.contains("Progress") && dict["Progress"] != nil {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: PublicCreateImageScanTaskResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = PublicCreateImageScanTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PublicCreateImageScanTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublicCreateImageScanTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PublicCreateImageScanTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublicPreCheckImageScanTaskRequest : Tea.TeaModel {
    public var digests: String?

    public var instanceIds: String?

    public var regionIds: String?

    public var registryTypes: String?

    public var repoIds: String?

    public var repoNames: String?

    public var repoNamespaces: String?

    public var sourceIp: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.digests != nil {
            map["Digests"] = self.digests!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.regionIds != nil {
            map["RegionIds"] = self.regionIds!
        }
        if self.registryTypes != nil {
            map["RegistryTypes"] = self.registryTypes!
        }
        if self.repoIds != nil {
            map["RepoIds"] = self.repoIds!
        }
        if self.repoNames != nil {
            map["RepoNames"] = self.repoNames!
        }
        if self.repoNamespaces != nil {
            map["RepoNamespaces"] = self.repoNamespaces!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Digests") && dict["Digests"] != nil {
            self.digests = dict["Digests"] as! String
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("RegionIds") && dict["RegionIds"] != nil {
            self.regionIds = dict["RegionIds"] as! String
        }
        if dict.keys.contains("RegistryTypes") && dict["RegistryTypes"] != nil {
            self.registryTypes = dict["RegistryTypes"] as! String
        }
        if dict.keys.contains("RepoIds") && dict["RepoIds"] != nil {
            self.repoIds = dict["RepoIds"] as! String
        }
        if dict.keys.contains("RepoNames") && dict["RepoNames"] != nil {
            self.repoNames = dict["RepoNames"] as! String
        }
        if dict.keys.contains("RepoNamespaces") && dict["RepoNamespaces"] != nil {
            self.repoNamespaces = dict["RepoNamespaces"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class PublicPreCheckImageScanTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var needAuthCount: Int32?

        public var scanImageCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.needAuthCount != nil {
                map["NeedAuthCount"] = self.needAuthCount!
            }
            if self.scanImageCount != nil {
                map["ScanImageCount"] = self.scanImageCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NeedAuthCount") && dict["NeedAuthCount"] != nil {
                self.needAuthCount = dict["NeedAuthCount"] as! Int32
            }
            if dict.keys.contains("ScanImageCount") && dict["ScanImageCount"] != nil {
                self.scanImageCount = dict["ScanImageCount"] as! Int32
            }
        }
    }
    public var data: PublicPreCheckImageScanTaskResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = PublicPreCheckImageScanTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PublicPreCheckImageScanTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublicPreCheckImageScanTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PublicPreCheckImageScanTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublicSyncAndCreateImageScanTaskRequest : Tea.TeaModel {
    public var images: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.images != nil {
            map["Images"] = self.images!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Images") && dict["Images"] != nil {
            self.images = dict["Images"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class PublicSyncAndCreateImageScanTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var canCreate: Bool?

        public var collectTime: Int64?

        public var execTime: Int64?

        public var finishCount: Int32?

        public var progress: Int32?

        public var result: String?

        public var status: String?

        public var taskId: String?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canCreate != nil {
                map["CanCreate"] = self.canCreate!
            }
            if self.collectTime != nil {
                map["CollectTime"] = self.collectTime!
            }
            if self.execTime != nil {
                map["ExecTime"] = self.execTime!
            }
            if self.finishCount != nil {
                map["FinishCount"] = self.finishCount!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanCreate") && dict["CanCreate"] != nil {
                self.canCreate = dict["CanCreate"] as! Bool
            }
            if dict.keys.contains("CollectTime") && dict["CollectTime"] != nil {
                self.collectTime = dict["CollectTime"] as! Int64
            }
            if dict.keys.contains("ExecTime") && dict["ExecTime"] != nil {
                self.execTime = dict["ExecTime"] as! Int64
            }
            if dict.keys.contains("FinishCount") && dict["FinishCount"] != nil {
                self.finishCount = dict["FinishCount"] as! Int32
            }
            if dict.keys.contains("Progress") && dict["Progress"] != nil {
                self.progress = dict["Progress"] as! Int32
            }
            if dict.keys.contains("Result") && dict["Result"] != nil {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var data: PublicSyncAndCreateImageScanTaskResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = PublicSyncAndCreateImageScanTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PublicSyncAndCreateImageScanTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublicSyncAndCreateImageScanTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PublicSyncAndCreateImageScanTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAttackCountRequest : Tea.TeaModel {
    public var from: String?

    public var lang: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class QueryAttackCountResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var eventCount: Int32?

        public var tacticId: String?

        public var tacticType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventCount != nil {
                map["EventCount"] = self.eventCount!
            }
            if self.tacticId != nil {
                map["TacticId"] = self.tacticId!
            }
            if self.tacticType != nil {
                map["TacticType"] = self.tacticType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventCount") && dict["EventCount"] != nil {
                self.eventCount = dict["EventCount"] as! Int32
            }
            if dict.keys.contains("TacticId") && dict["TacticId"] != nil {
                self.tacticId = dict["TacticId"] as! String
            }
            if dict.keys.contains("TacticType") && dict["TacticType"] != nil {
                self.tacticType = dict["TacticType"] as! String
            }
        }
    }
    public var code: String?

    public var count: Int32?

    public var data: [QueryAttackCountResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [QueryAttackCountResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryAttackCountResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryAttackCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAttackCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryAttackCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryDiscoverDatabaseRequest : Tea.TeaModel {
    public var createMark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createMark != nil {
            map["CreateMark"] = self.createMark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateMark") && dict["CreateMark"] != nil {
            self.createMark = dict["CreateMark"] as! String
        }
    }
}

public class QueryDiscoverDatabaseResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskProgress: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskProgress != nil {
            map["TaskProgress"] = self.taskProgress!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskProgress") && dict["TaskProgress"] != nil {
            self.taskProgress = dict["TaskProgress"] as! Int32
        }
    }
}

public class QueryDiscoverDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryDiscoverDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryDiscoverDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGroupIdByGroupNameRequest : Tea.TeaModel {
    public var groupName: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupName") && dict["GroupName"] != nil {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class QueryGroupIdByGroupNameResponseBody : Tea.TeaModel {
    public var groupId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryGroupIdByGroupNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGroupIdByGroupNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryGroupIdByGroupNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryGroupedSecurityEventMarkMissListRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var disposalWay: String?

    public var eventName: String?

    public var from: String?

    public var lang: String?

    public var pageSize: Int32?

    public var remark: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.disposalWay != nil {
            map["DisposalWay"] = self.disposalWay!
        }
        if self.eventName != nil {
            map["EventName"] = self.eventName!
        }
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("DisposalWay") && dict["DisposalWay"] != nil {
            self.disposalWay = dict["DisposalWay"] as! String
        }
        if dict.keys.contains("EventName") && dict["EventName"] != nil {
            self.eventName = dict["EventName"] as! String
        }
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class QueryGroupedSecurityEventMarkMissListResponseBody : Tea.TeaModel {
    public class List : Tea.TeaModel {
        public var aliUid: Int64?

        public var disposalWay: String?

        public var eventName: String?

        public var eventNameOriginal: String?

        public var eventType: String?

        public var eventTypeOriginal: String?

        public var field: String?

        public var fieldValue: String?

        public var filedAliasName: String?

        public var operate: String?

        public var uuids: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.disposalWay != nil {
                map["DisposalWay"] = self.disposalWay!
            }
            if self.eventName != nil {
                map["EventName"] = self.eventName!
            }
            if self.eventNameOriginal != nil {
                map["EventNameOriginal"] = self.eventNameOriginal!
            }
            if self.eventType != nil {
                map["EventType"] = self.eventType!
            }
            if self.eventTypeOriginal != nil {
                map["EventTypeOriginal"] = self.eventTypeOriginal!
            }
            if self.field != nil {
                map["Field"] = self.field!
            }
            if self.fieldValue != nil {
                map["FieldValue"] = self.fieldValue!
            }
            if self.filedAliasName != nil {
                map["FiledAliasName"] = self.filedAliasName!
            }
            if self.operate != nil {
                map["Operate"] = self.operate!
            }
            if self.uuids != nil {
                map["Uuids"] = self.uuids!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AliUid") && dict["AliUid"] != nil {
                self.aliUid = dict["AliUid"] as! Int64
            }
            if dict.keys.contains("DisposalWay") && dict["DisposalWay"] != nil {
                self.disposalWay = dict["DisposalWay"] as! String
            }
            if dict.keys.contains("EventName") && dict["EventName"] != nil {
                self.eventName = dict["EventName"] as! String
            }
            if dict.keys.contains("EventNameOriginal") && dict["EventNameOriginal"] != nil {
                self.eventNameOriginal = dict["EventNameOriginal"] as! String
            }
            if dict.keys.contains("EventType") && dict["EventType"] != nil {
                self.eventType = dict["EventType"] as! String
            }
            if dict.keys.contains("EventTypeOriginal") && dict["EventTypeOriginal"] != nil {
                self.eventTypeOriginal = dict["EventTypeOriginal"] as! String
            }
            if dict.keys.contains("Field") && dict["Field"] != nil {
                self.field = dict["Field"] as! String
            }
            if dict.keys.contains("FieldValue") && dict["FieldValue"] != nil {
                self.fieldValue = dict["FieldValue"] as! String
            }
            if dict.keys.contains("FiledAliasName") && dict["FiledAliasName"] != nil {
                self.filedAliasName = dict["FiledAliasName"] as! String
            }
            if dict.keys.contains("Operate") && dict["Operate"] != nil {
                self.operate = dict["Operate"] as! String
            }
            if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
                self.uuids = dict["Uuids"] as! String
            }
        }
    }
    public class PageInfo : Tea.TeaModel {
        public var count: Int32?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Count") && dict["Count"] != nil {
                self.count = dict["Count"] as! Int32
            }
            if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var list: [QueryGroupedSecurityEventMarkMissListResponseBody.List]?

    public var message: String?

    public var pageInfo: QueryGroupedSecurityEventMarkMissListResponseBody.PageInfo?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pageInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageInfo != nil {
            map["PageInfo"] = self.pageInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("List") && dict["List"] != nil {
            var tmp : [QueryGroupedSecurityEventMarkMissListResponseBody.List] = []
            for v in dict["List"] as! [Any] {
                var model = QueryGroupedSecurityEventMarkMissListResponseBody.List()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageInfo") && dict["PageInfo"] != nil {
            var model = QueryGroupedSecurityEventMarkMissListResponseBody.PageInfo()
            model.fromMap(dict["PageInfo"] as! [String: Any])
            self.pageInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryGroupedSecurityEventMarkMissListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryGroupedSecurityEventMarkMissListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryGroupedSecurityEventMarkMissListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryJenkinsImageRegistryPersistenceDayRequest : Tea.TeaModel {
    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class QueryJenkinsImageRegistryPersistenceDayResponseBody : Tea.TeaModel {
    public var data: Int32?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var timeCost: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeCost != nil {
            map["TimeCost"] = self.timeCost!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Int32
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TimeCost") && dict["TimeCost"] != nil {
            self.timeCost = dict["TimeCost"] as! Int64
        }
    }
}

public class QueryJenkinsImageRegistryPersistenceDayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryJenkinsImageRegistryPersistenceDayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryJenkinsImageRegistryPersistenceDayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryPreCheckDatabaseRequest : Tea.TeaModel {
    public var instanceUuid: String?

    public var taskId: String?

    public var uniRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceUuid != nil {
            map["InstanceUuid"] = self.instanceUuid!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.uniRegionId != nil {
            map["UniRegionId"] = self.uniRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceUuid") && dict["InstanceUuid"] != nil {
            self.instanceUuid = dict["InstanceUuid"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("UniRegionId") && dict["UniRegionId"] != nil {
            self.uniRegionId = dict["UniRegionId"] as! String
        }
    }
}

public class QueryPreCheckDatabaseResponseBody : Tea.TeaModel {
    public var completedTime: Int64?

    public var createdTime: Int64?

    public var description_: String?

    public var progress: Int32?

    public var requestId: String?

    public var result: String?

    public var updatedTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.completedTime != nil {
            map["CompletedTime"] = self.completedTime!
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.progress != nil {
            map["Progress"] = self.progress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.updatedTime != nil {
            map["UpdatedTime"] = self.updatedTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CompletedTime") && dict["CompletedTime"] != nil {
            self.completedTime = dict["CompletedTime"] as! Int64
        }
        if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
            self.createdTime = dict["CreatedTime"] as! Int64
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Progress") && dict["Progress"] != nil {
            self.progress = dict["Progress"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
            self.updatedTime = dict["UpdatedTime"] as! Int64
        }
    }
}

public class QueryPreCheckDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryPreCheckDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryPreCheckDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootMachineRequest : Tea.TeaModel {
    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class RebootMachineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RebootMachineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshAssetsRequest : Tea.TeaModel {
    public var assetType: String?

    public var cloudAssetSubType: Int32?

    public var cloudAssetType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetType != nil {
            map["AssetType"] = self.assetType!
        }
        if self.cloudAssetSubType != nil {
            map["CloudAssetSubType"] = self.cloudAssetSubType!
        }
        if self.cloudAssetType != nil {
            map["CloudAssetType"] = self.cloudAssetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
            self.assetType = dict["AssetType"] as! String
        }
        if dict.keys.contains("CloudAssetSubType") && dict["CloudAssetSubType"] != nil {
            self.cloudAssetSubType = dict["CloudAssetSubType"] as! Int32
        }
        if dict.keys.contains("CloudAssetType") && dict["CloudAssetType"] != nil {
            self.cloudAssetType = dict["CloudAssetType"] as! Int32
        }
    }
}

public class RefreshAssetsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RefreshAssetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshAssetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefreshAssetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshContainerAssetsRequest : Tea.TeaModel {
    public var assetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assetType != nil {
            map["AssetType"] = self.assetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssetType") && dict["AssetType"] != nil {
            self.assetType = dict["AssetType"] as! String
        }
    }
}

public class RefreshContainerAssetsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RefreshContainerAssetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshContainerAssetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefreshContainerAssetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveCheckInstanceResultWhiteListRequest : Tea.TeaModel {
    public var checkId: Int64?

    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
            self.checkId = dict["CheckId"] as! Int64
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class RemoveCheckInstanceResultWhiteListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveCheckInstanceResultWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveCheckInstanceResultWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveCheckInstanceResultWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveCheckResultWhiteListRequest : Tea.TeaModel {
    public var checkGroupId: String?

    public var checkIds: [Int64]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkGroupId != nil {
            map["CheckGroupId"] = self.checkGroupId!
        }
        if self.checkIds != nil {
            map["CheckIds"] = self.checkIds!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckGroupId") && dict["CheckGroupId"] != nil {
            self.checkGroupId = dict["CheckGroupId"] as! String
        }
        if dict.keys.contains("CheckIds") && dict["CheckIds"] != nil {
            self.checkIds = dict["CheckIds"] as! [Int64]
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class RemoveCheckResultWhiteListResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RemoveCheckResultWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveCheckResultWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveCheckResultWhiteListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryAgentlessTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class RetryAgentlessTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RetryAgentlessTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryAgentlessTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RetryAgentlessTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetryInstallProbeRequest : Tea.TeaModel {
    public var probeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.probeId != nil {
            map["ProbeId"] = self.probeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProbeId") && dict["ProbeId"] != nil {
            self.probeId = dict["ProbeId"] as! String
        }
    }
}

public class RetryInstallProbeResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RetryInstallProbeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetryInstallProbeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RetryInstallProbeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RollbackSuspEventQuaraFileRequest : Tea.TeaModel {
    public var from: String?

    public var quaraFileId: Int32?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.quaraFileId != nil {
            map["QuaraFileId"] = self.quaraFileId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("QuaraFileId") && dict["QuaraFileId"] != nil {
            self.quaraFileId = dict["QuaraFileId"] as! Int32
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class RollbackSuspEventQuaraFileResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RollbackSuspEventQuaraFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackSuspEventQuaraFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RollbackSuspEventQuaraFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SasInstallCodeRequest : Tea.TeaModel {
    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class SasInstallCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") && dict["data"] != nil {
            self.data = dict["data"] as! String
        }
    }
}

public class SasInstallCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SasInstallCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SasInstallCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveImageBaselineStrategyRequest : Tea.TeaModel {
    public var baselineItemList: String?

    public var lang: String?

    public var source: String?

    public var strategyId: Int64?

    public var strategyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baselineItemList != nil {
            map["BaselineItemList"] = self.baselineItemList!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.strategyId != nil {
            map["StrategyId"] = self.strategyId!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BaselineItemList") && dict["BaselineItemList"] != nil {
            self.baselineItemList = dict["BaselineItemList"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("StrategyId") && dict["StrategyId"] != nil {
            self.strategyId = dict["StrategyId"] as! Int64
        }
        if dict.keys.contains("StrategyName") && dict["StrategyName"] != nil {
            self.strategyName = dict["StrategyName"] as! String
        }
    }
}

public class SaveImageBaselineStrategyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SaveImageBaselineStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveImageBaselineStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveImageBaselineStrategyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveSuspEventUserSettingRequest : Tea.TeaModel {
    public var from: String?

    public var levelsOn: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.levelsOn != nil {
            map["LevelsOn"] = self.levelsOn!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") && dict["From"] != nil {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("LevelsOn") && dict["LevelsOn"] != nil {
            self.levelsOn = dict["LevelsOn"] as! String
        }
    }
}

public class SaveSuspEventUserSettingResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SaveSuspEventUserSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveSuspEventUserSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveSuspEventUserSettingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetClusterInterceptionConfigRequest : Tea.TeaModel {
    public var clusterIds: String?

    public var switchOn: Int32?

    public var switchType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterIds != nil {
            map["ClusterIds"] = self.clusterIds!
        }
        if self.switchOn != nil {
            map["SwitchOn"] = self.switchOn!
        }
        if self.switchType != nil {
            map["SwitchType"] = self.switchType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterIds") && dict["ClusterIds"] != nil {
            self.clusterIds = dict["ClusterIds"] as! String
        }
        if dict.keys.contains("SwitchOn") && dict["SwitchOn"] != nil {
            self.switchOn = dict["SwitchOn"] as! Int32
        }
        if dict.keys.contains("SwitchType") && dict["SwitchType"] != nil {
            self.switchType = dict["SwitchType"] as! Int32
        }
    }
}

public class SetClusterInterceptionConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") && dict["Result"] != nil {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class SetClusterInterceptionConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetClusterInterceptionConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetClusterInterceptionConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetRegistryScanDayNumRequest : Tea.TeaModel {
    public var scanDayNum: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scanDayNum != nil {
            map["ScanDayNum"] = self.scanDayNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScanDayNum") && dict["ScanDayNum"] != nil {
            self.scanDayNum = dict["ScanDayNum"] as! Int32
        }
    }
}

public class SetRegistryScanDayNumResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetRegistryScanDayNumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetRegistryScanDayNumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SetRegistryScanDayNumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartBaselineSecurityCheckRequest : Tea.TeaModel {
    public var itemIds: [Int64]?

    public var lang: String?

    public var resourceOwnerId: Int64?

    public var sourceIp: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ItemIds") && dict["ItemIds"] != nil {
            self.itemIds = dict["ItemIds"] as! [Int64]
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class StartBaselineSecurityCheckResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartBaselineSecurityCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartBaselineSecurityCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartBaselineSecurityCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartDiscoverDatabaseTaskResponseBody : Tea.TeaModel {
    public var createMark: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createMark != nil {
            map["CreateMark"] = self.createMark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateMark") && dict["CreateMark"] != nil {
            self.createMark = dict["CreateMark"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartDiscoverDatabaseTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartDiscoverDatabaseTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartDiscoverDatabaseTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartPreCheckDatabaseRequest : Tea.TeaModel {
    public var databaseType: String?

    public var instanceUuid: String?

    public var uniRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.databaseType != nil {
            map["DatabaseType"] = self.databaseType!
        }
        if self.instanceUuid != nil {
            map["InstanceUuid"] = self.instanceUuid!
        }
        if self.uniRegionId != nil {
            map["UniRegionId"] = self.uniRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatabaseType") && dict["DatabaseType"] != nil {
            self.databaseType = dict["DatabaseType"] as! String
        }
        if dict.keys.contains("InstanceUuid") && dict["InstanceUuid"] != nil {
            self.instanceUuid = dict["InstanceUuid"] as! String
        }
        if dict.keys.contains("UniRegionId") && dict["UniRegionId"] != nil {
            self.uniRegionId = dict["UniRegionId"] as! String
        }
    }
}

public class StartPreCheckDatabaseResponseBody : Tea.TeaModel {
    public var createMark: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createMark != nil {
            map["CreateMark"] = self.createMark!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateMark") && dict["CreateMark"] != nil {
            self.createMark = dict["CreateMark"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartPreCheckDatabaseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartPreCheckDatabaseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartPreCheckDatabaseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartVirusScanTaskRequest : Tea.TeaModel {
    public var targetInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.targetInfo != nil {
            map["TargetInfo"] = self.targetInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TargetInfo") && dict["TargetInfo"] != nil {
            self.targetInfo = dict["TargetInfo"] as! String
        }
    }
}

public class StartVirusScanTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var scanTaskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scanTaskId != nil {
            map["ScanTaskId"] = self.scanTaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScanTaskId") && dict["ScanTaskId"] != nil {
            self.scanTaskId = dict["ScanTaskId"] as! Int64
        }
    }
}

public class StartVirusScanTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartVirusScanTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartVirusScanTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopHoneypotRequest : Tea.TeaModel {
    public var honeypotId: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeypotId != nil {
            map["HoneypotId"] = self.honeypotId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneypotId") && dict["HoneypotId"] != nil {
            self.honeypotId = dict["HoneypotId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
    }
}

public class StopHoneypotResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var controlNodeName: String?

        public var honeypotId: String?

        public var honeypotImageDisplayName: String?

        public var honeypotImageName: String?

        public var honeypotName: String?

        public var nodeId: String?

        public var presetId: String?

        public var state: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.controlNodeName != nil {
                map["ControlNodeName"] = self.controlNodeName!
            }
            if self.honeypotId != nil {
                map["HoneypotId"] = self.honeypotId!
            }
            if self.honeypotImageDisplayName != nil {
                map["HoneypotImageDisplayName"] = self.honeypotImageDisplayName!
            }
            if self.honeypotImageName != nil {
                map["HoneypotImageName"] = self.honeypotImageName!
            }
            if self.honeypotName != nil {
                map["HoneypotName"] = self.honeypotName!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.presetId != nil {
                map["PresetId"] = self.presetId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ControlNodeName") && dict["ControlNodeName"] != nil {
                self.controlNodeName = dict["ControlNodeName"] as! String
            }
            if dict.keys.contains("HoneypotId") && dict["HoneypotId"] != nil {
                self.honeypotId = dict["HoneypotId"] as! String
            }
            if dict.keys.contains("HoneypotImageDisplayName") && dict["HoneypotImageDisplayName"] != nil {
                self.honeypotImageDisplayName = dict["HoneypotImageDisplayName"] as! String
            }
            if dict.keys.contains("HoneypotImageName") && dict["HoneypotImageName"] != nil {
                self.honeypotImageName = dict["HoneypotImageName"] as! String
            }
            if dict.keys.contains("HoneypotName") && dict["HoneypotName"] != nil {
                self.honeypotName = dict["HoneypotName"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PresetId") && dict["PresetId"] != nil {
                self.presetId = dict["PresetId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! [String]
            }
        }
    }
    public var code: String?

    public var data: StopHoneypotResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = StopHoneypotResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StopHoneypotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopHoneypotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StopHoneypotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitCheckRequest : Tea.TeaModel {
    public var scanRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.scanRange != nil {
            map["ScanRange"] = self.scanRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ScanRange") && dict["ScanRange"] != nil {
            self.scanRange = dict["ScanRange"] as! String
        }
    }
}

public class SubmitCheckResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var operateCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateCode != nil {
                map["OperateCode"] = self.operateCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OperateCode") && dict["OperateCode"] != nil {
                self.operateCode = dict["OperateCode"] as! String
            }
        }
    }
    public var data: SubmitCheckResponseBody.Data?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = SubmitCheckResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class SubmitCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindAegisRequest : Tea.TeaModel {
    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class UnbindAegisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindAegisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindAegisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnbindAegisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UninstallBackupClientRequest : Tea.TeaModel {
    public var policyVersion: String?

    public var uuid: String?

    public var uuidList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyVersion != nil {
            map["PolicyVersion"] = self.policyVersion!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        if self.uuidList != nil {
            map["UuidList"] = self.uuidList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyVersion") && dict["PolicyVersion"] != nil {
            self.policyVersion = dict["PolicyVersion"] as! String
        }
        if dict.keys.contains("Uuid") && dict["Uuid"] != nil {
            self.uuid = dict["Uuid"] as! String
        }
        if dict.keys.contains("UuidList") && dict["UuidList"] != nil {
            self.uuidList = dict["UuidList"] as! [String]
        }
    }
}

public class UninstallBackupClientResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UninstallBackupClientResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallBackupClientResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UninstallBackupClientResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UninstallRaspAttachRequest : Tea.TeaModel {
    public var applicationId: String?

    public var ecsUUIDList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.ecsUUIDList != nil {
            map["EcsUUIDList"] = self.ecsUUIDList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationId") && dict["ApplicationId"] != nil {
            self.applicationId = dict["ApplicationId"] as! String
        }
        if dict.keys.contains("EcsUUIDList") && dict["EcsUUIDList"] != nil {
            self.ecsUUIDList = dict["EcsUUIDList"] as! [String]
        }
    }
}

public class UninstallRaspAttachResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UninstallRaspAttachResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallRaspAttachResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UninstallRaspAttachResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UninstallUniBackupAgentRequest : Tea.TeaModel {
    public var policyId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! Int64
        }
    }
}

public class UninstallUniBackupAgentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UninstallUniBackupAgentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallUniBackupAgentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UninstallUniBackupAgentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAlarmEventRequest : Tea.TeaModel {
    public var alarmEventIdList: [Int64]?

    public var lang: String?

    public var operationCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alarmEventIdList != nil {
            map["AlarmEventIdList"] = self.alarmEventIdList!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.operationCode != nil {
            map["OperationCode"] = self.operationCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlarmEventIdList") && dict["AlarmEventIdList"] != nil {
            self.alarmEventIdList = dict["AlarmEventIdList"] as! [Int64]
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("OperationCode") && dict["OperationCode"] != nil {
            self.operationCode = dict["OperationCode"] as! String
        }
    }
}

public class UpdateAlarmEventResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAlarmEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAlarmEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAlarmEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateClientAlertModeRequest : Tea.TeaModel {
    public var mode: String?

    public var uuids: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! [String]
        }
    }
}

public class UpdateClientAlertModeResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateClientAlertModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateClientAlertModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateClientAlertModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFileProtectEventStatusRequest : Tea.TeaModel {
    public var id: [Int64]?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! [Int64]
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class UpdateFileProtectEventStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateFileProtectEventStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFileProtectEventStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateFileProtectEventStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFileProtectRemarkRequest : Tea.TeaModel {
    public var id: Int64?

    public var remark: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! [String]
        }
    }
}

public class UpdateFileProtectRemarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateFileProtectRemarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFileProtectRemarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateFileProtectRemarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateFileProtectRuleRequest : Tea.TeaModel {
    public var alertLevel: Int32?

    public var fileOps: [String]?

    public var filePaths: [String]?

    public var id: Int64?

    public var procPaths: [String]?

    public var ruleAction: String?

    public var ruleName: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertLevel != nil {
            map["AlertLevel"] = self.alertLevel!
        }
        if self.fileOps != nil {
            map["FileOps"] = self.fileOps!
        }
        if self.filePaths != nil {
            map["FilePaths"] = self.filePaths!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.procPaths != nil {
            map["ProcPaths"] = self.procPaths!
        }
        if self.ruleAction != nil {
            map["RuleAction"] = self.ruleAction!
        }
        if self.ruleName != nil {
            map["RuleName"] = self.ruleName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertLevel") && dict["AlertLevel"] != nil {
            self.alertLevel = dict["AlertLevel"] as! Int32
        }
        if dict.keys.contains("FileOps") && dict["FileOps"] != nil {
            self.fileOps = dict["FileOps"] as! [String]
        }
        if dict.keys.contains("FilePaths") && dict["FilePaths"] != nil {
            self.filePaths = dict["FilePaths"] as! [String]
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("ProcPaths") && dict["ProcPaths"] != nil {
            self.procPaths = dict["ProcPaths"] as! [String]
        }
        if dict.keys.contains("RuleAction") && dict["RuleAction"] != nil {
            self.ruleAction = dict["RuleAction"] as! String
        }
        if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
            self.ruleName = dict["RuleName"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class UpdateFileProtectRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateFileProtectRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateFileProtectRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateFileProtectRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateHoneypotRequest : Tea.TeaModel {
    public var honeypotId: String?

    public var honeypotName: String?

    public var lang: String?

    public var meta: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeypotId != nil {
            map["HoneypotId"] = self.honeypotId!
        }
        if self.honeypotName != nil {
            map["HoneypotName"] = self.honeypotName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.meta != nil {
            map["Meta"] = self.meta!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneypotId") && dict["HoneypotId"] != nil {
            self.honeypotId = dict["HoneypotId"] as! String
        }
        if dict.keys.contains("HoneypotName") && dict["HoneypotName"] != nil {
            self.honeypotName = dict["HoneypotName"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Meta") && dict["Meta"] != nil {
            self.meta = dict["Meta"] as! String
        }
    }
}

public class UpdateHoneypotResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var honeypotId: String?

        public var honeypotImageDisplayName: String?

        public var honeypotImageName: String?

        public var honeypotName: String?

        public var nodeId: String?

        public var presetId: String?

        public var state: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.honeypotId != nil {
                map["HoneypotId"] = self.honeypotId!
            }
            if self.honeypotImageDisplayName != nil {
                map["HoneypotImageDisplayName"] = self.honeypotImageDisplayName!
            }
            if self.honeypotImageName != nil {
                map["HoneypotImageName"] = self.honeypotImageName!
            }
            if self.honeypotName != nil {
                map["HoneypotName"] = self.honeypotName!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.presetId != nil {
                map["PresetId"] = self.presetId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HoneypotId") && dict["HoneypotId"] != nil {
                self.honeypotId = dict["HoneypotId"] as! String
            }
            if dict.keys.contains("HoneypotImageDisplayName") && dict["HoneypotImageDisplayName"] != nil {
                self.honeypotImageDisplayName = dict["HoneypotImageDisplayName"] as! String
            }
            if dict.keys.contains("HoneypotImageName") && dict["HoneypotImageName"] != nil {
                self.honeypotImageName = dict["HoneypotImageName"] as! String
            }
            if dict.keys.contains("HoneypotName") && dict["HoneypotName"] != nil {
                self.honeypotName = dict["HoneypotName"] as! String
            }
            if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("PresetId") && dict["PresetId"] != nil {
                self.presetId = dict["PresetId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! [String]
            }
        }
    }
    public var code: String?

    public var data: UpdateHoneypotResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UpdateHoneypotResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateHoneypotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHoneypotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateHoneypotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateHoneypotNodeRequest : Tea.TeaModel {
    public var availableProbeNum: Int32?

    public var nodeId: String?

    public var nodeName: String?

    public var securityGroupProbeIpList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableProbeNum != nil {
            map["AvailableProbeNum"] = self.availableProbeNum!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.securityGroupProbeIpList != nil {
            map["SecurityGroupProbeIpList"] = self.securityGroupProbeIpList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableProbeNum") && dict["AvailableProbeNum"] != nil {
            self.availableProbeNum = dict["AvailableProbeNum"] as! Int32
        }
        if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("SecurityGroupProbeIpList") && dict["SecurityGroupProbeIpList"] != nil {
            self.securityGroupProbeIpList = dict["SecurityGroupProbeIpList"] as! [String]
        }
    }
}

public class UpdateHoneypotNodeResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateHoneypotNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHoneypotNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateHoneypotNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateHoneypotPresetRequest : Tea.TeaModel {
    public var honeypotImageName: String?

    public var honeypotPresetId: String?

    public var lang: String?

    public var meta: String?

    public var presetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.honeypotImageName != nil {
            map["HoneypotImageName"] = self.honeypotImageName!
        }
        if self.honeypotPresetId != nil {
            map["HoneypotPresetId"] = self.honeypotPresetId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.meta != nil {
            map["Meta"] = self.meta!
        }
        if self.presetName != nil {
            map["PresetName"] = self.presetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HoneypotImageName") && dict["HoneypotImageName"] != nil {
            self.honeypotImageName = dict["HoneypotImageName"] as! String
        }
        if dict.keys.contains("HoneypotPresetId") && dict["HoneypotPresetId"] != nil {
            self.honeypotPresetId = dict["HoneypotPresetId"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Meta") && dict["Meta"] != nil {
            self.meta = dict["Meta"] as! String
        }
        if dict.keys.contains("PresetName") && dict["PresetName"] != nil {
            self.presetName = dict["PresetName"] as! String
        }
    }
}

public class UpdateHoneypotPresetResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateHoneypotPresetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHoneypotPresetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateHoneypotPresetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateHoneypotProbeRequest : Tea.TeaModel {
    public var arp: Bool?

    public var displayName: String?

    public var lang: String?

    public var ping: Bool?

    public var probeId: String?

    public var serviceIpList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arp != nil {
            map["Arp"] = self.arp!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.ping != nil {
            map["Ping"] = self.ping!
        }
        if self.probeId != nil {
            map["ProbeId"] = self.probeId!
        }
        if self.serviceIpList != nil {
            map["ServiceIpList"] = self.serviceIpList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Arp") && dict["Arp"] != nil {
            self.arp = dict["Arp"] as! Bool
        }
        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Ping") && dict["Ping"] != nil {
            self.ping = dict["Ping"] as! Bool
        }
        if dict.keys.contains("ProbeId") && dict["ProbeId"] != nil {
            self.probeId = dict["ProbeId"] as! String
        }
        if dict.keys.contains("ServiceIpList") && dict["ServiceIpList"] != nil {
            self.serviceIpList = dict["ServiceIpList"] as! [String]
        }
    }
}

public class UpdateHoneypotProbeResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateHoneypotProbeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHoneypotProbeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateHoneypotProbeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateHoneypotProbeBindRequest : Tea.TeaModel {
    public class BindPortList : Tea.TeaModel {
        public var bindPort: Bool?

        public var endPort: Int32?

        public var fixed: Bool?

        public var id: Int64?

        public var proto: String?

        public var startPort: Int32?

        public var targetPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bindPort != nil {
                map["BindPort"] = self.bindPort!
            }
            if self.endPort != nil {
                map["EndPort"] = self.endPort!
            }
            if self.fixed != nil {
                map["Fixed"] = self.fixed!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.proto != nil {
                map["Proto"] = self.proto!
            }
            if self.startPort != nil {
                map["StartPort"] = self.startPort!
            }
            if self.targetPort != nil {
                map["TargetPort"] = self.targetPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BindPort") && dict["BindPort"] != nil {
                self.bindPort = dict["BindPort"] as! Bool
            }
            if dict.keys.contains("EndPort") && dict["EndPort"] != nil {
                self.endPort = dict["EndPort"] as! Int32
            }
            if dict.keys.contains("Fixed") && dict["Fixed"] != nil {
                self.fixed = dict["Fixed"] as! Bool
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Proto") && dict["Proto"] != nil {
                self.proto = dict["Proto"] as! String
            }
            if dict.keys.contains("StartPort") && dict["StartPort"] != nil {
                self.startPort = dict["StartPort"] as! Int32
            }
            if dict.keys.contains("TargetPort") && dict["TargetPort"] != nil {
                self.targetPort = dict["TargetPort"] as! Int32
            }
        }
    }
    public var bindId: String?

    public var bindPortList: [UpdateHoneypotProbeBindRequest.BindPortList]?

    public var bindType: String?

    public var currentPage: Int32?

    public var honeypotId: String?

    public var id: Int64?

    public var lang: String?

    public var pageSize: Int32?

    public var ports: String?

    public var probeId: String?

    public var serviceIpList: [String]?

    public var setStatus: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bindId != nil {
            map["BindId"] = self.bindId!
        }
        if self.bindPortList != nil {
            var tmp : [Any] = []
            for k in self.bindPortList! {
                tmp.append(k.toMap())
            }
            map["BindPortList"] = tmp
        }
        if self.bindType != nil {
            map["BindType"] = self.bindType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.honeypotId != nil {
            map["HoneypotId"] = self.honeypotId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ports != nil {
            map["Ports"] = self.ports!
        }
        if self.probeId != nil {
            map["ProbeId"] = self.probeId!
        }
        if self.serviceIpList != nil {
            map["ServiceIpList"] = self.serviceIpList!
        }
        if self.setStatus != nil {
            map["SetStatus"] = self.setStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BindId") && dict["BindId"] != nil {
            self.bindId = dict["BindId"] as! String
        }
        if dict.keys.contains("BindPortList") && dict["BindPortList"] != nil {
            var tmp : [UpdateHoneypotProbeBindRequest.BindPortList] = []
            for v in dict["BindPortList"] as! [Any] {
                var model = UpdateHoneypotProbeBindRequest.BindPortList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bindPortList = tmp
        }
        if dict.keys.contains("BindType") && dict["BindType"] != nil {
            self.bindType = dict["BindType"] as! String
        }
        if dict.keys.contains("CurrentPage") && dict["CurrentPage"] != nil {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("HoneypotId") && dict["HoneypotId"] != nil {
            self.honeypotId = dict["HoneypotId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Ports") && dict["Ports"] != nil {
            self.ports = dict["Ports"] as! String
        }
        if dict.keys.contains("ProbeId") && dict["ProbeId"] != nil {
            self.probeId = dict["ProbeId"] as! String
        }
        if dict.keys.contains("ServiceIpList") && dict["ServiceIpList"] != nil {
            self.serviceIpList = dict["ServiceIpList"] as! [String]
        }
        if dict.keys.contains("SetStatus") && dict["SetStatus"] != nil {
            self.setStatus = dict["SetStatus"] as! Int32
        }
    }
}

public class UpdateHoneypotProbeBindResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateHoneypotProbeBindResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHoneypotProbeBindResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateHoneypotProbeBindResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateImageVulWhitelistTargetRequest : Tea.TeaModel {
    public var id: Int64?

    public var lang: String?

    public var reason: String?

    public var source: String?

    public var target: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
        if dict.keys.contains("Lang") && dict["Lang"] != nil {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Reason") && dict["Reason"] != nil {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("Source") && dict["Source"] != nil {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Target") && dict["Target"] != nil {
            self.target = dict["Target"] as! String
        }
    }
}

public class UpdateImageVulWhitelistTargetResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateImageVulWhitelistTargetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateImageVulWhitelistTargetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateImageVulWhitelistTargetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateJenkinsImageRegistryNameRequest : Tea.TeaModel {
    public var registryId: Int64?

    public var registryName: String?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.registryId != nil {
            map["RegistryId"] = self.registryId!
        }
        if self.registryName != nil {
            map["RegistryName"] = self.registryName!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegistryId") && dict["RegistryId"] != nil {
            self.registryId = dict["RegistryId"] as! Int64
        }
        if dict.keys.contains("RegistryName") && dict["RegistryName"] != nil {
            self.registryName = dict["RegistryName"] as! String
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class UpdateJenkinsImageRegistryNameResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var timeCost: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeCost != nil {
            map["TimeCost"] = self.timeCost!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TimeCost") && dict["TimeCost"] != nil {
            self.timeCost = dict["TimeCost"] as! Int64
        }
    }
}

public class UpdateJenkinsImageRegistryNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateJenkinsImageRegistryNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateJenkinsImageRegistryNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateJenkinsImageRegistryPersistenceDayRequest : Tea.TeaModel {
    public var persistenceDay: Int32?

    public var registryId: Int64?

    public var sourceIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.persistenceDay != nil {
            map["PersistenceDay"] = self.persistenceDay!
        }
        if self.registryId != nil {
            map["RegistryId"] = self.registryId!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PersistenceDay") && dict["PersistenceDay"] != nil {
            self.persistenceDay = dict["PersistenceDay"] as! Int32
        }
        if dict.keys.contains("RegistryId") && dict["RegistryId"] != nil {
            self.registryId = dict["RegistryId"] as! Int64
        }
        if dict.keys.contains("SourceIp") && dict["SourceIp"] != nil {
            self.sourceIp = dict["SourceIp"] as! String
        }
    }
}

public class UpdateJenkinsImageRegistryPersistenceDayResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var timeCost: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeCost != nil {
            map["TimeCost"] = self.timeCost!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TimeCost") && dict["TimeCost"] != nil {
            self.timeCost = dict["TimeCost"] as! Int64
        }
    }
}

public class UpdateJenkinsImageRegistryPersistenceDayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateJenkinsImageRegistryPersistenceDayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateJenkinsImageRegistryPersistenceDayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeBackupPolicyVersionRequest : Tea.TeaModel {
    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! Int64
        }
    }
}

public class UpgradeBackupPolicyVersionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpgradeBackupPolicyVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeBackupPolicyVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpgradeBackupPolicyVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ValidateHcWarningsRequest : Tea.TeaModel {
    public var checkIds: String?

    public var riskIds: String?

    public var uuids: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkIds != nil {
            map["CheckIds"] = self.checkIds!
        }
        if self.riskIds != nil {
            map["RiskIds"] = self.riskIds!
        }
        if self.uuids != nil {
            map["Uuids"] = self.uuids!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckIds") && dict["CheckIds"] != nil {
            self.checkIds = dict["CheckIds"] as! String
        }
        if dict.keys.contains("RiskIds") && dict["RiskIds"] != nil {
            self.riskIds = dict["RiskIds"] as! String
        }
        if dict.keys.contains("Uuids") && dict["Uuids"] != nil {
            self.uuids = dict["Uuids"] as! String
        }
    }
}

public class ValidateHcWarningsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ValidateHcWarningsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateHcWarningsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ValidateHcWarningsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyCheckInstanceResultRequest : Tea.TeaModel {
    public var checkId: Int64?

    public var instanceIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkId != nil {
            map["CheckId"] = self.checkId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckId") && dict["CheckId"] != nil {
            self.checkId = dict["CheckId"] as! Int64
        }
        if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
    }
}

public class VerifyCheckInstanceResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var failInstances: [String]?

        public var operateCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failInstances != nil {
                map["FailInstances"] = self.failInstances!
            }
            if self.operateCode != nil {
                map["OperateCode"] = self.operateCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailInstances") && dict["FailInstances"] != nil {
                self.failInstances = dict["FailInstances"] as! [String]
            }
            if dict.keys.contains("OperateCode") && dict["OperateCode"] != nil {
                self.operateCode = dict["OperateCode"] as! String
            }
        }
    }
    public var data: VerifyCheckInstanceResultResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = VerifyCheckInstanceResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class VerifyCheckInstanceResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyCheckInstanceResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = VerifyCheckInstanceResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyCheckResultRequest : Tea.TeaModel {
    public var checkIds: [Int64]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkIds != nil {
            map["CheckIds"] = self.checkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckIds") && dict["CheckIds"] != nil {
            self.checkIds = dict["CheckIds"] as! [Int64]
        }
    }
}

public class VerifyCheckResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var operateCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operateCode != nil {
                map["OperateCode"] = self.operateCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OperateCode") && dict["OperateCode"] != nil {
                self.operateCode = dict["OperateCode"] as! String
            }
        }
    }
    public var data: VerifyCheckResultResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = VerifyCheckResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class VerifyCheckResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyCheckResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = VerifyCheckResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
